<token_count>528901</token_count>
This file is a merged representation of the entire codebase, combined into a single document.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<user_provided_header>
This repository contains the source code for the Repomix tool.
Repomix is designed to pack repository contents into a single file,
making it easier for AI systems to analyze and process the codebase.

Key Features:
- Configurable ignore patterns
- Custom header text support
- Efficient file processing and packing

Please refer to the README.md file for more detailed information on usage and configuration.

</user_provided_header>

<directory_structure>
.claude/
  commands/
    claude-rule-update.md
    git-commit-push.md
    git-commit.md
    pr-create.md
    pr-review-request.md
    pr-review.md
.devcontainer/
  devcontainer.json
.github/
  actions/
    repomix/
      action.yml
  instructions/
    base.instructions.md
    github-release-note.instructions.md
    website.instructions.md
  ISSUE_TEMPLATE/
    01_feature_request.yml
    02_bug_report.yml
    config.yml
  releases/
    v0.1.x/
      v0.1.15.md
      v0.1.16.md
      v0.1.18.md
      v0.1.19.md
      v0.1.20.md
      v0.1.21.md
      v0.1.22.md
      v0.1.23.md
      v0.1.24.md
      v0.1.25.md
      v0.1.26.md
      v0.1.27.md
      v0.1.28.md
      v0.1.29.md
      v0.1.30.md
      v0.1.31.md
      v0.1.32.md
      v0.1.33.md
      v0.1.34.md
      v0.1.35.md
      v0.1.36.md
      v0.1.37.md
      v0.1.38.md
      v0.1.39.md
      v0.1.40.md
      v0.1.41.md
      v0.1.42.md
      v0.1.43.md
      v0.1.44.md
      v0.1.45.md
    v0.2.x/
      v0.2.1.md
      v0.2.10.md
      v0.2.11.md
      v0.2.12.md
      v0.2.15.md
      v0.2.16.md
      v0.2.17.md
      v0.2.2.md
      v0.2.20.md
      v0.2.21.md
      v0.2.22.md
      v0.2.23.md
      v0.2.24.md
      v0.2.25.md
      v0.2.26.md
      v0.2.28.md
      v0.2.29.md
      v0.2.3.md
      v0.2.30.md
      v0.2.32.md
      v0.2.33.md
      v0.2.34.md
      v0.2.35.md
      v0.2.36.md
      v0.2.4.md
      v0.2.40.md
      v0.2.41.md
      v0.2.5.md
      v0.2.6.md
      v0.2.7.md
      v0.2.8.md
    v0.3.x/
      v0.3.0.md
      v0.3.1.md
      v0.3.2.md
      v0.3.3.md
      v0.3.5.md
      v0.3.6.md
      v0.3.7.md
      v0.3.8.md
      v0.3.9.md
  workflows/
    ci.yml
    claude.yml
    codeql.yml
    docker.yml
    homebrew.yml
    pack-repository.yml
    ratchet-verify.yml
    test-action.yml
  CODEOWNERS
  dependabot.yml
  FUNDING.yml
  pull_request_template.md
  renovate.json5
bin/
  repomix.cjs
browser/
  app/
    _locales/
      de/
        detailed-description.txt
        messages.json
      en/
        detailed-description.txt
        messages.json
      es/
        detailed-description.txt
        messages.json
      fr/
        detailed-description.txt
        messages.json
      hi/
        detailed-description.txt
        messages.json
      id/
        detailed-description.txt
        messages.json
      ja/
        detailed-description.txt
        messages.json
      ko/
        detailed-description.txt
        messages.json
      pt_BR/
        detailed-description.txt
        messages.json
      vi/
        detailed-description.txt
        messages.json
      zh_CN/
        detailed-description.txt
        messages.json
      zh_TW/
        detailed-description.txt
        messages.json
    images/
      icon.svg
    scripts/
      background.ts
      content.ts
    styles/
      content.css
    manifest.json
  scripts/
    generate-icons.ts
  tests/
    repomix-integration.test.ts
  .gitignore
  CLAUDE.md
  package.json
  README.md
  tsconfig.json
  vitest.config.ts
src/
  cli/
    actions/
      defaultAction.ts
      initAction.ts
      mcpAction.ts
      migrationAction.ts
      remoteAction.ts
      versionAction.ts
    cliPrint.ts
    cliRun.ts
    cliSpinner.ts
    types.ts
  config/
    configLoad.ts
    configSchema.ts
    defaultIgnore.ts
    globalDirectory.ts
  core/
    file/
      workers/
        fileCollectWorker.ts
        fileProcessWorker.ts
      fileCollect.ts
      fileManipulate.ts
      filePathSort.ts
      fileProcess.ts
      fileProcessContent.ts
      fileRead.ts
      fileSearch.ts
      fileStdin.ts
      fileTreeGenerate.ts
      fileTypes.ts
      packageJsonParse.ts
      permissionCheck.ts
    git/
      gitCommand.ts
      gitDiffHandle.ts
      gitHubArchive.ts
      gitHubArchiveApi.ts
      gitRemoteHandle.ts
      gitRemoteParse.ts
      gitRepositoryHandle.ts
    metrics/
      workers/
        fileMetricsWorker.ts
        outputMetricsWorker.ts
        types.ts
      calculateAllFileMetrics.ts
      calculateMetrics.ts
      calculateOutputMetrics.ts
      TokenCounter.ts
    output/
      outputStyles/
        markdownStyle.ts
        plainStyle.ts
        xmlStyle.ts
      outputGenerate.ts
      outputGeneratorTypes.ts
      outputSort.ts
      outputStyleDecorate.ts
    packager/
      copyToClipboardIfEnabled.ts
      writeOutputToDisk.ts
    security/
      workers/
        securityCheckWorker.ts
      filterOutUntrustedFiles.ts
      securityCheck.ts
      validateFileSafety.ts
    treeSitter/
      parseStrategies/
        CssParseStrategy.ts
        DefaultParseStrategy.ts
        GoParseStrategy.ts
        ParseStrategy.ts
        PythonParseStrategy.ts
        TypeScriptParseStrategy.ts
        VueParseStrategy.ts
      queries/
        queryC.ts
        queryCpp.ts
        queryCSharp.ts
        queryCss.ts
        queryGo.ts
        queryJava.ts
        queryJavascript.ts
        queryPhp.ts
        queryPython.ts
        queryRuby.ts
        queryRust.ts
        querySolidity.ts
        querySwift.ts
        queryTypescript.ts
        queryVue.ts
        README.md
      ext2Lang.ts
      lang2Query.ts
      languageParser.ts
      loadLanguage.ts
      parseFile.ts
    packager.ts
  mcp/
    prompts/
      packRemoteRepositoryPrompts.ts
    tools/
      fileSystemReadDirectoryTool.ts
      fileSystemReadFileTool.ts
      grepRepomixOutputTool.ts
      mcpToolRuntime.ts
      packCodebaseTool.ts
      packRemoteRepositoryTool.ts
      readRepomixOutputTool.ts
    mcpServer.ts
  shared/
    constants.ts
    errorHandle.ts
    logger.ts
    patternUtils.ts
    processConcurrency.ts
    types.ts
  types/
    git-url-parse.d.ts
  index.ts
tests/
  cli/
    actions/
      defaultAction.test.ts
      diffsFlag.test.ts
      initAction.test.ts
      mcpAction.test.ts
      migrationAction.test.ts
      remoteAction.test.ts
      versionAction.test.ts
    cliPrint.test.ts
    cliRun.test.ts
  config/
    configLoad.test.ts
    configSchema.test.ts
    globalDirectory.test.ts
  core/
    file/
      fileCollect.test.ts
      fileManipulate.test.ts
      filePathSort.test.ts
      fileProcess.test.ts
      fileProcessContent.test.ts
      fileSearch.test.ts
      fileStdin.test.ts
      packageJsonParse.test.ts
      permissionCheck.test.ts
    git/
      gitCommand.test.ts
      gitDiffHandle.test.ts
      gitHubArchive.test.ts
      gitHubArchiveApi.test.ts
      gitRemoteHandle.test.ts
      gitRemoteParse.test.ts
      gitRepositoryHandle.test.ts
    metrics/
      calculateAllFileMetrics.test.ts
      calculateMetrics.test.ts
      calculateOutputMetrics.test.ts
      diffTokenCount.test.ts
      TokenCounter.test.ts
    output/
      outputStyles/
        markdownStyle.test.ts
        plainStyle.test.ts
        xmlStyle.test.ts
      diffsInOutput.test.ts
      outputGenerate.test.ts
      outputGenerateDiffs.test.ts
      outputSort.test.ts
      outputStyleDecorate.test.ts
    packager/
      copyToClipboardIfEnabled.test.ts
      diffsFunctionality.test.ts
      writeOutputToDisk.test.ts
    security/
      workers/
        securityCheckWorker.test.ts
      filterOutUntrustedFiles.test.ts
      securityCheck.test.ts
      validateFileSafety.test.ts
    treeSitter/
      LanguageParser.test.ts
      loadLanguage.test.ts
      parseFile.c.test.ts
      parseFile.comments.test.ts
      parseFile.cpp.test.ts
      parseFile.csharp.test.ts
      parseFile.css.test.ts
      parseFile.go.test.ts
      parseFile.java.test.ts
      parseFile.javascript.test.ts
      parseFile.php.test.ts
      parseFile.python.test.ts
      parseFile.ruby.test.ts
      parseFile.rust.test.ts
      parseFile.solidity.test.ts
      parseFile.swift.test.ts
      parseFile.test.ts
      parseFile.typescript.test.ts
      parseFile.vue.test.ts
    packager.test.ts
  integration-tests/
    packager.test.ts
  mcp/
    prompts/
      packRemoteRepositoryPrompts.test.ts
    tools/
      fileSystemReadDirectoryTool.test.ts
      fileSystemReadFileTool.test.ts
      grepRepomixOutputTool.test.ts
      mcpToolRuntime.test.ts
      packCodebaseTool.test.ts
      readRepomixOutputTool.test.ts
    mcpServer.test.ts
  shared/
    logger.test.ts
    patternUtils.test.ts
    processConcurrency.test.ts
  testing/
    testUtils.ts
website/
  client/
    .vitepress/
      config/
        configDe.ts
        configEnUs.ts
        configEs.ts
        configFr.ts
        configHi.ts
        configId.ts
        configJa.ts
        configKo.ts
        configPtBr.ts
        configShard.ts
        configVi.ts
        configZhCn.ts
        configZhTw.ts
      theme/
        component.d.ts
        custom.css
        index.ts
        style.css
      config.ts
    components/
      api/
        client.ts
      Home/
        Hero.vue
        PackButton.vue
        TryIt.vue
        TryItFileUpload.vue
        TryItFolderUpload.vue
        TryItPackOptions.vue
        TryItResult.vue
        TryItResultContent.vue
        TryItResultErrorContent.vue
        TryItUrlInput.vue
      utils/
        analytics.ts
        requestHandlers.ts
        resultViewer.ts
        validation.ts
      Home.vue
      HomeBadges.vue
      YouTubeVideo.vue
    composables/
      useFileUpload.ts
      usePackOptions.ts
      usePackRequest.ts
      useZipProcessor.ts
    constants/
      videos.ts
    scripts/
      generateSchema.ts
    src/
      de/
        guide/
          development/
            index.md
            using-repomix-as-a-library.md
          tips/
            best-practices.md
          code-compress.md
          command-line-options.md
          comment-removal.md
          configuration.md
          custom-instructions.md
          github-actions.md
          index.md
          installation.md
          mcp-server.md
          output.md
          prompt-examples.md
          remote-repository-processing.md
          security.md
          usage.md
        index.md
      en/
        guide/
          development/
            index.md
            using-repomix-as-a-library.md
          tips/
            best-practices.md
          code-compress.md
          command-line-options.md
          comment-removal.md
          configuration.md
          custom-instructions.md
          github-actions.md
          index.md
          installation.md
          mcp-server.md
          output.md
          prompt-examples.md
          remote-repository-processing.md
          security.md
          usage.md
        index.md
      es/
        guide/
          development/
            index.md
            using-repomix-as-a-library.md
          tips/
            best-practices.md
          code-compress.md
          command-line-options.md
          comment-removal.md
          configuration.md
          custom-instructions.md
          github-actions.md
          index.md
          installation.md
          mcp-server.md
          output.md
          prompt-examples.md
          remote-repository-processing.md
          security.md
          usage.md
        index.md
      fr/
        guide/
          development/
            index.md
            using-repomix-as-a-library.md
          tips/
            best-practices.md
          code-compress.md
          command-line-options.md
          comment-removal.md
          configuration.md
          custom-instructions.md
          github-actions.md
          index.md
          installation.md
          mcp-server.md
          output.md
          prompt-examples.md
          remote-repository-processing.md
          security.md
          usage.md
        index.md
      hi/
        guide/
          development/
            index.md
            using-repomix-as-a-library.md
          tips/
            best-practices.md
          code-compress.md
          command-line-options.md
          comment-removal.md
          configuration.md
          custom-instructions.md
          github-actions.md
          index.md
          installation.md
          mcp-server.md
          output.md
          prompt-examples.md
          remote-repository-processing.md
          security.md
          usage.md
        index.md
      id/
        guide/
          development/
            index.md
            using-repomix-as-a-library.md
          tips/
            best-practices.md
          code-compress.md
          command-line-options.md
          comment-removal.md
          configuration.md
          custom-instructions.md
          github-actions.md
          index.md
          installation.md
          mcp-server.md
          output.md
          prompt-examples.md
          remote-repository-processing.md
          security.md
          usage.md
        index.md
      ja/
        guide/
          development/
            index.md
            using-repomix-as-a-library.md
          tips/
            best-practices.md
          code-compress.md
          command-line-options.md
          comment-removal.md
          configuration.md
          custom-instructions.md
          github-actions.md
          index.md
          installation.md
          mcp-server.md
          output.md
          prompt-examples.md
          remote-repository-processing.md
          security.md
          usage.md
        index.md
      ko/
        guide/
          development/
            index.md
            using-repomix-as-a-library.md
          tips/
            best-practices.md
          code-compress.md
          command-line-options.md
          comment-removal.md
          configuration.md
          custom-instructions.md
          github-actions.md
          index.md
          installation.md
          mcp-server.md
          output.md
          prompt-examples.md
          remote-repository-processing.md
          security.md
          usage.md
        index.md
      pt-br/
        guide/
          development/
            index.md
            using-repomix-as-a-library.md
          tips/
            best-practices.md
          code-compress.md
          command-line-options.md
          comment-removal.md
          configuration.md
          custom-instructions.md
          github-actions.md
          index.md
          installation.md
          mcp-server.md
          output.md
          prompt-examples.md
          remote-repository-processing.md
          security.md
          usage.md
        index.md
      public/
        images/
          repomix-logo.svg
        schemas/
          0.3.5/
            schema.json
          latest/
            schema.json
      vi/
        guide/
          development/
            index.md
            using-repomix-as-a-library.md
          tips/
            best-practices.md
          code-compress.md
          command-line-options.md
          comment-removal.md
          configuration.md
          custom-instructions.md
          github-actions.md
          index.md
          installation.md
          mcp-server.md
          output.md
          prompt-examples.md
          remote-repository-processing.md
          security.md
          usage.md
        index.md
      zh-cn/
        guide/
          development/
            index.md
            using-repomix-as-a-library.md
          tips/
            best-practices.md
          code-compress.md
          command-line-options.md
          comment-removal.md
          configuration.md
          custom-instructions.md
          github-actions.md
          index.md
          installation.md
          mcp-server.md
          output.md
          prompt-examples.md
          remote-repository-processing.md
          security.md
          usage.md
        index.md
      zh-tw/
        guide/
          development/
            index.md
            using-repomix-as-a-library.md
          tips/
            best-practices.md
          code-compress.md
          command-line-options.md
          comment-removal.md
          configuration.md
          custom-instructions.md
          github-actions.md
          index.md
          installation.md
          mcp-server.md
          output.md
          prompt-examples.md
          remote-repository-processing.md
          security.md
          usage.md
        index.md
    utils/
      videos.ts
    .gitignore
    .tool-versions
    Dockerfile
    package.json
    tsconfig.json
    tsconfig.node.json
  server/
    src/
      schemas/
        request.ts
      utils/
        cache.ts
        errorHandler.ts
        fileUtils.ts
        logger.ts
        network.ts
        processConcurrency.ts
        rateLimit.ts
        sharedInstance.ts
        time.ts
        validation.ts
      constants.ts
      index.ts
      processZipFile.ts
      remoteRepo.ts
      types.ts
    .dockerignore
    .gitignore
    cloudbuild.yaml
    Dockerfile
    package.json
    tsconfig.json
  CLAUDE.md
  compose.yml
  README.md
.clinerules
.codecov.yml
.coderabbit.yaml
.cursorrules
.dockerignore
.editorconfig
.gitignore
.node-version
.repomixignore
.secretlintrc.json
.tool-versions
biome.json
CLAUDE.md
CODE_OF_CONDUCT.md
CONTRIBUTING.md
Dockerfile
LICENSE
llms-install.md
package.json
README.md
repomix-instruction.md
repomix.config.json
SECURITY.md
tsconfig.build.json
tsconfig.json
typos.toml
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/commands/claude-rule-update.md">
Please update CLAUDE.md based on our conversation.
Follow any additional instructions if provided.
</file>

<file path=".claude/commands/git-commit-push.md">
Please commit and push your changes.

The commit message should follow the rules specified in CLAUDE.md.
</file>

<file path=".claude/commands/git-commit.md">
Please commit your changes.

The commit message should follow the rules specified in CLAUDE.md.
</file>

<file path=".claude/commands/pr-create.md">
Please create a PR following the template at `.github/pull_request_template.md`.
</file>

<file path=".claude/commands/pr-review-request.md">
Please request a review of this pull request from Gemini and Coderabbit.
</file>

<file path=".claude/commands/pr-review.md">
Please review the provided PR.

Even if there are no issues to point out, please leave a review comment on GitHub.

You can use the `gh` command for comments.
</file>

<file path=".devcontainer/devcontainer.json">
{
  "name": "Repomix",
  "image": "mcr.microsoft.com/devcontainers/typescript-node:1-22-bullseye",
  "runArgs": ["--name", "repomix-devcontainer"],
  "postCreateCommand": "npm install"
}
</file>

<file path=".github/actions/repomix/action.yml">
name: "Repomix Action"
description: "Pack repository contents into a single file that is easy for LLMs to process"
author: "Kazuki Yamada <koukun0120@gmail.com>"
branding:
  icon: archive
  color: purple

inputs:
  directories:
    description: "Space-separated list of directories to process (defaults to '.')"
    required: false
    default: "."
  include:
    description: "Comma-separated glob patterns to include"
    required: false
    default: ""
  ignore:
    description: "Comma-separated glob patterns to ignore"
    required: false
    default: ""
  output:
    description: "Relative path to write packed file"
    required: false
    default: "repomix-output.xml"
  compress:
    description: "Set to 'false' to disable smart compression"
    required: false
    default: "true"
  style:
    description: "Output style (xml, markdown, plain)"
    required: false
    default: "xml"
  additional-args:
    description: "Any extra raw arguments to pass directly to the repomix CLI"
    required: false
    default: ""
  repomix-version:
    description: "Version (or tag) of the npm package to install – defaults to latest"
    required: false
    default: "latest"

runs:
  using: "composite"
  steps:
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: "24"
        cache: "npm"
    - name: Install Repomix
      shell: bash
      run: |
        npm install --global repomix@${{ inputs.repomix-version }}
    - name: Run Repomix
      id: build
      shell: bash
      run: |
        set -e
        # Using an array for safer command execution
        # Safely split directories input into an array, handling spaces correctly
        IFS=' ' read -r -a ARGS <<< "${{ inputs.directories }}"
        
        if [ -n "${{ inputs.include }}" ]; then
          ARGS+=(--include "${{ inputs.include }}")
        fi
        
        if [ -n "${{ inputs.ignore }}" ]; then
          ARGS+=(--ignore "${{ inputs.ignore }}")
        fi
        
        if [ "${{ inputs.compress }}" = "false" ]; then
          ARGS+=(--no-compress)
        else
          ARGS+=(--compress)
        fi
        
        if [ -n "${{ inputs.style }}" ]; then
          ARGS+=(--style "${{ inputs.style }}")
        fi
        
        ARGS+=(--output "${{ inputs.output }}")
        
        # Only add additional args if not empty
        if [ -n "${{ inputs.additional-args }}" ]; then
          # Use safer parsing for additional arguments
          IFS=' ' read -r -a ADDITIONAL_ARGS <<< "${{ inputs.additional-args }}"
          ARGS+=("${ADDITIONAL_ARGS[@]}")
        fi
        
        echo "Running: repomix ${ARGS[*]}"
        repomix "${ARGS[@]}"
        
        echo "output_file=${{ inputs.output }}" >> "$GITHUB_OUTPUT"

outputs:
  output_file:
    description: "Path to the file generated by Repomix"
    value: ${{ steps.build.outputs.output_file }}
</file>

<file path=".github/instructions/base.instructions.md">
---
applyTo: '**'
---

# Repomix Project Structure and Overview

This document provides a structural overview of the Repomix project, designed to aid AI code assistants (like Copilot) in understanding the codebase.

Please refer to `README.md` for a complete and up-to-date project overview, and `CONTRIBUTING.md` for implementation guidelines and contribution procedures.

## Project Overview

Repomix is a tool that packs the contents of a software repository into a single file, making it easier for AI systems to analyze and process the codebase. It supports various output formats (XML, Markdown, or plain text), ignores files based on configurable patterns, and performs security checks to exclude potentially sensitive information.

## Directory Structure

The project is organized into the following directories:

```
repomix/
├── src/ # Main source code
│   ├── cli/ # Command-line interface logic (argument parsing, command handling, output)
│   ├── config/ # Configuration loading, schema, and defaults
│   ├── core/ # Core logic of Repomix
│   │   ├── file/ # File handling (reading, processing, searching, tree structure generation, git commands)
│   │   ├── metrics/ # Calculating code metrics (character count, token count)
│   │   ├── output/ # Output generation (different styles, headers, etc.)
│   │   ├── packager/ # Orchestrates file collection, processing, output, and clipboard operations.
│   │   ├── security/ # Security checks to exclude sensitive files
│   │   ├── mcp/ # MCP server integration (packaging codebases for AI analysis)
│   │   ├── tokenCount/ # Token counting using Tiktoken
│   │   └── treeSitter/ # Code parsing using Tree-sitter and language-specific queries
│   └── shared/ # Shared utilities and types (error handling, logging, helper functions)
├── tests/ # Unit and integration tests (organized mirroring src/)
│   ├── cli/
│   ├── config/
│   ├── core/
│   ├── integration-tests/
│   ├── shared/
│   └── testing/
└── website/ # Documentation website (VitePress)
    ├── client/      # Client-side code (Vue.js components, styles, configuration)
    │   ├── .vitepress/  # VitePress configuration and theme
    │   │   ├── config/  # Site configuration files (navigation, sidebar, etc.)
    │   │   └── theme/   # Custom theme and styles
    │   ├── components/ # Vue.js components for the website
    │   └── src/        # Markdown files for multilingual documentation
    └── server/      # Server-side API (for remote repository processing)
        └── src/       # Server source code (API endpoints, request handling)
```



# Coding Guidelines
- Follow the Airbnb JavaScript Style Guide.
- Split files into smaller, focused units when appropriate:
  - Aim to keep code files under 250 lines. If a file exceeds 250 lines, split it into multiple files based on functionality.
- Add comments to clarify non-obvious logic. **Ensure all comments are written in English.**
- Provide corresponding unit tests for all new features.
- After implementation, verify changes by running:
  ```bash
  npm run lint  # Ensure code style compliance
  npm run test  # Verify all tests pass
  ```

## Commit Messages
- Follow the [Conventional Commits](https://www.conventionalcommits.org/) specification for all commit messages
- Always include a scope in your commit messages
- Format: `type(scope): Description`
  ```
  # Examples:
  feat(cli): Add new --no-progress flag
  fix(security): Handle special characters in file paths
  docs(website): Update installation guide
  style(website): Update GitHub sponsor button color
  refactor(core): Split packager into smaller modules
  test(cli): Add tests for new CLI options
  ```
- Types: feat, fix, docs, style, refactor, test, chore, etc.
- Scope should indicate the affected part of the codebase (cli, core, website, security, etc.)
- Description should be clear and concise in present tense
- Description must start with a capital letter

## Pull Request Guidelines
- All pull requests must follow the template:
  ```md
  <!-- Please include a summary of the changes -->

  ## Checklist

  - [ ] Run `npm run test`
  - [ ] Run `npm run lint`
  ```
- Include a clear summary of the changes at the top of the pull request description
- Reference any related issues using the format `#issue-number` 


## Dependencies and Testing
- Inject dependencies through a deps object parameter for testability
- Example:
  ```typescript
  export const functionName = async (
    param1: Type1,
    param2: Type2,
    deps = {
      defaultFunction1,
      defaultFunction2,
    }
  ) => {
    // Use deps.defaultFunction1() instead of direct call
  };
  ```
- Mock dependencies by passing test doubles through deps object
- Use vi.mock() only when dependency injection is not feasible

## Generate Comprehensive Output
- Include all content without abbreviation, unless specified otherwise
- Optimize for handling large codebases while maintaining output quality
</file>

<file path=".github/instructions/github-release-note.instructions.md">
---
applyTo: '**'
---

# GitHub Release Note Guidelines
When writing release notes, please follow these guidelines:

- When referencing issues or PRs, use the gh command to verify the content:
  ```bash
  gh issue view <issue-number>  # For checking issue content
  gh pr view <pr-number>        # For checking PR content
  ```
  This helps ensure accuracy in release note descriptions.

Here are some examples of release notes that follow the guidelines:

v0.2.25
````md
This release brings significant improvements to output formatting and introduces flexible remote repository handling capabilities along with enhanced logging features.

# Improvements ⚡

## Remote Repository Enhancement (#335)
- Added branch/tag parsing directly from repository URLs:
```bash
repomix --remote https://github.com/yamadashy/repomix/tree/0.1.x
```
Functions identically to:
```bash
repomix --remote https://github.com/yamadashy/repomix --remote-branch 0.1.x
```

Special thanks to @huy-trn for implementing this user-friendly feature!

## Enhanced Output Formatting (#328, #329, #330)
- Added "End of Codebase" marker for better clarity in output
- Improved output header accuracy:
  - Better representation of codebase scope
  - Clear indication when using `--include` or `--ignore` options

Special thanks to @gitkenan for adding the "End of Codebase" marker and reporting the header issue!

## Path Pattern Support (#337)
- Added support for special characters in paths:
  - Handles parentheses in include patterns (e.g., `src/(categories)/**/*`)
  - Improved escaping for `[]` and `{}`
  - Essential for Next.js route groups and similar frameworks

Thank you @matheuscoelhomalta for improving path pattern support!

# How to Update

```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
````

v0.2.24
````md
This release significantly enhances configuration flexibility with comprehensive CLI flag support and expands default ignore patterns for better project scaffolding. 

# What's New 🚀

## CLI Flags Revolution (#324)
- New command-line configuration now available.

```
- `--no-gitignore`: Disable .gitignore file usage
- `--no-default-patterns`: Disable default patterns
- `--header-text <text>`: Custom text to include in the file header
- `--instruction-file-path <path>`: Path to a file containing detailed custom instructions
- `--include-empty-directories`: Include empty directories in the output
```

Special recognition to @massdo for driving ecosystem growth.

# Improvements ⚡

## Enhanced Ignore Patterns (#318, #322)
- Expanded default ignores for Rust projects:
  - `target/`, `Cargo.lock`, build artifacts
  - PHP, Ruby, Go, Elixir, Haskell: package manager lock files

To @boralg for helping curate Rust-specific patterns!

# How to Update
```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
````

v0.2.23
````md
This release adds significant performance improvements for large repositories, making Repomix faster and more efficient when needed.

# Improvements ⚡

## Parallel Processing Enhancement (#309)
- Implemented worker threads using [Piscina](https://github.com/piscinajs/piscina) for parallel processing

### Benchmark Results
- `yamadashy.repomix`: No significant change
  - Before: 868.73 millis
  - After: 671.26 millis
- `facebook/react`: 29x faster
  - Before: 123.31 secs
  - After: 4.19 secs
- `vercel/next.js`: 58x faster
  - Before: 17.85 mins
  - After: 17.27 secs

Note: While Repomix is not primarily designed for processing large repositories, and speed is not a primary goal, faster processing can provide a better user experience when working with larger codebases.

# How to Update

```bash
npm update -g repomix
```


---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
````

v0.2.22
````md
This release introduces significant improvements to large file handling and expands the Repomix ecosystem with new tools and community channels.

# Improvements ⚡ 

## Improved Large File Handling (#302)

- Added a file size limit check (50MB) to prevent memory issues
- Graceful error handling for large files with clear user guidance:

Special thanks to @slavashvets for their continued contributions!

# Ecosystem Growth 🤝 

## New VS Code Extension (#300)
A community-created VS Code extension "Repomix Runner" is now available:
- Run Repomix directly from VS Code
- Extension by @massdo: [View on VS Code Marketplace](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner)

Thank you @massdo for bringing Repomix to VS Code and expanding our tooling ecosystem!

## Official Social Media
- Launched official Repomix X (Twitter) account: [@repomix_ai](https://x.com/repomix_ai)
  - Follow for updates, tips, and community highlights

# How to Update

```bash
npm update -g repomix
```

---

Join our growing community on [Discord](https://discord.gg/BF8GxZHE2C) and follow us on [X](https://x.com/repomix_ai) for updates!
````

v0.2.21
````md
This release introduces significant improvements to output formatting and documentation, featuring a new parsable style option for enhanced XML handling.

# What's New 🚀 

## Enhanced Output Style Control (#287)
- Added new `parsableStyle` option for better output handling:
  - Ensures output strictly follows the specification of the chosen format
  - Provides properly escaped XML output with fast-xml-parser
  - Dynamically adjusts markdown code block delimiters to avoid content conflicts
- Available via CLI flag `--parsable-style` or in configuration file

Special thanks to @atollk for their first contribution!

# Documentation 📚

## README Enhancements (#296)
- Updated Homebrew installation documentation to include Linux support

Special thanks to @chenrui333 for their continued contributions!

## Website Multi-Language Support (#293)
- Enhanced multi-language support in [repomix.com](https://repomix.com)

# How to Update

To update to the latest version, run:
```bash
npm update -g repomix
```


---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
````
</file>

<file path=".github/instructions/website.instructions.md">
---
applyTo: '**'
---

# Website Documentation

## Supported Languages
The website documentation is available in the following languages:
- English (en)
- Japanese (日本語) (ja)
- Chinese Simplified (简体中文) (zh-cn)
- Chinese Traditional (繁體中文) (zh-tw)
- Korean (한국어) (ko)
- German (Deutsch) (de)
- French (Français) (fr)
- Spanish (Español) (es)
- Portuguese Brazilian (Português do Brasil) (pt-br)
- Indonesian (Bahasa Indonesia) (id)
- Vietnamese (Tiếng Việt) (vi)
- Hindi (हिन्दी) (hi)

All translations should be accurate and maintain consistent terminology across languages. When adding new features or documentation, please ensure that the English version is updated first, followed by translations in other languages.

## Navigation Configuration
When modifying website navigation or adding new pages:
1. Update the configuration files in `website/client/.vitepress/config/`.

Ensure all language configurations are synchronized to maintain consistency across the documentation.

## Adding New Languages
When adding support for a new language, follow these steps:

1. Create a configuration file (e.g., `configXx.ts`) in `website/client/.vitepress/config/` based on existing language configurations
2. Include proper sidebar navigation, labels, and search translations
3. Update the imports and locale entries in the main VitePress configuration (`config.ts`)
4. Add search configurations to `configShard.ts`
5. Update the supported languages list in this file
6. Create directory structure for content (e.g., `website/client/src/xx/`)
7. Create content files starting with main index page and guide index
8. Progressively translate remaining documentation pages
9. Test navigation and search functionality in the new language

When working on multiple languages simultaneously, approach one language at a time completely before moving to the next language to maintain quality and consistency.
</file>

<file path=".github/ISSUE_TEMPLATE/01_feature_request.yml">
name: 🚀 Feature Request
description: Suggest an idea or improvement for Repomix
labels:
  - enhancement
body:
  - type: markdown
    attributes:
      value: |
        Thank you for helping improve Repomix!

        We appreciate your feedback and will review your request as soon as possible.

  - type: textarea
    id: description
    attributes:
      label: Description
      description: "A clear and concise description of the feature you’d like to see."
      placeholder: |
        e.g. Add support for a `.repomixignore` file to exclude certain paths when packing.
    validations:
      required: true
</file>

<file path=".github/ISSUE_TEMPLATE/02_bug_report.yml">
name: 🐛 Bug Report
description: Report an unexpected behavior or error in Repomix
labels: [triage]
body:
  - type: markdown
    attributes:
      value: |
        Thank you for reporting an issue! We appreciate your help in making Repomix better.

        If you need real-time support, feel free to join our [Discord server](https://discord.gg/wNYzTwZFku).

        Please provide as much detail as possible.

  - type: textarea
    id: description
    attributes:
      label: Description
      description: "Please provide a concise description of what happened."
      placeholder: |
        e.g. Running `repomix --version` prints an error instead of the version.
    validations:
      required: true

  - type: dropdown
    id: usage_context
    attributes:
      label: Usage Context
      description: "Where did you encounter this issue?"
      options:
        - Repomix CLI
        - repomix.com

  - type: input
    id: repomix_version
    attributes:
      label: Repomix Version
      description: "Output of `repomix --version`"
      placeholder: "e.g. v0.3.5"

  - type: input
    id: node_version
    attributes:
      label: Node.js Version
      description: "Output of `node --version`"
      placeholder: "e.g. v18.16.0"
</file>

<file path=".github/ISSUE_TEMPLATE/config.yml">
blank_issues_enabled: true

contact_links:
  - name: "💬 Discord Community"
    about: "Join our Discord server for support and discussion"
    url: "https://discord.gg/wNYzTwZFku"
</file>

<file path=".github/releases/v0.1.x/v0.1.15.md">
It appears I've been fashionably late to the release notes soirée.  It's like we've been living under a rock from v0.1.1 to v0.1.14. But they, better late than never, as they say in the world of procrastinating developers.

## New Features

### Output Style Options
- Introducing the `output.style` configuration option:
  - `plain`: The classic output format.
  - `xml`: An XML-structured output for enhanced parsing.

This addition aims to provide more flexibility in how Repopack structures its output.

For those interested in the potential of XML tags in AI contexts:
https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags

## How to Use

Add `output.style` to your configuration and select either `plain` or `xml`. The choice is yours, based on your project needs.

---
Your feedback is the wind beneath Repopack's wings. Feel free to report bugs or request features.

Thank you for your continued support.
</file>

<file path=".github/releases/v0.1.x/v0.1.16.md">
Our CLI has learned the art of style. It's now fluent in both plain and XML.

## What's New

- Added `--style` option to CLI
  - Choose between `plain` and `xml` output styles
  - Usage: `repopack --style xml`

Happy packing!
</file>

<file path=".github/releases/v0.1.x/v0.1.18.md">
It's focusing on security improvements and output refinements. 

## Improvements
###  Security Enhancements: Exclude Suspicious Files
- Implemented a filter to exclude potentially sensitive files from the output. 
- This improvement prevents the inclusion of suspicious files, enhancing overall security.

## Fixes
### Prevent Recursive Output Issues
- Modified the `getFilePaths` function in `src/core/packager.ts` to exclude the output file from processing.
- This fix resolves a recursive issue where the output file was being included in itself.

## Changes
### XML Escaping Removal
- Removed XML escaping for file paths and contents in repository files.
- This change improves readability and AI comprehension of the generated output.

Note: This update assumes that input data (file paths, contents, etc.) does not contain characters that would break XML syntax. If there's a possibility of such characters, we may implement a more robust solution in the future, such as using CDATA sections for file contents.
</file>

<file path=".github/releases/v0.1.x/v0.1.19.md">
It's focusing on improved file filtering capabilities and overall performance enhancements. 

## New Features

### Support `include` (#22, #30)
- Introduced the `--include` CLI option for specifying files to include using glob patterns. 
- Added support for `include` patterns in the configuration file.

To pack specific files or directories using glob patterns:
```bash
repopack --include "src/**/*.ts,**/*.md"
```

Special thanks to @IsaacSante for their contributions.

## Improvements

### Performance Optimization
- Replaced the `ignore` package with `globby` for more efficient file filtering.
</file>

<file path=".github/releases/v0.1.x/v0.1.20.md">
## Changes

### gitignore Syntax Compliance
- Fixed handling of `.gitignore` and `.repopackignore` files to properly comply with gitignore syntax.
- This ensures more accurate and consistent file filtering based on your ignore patterns.

### Change File Filtering Logic
- Migrated custom ignore pattern processing from gitignore syntax to glob patterns. 

## Notes

- This update may affect which files are included/excluded in the packed output. We recommend reviewing your ignore patterns to ensure desired behavior.
- If you're using a custom configuration, make sure to update your `ignore.customPatterns` to use glob patterns instead of gitignore syntax.
</file>

<file path=".github/releases/v0.1.x/v0.1.21.md">
## Improvements

### Enhanced ignore files support (#34, #35)
- Updated the file filtering logic to consider `.gitignore`, `.repopackignore` files in all directories, not just the root.
- This change ensures that all ignore files, regardless of their location in the project structure, are properly respected during the file filtering process.

## Notes
- This update improves the handling of ignore files in your project structure. You may notice changes in which files are included or excluded if you have ignore files in subdirectories.
</file>

<file path=".github/releases/v0.1.x/v0.1.22.md">
This update brings a significant new feature that enhances the tool's utility for working with large language models.

## New Features

### Token Counting Support (#39)

Thanks to the fantastic contribution from @joshellington, Repopack now includes token counting functionality:

- Added token counts for individual files and the entire repository
- Updated CLI output to display token information in the summary and top files list

This feature is particularly useful for users working within context limits of large language models like GPT-4.

A huge thank you to @joshellington for this valuable contribution!
</file>

<file path=".github/releases/v0.1.x/v0.1.23.md">
This update introduces a new interactive configuration setup and includes several improvements to enhance user experience.

## New Features

### Interactive Configuration Setup (#45)

- Added a new `--init` command to Repopack
- Users can now interactively create a basic `repopack.config.json` file
- The setup prompts for:
  - Output file path
  - Output style (plain or XML)

<img width="633" alt="image" src="https://github.com/user-attachments/assets/e3a2bba3-053a-491c-ae42-36bd24cc4395">

This new feature simplifies the process of getting started with Repopack, especially for new users.

---

To update, simply run:
```bash
npm update -g repopack
```
</file>

<file path=".github/releases/v0.1.x/v0.1.24.md">
This update focuses on significant performance improvements through the implementation of parallel processing.

## What's New

### Parallel Processing (#50)

- Implemented parallel processing in key components of Repopack

---
To update, simply run:
```
npm update -g repopack
```

As always, we appreciate your feedback and contributions to make Repopack even better!
</file>

<file path=".github/releases/v0.1.x/v0.1.25.md">
This update introduces global configuration support, allowing for more consistent settings across projects.

## What's New

### Global Configuration Support (#51, #52)

- Added support for global configuration files
- Implemented `repopack --init --global` command to create a global config
- Global config locations:
  - Windows: `%LOCALAPPDATA%\Repopack\repopack.config.json`
  - macOS/Linux: `$XDG_CONFIG_HOME/repopack/repopack.config.json` or `~/.config/repopack/repopack.config.json`
- Local configs still take precedence when present

---
To update, simply run:
```
npm update -g repopack
```

As always, we appreciate your feedback and contributions to make Repopack even better!
</file>

<file path=".github/releases/v0.1.x/v0.1.26.md">
## Bug Fixes

- Fixed issue where Repopack could process its own output file (#53)

---

To update:

```
npm update -g repopack
```

Thank you for using Repopack!
</file>

<file path=".github/releases/v0.1.x/v0.1.27.md">
## Bug Fixes

### Fix `output.showLineNumbers` (#54)

- Resolved the issue where line numbers were not being added to processed content when `output.showLineNumbers` was enabled
  - Implemented padding for line numbers to ensure proper alignment

---

To update, simply run:
```
npm update -g repopack
```

As always, we appreciate your feedback and contributions to make Repopack even better!
</file>

<file path=".github/releases/v0.1.x/v0.1.28.md">
## Bug Fixes

### Fix concurrency issue in environments where CPU count is unavailable (#56, #57)

- Resolved the issue where Repopack would fail in environments where `os.cpus().length` returns 0 (e.g., some Termux on Android setups)

---

To update, simply run:
```
npm update -g repopack
```

As always, we appreciate your feedback and contributions to make Repopack even better!
</file>

<file path=".github/releases/v0.1.x/v0.1.29.md">
## Security Updates

### Update micromatch to address security vulnerability (#58)

- Updated `micromatch` from version 4.0.7 to 4.0.8
- This update includes a critical security fix for CVE-2024-4067

---

To update, simply run:
```
npm update -g repopack
```
</file>

<file path=".github/releases/v0.1.x/v0.1.30.md">
## Bug Fixes

### Simplify Python comment removal to preserve f-strings and other content (#55, #59)

- Changed the comment removal strategy for Python files to only remove single-line comments starting with '#'
  - Preserved all other content, including string literals, f-strings, and docstrings
  - Resolved the issue where f-strings and other important code elements were being incorrectly removed

---

To update, simply run:
```
npm update -g repopack
```

As always, we appreciate your feedback and contributions to make Repopack even better!
</file>

<file path=".github/releases/v0.1.x/v0.1.31.md">
This update introduces remote repository processing, allowing users to analyze any public Git repository without manual cloning.

## What's New

### Remote Repository Processing Support (#61)

- Added `--remote` option to process remote Git repositories
- Supports full URLs and GitHub shorthand format (e.g., `user/repo`)

#### Usage Examples

Process a GitHub repository:
```bash
repopack --remote https://github.com/user/repo.git
```

Use GitHub shorthand:
```bash
repopack --remote user/repo
```

Process a GitLab repository:
```bash
repopack --remote https://gitlab.com/user/repo.git
```

---
To update, simply run:
```
npm update -g repopack
```

As always, we appreciate your feedback and contributions to make Repopack even better!
</file>

<file path=".github/releases/v0.1.x/v0.1.32.md">
This release focuses on improving performance and user experience, particularly when processing large repositories.

## Bug Fixes
###  Fixed an issue where the application appeared to hang (#63, #65)

- Fixed an issue where the application appeared to hang during the security check process on large repositories.
- Reduced the impact on the event loop to prevent hanging when processing a large number of files.
- Implemented more frequent console updates during file processing and security checks.

---
To update, simply run:
```
npm update -g repopack
```

As always, we appreciate your feedback and contributions to make Repopack even better!
</file>

<file path=".github/releases/v0.1.x/v0.1.33.md">
This release  brings improvements to the `--init` process.

## Improvements

### Enhanced `repopack --init` Process (#67)

- Separated the creation processes for `repopack.config.json` and `.repopackignore` files, allowing users more granular control over their setup.

These improvements make it easier for new users to get started with Repopack and provide a smoother configuration experience for all users.

---

To update, simply run:
```
npm update -g repopack
```

As always, we appreciate your feedback and contributions to make Repopack even better!
</file>

<file path=".github/releases/v0.1.x/v0.1.34.md">
This release focuses on improving the default ignore patterns, particularly for subdirectories.

## Improvements

### Enhanced Default Ignore Patterns (#68)

- Fixed an issue where dependency directories in subdirectories (particularly `node_modules`) were not being ignored correctly.
- Updated default ignore patterns include more comprehensive patterns:
  - Included additional common dependency directories for various languages (e.g., `vendor`, `.bundle`, `.gradle`, `target`).

---

To update, run:
```
npm update -g repopack
```

As always, we appreciate your feedback and contributions to make Repopack even better!
</file>

<file path=".github/releases/v0.1.x/v0.1.35.md">
This release introduces experimental support for custom instruction files, allowing users to provide more detailed context and guidelines for AI analysis of their projects.

## What's New

### Custom Instruction File Support (#40, #46)

- Added `output.instructionFilePath` option to configuration
  - Updated output generators to include project instructions in the output

We are introducing this feature experimentally and plan to continuously evaluate and improve it based on user feedback and real-world usage. Your insights and experiences with this new feature will be invaluable as we refine and enhance it in future updates.

Note: Custom instructions are appended at the end of the output file for optimal AI processing

For more details, see:
https://github.com/yamadashy/repopack?tab=readme-ov-file#custom-instruction

## Internal Changes

### Handlebars Integration

- Integrated Handlebars templating engine for more flexible and maintainable output generation

---

To update, simply run:
```bash
npm update -g repopack
```

As always, we appreciate your contributions to make Repopack even better!
</file>

<file path=".github/releases/v0.1.x/v0.1.36.md">
This release introduces a new configuration option that allows users to control the security check feature, providing more flexibility in how Repopack handles sensitive information detection.

## What's New

### Configurable Security Check (#74, #75)

- Added new configuration option `security.enableSecurityCheck` (default: `true`)
  - Users can now disable the security check when needed, such as when working with cryptographic libraries or known false positives

## How to Use

To **disable** the security check, add the following to your `repopack.config.json`:

```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

**Note:** Disabling the security check may expose sensitive information. Use this option with caution and only when necessary.

---

To update, simply run:
```bash
npm update -g repopack
```

As always, we appreciate your feedback and contributions to make Repopack even better! If you encounter any issues or have suggestions regarding this new feature, please let us know through our GitHub issues.
</file>

<file path=".github/releases/v0.1.x/v0.1.37.md">
This release introduces significant improvements to Python comment removal.

## Improvements

### Enhanced Python Comment Removal (#81, #60, #55)

- Improved handling of Python comments and docstrings
  - Better support for complex scenarios including nested quotes and multi-line strings

We'd like to extend our sincere thanks to @thecurz and @KrunchMuffin for their valuable contributions to this release!

---

To update, simply run:
```bash
npm update -g repopack
```

As always, we appreciate your feedback and contributions to make Repopack even better! If you encounter any issues or have suggestions regarding these new features, please let us know through our GitHub issues.
</file>

<file path=".github/releases/v0.1.x/v0.1.38.md">
This release introduces a new Markdown output style, providing users with an additional option for formatting their repository content.

## What's New

### Markdown Output Style (#86, #87)

- Added new 'markdown' output style option
  - Users can now generate output in Markdown format, alongside existing plain text and XML options

## How to Use

To use the new Markdown output style, use the `--style markdown` option:

```bash
repopack --style markdown
```

Or update your `repopack.config.json`:

```json
{
  "output": {
    "style": "markdown"
  }
}
```

---

To update, simply run:
```bash
npm update -g repopack
```

As always, we appreciate your feedback and contributions to make Repopack even better! If you encounter any issues or have suggestions regarding this new feature, please let us know through our GitHub issues.
</file>

<file path=".github/releases/v0.1.x/v0.1.39.md">
This release focuses on improving the stability of Repopack by enhancing error handling for tiktoken-related issues. 

## Improvements

### Enhanced Error Handling for Token Counting (#89, #91)

- Improved error handling for tiktoken-related issues in the token counting process
  - Added warning logs for files that fail token counting

## How to Update

To update to the latest version, simply run:

```bash
npm update -g repopack
```

---

We appreciate your feedback and contributions to make Repopack even better! If you encounter any issues or have suggestions, please let us know through our GitHub issues.
</file>

<file path=".github/releases/v0.1.x/v0.1.40.md">
This release introduces improvements to file handling and output formatting, enhancing Repopack's functionality and user experience.

## Improvements

### Enhanced Markdown Support (#86, #95)

- Improved code block formatting in Markdown output:
  - Added language identifiers to code blocks for better syntax highlighting
  - Extended support for various file extensions to improve language detection
- Dynamic output file extension:
  - The extension of the output file now changes based on the selected style (e.g., `.md` for Markdown, `.xml` for XML)
  - This behavior only applies when no specific output file path is provided by the user

### Enhanced Exclusion of Package Manager Lock Files (#90, #94)

- Improved exclusion of common package manager lock files:
  - npm: `package-lock.json`
  - Yarn: `yarn.lock`
  - pnpm: `pnpm-lock.yaml`
  - These files are now automatically excluded from the packed output, including those in subdirectories

## How to Update

To update to the latest version, run:

```bash
npm update -g repopack
```

---

We value your feedback and contributions in making Repopack better! If you encounter any issues or have suggestions, please share them through our GitHub issues.
</file>

<file path=".github/releases/v0.1.x/v0.1.41.md">
This release brings improvements to the initialization process and adds Homebrew installation support for macOS users.

## Improvements

### Improved Initialization Process (#96)

- Reordered prompts to ask for output style before file path
- Added Markdown as a new output style option during initialization

### Homebrew Installation Support (https://github.com/Homebrew/homebrew-core/pull/192391)

- Added Homebrew installation instructions for macOS users

## How to Update/Install

To update to the latest version, run:

```bash
npm install -g repopack
```

For macOS users, you can now install Repopack using Homebrew:

```bash
brew install repopack
```

---

We value your feedback and contributions in making Repopack better! If you encounter any issues or have suggestions, please share them through our GitHub issues.
</file>

<file path=".github/releases/v0.1.x/v0.1.42.md">
This release focuses on optimizing file processing and improving overall code efficiency.

## Improvements

### Optimize File Processing (#112, #122)

- Improved the efficiency of string parsing operations
- Enhanced whitespace handling for better performance

We'd like to extend our sincere thanks to @Mefisto04 for their valuable contributions to this release!

## How to Update

To update to the latest version, run:

```bash
npm update -g repopack
```

---

We value your feedback and contributions in making Repopack better! If you encounter any issues or have suggestions, please share them through our GitHub issues.
</file>

<file path=".github/releases/v0.1.x/v0.1.43.md">
This release addresses a bug fix related to configuration validation for the Markdown output style.

## Bug Fixes

### Fixed Configuration Validation for Markdown Style (#126)

- Resolved an issue where using 'markdown' in the configuration file would trigger an invalid configuration error

We'd like to extend our sincere thanks to @r-dh for identifying and fixing this issue!

## How to Update

To update to the latest version, run:

```bash
npm update -g repopack
```

---

We value your feedback and contributions in making Repopack better! If you encounter any issues or have suggestions, please share them through our GitHub issues.
</file>

<file path=".github/releases/v0.1.x/v0.1.44.md">
This release brings several enhancements, focusing on improved performance, streamlined output generation, better error handling, and added convenience for developers.  We've also addressed a few bugs and updated dependencies for better compatibility and security.

## Improvements

* **Streamlined Output Generation**:  The output generation process has been refactored for better maintainability and efficiency. This reduces code duplication and simplifies adding new output styles in the future. Thanks @iNerdStack!
* **Optimized File Searching**: Improved error handling and efficiency in the file searching process, providing more informative error messages and faster execution. Thanks @Mefisto04!
* **Enhanced Process Concurrency**: More accurate calculation of CPU cores to optimize concurrency during file processing, leading to faster packing times. Thanks @twlite!
* **Async Timeout for Sleep**: Replaced the previous sleep implementation with `setTimeout` to avoid blocking the event loop, enhancing responsiveness. Thanks @twlite!

## Bug Fixes

* **Markdown Configuration Validation**: Resolved an issue where using 'markdown' in the configuration file would trigger an invalid configuration error. Thanks @r-dh!

## Internal Changes

* **Brew Formula Auto-Update**: Homebrew formula will now be automatically updated with each tagged release, simplifying installation and updates for macOS users. Thanks @r-dh!

* **Corrected License Link in README**: Fixed a broken link to the license in the README file. Thanks @Kaushik080!

### How to Update

To update to the latest version, run:

```bash
npm update -g repopack
```

We appreciate all contributions and feedback from our community! If you encounter any issues or have suggestions, please open an issue on GitHub.
</file>

<file path=".github/releases/v0.1.x/v0.1.45.md">
This release adds important migration notices as we prepare to transition from Repopack to Repomix.

## Important: Project Renamed to Repomix

Due to legal considerations, this project has been renamed from "Repopack" to "Repomix". We are committed to ensuring a smooth transition for all users.

### How to Migrate

We strongly recommend migrating to the new package. Install Repomix using either:

```bash
npx repomix
```

or

```bash
npm install -g repomix
```

#### Optional: Uninstall Repopack
After confirming Repomix works for your needs, you can optionally uninstall Repopack:

```bash
npm uninstall -g repopack
```

---

Thank you for being part of the Repopack community. We look forward to continuing to serve you as Repomix! If you have any questions about the migration, please feel free to create an issue on our GitHub repository.
</file>

<file path=".github/releases/v0.2.x/v0.2.1.md">
This release introduces our rename from Repopack to Repomix, along with automated migration functionality to ensure a smooth transition for all users.

## Important: Project Renamed to Repomix

Due to legal considerations, this project has been renamed from "Repopack" to "Repomix". We are committed to ensuring a smooth transition for all users.

### What's New

#### Automated Migration Support (v0.2.1)
- Added functionality to automatically detect and migrate existing Repopack configurations
- Handles migration of:
  - Configuration files (`repopack.config.json` → `repomix.config.json`)
  - Ignore files (`.repopackignore` → `.repomixignore`)
  - Instruction files (`repopack-instruction.md` → `repomix-instruction.md`)
  - Both local and global configurations
- Preserves all user settings during migration

#### Project Rename Changes (v0.2.0)
- Updated all project files and references to use the new name
- Updated npm package name to `repomix`
- Updated documentation to reflect the new name
- Added support for legacy output file detection

### How to Migrate

We strongly recommend migrating to the new package. Install Repomix using either:

```bash
npx repomix
```

or

```bash
npm install -g repomix
```

The tool will automatically detect your existing Repopack configuration files and offer to migrate them to the new format.

#### Optional: Uninstall Repopack
After confirming Repomix works for your needs, you can optionally uninstall Repopack:

```bash
npm uninstall -g repopack
```

---

Thank you for being part of our community. We look forward to continuing to serve you as Repomix! If you have any questions about the migration, please feel free to create an issue on our GitHub repository.
</file>

<file path=".github/releases/v0.2.x/v0.2.10.md">
This release introduces Docker support, making Repomix more accessible and easier to use in containerized environments. It also includes an important breaking change regarding Node.js version support.

## What's New

### Docker Support 🐳 (#221, #222)
- Added official Docker support for running Repomix. 

You can now run Repomix using Docker:
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

For more detailed Docker usage instructions and examples, please see our [Docker documentation](https://github.com/yamadashy/repomix?tab=readme-ov-file#docker-usage).

Thanks to @gaby for this valuable contribution that makes Repomix more accessible to containerized environments.

## Maintenance

### Node.js Version Support (#225)
- Dropped support for Node.js 16.x as it has reached End of Life.
  - **Required Action**: Please upgrade to Node.js 18.x or later

Thanks to @chenrui333 for helping maintain our Node.js compatibility:

## How to Update

To update to the latest version, run:
```bash
npm update -g repomix
```

----

As always, we appreciate your feedback and contributions to make Repomix even better! If you encounter any issues or have suggestions, please share them through our GitHub issues.
</file>

<file path=".github/releases/v0.2.x/v0.2.11.md">
This release focuses on enhancing usability, flexibility, and remote repository handling. We've aimed to make Repomix more intuitive, particularly for those working with remote repositories or using custom configurations.

## What's New

### Support Commit SHA in --remote-branch Option (#195, #212)
- The `--remote-branch` option now supports specific commit hashes, not just branch names or tags.
  - This allows users to checkout the remote repository to a specific state using a SHA, providing finer control over remote repository fetching.
 
For more details, please see [Remote Repository Processing](https://github.com/yamadashy/repomix?tab=readme-ov-file#remote-repository-processing) in the README.

Thank you to @tranquochuy645 for this valuable contribution!

## Bug Fixes

### Fixed an issue where instruction file is not found when using a custom config file (#231)
-   The instruction file path is now resolved relative to the current working directory (CWD) instead of the location of the config file.

## How to Update

To update to the latest version, run:

```bash
npm update -g repomix
```

or if you use Homebrew

```bash
brew upgrade repomix
```

or if you use docker  🐳

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix:0.2.11
```

---

We appreciate your feedback and contributions in making Repomix better! If you encounter any issues or have suggestions, please share them through our GitHub issues.
</file>

<file path=".github/releases/v0.2.x/v0.2.12.md">
This release introduces new CLI flags to provide users with more control over the structure and content of Repomix output.

## Features

### Added CLI Flags for Output Control (#236)

This release adds new CLI flags that allow users to control the output:
-   `--no-file-summary`: Disables the file summary section in the output.
-   `--no-directory-structure`: Disables the directory structure section in the output.
-   `--remove-comments`: Enables comment removal from supported file types.
-   `--remove-empty-lines`: Enables removal of empty lines from the output.

These flags provide more granular control over the output, and can be used to override configurations from the config file.

## How to Update

To update to the latest version, run:

```bash
npm update -g repomix
```

or if you use Homebrew

```bash
brew upgrade repomix
```

or if you use docker 🐳

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix:0.2.12
```

---
We appreciate your feedback and contributions to make Repomix even better!
</file>

<file path=".github/releases/v0.2.x/v0.2.15.md">
This release marks a significant milestone for Repomix with the launch of our official website and the opening of our community Discord server! While the code changes are relatively minor, this release introduces essential resources for users to learn more about Repomix and connect with other members.

## What's New

### Official Website Launched! 🌐

- We're excited to announce the launch of the official Repomix website!
  -  Visit [repomix.com](https://repomix.com/) to explore interactive demos.
  - The website provides a convenient way to try Repomix online and understand its features.

### Community Discord Server Opened! 💬

- Join our new community Discord server!
  -  We've created a dedicated space for users to connect, ask questions, share projects, and collaborate on new ideas.
  -  Join the server here: [https://discord.gg/wNYzTwZFku](https://discord.gg/wNYzTwZFku)
  -  This is our first time running a Discord server, so any feedback is welcome! If you're experienced with Discord, please share your best practices with us!

## Try It Out and Share Your Feedback

We encourage you to explore the new website and join our Discord server. Your feedback is invaluable as we continue to improve Repomix.

- Visit the website: [https://repomix.com/](https://repomix.com/)
- Join the Discord server: [https://discord.gg/wNYzTwZFku](https://discord.gg/wNYzTwZFku)

## Internal Changes

While this release is significant due to the website and Discord launch, the actual code changes are mostly internal and related to preparing for the website's launch.

---

Thank you for your continued support of Repomix! We look forward to seeing you on the website and in our Discord community!
</file>

<file path=".github/releases/v0.2.x/v0.2.16.md">
This release focuses on improving both CLI experience and web interface functionality, along with some important infrastructure updates.

## Updates

### Token counting configurable
- Enhanced token counting with configurable encoding (default: cl100k_base)
- Add config `tokenCount.encoding`

### CLI Improvements
- Added a subtle announcement about our web version in the CLI completion message
  - Helps users discover our online version at [repomix.com](https://repomix.com)
  - The frequency of this announcement will be adjusted based on user feedback
- Removed repository URL from output files for cleaner output

## Fixes
- Fixed an issue where output paths weren't properly ignored in certain scenarios
  - Special thanks to @massdo for identifying and fixing this issue

## Internal Changes
- Updated minimum Node.js engine requirement to >=18.20.0
  - Thanks to @massdo for implementing this update

---

To update to the latest version, run:
```bash
npm update -g repomix
```

As always, we appreciate your feedback and contributions! If you encounter any issues or have suggestions, please let us know through our [GitHub issues](https://github.com/yamadashy/repomix/issues).
</file>

<file path=".github/releases/v0.2.x/v0.2.17.md">
This release fixes Node.js compatibility issues and adds comprehensive documentation to the website.

## Bug Fixes 🐛 

### Enhanced Node.js Compatibility (#274, #277)

- Fixed an issue where Repomix wasn't working properly on Node.js 19
  - Downgraded cli-spinners dependency to ensure compatibility
  - Now using version 2.9.2 which has better version support
- Extended Node.js version support:
  - Minimum required version lowered from 18.20.0 to 18.0.0
  - This change enables support for the entire Node.js 18.x LTS series

## Documentation 📚

### New Website Documentation (#269, #271, #265)
- Added comprehensive documentation at [repomix.com/guide/](https://repomix.com/guide/)
  - Detailed installation and usage instructions
  - Advanced configuration examples
  - Best practices and tips

Special thanks to @mostypc123 for their first contribution to Repomix! 

## How to Update

To update to the latest version, run:

```bash
npm update -g repomix
```

We welcome community involvement and appreciate all contributions that help make Repomix better.

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.2.x/v0.2.2.md">
This release adds a new clipboard copy feature and includes several internal improvements to our CI process.

## What's New

### Copy to Clipboard Feature (#152, #160)

- Added new `--copy` option to copy the output to system clipboard
- Output can now be both saved to file and copied to clipboard in one command
- Configurable through `repomix.config.json` using `output.copyToClipboard` option

We'd like to thank @vznh for implementing this feature in their first contribution to Repomix!

## Internal Changes

### CI Improvements

- Switched to official actionlint Docker image for more reliable CI checks (@szepeviktor in #156)
- Re-added Homebrew bump workflow for automated formula updates (@chenrui333 in #151)

## How to Use

Copy output to clipboard using CLI:
```bash
repomix --copy
```

Or configure it in `repomix.config.json`:
```json
{
  "output": {
    "copyToClipboard": true
  }
}
```

## How to Update

To update to the latest version, run:
```bash
npm install -g repomix
```

For macOS users:
```bash
brew upgrade repomix
```

---

We value your feedback and contributions in making Repomix better! If you encounter any issues or have suggestions, please share them through our GitHub issues.

📢 Join our community discussion and share your experience with Repomix: https://github.com/yamadashy/repomix/discussions/154
</file>

<file path=".github/releases/v0.2.x/v0.2.20.md">
This release includes important fixes for Git Worktree support and repository name validation, improving Repomix's compatibility and stability.

## Bug Fixes 🐛

### Git Worktree Support (#279)
- Fixed an issue where Repomix fails when processing repositories created using `git worktree`
  - Now correctly handles `.git` as a reference file in worktree repositories

Special thanks to @slavashvets for discovering and fixing this issue! 

### Repository Name Validation
- Fixed an issue where `--remote` option would fail when using GitHub shorthand names containing dots (e.g., `user/repo.name`)

## How to Update

To update to the latest version, run:

```bash
npm update -g repomix
```

We welcome community involvement and appreciate all contributions that help make Repomix better.

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.2.x/v0.2.21.md">
This release introduces significant improvements to output formatting and documentation, featuring a new parsable style option for enhanced XML handling.

# What's New 🚀 

## Enhanced Output Style Control (#287)
- Added new `parsableStyle` option for better output handling:
  - Ensures output strictly follows the specification of the chosen format
  - Provides properly escaped XML output with fast-xml-parser
  - Dynamically adjusts markdown code block delimiters to avoid content conflicts
- Available via CLI flag `--parsable-style` or in configuration file

Special thanks to @atollk for their first contribution!

# Documentation 📚

## README Enhancements (#296)
- Updated Homebrew installation documentation to include Linux support

Special thanks to @chenrui333 for their continued contributions!

## Website Multi-Language Support (#293)
- Enhanced multi-language support in [repomix.com](https://repomix.com)

# How to Update

To update to the latest version, run:
```bash
npm update -g repomix
```


---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.2.x/v0.2.22.md">
This release introduces significant improvements to large file handling and expands the Repomix ecosystem with new tools and community channels.

# Improvements ⚡ 

## Improved Large File Handling (#302)

- Added a file size limit check (50MB) to prevent memory issues
- Graceful error handling for large files with clear user guidance:

Special thanks to @slavashvets for their continued contributions!

# Ecosystem Growth 🤝 

## New VS Code Extension (#300)
A community-created VS Code extension "Repomix Runner" is now available:
- Run Repomix directly from VS Code
- Extension by @massdo: [View on VS Code Marketplace](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner)

Thank you @massdo for bringing Repomix to VS Code and expanding our tooling ecosystem!

## Official Social Media
- Launched official Repomix X (Twitter) account: [@repomix_ai](https://x.com/repomix_ai)
  - Follow for updates, tips, and community highlights

# How to Update

```bash
npm update -g repomix
```

---

Join our growing community on [Discord](https://discord.gg/BF8GxZHE2C) and follow us on [X](https://x.com/repomix_ai) for updates!
</file>

<file path=".github/releases/v0.2.x/v0.2.23.md">
This release adds significant performance improvements for large repositories, making Repomix faster and more efficient when needed.

# Improvements ⚡

## Parallel Processing Enhancement (#309)
- Implemented worker threads using [Piscina](https://github.com/piscinajs/piscina) for parallel processing

### Benchmark Results
- `yamadashy.repomix`: No significant change
  - Before: 868.73 millis
  - After: 671.26 millis
- `facebook/react`: 29x faster
  - Before: 123.31 secs
  - After: 4.19 secs
- `vercel/next.js`: 58x faster
  - Before: 17.85 mins
  - After: 17.27 secs

Note: While Repomix is not primarily designed for processing large repositories, and speed is not a primary goal, faster processing can provide a better user experience when working with larger codebases.

# How to Update

```bash
npm update -g repomix
```


---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.2.x/v0.2.24.md">
This release significantly enhances configuration flexibility with comprehensive CLI flag support and expands default ignore patterns for better project scaffolding. 

# What's New 🚀

## CLI Flags Revolution (#324)
- New command-line configuration now available.

```
- `--no-gitignore`: Disable .gitignore file usage
- `--no-default-patterns`: Disable default patterns
- `--header-text <text>`: Custom text to include in the file header
- `--instruction-file-path <path>`: Path to a file containing detailed custom instructions
- `--include-empty-directories`: Include empty directories in the output
```

Special recognition to @massdo for driving ecosystem growth.

# Improvements ⚡

## Enhanced Ignore Patterns (#318, #322)
- Expanded default ignores for Rust projects:
  - `target/`, `Cargo.lock`, build artifacts
  - PHP, Ruby, Go, Elixir, Haskell: package manager lock files

To @boralg for helping curate Rust-specific patterns!

# How to Update
```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.2.x/v0.2.25.md">
This release brings significant improvements to output formatting and introduces flexible remote repository handling capabilities along with enhanced logging features.

# Improvements ⚡

## Remote Repository Enhancement (#335)
- Added branch/tag parsing directly from repository URLs:
```bash
repomix --remote https://github.com/yamadashy/repomix/tree/0.1.x
```
Functions identically to:
```bash
repomix --remote https://github.com/yamadashy/repomix --remote-branch 0.1.x
```

Special thanks to @huy-trn for implementing this user-friendly feature!

## Enhanced Output Formatting (#328, #329, #330)
- Added "End of Codebase" marker for better clarity in output
- Improved output header accuracy:
  - Better representation of codebase scope
  - Clear indication when using `--include` or `--ignore` options

Special thanks to @gitkenan for adding the "End of Codebase" marker and reporting the header issue!

## Path Pattern Support (#337)
- Added support for special characters in paths:
  - Handles parentheses in include patterns (e.g., `src/(categories)/**/*`)
  - Improved escaping for `[]` and `{}`
  - Essential for Next.js route groups and similar frameworks

Thank you @matheuscoelhomalta for improving path pattern support!

# How to Update

```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.2.x/v0.2.26.md">
This release brings feature enhancements, documentation improvements, and website updates, along with contributions from new community members.

# What's New 🚀

## Multiple Directory Support (#338)
- Added ability to process multiple directories at once

Special thanks to @rchatrath7 for implementing this feature!

## CLI Quiet Mode Option (#347)
- Added new `--quiet` option:
  - Disables all stdout output
  - Perfect for programmatic usage when using Repomix as a library

# Improvements ⚡

## Output Enhancement (#341, #348)
- Removed generation timestamp for cleaner output
- This change reduces API costs by approximately 20-40% when using OpenAI/Anthropic APIs by preventing cache misses

Special thanks to @PaperBoardOfficial for this improvement!

## Website Enhancements: Git URL Parsing Support (#343)
- Enhanced repository URL parsing capabilities:
  - Direct support for branch URLs (`/tree/branch`)
  - Direct support for commit URLs (`/commit/hash`)

For more details on remote repository features, see [Remote Repository Processing](https://github.com/yamadashy/repomix?tab=readme-ov-file#remote-repository-processing).

# Documentation 📚

## Documentation (#344, #345)
- Added [German translation](https://repomix.com/de/) for website
- Added local development instructions for website
- Updated supported AI model list (ChatGPT, DeepSeek, Perplexity, Gemini, Gemma, Llama, Grok, and more)
- Improved existing translations

Special thanks to @SpyC0der77 for keeping our documentation consistent!

# How to Update

```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.2.x/v0.2.28.md">
This release brings advanced code analysis capabilities through Tree-sitter integration, along with contributions from community members.

# What's New 🚀

## Code Compression with Tree-sitter (#336)
- Added intelligent code compression feature for optimizing LLM prompts
  - Implemented language-specific Tree-sitter queries for accurate code parsing
  - Supports multiple languages including JavaScript/TypeScript, Python, Rust, Go, C/C++, C#, Ruby, Java, PHP, and Swift

> [!NOTE]
> This is an experimental feature that we'll be actively improving based on user feedback and real-world usage
> Known issue: https://github.com/yamadashy/repomix/issues/359

### Example
Using compression via CLI:
```bash
repomix --compress
```

Before:
```typescript
const calculateTotal = (items: ShoppingItem[]) => {
  let total = 0;
  for (const item of items) {
    total += item.price * item.quantity;
  }
  return total;
}
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

After compression:
```typescript
const calculateTotal = (items: ShoppingItem[]) => {
interface Item {
```

Special thanks to @huy-trn for the initial implementation of this feature! His groundwork with Tree-sitter integration laid the foundation for this powerful enhancement to Repomix. 

# How to Update

```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.2.x/v0.2.29.md">
This release introduces a major new feature for file uploads, along with improvements to library usage and default ignore patterns.

# What's New 🚀

## Website: File Upload Support (#353, #310)
- Added support for uploading ZIP files directly through the web interface (https://repomix.com/)

<img width="962" alt="image" src="https://github.com/user-attachments/assets/58069431-7e45-487b-94df-c3eeb2ef8695" />

Special thanks to @PaperBoardOfficial for implementing this significant feature!

# Improvements ⚡

## Enhanced Default Ignore Patterns (#364)
- Improved subdirectory matching in default ignore patterns using `**/`

## Library Usage Enhancement (#363)
- Added additional exports to support using Repomix as a library

# How to Update

```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.2.x/v0.2.3.md">
This release introduces enhanced security features and improved error handling, making Repomix more robust and user-friendly.

## Improvements

### Enhanced File System Permission Handling (#165)
- Added comprehensive permission checks for directory scanning
- Improved error messages with clear remediation steps, especially for macOS security restrictions
- Added detailed guidance in CLI output when permission issues are encountered

### Node.js 23 Support (#166)
- Added full support for Node.js 23

### Improved Error Handling and Validation (#167, #171)
- Implemented robust configuration validation system
- Added clear, actionable error messages for configuration issues
- Enhanced error recovery and reporting across core functionalities

## How to Update

To update to the latest version, run:
```bash
npm update -g repomix
```

---

We value your feedback and contributions in making Repomix better! If you encounter any issues or have suggestions, please share them through our GitHub issues.
</file>

<file path=".github/releases/v0.2.x/v0.2.30.md">
This release addresses a file system permission issue and adds support for more flexible configuration formats.

# Improvements ⚡

## Configuration Flexibility (#346, #366)
- Added support for JSON5 in configuration files
  - More flexible and developer-friendly configuration format
  - Allows comments and trailing commas

# Bug Fixes 🐛
## File System Handling (#372, #374)
- Removed unnecessary write permission check on source directories

# How to Update

```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.2.x/v0.2.32.md">
The code compression feature introduced in [v0.2.28](https://github.com/yamadashy/repomix/releases/tag/v0.2.28) has been enhanced! 🚀 

# Improvements ⚡

## Enhanced Code Compression (#380)
- Now includes comments and import statements in compression output:
  - Preserves both single-line and multi-line comments
  - Keeps import/require statements for better code context
- Complete type definition support for TypeScript, Python, and Go:
  - Full inclusion of interface and type definitions
- Enhanced function signature preservation:
  - Captures complete function signatures including arguments spanning multiple lines
  - Ensures accurate preservation of all function parameters


### Example
Using compression via CLI:
```bash
repomix --compress
```

Before:
```typescript
import { ShoppingItem } from './shopping-item';

/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
  let total = 0;
  for (const item of items) {
    total += item.price * item.quantity;
  }
  return total;
}

// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

After compression:
```typescript
import { ShoppingItem } from './shopping-item';
⋮----
/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
⋮----
// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```


# How to Update

```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.2.x/v0.2.33.md">
This release addresses two important issues to improve code handling and file output capabilities.

# Bug Fixes 🐛

## TypeScript Import Handling for Compressed Output (#382)
- Fixed an issue where named imports were partially excluded when using compress mode
  - Now properly preserves all import statements including named imports like `import { Component } from 'module'`

## Directory Structure Support for Output Files (#378, #383)
- Fixes related issue (#378) where nested output paths would fail, especially with remote repositories
  - Now automatically creates parent directories when writing to nested output paths

# How to Update

```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.2.x/v0.2.34.md">
This release fixes an important configuration issue affecting negative boolean options in Repomix.

## Bug Fixes 🐛

### Configuration Handling Fix (#385, #389)
- Fixed an issue where setting `false` values in the config file for certain options (like `"fileSummary": false`) was not being respected
- Properly handles all `--no-*` style CLI options when specified in the config file
- Affected options include:
  - `fileSummary`
  - `directoryStructure`
  - `gitignore`
  - `defaultPatterns`
  - `securityCheck`

Special thanks to @mapleroyal for reporting this issue!

## How to Update

```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our [GitHub issues](https://github.com/yamadashy/repomix/issues) or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.2.x/v0.2.35.md">
This release adds folder upload capability to the website, improves gitignore handling, and includes documentation updates.

## What's New 🚀

### Website Folder Upload (#387, #377)
* Added folder upload option to the https://repomix.com
  * Supports drag & drop or folder browser selection

Thank you @PaperBoardOfficial for implementing folder upload on our website!

## Improvements ⚡️

### Enhanced Gitignore Support (#391, #375)
* Now uses the contents of `.git/info/exclude` when `useGitignore` is set to true
* Allows for local-only file exclusions without modifying the shared `.gitignore`
* Fixes issue #375

Thanks to @motlin for improving gitignore support! 

## How to Update

```
npm update -g repomix
```

--------

As always if you encounter any issues or have suggestions please let us know through our GitHub issues or join our Discord community https://discord.gg/wNYzTwZFku for support.
</file>

<file path=".github/releases/v0.2.x/v0.2.36.md">
This release adds MCP server support, improves ignore pattern handling on the website, and includes dependency updates.

## What's New 🚀

### MCP Server Support (#399)
* Added initial implementation of the [Model Context Protocol (MCP)](https://modelcontextprotocol.io) server
  * Allows AI assistants to directly interact with your codebase without manual file preparation
  * Provides two powerful tools:
    * `pack_codebase`: Package local code directories for AI analysis
    * `pack_remote_repository`: Fetch, clone and package GitHub repositories

We've also submitted Repomix to the MCP marketplace:
- https://github.com/cline/mcp-marketplace/issues/64

To use Repomix as an MCP server with Cline (VS Code extension), edit the `cline_mcp_settings.json` file:
```json
{
  "mcpServers": {
    "repomix": {
      "command": "npx",
      "args": [
        "-y",
        "repomix",
        "--mcp"
      ]
    }
  }
}
```

<img width="520" alt="image" src="https://github.com/user-attachments/assets/c698e8ba-91bb-4207-b0fe-ba0a56871975" />

For more details, please refer to the documentation:
https://github.com/yamadashy/repomix#mcp-integration

## Improvements ⚡️

### Enhanced Ignore Pattern Support (#396)
* Now allows special characters like `!` `(` `)` in ignore patterns via the website

**Known Issue**: There's currently an issue where negation patterns (`!`) don't work correctly. See [Issue #400](https://github.com/yamadashy/repomix/issues/400) for details.

Thank you @eastlondoner for your first contribution to the project!

## How to Update

```
npm update -g repomix
```

--------

As always if you encounter any issues or have suggestions please let us know through our GitHub issues or join our Discord community https://discord.gg/wNYzTwZFku for support.
</file>

<file path=".github/releases/v0.2.x/v0.2.4.md">
This release introduces enhanced directory handling capabilities and includes several improvements to core functionality, making Repomix more versatile and reliable.

## What's New

### Empty Directory Support (#180, #161)
- Added new option `includeEmptyDirectories`  to include empty directories in repository structure

To include empty directories in your output, add the following to your `repomix.config.json`:

```json
{
  "output": {
    "includeEmptyDirectories": true
  }
}
```

We'd like to thank @iNerdStack for implementing this feature in their contribution to Repomix!

## Improvements

### Statistics Formatting Enhancement (#177)
- Added number formatting for improved readability
- Fixed token calculation for more accurate reporting

## How to Update

To update to the latest version, run:

```bash
npm update -g repomix
```

---

We value your feedback and contributions in making Repomix better! If you encounter any issues or have suggestions, please share them through our GitHub issues.
</file>

<file path=".github/releases/v0.2.x/v0.2.40.md">
This release brings significant enhancements to Model Context Protocol (MCP) integration and improves file handling capabilities.

## Improvements ⚡

### Enhanced MCP Integration (#419, #415, #409, #413)
- Added file and directory reading capabilities with integrated [Secretlint](https://github.com/secretlint/secretlint) security checks
- Introduced result retrieval tools for Claude Desktop and Cursor AI assistants
 
**Pack local repo with compress:**
```bash
Please pack this with compress in repomix.
<path>
```

![MCP Integration - Command Example](https://github.com/user-attachments/assets/6eb70126-ed60-4d5e-956d-1454ab7bfd41)

**Read detailed results:**
![MCP Integration - Results View](https://github.com/user-attachments/assets/db536a6d-c164-4426-9993-25fbff21ffa5)

For more MCP details, please refer to the documentation:
https://github.com/yamadashy/repomix#mcp-integration

### Extended File Format Support (#407)
- Added support for Bun lockfile format (`bun.lockb`)

Special thanks to @jiftoo for their first contribution!

## How to Update

```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.2.x/v0.2.41.md">
This release introduces Git-based file sorting and enhances file compression capabilities.

## What's New 🚀

### Git-based File Sorting (#356, #421)
* Added ability to sort files by Git commit frequency
  * Prioritizes frequently modified files in the output
* Can be controlled via CLI options or configuration
  * Use `--no-git-sort-by-changes` flag to disable Git-based sorting
  * Configure in repomix.config.json:
    ```json
    {
      "output": {
        "git": {
          "sortByChanges": true,
          "sortByChangesMaxCommits": 100
        }
      }
    }
    ```
Special thanks to @SpyC0der77 for suggesting this feature!

## Improvements ⚡️

### Enhanced Compress Mode (#420)
* Added Vue.js and CSS file support for compress mode

## How to Update

```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.2.x/v0.2.5.md">
## Bug Fixes

### Fixed Missing Dependency (#186)
- Added missing `minimatch` dependency

## How to Update

To update to the latest version, run:

```bash
npm update -g repomix
```

---

We value your feedback and contributions in making Repomix better! If you encounter any issues or have suggestions, please share them through our GitHub issues.
</file>

<file path=".github/releases/v0.2.x/v0.2.6.md">
This release introduces remote repository features and security check improvements.

## What's New

### Enhanced Remote Repository Support (#196, #199)
- Added new `--remote-branch` option for cloning specific branches

Example usage:
```bash
# Clone a specific branch
repomix --remote user/repo --remote-branch develop
```

Special thanks to @tranquochuy645 for their first contribution, adding the remote branch feature!

### Security Check Improvements (#191, #201)
- Added `--no-security-check` command line option for more control over security checking
- Enables bypassing security checks when needed (e.g., when working with cryptographic libraries)

## How to Update

To update to the latest version, run:
```bash
npm update -g repomix
```

---

We value your feedback and contributions in making Repomix better! If you encounter any issues or have suggestions, please share them through our GitHub issues.
</file>

<file path=".github/releases/v0.2.x/v0.2.7.md">
This release focuses on improving code quality and performance, particularly when processing large codebases.

## Improvements

### JSON Configuration Improvements (#209, #214)
- Added support for inline and block comments in repomix.config.json

Special thanks to @ivanionut for improving JSON configuration handling with their first contribution!

### Enhanced File Processing Performance (#208, #223)
- Optimized file processing efficiency when removeComments and removeEmptyLines are enabled

## Internal Changes

### Code Reorganization (#217)
- Refactored packager.ts into smaller, single-purpose functions
- Improved code maintainability while preserving functionality

Special thanks to @mikelovesrobots for the excellent refactoring work on their first contribution! The changes have made the codebase more maintainable for future development.

To update to the latest version, run:
```bash
npm update -g repomix
```

---

As always, we appreciate your feedback and contributions to make Repomix even better! If you encounter any issues or have suggestions, please share them through our GitHub issues.
</file>

<file path=".github/releases/v0.2.x/v0.2.8.md">
This release introduces new configuration options to control the output of the file summary and directory structure sections, providing more flexibility in customizing the output.

## What's New

### Customizable File Summary and Directory Structure Output (#206, #224)

- Added `output.fileSummary` option (default: `true`): Controls whether to include the file summary section at the beginning of the output.
- Added `output.directoryStructure` option (default: `true`): Controls whether to include the directory structure in the output.

These options allow you to tailor the output to your specific needs. For example:

-   You can omit the file summary and directory structure to reduce token usage when interacting with LLMs.
-   You can include only necessary sections to generate output optimized for specific AI models.

**Example Configuration:**

```json5
{
  "output": {
    "fileSummary": false,
    "directoryStructure": true,
    // ... other settings
  }
}
```


To update to the latest version, run:
```bash
npm update -g repomix
```

---

As always, we appreciate your feedback and contributions to make Repomix even better! If you encounter any issues or have suggestions, please share them through our GitHub issues.
</file>

<file path=".github/releases/v0.3.x/v0.3.0.md">
> [!IMPORTANT]
> The default output format has been changed to XML in this release.

This version has been bumped to 0.3.0 not because of a major update, but due to a breaking change in the default output format. It represents an important improvement for anyone installing Repomix for the first time.

## Breaking Changes 🔄

### Default Output Format Changed to XML (#422)
- The default output format has been changed to XML
  - XML format provides better parsing accuracy for AI models (especially Claude)
  - Other formats (Markdown, Plain Text) remain available via the `--style` option

## How to Update

```bash
npm update -g repomix
```

---

If you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.3.x/v0.3.1.md">
This release introduces enhancements including improved comment removal support for C++, code compression features for Solidity, and MCP improvements.

## Improvements ⚡️

### C++ Comment Removal Enhancement (#435)
- Added support for comment removal `--remove-comments` in C++ file extensions:
  - .h, .hpp (header files)
  - .cpp, .cc, .cxx (source files)

Special thanks to @AdijeShen for this valuable contribution in expanding C++ support!

### Solidity Support Enhancement (#436)
- Added compression support `--compress` for Solidity files
- Implemented comment removal `--remove-comments` functionality

### MCP Resource Enhancement (#426, #434)
- Enhanced read_repomix_output tool functionality:
  - Now includes output as a resource

### Default Ignore Pattern Enhancement (#428)
- Added `uv.lock` to the default ignore list

## Documentation 📚

### French Documentation (#429)
- Added comprehensive French guides for installation and usage

https://repomix.com/fr/

## How to Update

To update to the latest version, run:
```bash
npm update -g repomix
```

---

If you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.3.x/v0.3.2.md">
Repomix v0.3.2 brings various improvements including website functionality improvements, better CLI usability, and improved glob pattern handling reliability.

## What's New 🚀

### Website Compression Functionality (#448)
- Improved processing efficiency on the [repomix.com](https://repomix.com/), enabling smoother processing of large repositories directly from the browser.

<img width="233" alt="image" src="https://github.com/user-attachments/assets/19d72c83-7eea-492e-a2ec-d6ed93f0f846" />

## Improvements ⚡

### Semantic Suggestion System for CLI (#452)
Added functionality that automatically suggests correct options when incorrect option names are entered.

Special thanks to @pranshugupta01 for this thoughtful usability enhancement that makes the CLI experience much more intuitive for users!

### Glob Pattern Handling Improvements
- Automatically removes extra whitespace from comma-separated glob patterns (#464)
- Consistently handles directory patterns with trailing slashes, making `folder/` and `folder` patterns behave the same way (#453)
- Improved brace expansion and whitespace handling in CLI pattern options for more accurate and predictable behavior with complex glob patterns (#469)

Special thanks to @pranshugupta01 for these meticulous pattern handling improvements that make file filtering more reliable and predictable!

## Documentation 📚

### VS Code Server Installation Docs (#439)
👇🏻 Click to open VS Code with the Repomix MCP server pre-configured:

[![Install in VS Code](https://img.shields.io/badge/VS_Code-Install_Server-0098FF?style=flat-square&logo=visualstudiocode&logoColor=white)](https://insiders.vscode.dev/redirect/mcp/install?name=repomix&config=%7B%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)

Special thanks to @burkeholland for this excellent contribution that makes the integration with VS Code more seamless and user-friendly!

### Ensured consistency across all documentation regarding the default output format change to XML (#466)

Special thanks to @yoshi-taka for the careful attention to documentation consistency across the project!

## How to Update

```bash
npm install -g repomix@latest
```

---

If you encounter any issues or have suggestions, please let us know through [GitHub Issues](https://github.com/yamadashy/repomix/issues) or join our [Discord community](https://discord.gg/wNYzTwZFku).
</file>

<file path=".github/releases/v0.3.x/v0.3.3.md">
Repomix v0.3.3 brings metadata-only output, expanded library support, Wayland clipboard compatibility, and various improvements for better usability and maintainability.

## What's New 🚀

### No Files Output Mode `--no-files` (#475, #491)
- Added the ability to generate output containing only metadata, excluding file contents, using the `--no-files` flag.
  - Useful for fast analysis of large repositories or when you want to avoid including file bodies.

### Wayland Clipboard `wl-copy` Support (#484)
- Clipboard copy now works on Linux Wayland environments using `wl-copy`.
  - The `--copy` option is now fully supported on Wayland.

Special thanks to @pmdyy for adding Wayland clipboard support!

### Expanded Core Exports for Library Usage (#504, #492)
- More core functions are now exported for direct use when integrating Repomix as a Node.js library.

Special thanks to @riqwan for contributing to the core export improvements!

> [!TIP]
> Want to use Repomix as a library in your Node.js project?  
> See the official guide here: [Using Repomix as a Library](https://repomix.com/guide/development/using-repomix-as-a-library)

## Improvements ⚡

### Various Maintenance & Fixes (#496, #497, #499)
- Spellcheck now includes dot files.
- Fixed `.editorconfig` and EditorConfig violations.

Special thanks to @szepeviktor for maintenance improvements!

## How to Update

```bash
npm install -g repomix@latest
```

---

If you encounter any issues or have suggestions, please let us know through [GitHub Issues](https://github.com/yamadashy/repomix/issues) or join our [Discord community](https://discord.gg/wNYzTwZFku).
</file>

<file path=".github/releases/v0.3.x/v0.3.5.md">
This release introduces git diff support, CLI output enhancements, GitHub Actions support, and website-based URL input history management. It also includes several documentation improvements and Node.js compatibility updates.

## What's New 🚀

### Git Diff Support (#533)
- Added git diff support with `--include-diffs` flag
  - Includes git diffs in the output, covering both staged and unstaged changes for better context

Special thanks to @pmdyy for this contribution!

### CLI Output Enhancement (#534)
- Added `--stdout` option for CLI output  
  - Provides more flexibility for integrating Repomix in scripts and pipelines
    ```bash
    # Send output to stdout, then pipe into another command (for example, simonw/llm)
    repomix --stdout | llm "Please explain what this code does."
    ```

### GitHub Actions Support (#510, #528)
- Added GitHub Action for integrating Repomix into CI/CD workflows  

See full usage at [repomix.com/guide/github-actions](https://repomix.com/guide/github-actions).

## Improvements ⚡

### MCP Tool Annotations Support (#537)  
- Added support for Model Context Protocol (MCP) [tool annotations](https://modelcontextprotocol.io/docs/concepts/tools#tool-annotations)

### Website URL Input History (#527)
- Added input history management for repository URLs on the website  

<img width="509" alt="image" src="https://github.com/user-attachments/assets/05615e8f-01d2-45fd-9fb0-71d7d2c93a66" />

### Node 24 Support
- Added support for Node.js v24 (#543)  

## Documentation 📚
- Added Chinese (Traditional) documentation (#526)  

## How to Update

```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.3.x/v0.3.6.md">
This release enhances header configuration control, adds JSON Schema validation, and improves Docker integration for the MCP server with comprehensive documentation updates.

## Improvements ⚡

### Enhanced `--no-file-summary` Option (#556)
- `--no-file-summary` now also suppresses the generation header
  - Header text (`headerText`) is still displayed, maintaining custom messages
  - Users can now control headers more flexibly and intuitively, showing custom headers while hiding Repomix-generated content

Special thanks to @joshwand for this significant improvement!

### JSON Schema Configuration Validation (#570)
- Added JSON schema for `repomix.config.json` validation
  - Enables auto-completion and validation in supported editors
  - Improves developer experience in VSCode and other editors with JSON schema support
```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "output": {
    "filePath": "repomix-output.md",
    "style": "markdown"
  }
}
```

## Documentation 📚

### Docker Configuration for MCP Server (#559)
- Added Docker container support for running Repomix as an MCP server
```json
{
  "mcpServers": {
    "repomix-docker": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "ghcr.io/yamadashy/repomix",
        "--mcp"
      ]
    }
  }
}
```

## How to Update

```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path=".github/releases/v0.3.x/v0.3.7.md">
This release brings major enhancements to the MCP (Model Context Protocol) server and improved remote repository handling.

## What's New 🚀

### MCP Tool Grep Functionality (#590)

We've added a powerful `grep_repomix_output` tool to the Repomix MCP server! This feature enables AI assistants to perform advanced searches within packaged codebases. Additionally, the `read_repomix_output` tool now supports partial content retrieval.

<img width="754" alt="image" src="https://github.com/user-attachments/assets/cc656d86-b692-4e8b-be80-122b957a9a9d" />

This functionality allows AI assistants to efficiently search for specific patterns in codebases and retrieve results with surrounding context.
By combining the `grep_repomix_output` and `read_repomix_output` tools, repository analysis is now possible without fetching the entire output, making it particularly useful for analyzing medium to large-scale repositories.

For MCP setup instructions, see:
https://github.com/yamadashy/repomix?tab=readme-ov-file#mcp-server-integration

## Improvements ⚡

### CLI Help Group Feature Implementation (#578)

The CLI help display has been improved. Options are now organized into logical groups for better usability:

```bash
$ repomix -h
Usage: repomix [options] [directories...]

Repomix - Pack your repository into a single AI-friendly file

Arguments:
  directories                        list of directories to process (default: ["."])

Basic Options
  -v, --version                      show version information

Output Options
  -o, --output <file>                specify the output file name
  --stdout                           output to stdout instead of writing to a file
  --style <type>                     specify the output style (xml, markdown, plain)
  --parsable-style                   by escaping and formatting, ensure the output is parsable as a
                                     document of its type
  --compress                         perform code compression to reduce token count
  
Filter Options
  --include <patterns>               list of include patterns (comma-separated)
  -i, --ignore <patterns>            additional ignore patterns (comma-separated)

...
```

### Enhanced Remote Repository Reference Handling (#583, #592)

Remote repository processing has become more robust with improved URL handling:

- The `--remote` option now handles URLs more precisely by reading refs to correctly distinguish between branch names and folder paths
- Proper identification and processing of remote branches and tags
- Better handling of repository paths and subdirectories

## How to Update

```bash
npm update -g repomix
```

---

As always, if you have any issues or suggestions, please let us know on GitHub issues or our [Discord community](https://discord.gg/wNYzTwZFku).
</file>

<file path=".github/releases/v0.3.x/v0.3.8.md">
This release brings major updates including browser extension support, extensive multilingual expansion, and enhanced mobile experience.

## What's New 🚀

### Browser Extension (#612)
Introducing a browser extension that provides instant access to Repomix from any GitHub repository! The Chrome extension adds a convenient "Repomix" button to GitHub repository pages.

[![image](https://github.com/user-attachments/assets/ca81bd58-f2a9-4184-ae43-18ed52294dad)](https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa)

#### Installation
- Chrome Extension: [Repomix - Chrome Web Store](https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa)
- Firefox Add-on: [Repomix - Firefox Add-ons](https://addons.mozilla.org/firefox/addon/repomix/)

#### Key Features
- One-click access to any GitHub repository
- More exciting features coming soon!

### Website: Open with your app (#616)
📱 You can now send Repomix output directly to Claude or Gemini on mobile!

Perfect when you're on the go and need to analyze a GitHub repo fast — just tap "Open with your app" to share it to your favorite chat app.

Try it on [repomix.com](https://repomix.com)!

https://github.com/user-attachments/assets/c2059c65-3891-4400-8d09-e976a268d93a

### `.jsonc` and `.json5` Configuration File Support (#620)
Added support for `.jsonc` and `.json5` configuration file extensions with priority ordering.
```json5
// repomix.jsonc or repomix.json5
{
  // Comments are now supported!
  "include": ["src/**"],
  "exclude": ["**/*.test.js"]
}
```

## Documentation 📚

### Multilingual Support Expansion (#602, #603, #607)
Added three new languages to the website:
- **Indonesian (id)**: Bahasa Indonesia support
- **Vietnamese (vi)**: Tiếng Việt support  
- **Hindi (hi)**: हिन्दी support

This brings our total language support to 12 languages.

## How to Update

```bash
npm update -g repomix
```

---

As always, if you have any issues or suggestions, please let us know on GitHub issues or our [Discord community](https://discord.gg/wNYzTwZFku).
</file>

<file path=".github/releases/v0.3.x/v0.3.9.md">
This release brings important improvements to CLI reliability and enhanced documentation for power users.

## What's New 🚀

### CLI Exit Code Enhancement (#632)
Repomix now properly sets exit codes when operations fail, significantly improving CI/CD integration and error handling workflows. This enhancement ensures that build pipelines and automation scripts can correctly detect and respond to Repomix failures.

Special thanks to @sakamossan for implementing this important feature! 

## How to Update

```bash
npm update -g repomix
```

---

As always, if you have any issues or suggestions, please let us know on GitHub issues or our [Discord community](https://discord.gg/wNYzTwZFku).
</file>

<file path=".github/workflows/ci.yml">
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  lint-biome:
    name: Lint Biome
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4
      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # ratchet:actions/setup-node@v4
        with:
          node-version-file: .tool-versions
          cache: npm
      - run: npm ci
      - run: npm run lint-biome && git diff --exit-code

  lint-ts:
    name: Lint TypeScript
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4
      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # ratchet:actions/setup-node@v4
        with:
          node-version-file: .tool-versions
          cache: npm
      - run: npm ci
      - run: npm run lint-ts

  lint-secretlint:
    name: Lint Secretlint
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4
      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # ratchet:actions/setup-node@v4
        with:
          node-version-file: .tool-versions
          cache: npm
      - run: npm ci
      - run: npm run lint-secretlint

  lint-website-client:
    name: Lint Website Client
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4
      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # ratchet:actions/setup-node@v4
        with:
          node-version-file: .tool-versions
          cache: npm
      - name: Install website client dependencies
        working-directory: website/client
        run: npm ci
      - name: Lint website client
        working-directory: website/client
        run: npm run lint

  lint-website-server:
    name: Lint Website Server
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4
      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # ratchet:actions/setup-node@v4
        with:
          node-version-file: .tool-versions
          cache: npm
      - name: Install website server dependencies
        working-directory: website/server
        run: npm ci
      - name: Lint website server
        working-directory: website/server
        run: npm run lint

  lint-browser:
    name: Lint Browser Extension
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4
      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # ratchet:actions/setup-node@v4
        with:
          node-version-file: .tool-versions
          cache: npm
      - name: Install browser extension dependencies
        working-directory: browser
        run: npm ci
      - name: Lint browser extension
        working-directory: browser
        run: npm run lint

  lint-action:
    name: Lint GitHub Actions
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4
      - uses: rhysd/actionlint@4e683ab8014a63fafa117492a0c6053758e6d593 # ratchet:rhysd/actionlint@v1.7.3
        with:
          args: "-color"

  check-typos:
    name: Check typos
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4
      - uses: crate-ci/typos@022bdbe8ce21237ca3a95659bd6b8aef48389b9f # ratchet:crate-ci/typos@master

  test:
    name: Test
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [18.0.0, 18.x, 19.x, 20.x, 21.x, 22.x, 23.x, 24.x]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # ratchet:actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm ci
      - run: npm run test --reporter=verbose
        env:
          CI_OS: ${{ runner.os }}

  test-coverage:
    name: Test coverage
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4
      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # ratchet:actions/setup-node@v4
        with:
          node-version-file: .tool-versions
          cache: npm
      - run: npm ci
      - run: npm run test-coverage -- --reporter=verbose
        env:
          CI_OS: ${{ runner.os }}
      - uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # ratchet:actions/upload-artifact@v4
        with:
          name: test-coverage
          path: coverage/
      - uses: codecov/codecov-action@18283e04ce6e62d37312384ff67231eb8fd56d24 # ratchet:codecov/codecov-action@v5
        with:
          fail_ci_if_error: true
          directory: ./coverage
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  test-browser:
    name: Test Browser Extension
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4
      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # ratchet:actions/setup-node@v4
        with:
          node-version-file: .tool-versions
          cache: npm
      - name: Install browser extension dependencies
        working-directory: browser
        run: npm ci
      - name: Test browser extension
        working-directory: browser
        run: npm run test

  build-and-run:
    name: Build and run
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [18.0.0, 18.x, 19.x, 20.x, 21.x, 22.x, 23.x, 24.x]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # ratchet:actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm ci
      - run: npm run build
      - name: Install only production dependencies
        run: npm ci --omit=dev
      - run: node bin/repomix.cjs
      - run: node bin/repomix.cjs --version
      - run: node bin/repomix.cjs --help
      - name: Upload build artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # ratchet:actions/upload-artifact@v4
        with:
          name: repomix-output-${{ matrix.os }}-${{ matrix.node-version }}.txt
          path: repomix-output.txt
</file>

<file path=".github/workflows/claude.yml">
name: Claude Code

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned]
  pull_request_review:
    types: [submitted]

jobs:
  claude:
    if: |
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review' && contains(github.event.review.body, '@claude')) ||
      (github.event_name == 'issues' && (contains(github.event.issue.body, '@claude') || contains(github.event.issue.title, '@claude')))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: read
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code
        id: claude
        uses: anthropics/claude-code-action@3486c33ebfa03d71c98e72621759471c45388443 # ratchet:anthropics/claude-code-action@beta
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
</file>

<file path=".github/workflows/codeql.yml">
name: "CodeQL"

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
  schedule:
    - cron: '25 11 * * 0'

jobs:
  analyze:
    name: Analyze (${{ matrix.language }})
    runs-on: ${{ (matrix.language == 'swift' && 'macos-latest') || 'ubuntu-latest' }}
    permissions:
      security-events: write
      packages: read
      actions: read
      contents: read

    strategy:
      fail-fast: false
      matrix:
        include:
          - language: javascript-typescript
            build-mode: none
    steps:
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4

      # Initializes the CodeQL tools for scanning.
      - name: Initialize CodeQL
        uses: github/codeql-action/init@ce28f5bb42b7a9f2c824e633a3f6ee835bab6858 # ratchet:github/codeql-action/init@v3
        with:
          languages: ${{ matrix.language }}
          build-mode: ${{ matrix.build-mode }}

      - if: matrix.build-mode == 'manual'
        shell: bash
        run: |
          echo 'If you are using a "manual" build mode for one or more of the' \
            'languages you are analyzing, replace this with the commands to build' \
            'your code, for example:'
          echo '  make bootstrap'
          echo '  make release'
          exit 1

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@ce28f5bb42b7a9f2c824e633a3f6ee835bab6858 # ratchet:github/codeql-action/analyze@v3
        with:
          category: "/language:${{matrix.language}}"
</file>

<file path=".github/workflows/docker.yml">
name: Docker

on:
  push:
    branches:
      - "main"
    paths-ignore:
      - "**.md"
      - LICENSE
  pull_request:
    branches:
      - "*"
    paths:
      - "Dockerfile"
      - ".dockerignore"
      - ".github/workflows/docker.yml"
  workflow_dispatch:
  release:
    types: [published]

permissions:
  contents: read
  packages: write

jobs:
  build-and-publish-image:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@902fa8ec7d6ecbf8d84d538b9b233a880e428804 # ratchet:docker/metadata-action@v5
        with:
          images: |
            ghcr.io/yamadashy/repomix
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=latest,enable=${{ github.event_name == 'release' }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@29109295f81e9208d7d86ff1c6c12d2833863392 # ratchet:docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # ratchet:docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@74a5d142397b4f367a81961eba4e8cd7edddf772 # ratchet:docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Publish Docker Image
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # ratchet:docker/build-push-action@v6
        with:
          context: .
          push: ${{ github.event_name != 'pull_request' }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64,linux/arm/v7
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
</file>

<file path=".github/workflows/homebrew.yml">
name: Homebrew

on:
  release:
    types:
      - created

jobs:
  homebrew:
    runs-on: macos-latest
    steps:
      - name: Set up Homebrew
        uses: Homebrew/actions/setup-homebrew@b3fb6f7cb1475434d4285b90020c2aa51f1e0b12 # ratchet:Homebrew/actions/setup-homebrew@master
        with:
          test-bot: false

      - name: Configure Git user
        uses: Homebrew/actions/git-user-config@b3fb6f7cb1475434d4285b90020c2aa51f1e0b12 # ratchet:Homebrew/actions/git-user-config@master

      - name: Bump packages
        uses: Homebrew/actions/bump-packages@b3fb6f7cb1475434d4285b90020c2aa51f1e0b12 # ratchet:Homebrew/actions/bump-packages@master
        with:
          token: ${{ secrets.COMMITTER_TOKEN }}
          formulae: repomix
</file>

<file path=".github/workflows/pack-repository.yml">
name: Pack repository with Repomix

on:
  workflow_dispatch:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  pack-repo:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4

      - name: Pack repository with Repomix
        uses: yamadashy/repomix/.github/actions/repomix@a08ea352b585b5baf20e880ce27639f5557a76e1 # ratchet:yamadashy/repomix/.github/actions/repomix@main
        with:
          output: repomix-output.xml

      - name: Upload Repomix output
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # ratchet:actions/upload-artifact@v4
        with:
          name: repomix-output.xml
          path: repomix-output.xml
          retention-days: 30
</file>

<file path=".github/workflows/ratchet-verify.yml">
name: Ratchet verify
on:
  pull_request:
    paths: ['.github/workflows/**']
jobs:
  ratchet:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4
      - uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # ratchet:actions/setup-go@v5
        with:
          go-version: stable
      - name: Install ratchet
        run: |
          go install github.com/sethvargo/ratchet@v0.11.3
          ratchet --version
      - name: Verify pinned SHAs
        run: ratchet lint .github/workflows/*.yml
</file>

<file path=".github/workflows/test-action.yml">
name: Test Repomix Action

on:
  workflow_dispatch:
  push:
    paths:
      - '.github/actions/repomix/**'

jobs:
  test-action:
    name: Test Node.js ${{ matrix.node-version }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18, 20, 22]
        include:
          - node-version: 18
            test-case: "minimal"
          - node-version: 20
            test-case: "basic"
          - node-version: 22
            test-case: "full"
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4

      - name: Run Repomix Action (Minimal)
        if: matrix['test-case'] == 'minimal'
        uses: ./.github/actions/repomix
        with:
          output: "repomix-minimal-output.txt"

      - name: Run Repomix Action (Basic)
        if: matrix['test-case'] == 'basic'
        uses: ./.github/actions/repomix
        with:
          directories: "src"
          include: "**/*.ts"
          output: "repomix-basic-output.txt"
          compress: "true"

      - name: Run Repomix Action (Full)
        if: matrix['test-case'] == 'full'
        uses: ./.github/actions/repomix
        with:
          directories: "src tests"
          include: "**/*.ts,**/*.md"
          ignore: "**/*.test.ts"
          output: "repomix-full-output.txt"
          compress: "true"
          additional-args: "--no-file-summary"

      - name: Upload result
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # ratchet:actions/upload-artifact@v4
        with:
          name: repomix-output-node${{ matrix.node-version }}
          path: repomix-*-output.txt
</file>

<file path=".github/CODEOWNERS">
# Default owner for everything in the repo
* @yamadashy
</file>

<file path=".github/dependabot.yml">
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "daily"
</file>

<file path=".github/FUNDING.yml">
github: yamadashy
</file>

<file path=".github/pull_request_template.md">
<!-- Please include a summary of the changes -->

## Checklist

- [ ] Run `npm run test`
- [ ] Run `npm run lint`
</file>

<file path=".github/renovate.json5">
{
  "$schema": "https://docs.renovatebot.com/renovate-schema.json",
  "extends": [
    "config:recommended",
    "schedule:weekly",
    'group:allNonMajor'
  ],
  "rangeStrategy": "bump",
  "dependencyDashboard": false,
  "labels": ["dependencies", "renovate"],
  "packageRules": [
    {
      matchDepTypes: ['peerDependencies'],
      enabled: false,
    },
  ],
  "ignoreDeps": [
    "node",
  ]
}
</file>

<file path="bin/repomix.cjs">
#!/usr/bin/env node

const nodeVersion = process.versions.node;
const [major] = nodeVersion.split('.').map(Number);

const EXIT_CODES = {
  SUCCESS: 0,
  ERROR: 1,
};

if (major < 16) {
  console.error(`Repomix requires Node.js version 16 or higher. Current version: ${nodeVersion}\n`);
  process.exit(EXIT_CODES.ERROR);
}

function setupErrorHandlers() {
  process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
    process.exit(EXIT_CODES.ERROR);
  });

  process.on('unhandledRejection', (reason) => {
    console.error('Unhandled Promise Rejection:', reason);
    process.exit(EXIT_CODES.ERROR);
  });

  function shutdown() {
    process.exit(EXIT_CODES.SUCCESS);
  }

  process.on('SIGINT', () => {
    console.log('\nReceived SIGINT. Shutting down...');
    shutdown();
  });
  process.on('SIGTERM', shutdown);
}

(async () => {
  try {
    setupErrorHandlers();

    const { run } = await import('../lib/cli/cliRun.js');
    await run();
  } catch (error) {
    if (error instanceof Error) {
      console.error('Fatal Error:', {
        name: error.name,
        message: error.message,
        stack: error.stack,
      });
    } else {
      console.error('Fatal Error:', error);
    }

    process.exit(EXIT_CODES.ERROR);
  }
})();
</file>

<file path="browser/app/_locales/de/detailed-description.txt">
Diese Browsererweiterung fügt eine praktische "Repomix"-Schaltfläche zu GitHub-Repository-Seiten hinzu, mit der Sie Repositories schnell mit Repomix verpacken und analysieren können - einem leistungsstarken Tool, das Software-Repositories in AI-freundliche Einzeldateien umwandelt.

🛠️ Funktionen:
- Ein-Klick-Zugriff auf Repomix für jedes GitHub-Repository
- Weitere aufregende Funktionen kommen bald - freuen Sie sich auf erweiterte Funktionalität!

🚀 Verwendung:
1. Erweiterung installieren
2. Zu einem beliebigen GitHub-Repository navigieren
3. Auf die "Repomix"-Schaltfläche im Repository-Header klicken
4. Sie werden zur Repomix-Weboberfläche weitergeleitet
5. Eine verpackte Version des Repositories für AI-Analyse generieren

✨ Was ist Repomix?
Repomix ist ein innovatives Tool, das Ihre gesamte Codebasis in eine einzige, umfassende Datei verpackt, die für AI-Analyse optimiert ist. Es unterstützt mehrere Ausgabeformate (XML, Markdown, Plain Text), enthält Sicherheitsprüfungen zum Ausschluss sensibler Informationen und bietet detaillierte Metriken zu Ihrem Code.

💻 Open Source:
Sowohl diese Erweiterung als auch Repomix selbst sind Open-Source-Projekte. Sie können den Quellcode einsehen, beitragen oder die Erweiterung selbst erstellen.
Weitere Details finden Sie unter:
https://github.com/yamadashy/repomix

🌐 Mehr erfahren:
- Offizielle Website: https://repomix.com
- GitHub-Repository: https://github.com/yamadashy/repomix
</file>

<file path="browser/app/_locales/de/messages.json">
{
  "appDescription": {
    "message": "Fügt eine Schaltfläche hinzu, um schnell von GitHub-Repositories auf Repomix zuzugreifen",
    "description": "The description of the extension"
  },
  "openWithRepomix": {
    "message": "Mit Repomix öffnen",
    "description": "Button tooltip text for opening repository with Repomix"
  }
}
</file>

<file path="browser/app/_locales/en/detailed-description.txt">
This browser extension adds a convenient "Repomix" button to GitHub repository pages, allowing you to quickly package and analyze repositories with Repomix - a powerful tool that transforms software repositories into AI-friendly single files.

🛠️ Features:
- One-click access to Repomix for any GitHub repository
- More exciting features coming soon - stay tuned for enhanced functionality!

🚀 How to Use:
1. Install the extension
2. Navigate to any GitHub repository
3. Click the "Repomix" button in the repository header
4. You'll be redirected to Repomix web interface
5. Generate a packaged version of the repository for AI analysis

✨ What is Repomix?
Repomix is an innovative tool that packages your entire codebase into a single, comprehensive file optimized for AI analysis. It supports multiple output formats (XML, Markdown, Plain text), includes security checks to exclude sensitive information, and provides detailed metrics about your code.

💻 Open Source:
Both this extension and Repomix itself are open source projects. You can view the source code, contribute, or build the extension yourself.
For more details, please visit:
https://github.com/yamadashy/repomix

🌐 Learn More:
- Official Website: https://repomix.com
- GitHub Repository: https://github.com/yamadashy/repomix
</file>

<file path="browser/app/_locales/en/messages.json">
{
  "appDescription": {
    "message": "Add a button to quickly access Repomix from GitHub repositories",
    "description": "The description of the extension"
  },
  "openWithRepomix": {
    "message": "Open with Repomix",
    "description": "Button tooltip text for opening repository with Repomix"
  }
}
</file>

<file path="browser/app/_locales/es/detailed-description.txt">
Esta extensión de navegador añade un botón "Repomix" conveniente a las páginas de repositorio de GitHub, permitiéndote empaquetar y analizar rápidamente repositorios con Repomix - una herramienta poderosa que transforma repositorios de software en archivos únicos adaptados para IA.

🛠️ Características:
- Acceso con un clic a Repomix para cualquier repositorio de GitHub
- ¡Más características emocionantes llegarán pronto - mantente atento a la funcionalidad mejorada!

🚀 Cómo usar:
1. Instalar la extensión
2. Navegar a cualquier repositorio de GitHub
3. Hacer clic en el botón "Repomix" en el encabezado del repositorio
4. Serás redirigido a la interfaz web de Repomix
5. Generar una versión empaquetada del repositorio para análisis de IA

✨ ¿Qué es Repomix?
Repomix es una herramienta innovadora que empaqueta toda tu base de código en un solo archivo integral optimizado para análisis de IA. Soporta múltiples formatos de salida (XML, Markdown, texto plano), incluye verificaciones de seguridad para excluir información sensible y proporciona métricas detalladas sobre tu código.

💻 Código Abierto:
Tanto esta extensión como Repomix en sí son proyectos de código abierto. Puedes ver el código fuente, contribuir o construir la extensión tú mismo.
Para más detalles, por favor visita:
https://github.com/yamadashy/repomix

🌐 Aprende Más:
- Sitio Web Oficial: https://repomix.com
- Repositorio GitHub: https://github.com/yamadashy/repomix
</file>

<file path="browser/app/_locales/es/messages.json">
{
  "appDescription": {
    "message": "Añade un botón para acceder rápidamente a Repomix desde repositorios de GitHub",
    "description": "The description of the extension"
  },
  "openWithRepomix": {
    "message": "Abrir con Repomix",
    "description": "Button tooltip text for opening repository with Repomix"
  }
}
</file>

<file path="browser/app/_locales/fr/detailed-description.txt">
Cette extension de navigateur ajoute un bouton "Repomix" pratique aux pages de dépôt GitHub, vous permettant d'empaqueter et d'analyser rapidement les dépôts avec Repomix - un outil puissant qui transforme les dépôts logiciels en fichiers uniques adaptés à l'IA.

🛠️ Fonctionnalités:
- Accès en un clic à Repomix pour n'importe quel dépôt GitHub
- Plus de fonctionnalités passionnantes arrivent bientôt - restez à l'écoute pour des fonctionnalités améliorées !

🚀 Utilisation:
1. Installer l'extension
2. Naviguer vers n'importe quel dépôt GitHub
3. Cliquer sur le bouton "Repomix" dans l'en-tête du dépôt
4. Vous serez redirigé vers l'interface web Repomix
5. Générer une version empaquetée du dépôt pour l'analyse IA

✨ Qu'est-ce que Repomix ?
Repomix est un outil innovant qui empaquette l'ensemble de votre base de code en un seul fichier complet optimisé pour l'analyse IA. Il prend en charge plusieurs formats de sortie (XML, Markdown, texte brut), inclut des vérifications de sécurité pour exclure les informations sensibles et fournit des métriques détaillées sur votre code.

💻 Open Source:
Cette extension et Repomix lui-même sont des projets open source. Vous pouvez consulter le code source, contribuer ou construire l'extension vous-même.
Pour plus de détails, veuillez visiter:
https://github.com/yamadashy/repomix

🌐 En savoir plus:
- Site officiel: https://repomix.com
- Dépôt GitHub: https://github.com/yamadashy/repomix
</file>

<file path="browser/app/_locales/fr/messages.json">
{
  "appDescription": {
    "message": "Ajoute un bouton pour accéder rapidement à Repomix depuis les dépôts GitHub",
    "description": "The description of the extension"
  },
  "openWithRepomix": {
    "message": "Ouvrir avec Repomix",
    "description": "Button tooltip text for opening repository with Repomix"
  }
}
</file>

<file path="browser/app/_locales/hi/detailed-description.txt">
यह ब्राउज़र एक्सटेंशन GitHub रिपॉजिटरी पेजों पर एक सुविधाजनक "Repomix" बटन जोड़ता है, जो आपको Repomix के साथ रिपॉजिटरी को जल्दी पैकेज और विश्लेषित करने की अनुमति देता है - एक शक्तिशाली टूल जो सॉफ्टवेयर रिपॉजिटरी को AI-फ्रेंडली सिंगल फाइलों में बदल देता है।

🛠️ विशेषताएं:
- किसी भी GitHub रिपॉजिटरी के लिए वन-क्लिक Repomix एक्सेस
- और भी रोमांचक फीचर्स जल्द आ रहे हैं - बेहतर फंक्शनैलिटी के लिए बने रहें!

🚀 कैसे उपयोग करें:
1. एक्सटेंशन इंस्टॉल करें
2. किसी भी GitHub रिपॉजिटरी पर नेविगेट करें
3. रिपॉजिटरी हेडर में "Repomix" बटन पर क्लिक करें
4. आप Repomix वेब इंटरफेस पर रीडायरेक्ट हो जाएंगे
5. AI एनालिसिस के लिए रिपॉजिटरी का पैकेज्ड वर्जन जेनरेट करें

✨ Repomix क्या है?
Repomix एक इनोवेटिव टूल है जो आपके पूरे कोडबेस को AI एनालिसिस के लिए ऑप्टिमाइज़्ड एक सिंगल, कॉम्प्रिहेंसिव फाइल में पैकेज करता है। यह मल्टिपल आउटपुट फॉर्मेट्स (XML, Markdown, Plain text) को सपोर्ट करता है, सेंसिटिव इन्फॉर्मेशन को एक्सक्लूड करने के लिए सिक्यूरिटी चेक्स शामिल करता है, और आपके कोड के बारे में डिटेल्ड मेट्रिक्स प्रदान करता है।

💻 ओपन सोर्स:
यह एक्सटेंशन और Repomix दोनों ही ओपन सोर्स प्रोजेक्ट्स हैं। आप सोर्स कोड देख सकते हैं, कंट्रिब्यूट कर सकते हैं, या एक्सटेंशन को खुद बिल्ड कर सकते हैं।
अधिक डिटेल्स के लिए, कृपया विजिट करें:
https://github.com/yamadashy/repomix

🌐 और जानें:
- ऑफिशियल वेबसाइट: https://repomix.com
- GitHub रिपॉजिटरी: https://github.com/yamadashy/repomix
</file>

<file path="browser/app/_locales/hi/messages.json">
{
  "appDescription": {
    "message": "GitHub रिपॉजिटरी से Repomix तक तुरंत पहुंचने के लिए एक बटन जोड़ता है",
    "description": "The description of the extension"
  },
  "openWithRepomix": {
    "message": "Repomix के साथ खोलें",
    "description": "Button tooltip text for opening repository with Repomix"
  }
}
</file>

<file path="browser/app/_locales/id/detailed-description.txt">
Ekstensi browser ini menambahkan tombol "Repomix" yang mudah digunakan ke halaman repositori GitHub, memungkinkan Anda untuk dengan cepat mengemas dan menganalisis repositori dengan Repomix - alat yang kuat yang mengubah repositori perangkat lunak menjadi file tunggal yang ramah AI.

🛠️ Fitur:
- Akses satu klik ke Repomix untuk repositori GitHub apa pun
- Fitur menarik lainnya akan segera hadir - pantau terus untuk fungsionalitas yang ditingkatkan!

🚀 Cara Menggunakan:
1. Install ekstensi
2. Navigasi ke repositori GitHub mana pun
3. Klik tombol "Repomix" di header repositori
4. Anda akan diarahkan ke antarmuka web Repomix
5. Hasilkan versi terkemas dari repositori untuk analisis AI

✨ Apa itu Repomix?
Repomix adalah alat inovatif yang mengemas seluruh codebase Anda menjadi satu file komprehensif yang dioptimalkan untuk analisis AI. Ini mendukung berbagai format output (XML, Markdown, Plain text), mencakup pemeriksaan keamanan untuk mengecualikan informasi sensitif, dan menyediakan metrik terperinci tentang kode Anda.

💻 Open Source:
Baik ekstensi ini maupun Repomix itu sendiri adalah proyek open source. Anda dapat melihat source code, berkontribusi, atau membangun ekstensi sendiri.
Untuk detail lebih lanjut, silakan kunjungi:
https://github.com/yamadashy/repomix

🌐 Pelajari Lebih Lanjut:
- Official Website: https://repomix.com
- GitHub Repository: https://github.com/yamadashy/repomix
</file>

<file path="browser/app/_locales/id/messages.json">
{
  "appDescription": {
    "message": "Menambahkan tombol untuk mengakses Repomix dengan cepat dari repositori GitHub",
    "description": "The description of the extension"
  },
  "openWithRepomix": {
    "message": "Buka dengan Repomix",
    "description": "Button tooltip text for opening repository with Repomix"
  }
}
</file>

<file path="browser/app/_locales/ja/detailed-description.txt">
このブラウザ拡張機能は、GitHubリポジトリページに便利な「Repomix」ボタンを追加し、ソフトウェアリポジトリをAI分析に適した単一ファイルに変換する強力なツールであるRepomixで、リポジトリを素早くパッケージ化・分析できるようにします。

🛠️ 機能:
- あらゆるGitHubリポジトリへのワンクリックアクセス
- さらなるエキサイティングな機能を近日リリース予定 - 機能強化にご期待ください！

🚀 使用方法:
1. 拡張機能をインストール
2. 任意のGitHubリポジトリに移動
3. リポジトリヘッダーの「Repomix」ボタンをクリック
4. Repomixウェブインターフェースにリダイレクトされます
5. AI分析用のリポジトリのパッケージ版を生成

✨ Repomixとは？
Repomixは、コードベース全体をAI分析用に最適化された単一の包括的ファイルにパッケージ化する革新的なツールです。複数の出力フォーマット（XML、Markdown、プレーンテキスト）をサポートし、機密情報を除外するセキュリティチェックを含み、コードに関する詳細なメトリクスを提供します。

💻 オープンソース:
この拡張機能とRepomix自体の両方がオープンソースプロジェクトです。ソースコードを確認したり、貢献したり、自分で拡張機能をビルドしたりできます。
詳細については、以下をご覧ください:
https://github.com/yamadashy/repomix

🌐 詳細情報:
- 公式ウェブサイト: https://repomix.com
- GitHubリポジトリ: https://github.com/yamadashy/repomix
</file>

<file path="browser/app/_locales/ja/messages.json">
{
  "appDescription": {
    "message": "GitHubリポジトリからRepomixへ簡単にアクセスするためのボタンを追加します",
    "description": "The description of the extension"
  },
  "openWithRepomix": {
    "message": "Repomixで開く",
    "description": "Button tooltip text for opening repository with Repomix"
  }
}
</file>

<file path="browser/app/_locales/ko/detailed-description.txt">
이 브라우저 확장 프로그램은 GitHub 리포지토리 페이지에 편리한 "Repomix" 버튼을 추가하여, 소프트웨어 리포지토리를 AI 분석에 적합한 단일 파일로 변환하는 강력한 도구인 Repomix로 리포지토리를 빠르게 패키지화하고 분석할 수 있게 해줍니다.

🛠️ 기능:
- 모든 GitHub 리포지토리에 원클릭으로 Repomix 액세스
- 더 흥미로운 기능들이 곧 출시 예정 - 기능 향상을 기대해 주세요!

🚀 사용 방법:
1. 확장 프로그램 설치
2. 임의의 GitHub 리포지토리로 이동
3. 리포지토리 헤더의 "Repomix" 버튼 클릭
4. Repomix 웹 인터페이스로 리디렉션됩니다
5. AI 분석용 리포지토리의 패키지 버전 생성

✨ Repomix란?
Repomix는 전체 코드베이스를 AI 분석에 최적화된 포괄적인 단일 파일로 패키지화하는 혁신적인 도구입니다. 여러 출력 형식(XML, Markdown, 일반 텍스트)을 지원하고, 민감한 정보를 제외하는 보안 검사를 포함하며, 코드에 대한 자세한 메트릭을 제공합니다.

💻 오픈 소스:
이 확장 프로그램과 Repomix 자체 모두 오픈 소스 프로젝트입니다. 소스 코드를 확인하거나, 기여하거나, 직접 확장 프로그램을 빌드할 수 있습니다.
자세한 내용은 다음을 참조하세요:
https://github.com/yamadashy/repomix

🌐 자세히 알아보기:
- 공식 웹사이트: https://repomix.com
- GitHub 리포지토리: https://github.com/yamadashy/repomix
</file>

<file path="browser/app/_locales/ko/messages.json">
{
  "appDescription": {
    "message": "GitHub 리포지토리에서 Repomix에 빠르게 액세스할 수 있는 버튼을 추가합니다",
    "description": "The description of the extension"
  },
  "openWithRepomix": {
    "message": "Repomix로 열기",
    "description": "Button tooltip text for opening repository with Repomix"
  }
}
</file>

<file path="browser/app/_locales/pt_BR/detailed-description.txt">
Esta extensão de navegador adiciona um botão "Repomix" conveniente às páginas de repositório do GitHub, permitindo que você empacote e analise rapidamente repositórios com Repomix - uma ferramenta poderosa que transforma repositórios de software em arquivos únicos adequados para IA.

🛠️ Recursos:
- Acesso com um clique ao Repomix para qualquer repositório do GitHub
- Mais recursos emocionantes chegando em breve - fique atento para funcionalidades aprimoradas!

🚀 Como usar:
1. Instalar a extensão
2. Navegar para qualquer repositório do GitHub
3. Clicar no botão "Repomix" no cabeçalho do repositório
4. Você será redirecionado para a interface web do Repomix
5. Gerar uma versão empacotada do repositório para análise de IA

✨ O que é Repomix?
Repomix é uma ferramenta inovadora que empacota toda a sua base de código em um único arquivo abrangente otimizado para análise de IA. Suporta múltiplos formatos de saída (XML, Markdown, texto simples), inclui verificações de segurança para excluir informações sensíveis e fornece métricas detalhadas sobre seu código.

💻 Código Aberto:
Tanto esta extensão quanto o próprio Repomix são projetos de código aberto. Você pode visualizar o código fonte, contribuir ou construir a extensão você mesmo.
Para mais detalhes, por favor visite:
https://github.com/yamadashy/repomix

🌐 Saiba Mais:
- Site Oficial: https://repomix.com
- Repositório GitHub: https://github.com/yamadashy/repomix
</file>

<file path="browser/app/_locales/pt_BR/messages.json">
{
  "appDescription": {
    "message": "Adiciona um botão para acessar rapidamente o Repomix a partir de repositórios do GitHub",
    "description": "The description of the extension"
  },
  "openWithRepomix": {
    "message": "Abrir com Repomix",
    "description": "Button tooltip text for opening repository with Repomix"
  }
}
</file>

<file path="browser/app/_locales/vi/detailed-description.txt">
Tiện ích mở rộng trình duyệt này thêm nút "Repomix" tiện lợi vào các trang repository GitHub, cho phép bạn nhanh chóng đóng gói và phân tích repository với Repomix - một công cụ mạnh mẽ chuyển đổi repository phần mềm thành các file đơn thân thiện với AI.

🛠️ Tính năng:
- Truy cập một cú nhấp chuột vào Repomix cho bất kỳ repository GitHub nào
- Nhiều tính năng thú vị khác sắp ra mắt - theo dõi để có chức năng được cải tiến!

🚀 Cách sử dụng:
1. Cài đặt extension
2. Điều hướng đến bất kỳ repository GitHub nào
3. Nhấp vào nút "Repomix" trong header repository
4. Bạn sẽ được chuyển hướng đến giao diện web Repomix
5. Tạo phiên bản đóng gói của repository để phân tích AI

✨ Repomix là gì?
Repomix là một công cụ sáng tạo đóng gói toàn bộ codebase của bạn thành một file toàn diện được tối ưu hóa cho phân tích AI. Nó hỗ trợ nhiều định dạng đầu ra (XML, Markdown, Plain text), bao gồm kiểm tra bảo mật để loại trừ thông tin nhạy cảm và cung cấp các metrics chi tiết về code của bạn.

💻 Open Source:
Cả extension này và Repomix đều là các dự án open source. Bạn có thể xem source code, đóng góp hoặc tự xây dựng extension.
Để biết thêm chi tiết, vui lòng truy cập:
https://github.com/yamadashy/repomix

🌐 Tìm hiểu thêm:
- Official Website: https://repomix.com
- GitHub Repository: https://github.com/yamadashy/repomix
</file>

<file path="browser/app/_locales/vi/messages.json">
{
  "appDescription": {
    "message": "Thêm nút để truy cập nhanh Repomix từ các kho lưu trữ GitHub",
    "description": "The description of the extension"
  },
  "openWithRepomix": {
    "message": "Mở với Repomix",
    "description": "Button tooltip text for opening repository with Repomix"
  }
}
</file>

<file path="browser/app/_locales/zh_CN/detailed-description.txt">
这个浏览器扩展程序为GitHub仓库页面添加了一个便捷的"Repomix"按钮，让您可以快速使用Repomix打包和分析仓库。Repomix是一个强大的工具，可以将软件仓库转换为AI分析友好的单个文件。

🛠️ 功能:
- 一键访问任何GitHub仓库的Repomix
- 更多精彩功能即将推出 - 敬请期待功能增强！

🚀 使用方法:
1. 安装扩展程序
2. 导航到任何GitHub仓库
3. 点击仓库标题中的"Repomix"按钮
4. 您将被重定向到Repomix网页界面
5. 为AI分析生成仓库的打包版本

✨ 什么是Repomix？
Repomix是一个创新工具，可以将您的整个代码库打包成一个针对AI分析优化的综合文件。它支持多种输出格式（XML、Markdown、纯文本），包含安全检查以排除敏感信息，并提供有关代码的详细指标。

💻 开源:
这个扩展程序和Repomix本身都是开源项目。您可以查看源代码、贡献代码或自己构建扩展程序。
更多详情，请访问:
https://github.com/yamadashy/repomix

🌐 了解更多:
- 官方网站: https://repomix.com
- GitHub仓库: https://github.com/yamadashy/repomix
</file>

<file path="browser/app/_locales/zh_CN/messages.json">
{
  "appDescription": {
    "message": "为GitHub仓库添加一个按钮，快速访问Repomix",
    "description": "The description of the extension"
  },
  "openWithRepomix": {
    "message": "使用Repomix打开",
    "description": "Button tooltip text for opening repository with Repomix"
  }
}
</file>

<file path="browser/app/_locales/zh_TW/detailed-description.txt">
這個瀏覽器擴充功能為GitHub儲存庫頁面添加了一個便捷的「Repomix」按鈕，讓您可以快速使用Repomix打包和分析儲存庫。Repomix是一個強大的工具，可以將軟體儲存庫轉換為AI分析友好的單一檔案。

🛠️ 功能:
- 一鍵存取任何GitHub儲存庫的Repomix
- 更多精彩功能即將推出 - 敬請期待功能增強！

🚀 使用方法:
1. 安裝擴充功能
2. 導航到任何GitHub儲存庫
3. 點擊儲存庫標題中的「Repomix」按鈕
4. 您將被重新導向到Repomix網頁介面
5. 為AI分析生成儲存庫的打包版本

✨ 什麼是Repomix？
Repomix是一個創新工具，可以將您的整個程式碼庫打包成一個針對AI分析最佳化的綜合檔案。它支援多種輸出格式（XML、Markdown、純文字），包含安全檢查以排除敏感資訊，並提供有關程式碼的詳細指標。

💻 開源:
這個擴充功能和Repomix本身都是開源專案。您可以查看原始碼、貢獻程式碼或自己建置擴充功能。
更多詳情，請造訪:
https://github.com/yamadashy/repomix

🌐 了解更多:
- 官方網站: https://repomix.com
- GitHub儲存庫: https://github.com/yamadashy/repomix
</file>

<file path="browser/app/_locales/zh_TW/messages.json">
{
  "appDescription": {
    "message": "為GitHub儲存庫添加一個按鈕，快速存取Repomix",
    "description": "The description of the extension"
  },
  "openWithRepomix": {
    "message": "使用Repomix開啟",
    "description": "Button tooltip text for opening repository with Repomix"
  }
}
</file>

<file path="browser/app/images/icon.svg">
<?xml version="1.0" encoding="utf-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="96.259 93.171 300 300" xmlns:bx="https://boxy-svg.com">
  <g id="group-1" transform="matrix(1.160932, 0, 0, 1.160932, 97.635941, 94.725143)" style="">
    <path style="fill-rule: nonzero; fill-opacity: 1; stroke-width: 2; fill: rgb(234, 127, 58);" d="M 128.03 -1.486 L 21.879 65.349 L 21.848 190.25 L 127.979 256.927 L 234.2 190.27 L 234.197 65.463 L 128.03 -1.486 Z M 208.832 70.323 L 127.984 121.129 L 47.173 70.323 L 128.144 19.57 L 208.832 70.323 Z M 39.669 86.367 L 119.188 136.415 L 119.255 230.529 L 39.637 180.386 L 39.669 86.367 Z M 136.896 230.506 L 136.887 136.575 L 216.469 86.192 L 216.417 180.46 L 136.896 230.506 Z M 136.622 230.849"/>
  </g>
</svg>
</file>

<file path="browser/app/scripts/background.ts">
const injectContentToTab = async (tab: chrome.tabs.Tab): Promise<void> => {
  // Skip if URL is undefined
  if (!tab.url) {
    return;
  }

  // Skip if tab is discarded
  if (tab.discarded) {
    return;
  }

  // Skip if tab ID is undefined
  if (tab.id === undefined) {
    return;
  }

  // Skip if not a GitHub URL
  if (!tab.url.startsWith('https://github.com/')) {
    return;
  }

  try {
    const manifest = chrome.runtime.getManifest();

    // Inject CSS
    if (manifest.content_scripts?.[0]?.css) {
      await chrome.scripting.insertCSS({
        target: { tabId: tab.id },
        files: manifest.content_scripts[0].css,
      });
    }

    // Inject JavaScript
    if (manifest.content_scripts?.[0]?.js) {
      await chrome.scripting.executeScript({
        target: { tabId: tab.id },
        files: manifest.content_scripts[0].js,
      });
    }
  } catch (error) {
    console.error('Error injecting content script:', error);
  }
};

// Update extension content for tabs
chrome.tabs.query({}, async (tabs: chrome.tabs.Tab[]) => {
  for (const tab of tabs) {
    try {
      await injectContentToTab(tab);
    } catch (e) {
      console.error(e);
    }
  }
});
</file>

<file path="browser/app/scripts/content.ts">
interface RepositoryInfo {
  owner: string;
  repo: string;
  url: string;
}

interface RepomixButtonOptions {
  text: string;
  href: string;
  iconSrc?: string;
}

// Constants
const BUTTON_CLASS = 'repomix-button';
const ICON_SIZE = 16;
const REPOMIX_BASE_URL = 'https://repomix.com';
const BUTTON_TEXT = 'Repomix';
const DEFAULT_ICON_PATH = 'images/icon-64.png';

// Button functions
function isRepomixButtonAlreadyExists(): boolean {
  return document.querySelector(`.${BUTTON_CLASS}`) !== null;
}

function createRepomixButton(options: RepomixButtonOptions): HTMLElement {
  const container = document.createElement('li');

  const button = document.createElement('a');
  button.className = `${BUTTON_CLASS} btn-sm btn BtnGroup-item`;
  button.href = options.href;
  button.target = '_blank';
  button.rel = 'noopener noreferrer';
  button.title = chrome.i18n.getMessage('openWithRepomix');

  // Create octicon container
  const octicon = document.createElement('span');
  octicon.className = 'octicon';
  octicon.setAttribute('aria-hidden', 'true');

  // Use chrome.runtime.getURL for the icon
  const iconSrc = options.iconSrc || chrome.runtime.getURL(DEFAULT_ICON_PATH);
  octicon.innerHTML = `<img src="${iconSrc}" width="${ICON_SIZE}" height="${ICON_SIZE}" alt="Repomix">`;

  button.appendChild(octicon);

  // Add button text
  const textSpan = document.createElement('span');
  textSpan.textContent = options.text;
  button.appendChild(textSpan);

  container.appendChild(button);
  return container;
}

// GitHub functions
function extractRepositoryInfo(): RepositoryInfo | null {
  const pathMatch = window.location.pathname.match(/^\/([^/]+)\/([^/]+)/);
  if (!pathMatch) {
    return null;
  }

  const [, owner, repo] = pathMatch;
  return {
    owner,
    repo,
    url: `https://github.com/${owner}/${repo}`,
  };
}

function findNavigationContainer(): Element | null {
  return document.querySelector('ul.pagehead-actions');
}

function isRepositoryPage(): boolean {
  // Check if we're on a repository page (not user profile, organization, etc.)
  const pathParts = window.location.pathname.split('/').filter(Boolean);
  return pathParts.length >= 2 && !pathParts[0].startsWith('@');
}

// Main integration functions
function addRepomixButton(): void {
  try {
    // Check if button already exists
    if (isRepomixButtonAlreadyExists()) {
      return;
    }

    // Check if we're on a repository page
    if (!isRepositoryPage()) {
      return;
    }

    // Get repository information
    const repoInfo = extractRepositoryInfo();
    if (!repoInfo) {
      return;
    }

    // Find navigation container
    const navContainer = findNavigationContainer();
    if (!navContainer) {
      return;
    }

    // Create Repomix URL
    const repomixUrl = `${REPOMIX_BASE_URL}/?repo=${encodeURIComponent(repoInfo.url)}`;

    // Create button
    const buttonContainer = createRepomixButton({
      text: BUTTON_TEXT,
      href: repomixUrl,
    });

    // Insert button at the beginning (left side)
    navContainer.prepend(buttonContainer);

    console.log(`Repomix button added for ${repoInfo.owner}/${repoInfo.repo}`);
  } catch (error) {
    console.error('Error adding Repomix button:', error);
  }
}

function observePageChanges(): void {
  // Observe changes to handle GitHub's dynamic navigation
  const observer = new MutationObserver(() => {
    addRepomixButton();
  });

  observer.observe(document.body, {
    childList: true,
    subtree: true,
  });

  // Also listen for popstate events (back/forward navigation)
  window.addEventListener('popstate', () => {
    setTimeout(() => addRepomixButton(), 100);
  });
}

function initRepomixIntegration(): void {
  try {
    addRepomixButton();
    observePageChanges();
  } catch (error) {
    console.error('Error initializing Repomix integration:', error);
  }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => initRepomixIntegration());
} else {
  initRepomixIntegration();
}
</file>

<file path="browser/app/styles/content.css">
.repomix-button.btn-sm.btn.BtnGroup-item {
  display: inline-flex;
  align-items: center;
  gap: 0px;
}

.repomix-button .octicon {
  display: inline-flex;
  align-items: center;
}

.repomix-button .octicon img {
  vertical-align: text-bottom;
}
</file>

<file path="browser/app/manifest.json">
{
  "name": "Repomix",
  "short_name": "repomix",
  "version": "1.0.1",
  "manifest_version": 3,
  "description": "__MSG_appDescription__",
  "default_locale": "en",
  "icons": {
    "16": "images/icon-16.png",
    "19": "images/icon-19.png",
    "32": "images/icon-32.png",
    "38": "images/icon-38.png",
    "48": "images/icon-48.png",
    "64": "images/icon-64.png",
    "128": "images/icon-128.png"
  },
  "minimum_chrome_version": "88.0",
  "content_scripts": [
    {
      "matches": [
        "https://github.com/*"
      ],
      "css": [
        "styles/content.css"
      ],
      "js": [
        "scripts/content.js"
      ],
      "run_at": "document_start",
      "all_frames": true
    }
  ],
  "background": {
    "service_worker": "scripts/background.js"
  },
  "permissions": [
    "scripting"
  ],
  "web_accessible_resources": [
    {
      "resources": [
        "images/icon-16.png",
        "images/icon-19.png",
        "images/icon-32.png",
        "images/icon-38.png",
        "images/icon-48.png",
        "images/icon-64.png",
        "images/icon-128.png"
      ],
      "matches": ["https://github.com/*"]
    }
  ],
  "host_permissions": [
    "https://github.com/*"
  ],
  "__firefox__background": {
    "scripts": [
      "scripts/background.js"
    ]
  },
  "__firefox__browser_specific_settings": {
    "gecko": {
      "id": "{3AB97897-F299-4DBC-8084-A92813FE2685}",
      "strict_min_version": "102.0"
    }
  }
}
</file>

<file path="browser/scripts/generate-icons.ts">
import fs from 'node:fs';
import path from 'node:path';
import sharp from 'sharp';

interface IconSize {
  width: number;
  height: number;
}

const ICON_SIZES: readonly number[] = [16, 19, 32, 38, 48, 64, 128] as const;
const INPUT_SVG_PATH = path.join(__dirname, '../app/images/icon.svg');
const OUTPUT_DIR = path.join(__dirname, '../app/images');

/**
 * Ensures the output directory exists
 */
function ensureOutputDirectory(): void {
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    console.log(`Created output directory: ${OUTPUT_DIR}`);
  }
}

/**
 * Generates a PNG icon of the specified size
 */
async function generateIcon(size: number): Promise<void> {
  try {
    const outputPath = path.join(OUTPUT_DIR, `icon-${size}.png`);

    await sharp(INPUT_SVG_PATH).resize(size, size).png().toFile(outputPath);

    console.log(`✅ Generated ${size}x${size} icon: ${outputPath}`);
  } catch (error) {
    console.error(`❌ Error generating ${size}x${size} icon:`, error);
    throw error;
  }
}

/**
 * Validates that the input SVG file exists
 */
function validateInputFile(): void {
  if (!fs.existsSync(INPUT_SVG_PATH)) {
    throw new Error(`Input SVG file not found: ${INPUT_SVG_PATH}`);
  }
  console.log(`📁 Input SVG: ${INPUT_SVG_PATH}`);
}

/**
 * Main function to generate all icon sizes
 */
async function generateAllIcons(): Promise<void> {
  console.log('🚀 Starting icon generation...');

  try {
    validateInputFile();
    ensureOutputDirectory();

    // Generate all icons in parallel
    const iconPromises = ICON_SIZES.map((size) => generateIcon(size));
    await Promise.all(iconPromises);

    console.log(`🎉 Successfully generated ${ICON_SIZES.length} icons!`);
    console.log(`📂 Output directory: ${OUTPUT_DIR}`);
  } catch (error) {
    console.error('💥 Failed to generate icons:', error);
    process.exit(1);
  }
}

// Execute if this file is run directly
if (require.main === module) {
  void generateAllIcons();
}

export { generateAllIcons, generateIcon, ICON_SIZES };
</file>

<file path="browser/tests/repomix-integration.test.ts">
import { beforeEach, describe, expect, it } from 'vitest';

// Mock DOM environment
Object.defineProperty(window, 'location', {
  value: {
    pathname: '/yamadashy/repomix',
    href: 'https://github.com/yamadashy/repomix',
  },
  writable: true,
});

describe('RepomixIntegration', () => {
  beforeEach(() => {
    // Reset DOM
    document.body.innerHTML = '';

    // Mock GitHub page structure
    const navActions = document.createElement('ul');
    navActions.className = 'pagehead-actions';
    document.body.appendChild(navActions);
  });

  it('should extract repository information correctly', () => {
    // This is a placeholder test since we're testing static methods
    // In a real scenario, we'd need to import and test the actual classes
    const pathMatch = window.location.pathname.match(/^\/([^/]+)\/([^/]+)/);
    expect(pathMatch).toBeTruthy();

    if (pathMatch) {
      const [, owner, repo] = pathMatch;
      expect(owner).toBe('yamadashy');
      expect(repo).toBe('repomix');
    }
  });

  it('should construct correct Repomix URL', () => {
    const repoUrl = 'https://github.com/yamadashy/repomix';
    const expectedUrl = `https://repomix.com/?repo=${encodeURIComponent(repoUrl)}`;

    expect(expectedUrl).toBe('https://repomix.com/?repo=https%3A%2F%2Fgithub.com%2Fyamadashy%2Frepomix');
  });

  it('should find navigation container', () => {
    const navContainer = document.querySelector('ul.pagehead-actions');
    expect(navContainer).toBeTruthy();
  });
});
</file>

<file path="browser/.gitignore">
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Build output
dist/
packages/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# Logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/

# Temporary folders
tmp/
temp/
</file>

<file path="browser/CLAUDE.md">
# Browser Extension Guidelines

This file provides guidance for working with the Repomix browser extension.

## Project Overview

Cross-browser extension (Chrome/Firefox/Edge) that adds Repomix integration to GitHub repository pages. Uses Manifest V3 with content scripts to inject a "Repomix" button directly into GitHub's UI.

## Directory Structure

```
browser/
├── app/                    # Extension source code
│   ├── _locales/          # Internationalization files (11 languages)
│   ├── images/            # Extension icons (16px to 128px)
│   ├── manifest.json      # Extension manifest (Manifest V3)
│   ├── scripts/           # TypeScript source files
│   │   ├── background.ts  # Service worker (background script)
│   │   └── content.ts     # Content script for GitHub integration
│   └── styles/            # CSS styles for injected elements
├── dist/                  # Built extension files (generated)
├── promo/                 # Store promotional materials
└── tests/                 # Test files
```

## Development Commands

```bash
npm run dev chrome     # Development mode for Chrome
npm run build-all      # Build for all browsers
npm run lint          # TypeScript type checking
npm run test          # Run tests
npm run generate-icons # Generate icon set from SVG
```

## Internationalization

### Supported Languages (11 total)
English, Japanese, German, French, Spanish, Portuguese (Brazilian), Indonesian, Vietnamese, Korean, Chinese (Simplified/Traditional), Hindi.

### Adding New Languages
1. Create directory in `app/_locales/[language_code]/`
2. Add `messages.json` with required keys:
   - `appName`, `appDescription`, `buttonText`
3. Add `detailed-description.txt` for store descriptions
4. Test extension loads correctly with new locale
</file>

<file path="browser/package.json">
{
  "private": true,
  "name": "repomix",
  "description": "A browser extension that adds a Repomix button to GitHub repositories",
  "scripts": {
    "dev": "webextension-toolbox dev",
    "build": "webextension-toolbox build",
    "build-all": "npm run build chrome && npm run build firefox && npm run build edge",
    "generate-icons": "tsx scripts/generate-icons.ts",
    "lint": "npm run lint-tsc",
    "lint-tsc": "tsc --noEmit",
    "test": "vitest",
    "archive": "git archive HEAD -o storage/source.zip"
  },
  "keywords": [
    "chrome",
    "extension",
    "firefox",
    "addon",
    "repomix",
    "github",
    "documentation"
  ],
  "author": "yamadashy",
  "license": "MIT",
  "devDependencies": {
    "@biomejs/biome": "^1.9.4",
    "@secretlint/secretlint-rule-preset-recommend": "^9.3.1",
    "@types/chrome": "^0.0.323",
    "@types/node": "^22.10.2",
    "@types/webextension-polyfill": "^0.10.7",
    "@webextension-toolbox/webextension-toolbox": "^7.1.1",
    "jsdom": "^26.1.0",
    "secretlint": "^9.3.1",
    "sharp": "^0.34.1",
    "tsx": "^4.19.2",
    "typescript": "^5.8.3",
    "vitest": "^3.2.2"
  },
  "browserslist": [
    "last 2 versions, not dead, > 0.2%"
  ],
  "engines": {
    "node": ">=24.0.1"
  }
}
</file>

<file path="browser/README.md">
# Repomix Extension

A browser extension that adds a Repomix button to GitHub repository pages.

## 🚀 Features

- Adds a "Repomix" button to GitHub repository pages
- One-click redirect to Repomix (https://repomix.com)
- Seamlessly integrates with GitHub's UI design
- Works on Chrome, Firefox, and Edge

## 🛠️ Usage

1. Install the browser extension
2. Navigate to any GitHub repository page
3. A "Repomix" button will appear in the page header action area
4. Click the button to open the repository in Repomix

## 💻 Development

### Prerequisites

- Node.js 22 or higher

### Setup

```bash
# Install dependencies
npm install

# Generate icons
npm run generate-icons

# Development mode for Chrome
npm run dev chrome

# Development mode for Firefox
npm run dev firefox

# Development mode for Edge
npm run dev edge
```

### Build

```bash
# Build for all browsers
npm run build-all

# Build for specific browsers
npm run build chrome
npm run build firefox
npm run build edge
```

Built files will be generated in the `dist/` folder.

### Manual Installation

1. Run `npm run build chrome` to build
2. Open `chrome://extensions/` in Chrome
3. Enable "Developer mode"
4. Click "Load unpacked extension"
5. Select the `dist/chrome` folder

## 📝 Technical Specifications

- **Manifest V3** - Latest browser extension specification
- **Content Scripts** - Direct button injection into GitHub pages
- **Internationalization** - English and Japanese support
- **Cross-browser** - Chrome, Firefox, Edge support

## 🔒 Privacy

This extension:
- Does not collect any data
- Does not track user behavior
- Only accesses github.com
- Requires minimal permissions
</file>

<file path="browser/tsconfig.json">
{
  "compilerOptions": {
    "strict": true,
    "target": "esnext",
    "module": "commonjs",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "lib": [
      "dom",
      "esnext"
    ],
    "allowJs": false,
    "noImplicitAny": true,
    "removeComments": true,
    "skipLibCheck": true,
    "sourceMap": true
  }
}
</file>

<file path="browser/vitest.config.ts">
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: [],
    watch: false,
  },
  resolve: {
    extensions: ['.ts', '.js'],
  },
});
</file>

<file path="src/cli/actions/defaultAction.ts">
import path from 'node:path';
import { loadFileConfig, mergeConfigs } from '../../config/configLoad.js';
import {
  type RepomixConfigCli,
  type RepomixConfigFile,
  type RepomixConfigMerged,
  type RepomixOutputStyle,
  repomixConfigCliSchema,
} from '../../config/configSchema.js';
import { readFilePathsFromStdin } from '../../core/file/fileStdin.js';
import { type PackResult, pack } from '../../core/packager.js';
import { RepomixError } from '../../shared/errorHandle.js';
import { rethrowValidationErrorIfZodError } from '../../shared/errorHandle.js';
import { logger } from '../../shared/logger.js';
import { splitPatterns } from '../../shared/patternUtils.js';
import { printCompletion, printSecurityCheck, printSummary, printTopFiles } from '../cliPrint.js';
import { Spinner } from '../cliSpinner.js';
import type { CliOptions } from '../types.js';
import { runMigrationAction } from './migrationAction.js';

export interface DefaultActionRunnerResult {
  packResult: PackResult;
  config: RepomixConfigMerged;
}

export const runDefaultAction = async (
  directories: string[],
  cwd: string,
  cliOptions: CliOptions,
): Promise<DefaultActionRunnerResult> => {
  logger.trace('Loaded CLI options:', cliOptions);

  // Run migration before loading config
  await runMigrationAction(cwd);

  // Load the config file
  const fileConfig: RepomixConfigFile = await loadFileConfig(cwd, cliOptions.config ?? null);
  logger.trace('Loaded file config:', fileConfig);

  // Parse the CLI options into a config
  const cliConfig: RepomixConfigCli = buildCliConfig(cliOptions);
  logger.trace('CLI config:', cliConfig);

  // Merge default, file, and CLI configs
  const config: RepomixConfigMerged = mergeConfigs(cwd, fileConfig, cliConfig);

  logger.trace('Merged config:', config);

  // Route to appropriate processing workflow
  if (cliOptions.stdin) {
    return handleStdinProcessing(directories, cwd, config, cliOptions);
  }

  return handleDirectoryProcessing(directories, cwd, config, cliOptions);
};

/**
 * Handles stdin processing workflow for file paths input.
 */
export const handleStdinProcessing = async (
  directories: string[],
  cwd: string,
  config: RepomixConfigMerged,
  cliOptions: CliOptions,
): Promise<DefaultActionRunnerResult> => {
  // Validate directory arguments for stdin mode
  const firstDir = directories[0] ?? '.';
  if (directories.length > 1 || firstDir !== '.') {
    throw new RepomixError(
      'When using --stdin, do not specify directory arguments. File paths will be read from stdin.',
    );
  }

  const spinner = new Spinner('Reading file paths from stdin...', cliOptions);
  spinner.start();

  let packResult: PackResult;

  try {
    const stdinResult = await readFilePathsFromStdin(cwd);

    spinner.update('Packing files...');

    // Create a custom pack variant that uses the stdin file paths directly
    packResult = await pack(
      [cwd],
      config,
      (message) => {
        spinner.update(message);
      },
      {
        searchFiles: async () => ({
          filePaths: stdinResult.filePaths.map((filePath) => path.relative(cwd, filePath)),
          emptyDirPaths: stdinResult.emptyDirPaths,
        }),
      },
    );
  } catch (error) {
    spinner.fail('Error reading from stdin or during packing');
    throw error;
  }

  spinner.succeed('Packing completed successfully!');

  printResults(cwd, packResult, config);

  return {
    packResult,
    config,
  };
};

/**
 * Handles normal directory processing workflow.
 */
export const handleDirectoryProcessing = async (
  directories: string[],
  cwd: string,
  config: RepomixConfigMerged,
  cliOptions: CliOptions,
): Promise<DefaultActionRunnerResult> => {
  const targetPaths = directories.map((directory) => path.resolve(cwd, directory));

  const spinner = new Spinner('Packing files...', cliOptions);
  spinner.start();

  let packResult: PackResult;

  try {
    packResult = await pack(targetPaths, config, (message) => {
      spinner.update(message);
    });
  } catch (error) {
    spinner.fail('Error during packing');
    throw error;
  }

  spinner.succeed('Packing completed successfully!');

  printResults(cwd, packResult, config);

  return {
    packResult,
    config,
  };
};

/**
 * Prints the results of packing operation including top files, security check, summary, and completion.
 */
const printResults = (cwd: string, packResult: PackResult, config: RepomixConfigMerged): void => {
  logger.log('');

  if (config.output.topFilesLength > 0) {
    printTopFiles(
      packResult.fileCharCounts,
      packResult.fileTokenCounts,
      config.output.topFilesLength,
      packResult.totalTokens,
    );
    logger.log('');
  }

  printSecurityCheck(cwd, packResult.suspiciousFilesResults, packResult.suspiciousGitDiffResults, config);
  logger.log('');

  printSummary(packResult, config);
  logger.log('');

  printCompletion();
};

/**
 * Builds CLI configuration from command-line options.
 *
 * Note: Due to Commander.js behavior with --no-* flags:
 * - When --no-* flags are used (e.g., --no-file-summary), the options explicitly become false
 * - When no flag is specified, Commander defaults to true (e.g., options.fileSummary === true)
 * - For --no-* flags, we only apply the setting when it's explicitly false to respect config file values
 * - This allows the config file to maintain control unless explicitly overridden by CLI
 */
export const buildCliConfig = (options: CliOptions): RepomixConfigCli => {
  const cliConfig: RepomixConfigCli = {};

  if (options.output) {
    cliConfig.output = { filePath: options.output };
  }
  if (options.include) {
    cliConfig.include = splitPatterns(options.include);
  }
  if (options.ignore) {
    cliConfig.ignore = { customPatterns: splitPatterns(options.ignore) };
  }
  // Only apply gitignore setting if explicitly set to false
  if (options.gitignore === false) {
    cliConfig.ignore = { ...cliConfig.ignore, useGitignore: options.gitignore };
  }
  // Only apply defaultPatterns setting if explicitly set to false
  if (options.defaultPatterns === false) {
    cliConfig.ignore = {
      ...cliConfig.ignore,
      useDefaultPatterns: options.defaultPatterns,
    };
  }
  if (options.topFilesLen !== undefined) {
    cliConfig.output = {
      ...cliConfig.output,
      topFilesLength: options.topFilesLen,
    };
  }
  if (options.outputShowLineNumbers !== undefined) {
    cliConfig.output = {
      ...cliConfig.output,
      showLineNumbers: options.outputShowLineNumbers,
    };
  }
  if (options.copy) {
    cliConfig.output = { ...cliConfig.output, copyToClipboard: options.copy };
  }
  if (options.style) {
    cliConfig.output = {
      ...cliConfig.output,
      style: options.style.toLowerCase() as RepomixOutputStyle,
    };
  }
  if (options.parsableStyle !== undefined) {
    cliConfig.output = {
      ...cliConfig.output,
      parsableStyle: options.parsableStyle,
    };
  }
  if (options.stdout) {
    cliConfig.output = {
      ...cliConfig.output,
      stdout: true,
    };
  }
  // Only apply securityCheck setting if explicitly set to false
  if (options.securityCheck === false) {
    cliConfig.security = { enableSecurityCheck: options.securityCheck };
  }
  // Only apply fileSummary setting if explicitly set to false
  if (options.fileSummary === false) {
    cliConfig.output = {
      ...cliConfig.output,
      fileSummary: false,
    };
  }
  // Only apply directoryStructure setting if explicitly set to false
  if (options.directoryStructure === false) {
    cliConfig.output = {
      ...cliConfig.output,
      directoryStructure: false,
    };
  }
  // Only apply files setting if explicitly set to false
  if (options.files === false) {
    cliConfig.output = {
      ...cliConfig.output,
      files: false,
    };
  }
  if (options.removeComments !== undefined) {
    cliConfig.output = {
      ...cliConfig.output,
      removeComments: options.removeComments,
    };
  }
  if (options.removeEmptyLines !== undefined) {
    cliConfig.output = {
      ...cliConfig.output,
      removeEmptyLines: options.removeEmptyLines,
    };
  }
  if (options.headerText !== undefined) {
    cliConfig.output = { ...cliConfig.output, headerText: options.headerText };
  }

  if (options.compress !== undefined) {
    cliConfig.output = { ...cliConfig.output, compress: options.compress };
  }

  if (options.tokenCountEncoding) {
    cliConfig.tokenCount = { encoding: options.tokenCountEncoding };
  }
  if (options.instructionFilePath) {
    cliConfig.output = {
      ...cliConfig.output,
      instructionFilePath: options.instructionFilePath,
    };
  }
  if (options.includeEmptyDirectories) {
    cliConfig.output = {
      ...cliConfig.output,
      includeEmptyDirectories: options.includeEmptyDirectories,
    };
  }

  // Only apply gitSortByChanges setting if explicitly set to false
  if (options.gitSortByChanges === false) {
    cliConfig.output = {
      ...cliConfig.output,
      git: {
        ...cliConfig.output?.git,
        sortByChanges: false,
      },
    };
  }

  if (options.includeDiffs) {
    cliConfig.output = {
      ...cliConfig.output,
      git: {
        ...cliConfig.output?.git,
        includeDiffs: true,
      },
    };
  }

  try {
    return repomixConfigCliSchema.parse(cliConfig);
  } catch (error) {
    rethrowValidationErrorIfZodError(error, 'Invalid cli arguments');
    throw error;
  }
};
</file>

<file path="src/cli/actions/initAction.ts">
import fs from 'node:fs/promises';
import path from 'node:path';
import * as prompts from '@clack/prompts';
import pc from 'picocolors';
import {
  type RepomixConfigFile,
  type RepomixOutputStyle,
  defaultConfig,
  defaultFilePathMap,
} from '../../config/configSchema.js';
import { getGlobalDirectory } from '../../config/globalDirectory.js';
import { getVersion } from '../../core/file/packageJsonParse.js';
import { logger } from '../../shared/logger.js';

const onCancelOperation = () => {
  prompts.cancel('Initialization cancelled.');
  process.exit(0);
};

export const runInitAction = async (rootDir: string, isGlobal: boolean): Promise<void> => {
  prompts.intro(pc.bold(`Welcome to Repomix ${isGlobal ? 'Global ' : ''}Configuration!`));

  try {
    // Step 1: Ask if user wants to create a config file
    const isCreatedConfig = await createConfigFile(rootDir, isGlobal);

    // Step 2: Ask if user wants to create a .repomixignore file
    const isCreatedIgnoreFile = await createIgnoreFile(rootDir, isGlobal);

    if (!isCreatedConfig && !isCreatedIgnoreFile) {
      prompts.outro(
        pc.yellow('No files were created. You can run this command again when you need to create configuration files.'),
      );
    } else {
      prompts.outro(pc.green('Initialization complete! You can now use Repomix with your specified settings.'));
    }
  } catch (error) {
    logger.error('An error occurred during initialization:', error);
  }
};

export const createConfigFile = async (rootDir: string, isGlobal: boolean): Promise<boolean> => {
  const configPath = path.resolve(isGlobal ? getGlobalDirectory() : rootDir, 'repomix.config.json');

  const isCreateConfig = await prompts.confirm({
    message: `Do you want to create a ${isGlobal ? 'global ' : ''}${pc.green('repomix.config.json')} file?`,
  });
  if (!isCreateConfig) {
    prompts.log.info(`Skipping ${pc.green('repomix.config.json')} file creation.`);
    return false;
  }
  if (prompts.isCancel(isCreateConfig)) {
    onCancelOperation();
    return false;
  }

  let isConfigFileExists = false;
  try {
    await fs.access(configPath);
    isConfigFileExists = true;
  } catch {
    // File doesn't exist, so we can proceed
  }

  if (isConfigFileExists) {
    const isOverwrite = await prompts.confirm({
      message: `A ${isGlobal ? 'global ' : ''}${pc.green('repomix.config.json')} file already exists. Do you want to overwrite it?`,
    });
    if (!isOverwrite) {
      prompts.log.info(`Skipping ${pc.green('repomix.config.json')} file creation.`);
      return false;
    }
    if (prompts.isCancel(isOverwrite)) {
      onCancelOperation();
      return false;
    }
  }

  const options = await prompts.group(
    {
      outputStyle: () => {
        return prompts.select({
          message: 'Output style:',
          options: [
            { value: 'xml', label: 'XML', hint: 'Structured XML format' },
            { value: 'markdown', label: 'Markdown', hint: 'Markdown format' },
            { value: 'plain', label: 'Plain', hint: 'Simple text format' },
          ],
          initialValue: defaultConfig.output.style,
        });
      },
      outputFilePath: ({ results }) => {
        const defaultFilePath = defaultFilePathMap[results.outputStyle as RepomixOutputStyle];
        return prompts.text({
          message: 'Output file path:',
          initialValue: defaultFilePath,
          validate: (value) => (value.length === 0 ? 'Output file path is required' : undefined),
        });
      },
    },
    {
      onCancel: onCancelOperation,
    },
  );

  const config: RepomixConfigFile = {
    $schema: 'https://repomix.com/schemas/latest/schema.json',
    ...defaultConfig,
    output: {
      ...defaultConfig.output,
      filePath: options.outputFilePath as string,
      style: options.outputStyle as RepomixOutputStyle,
    },
  };

  await fs.mkdir(path.dirname(configPath), { recursive: true });
  await fs.writeFile(configPath, JSON.stringify(config, null, 2));

  const relativeConfigPath = path.relative(rootDir, configPath);

  prompts.log.success(
    pc.green(`${isGlobal ? 'Global config' : 'Config'} file created!\n`) + pc.dim(`Path: ${relativeConfigPath}`),
  );

  return true;
};

export const createIgnoreFile = async (rootDir: string, isGlobal: boolean): Promise<boolean> => {
  if (isGlobal) {
    prompts.log.info(`Skipping ${pc.green('.repomixignore')} file creation for global configuration.`);
    return false;
  }

  const ignorePath = path.resolve(rootDir, '.repomixignore');
  const createIgnore = await prompts.confirm({
    message: `Do you want to create a ${pc.green('.repomixignore')} file?`,
  });
  if (!createIgnore) {
    prompts.log.info(`Skipping ${pc.green('.repomixignore')} file creation.`);
    return false;
  }
  if (prompts.isCancel(createIgnore)) {
    onCancelOperation();
    return false;
  }

  let isIgnoreFileExists = false;
  try {
    await fs.access(ignorePath);
    isIgnoreFileExists = true;
  } catch {
    // File doesn't exist, so we can proceed
  }

  if (isIgnoreFileExists) {
    const overwrite = await prompts.confirm({
      message: `A ${pc.green('.repomixignore')} file already exists. Do you want to overwrite it?`,
    });

    if (!overwrite) {
      prompts.log.info(`${pc.green('.repomixignore')} file creation skipped. Existing file will not be modified.`);
      return false;
    }
  }

  const defaultIgnoreContent = `# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
`;

  await fs.writeFile(ignorePath, defaultIgnoreContent);
  prompts.log.success(
    pc.green('Created .repomixignore file!\n') + pc.dim(`Path: ${path.relative(rootDir, ignorePath)}`),
  );

  return true;
};
</file>

<file path="src/cli/actions/mcpAction.ts">
import { runMcpServer } from '../../mcp/mcpServer.js';
import { logger } from '../../shared/logger.js';

export const runMcpAction = async (): Promise<void> => {
  logger.trace('Starting Repomix MCP server...');
  await runMcpServer();
};
</file>

<file path="src/cli/actions/migrationAction.ts">
import * as fs from 'node:fs/promises';
import path from 'node:path';
import * as prompts from '@clack/prompts';
import pc from 'picocolors';
import { getGlobalDirectory } from '../../config/globalDirectory.js';
import { logger } from '../../shared/logger.js';

interface MigrationPaths {
  oldConfigPath: string;
  newConfigPath: string;
  oldIgnorePath: string;
  newIgnorePath: string;
  oldInstructionPath: string;
  newInstructionPath: string;
  oldOutputPaths: string[];
  newOutputPaths: string[];
  oldGlobalConfigPath: string;
  newGlobalConfigPath: string;
}

interface MigrationResult {
  configMigrated: boolean;
  ignoreMigrated: boolean;
  instructionMigrated: boolean;
  outputFilesMigrated: string[];
  globalConfigMigrated: boolean;
  error?: Error;
}

/**
 * Check if a file exists at the given path
 */
const fileExists = async (filePath: string): Promise<boolean> => {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
};

/**
 * Replace all occurrences of 'repopack' with 'repomix' in a string
 */
const replaceRepopackString = (content: string): string => {
  return content.replace(/repopack/g, 'repomix').replace(/Repopack/g, 'Repomix');
};

/**
 * Update file content by replacing 'repopack' with 'repomix'
 */
const updateFileContent = async (filePath: string): Promise<boolean> => {
  const content = await fs.readFile(filePath, 'utf8');
  const updatedContent = replaceRepopackString(content);

  // Check if content needs to be updated
  if (content !== updatedContent) {
    await fs.writeFile(filePath, updatedContent, 'utf8');
    const relativePath = path.relative(process.cwd(), filePath);
    logger.log(`Updated repopack references in ${pc.cyan(relativePath)}`);
    return true;
  }

  return false;
};

/**
 * Parse JSON content, update instructionFilePath if exists
 */
const updateInstructionPath = (content: string): string => {
  try {
    const config = JSON.parse(content);
    if (config.output?.instructionFilePath) {
      config.output.instructionFilePath = config.output.instructionFilePath.replace('repopack', 'repomix');
    }
    // Also update output.filePath if it exists
    if (config.output?.filePath) {
      config.output.filePath = config.output.filePath.replace('repopack', 'repomix');
    }
    return JSON.stringify(config, null, 2);
  } catch {
    return content;
  }
};

/**
 * Get output file paths pairs
 */
const getOutputFilePaths = (rootDir: string): { oldPaths: string[]; newPaths: string[] } => {
  const extensions = ['.txt', '.xml', '.md'];
  const oldPaths = extensions.map((ext) => path.join(rootDir, `repopack-output${ext}`));
  const newPaths = extensions.map((ext) => path.join(rootDir, `repomix-output${ext}`));
  return { oldPaths, newPaths };
};

/**
 * Migrate a single file from old path to new path
 */
const migrateFile = async (
  oldPath: string,
  newPath: string,
  description: string,
  isConfig = false,
): Promise<boolean> => {
  if (!(await fileExists(oldPath))) {
    return false;
  }

  const exists = await fileExists(newPath);
  if (exists) {
    const shouldOverwrite = await prompts.confirm({
      message: `${description} already exists at ${newPath}. Do you want to overwrite it?`,
    });

    if (prompts.isCancel(shouldOverwrite) || !shouldOverwrite) {
      logger.info(`Skipping migration of ${description}`);
      return false;
    }
  }

  try {
    // Read and update content
    let content = await fs.readFile(oldPath, 'utf8');
    content = replaceRepopackString(content);

    // For config files, also update instructionFilePath and output.filePath
    if (isConfig) {
      content = updateInstructionPath(content);
    }

    // Ensure the target directory exists
    await fs.mkdir(path.dirname(newPath), { recursive: true });

    // Write to new file
    await fs.writeFile(newPath, content, 'utf8');

    // Remove old file
    await fs.unlink(oldPath);

    const relativeOldPath = path.relative(process.cwd(), oldPath);
    const relativeNewPath = path.relative(process.cwd(), newPath);

    logger.log(`Renamed ${description} from ${relativeOldPath} to ${relativeNewPath}`);
    return true;
  } catch (error) {
    logger.error(`Failed to migrate ${description}:`, error);
    return false;
  }
};

/**
 * Update content of gitignore and repomixignore files
 */
const updateIgnoreFiles = async (rootDir: string): Promise<void> => {
  const gitignorePath = path.join(rootDir, '.gitignore');
  const repomixignorePath = path.join(rootDir, '.repomixignore');

  if (await fileExists(gitignorePath)) {
    const updated = await updateFileContent(gitignorePath);
    if (!updated) {
      logger.debug('No changes needed in .gitignore');
    }
  }

  if (await fileExists(repomixignorePath)) {
    const updated = await updateFileContent(repomixignorePath);
    if (!updated) {
      logger.debug('No changes needed in .repomixignore');
    }
  }
};

/**
 * Get all migration related file paths
 */
const getMigrationPaths = (rootDir: string): MigrationPaths => {
  const { oldPaths: oldOutputPaths, newPaths: newOutputPaths } = getOutputFilePaths(rootDir);
  const oldGlobalDirectory = path.join(process.env.HOME || '', '.config', 'repopack');
  const newGlobalDirectory = getGlobalDirectory();

  return {
    oldConfigPath: path.join(rootDir, 'repopack.config.json'),
    newConfigPath: path.join(rootDir, 'repomix.config.json'),
    oldIgnorePath: path.join(rootDir, '.repopackignore'),
    newIgnorePath: path.join(rootDir, '.repomixignore'),
    oldInstructionPath: path.join(rootDir, 'repopack-instruction.md'),
    newInstructionPath: path.join(rootDir, 'repomix-instruction.md'),
    oldOutputPaths,
    newOutputPaths,
    oldGlobalConfigPath: path.join(oldGlobalDirectory, 'repopack.config.json'),
    newGlobalConfigPath: path.join(newGlobalDirectory, 'repomix.config.json'),
  };
};

/**
 * Migrate output files
 */
const migrateOutputFiles = async (oldPaths: string[], newPaths: string[]): Promise<string[]> => {
  const migratedFiles: string[] = [];

  for (let i = 0; i < oldPaths.length; i++) {
    const oldPath = oldPaths[i];
    const newPath = newPaths[i];
    const ext = path.extname(oldPath);

    if (await migrateFile(oldPath, newPath, `Output file (${ext})`)) {
      migratedFiles.push(newPath);
    }
  }

  return migratedFiles;
};

export const runMigrationAction = async (rootDir: string): Promise<MigrationResult> => {
  const result: MigrationResult = {
    configMigrated: false,
    ignoreMigrated: false,
    instructionMigrated: false,
    outputFilesMigrated: [],
    globalConfigMigrated: false,
  };

  try {
    const paths = getMigrationPaths(rootDir);

    // Check if migration is needed
    const hasOldConfig = await fileExists(paths.oldConfigPath);
    const hasOldIgnore = await fileExists(paths.oldIgnorePath);
    const hasOldInstruction = await fileExists(paths.oldInstructionPath);
    const hasOldGlobalConfig = await fileExists(paths.oldGlobalConfigPath);
    const hasOldOutput = await Promise.all(paths.oldOutputPaths.map(fileExists)).then((results) =>
      results.some((exists) => exists),
    );

    if (!hasOldConfig && !hasOldIgnore && !hasOldInstruction && !hasOldOutput && !hasOldGlobalConfig) {
      logger.debug('No Repopack files found to migrate.');
      return result;
    }

    // Show migration notice based on what needs to be migrated
    let migrationMessage = `Found ${pc.green('Repopack')} `;
    const items = [];
    if (hasOldConfig || hasOldIgnore || hasOldInstruction || hasOldOutput) items.push('local configuration');
    if (hasOldGlobalConfig) items.push('global configuration');
    migrationMessage += `${items.join(' and ')}. Would you like to migrate to ${pc.green('Repomix')}?`;

    // Confirm migration with user
    const shouldMigrate = await prompts.confirm({
      message: migrationMessage,
    });

    if (prompts.isCancel(shouldMigrate) || !shouldMigrate) {
      logger.info('Migration cancelled.');
      return result;
    }

    // Show migration notice
    logger.info(pc.cyan('\nMigrating from Repopack to Repomix...'));
    logger.log('');

    // Migrate config file
    if (hasOldConfig) {
      result.configMigrated = await migrateFile(paths.oldConfigPath, paths.newConfigPath, 'Configuration file', true);
    }

    // Migrate global config file
    if (hasOldGlobalConfig) {
      result.globalConfigMigrated = await migrateFile(
        paths.oldGlobalConfigPath,
        paths.newGlobalConfigPath,
        'Global configuration file',
        true,
      );
    }

    // Migrate ignore file
    if (hasOldIgnore) {
      result.ignoreMigrated = await migrateFile(paths.oldIgnorePath, paths.newIgnorePath, 'Ignore file');
    }

    // Migrate instruction file
    if (hasOldInstruction) {
      result.instructionMigrated = await migrateFile(
        paths.oldInstructionPath,
        paths.newInstructionPath,
        'Instruction file',
      );
    }

    // Migrate output files
    if (hasOldOutput) {
      result.outputFilesMigrated = await migrateOutputFiles(paths.oldOutputPaths, paths.newOutputPaths);
    }

    // Update content in gitignore and repomixignore
    await updateIgnoreFiles(rootDir);

    // Show success message
    if (
      result.configMigrated ||
      result.ignoreMigrated ||
      result.instructionMigrated ||
      result.outputFilesMigrated.length > 0 ||
      result.globalConfigMigrated
    ) {
      logger.log('');
      logger.success('✔ Migration completed successfully!');
      logger.log('');
      logger.info(
        'You can now use Repomix commands as usual. The old Repopack files have been migrated to the new format.',
      );
      logger.log('');
    }

    return result;
  } catch (error) {
    if (error instanceof Error) {
      result.error = error;
    } else {
      result.error = new Error(String(error));
    }
    logger.error('An error occurred during migration:', error);
    return result;
  }
};
</file>

<file path="src/cli/actions/remoteAction.ts">
import * as fs from 'node:fs/promises';
import os from 'node:os';
import path from 'node:path';
import pc from 'picocolors';
import { execGitShallowClone } from '../../core/git/gitCommand.js';
import { downloadGitHubArchive, isArchiveDownloadSupported } from '../../core/git/gitHubArchive.js';
import { getRemoteRefs } from '../../core/git/gitRemoteHandle.js';
import { isGitHubRepository, parseGitHubRepoInfo, parseRemoteValue } from '../../core/git/gitRemoteParse.js';
import { isGitInstalled } from '../../core/git/gitRepositoryHandle.js';
import { RepomixError } from '../../shared/errorHandle.js';
import { logger } from '../../shared/logger.js';
import { Spinner } from '../cliSpinner.js';
import type { CliOptions } from '../types.js';
import { type DefaultActionRunnerResult, runDefaultAction } from './defaultAction.js';

export const runRemoteAction = async (
  repoUrl: string,
  cliOptions: CliOptions,
  deps = {
    isGitInstalled,
    execGitShallowClone,
    getRemoteRefs,
    runDefaultAction,
    downloadGitHubArchive,
    isGitHubRepository,
    parseGitHubRepoInfo,
    isArchiveDownloadSupported,
  },
): Promise<DefaultActionRunnerResult> => {
  let tempDirPath = await createTempDirectory();
  let result: DefaultActionRunnerResult;
  let downloadMethod: 'archive' | 'git' = 'git';

  try {
    // Check if this is a GitHub repository and archive download is supported
    const githubRepoInfo = deps.parseGitHubRepoInfo(repoUrl);
    const shouldTryArchive = githubRepoInfo && deps.isArchiveDownloadSupported(githubRepoInfo);

    if (shouldTryArchive) {
      // Try GitHub archive download first
      const spinner = new Spinner('Downloading repository archive...', cliOptions);

      try {
        spinner.start();

        // Override ref with CLI option if provided
        const repoInfoWithBranch = {
          ...githubRepoInfo,
          ref: cliOptions.remoteBranch ?? githubRepoInfo.ref,
        };

        await deps.downloadGitHubArchive(
          repoInfoWithBranch,
          tempDirPath,
          {
            timeout: 60000, // 1 minute timeout for large repos
            retries: 2,
          },
          (progress) => {
            if (progress.percentage !== null) {
              spinner.update(`Downloading repository archive... (${progress.percentage}%)`);
            } else {
              // Show downloaded bytes when percentage is not available
              const downloadedMB = (progress.downloaded / 1024 / 1024).toFixed(1);
              spinner.update(`Downloading repository archive... (${downloadedMB} MB)`);
            }
          },
        );

        downloadMethod = 'archive';
        spinner.succeed('Repository archive downloaded successfully!');
        logger.log('');
      } catch (archiveError) {
        spinner.fail('Archive download failed, trying git clone...');
        logger.trace('Archive download error:', (archiveError as Error).message);

        // Clear the temp directory for git clone attempt
        await cleanupTempDirectory(tempDirPath);
        tempDirPath = await createTempDirectory();

        // Fall back to git clone
        await performGitClone(repoUrl, tempDirPath, cliOptions, deps);
        downloadMethod = 'git';
      }
    } else {
      // Use git clone directly
      await performGitClone(repoUrl, tempDirPath, cliOptions, deps);
      downloadMethod = 'git';
    }

    // Run the default action on the downloaded/cloned repository
    result = await deps.runDefaultAction([tempDirPath], tempDirPath, cliOptions);
    await copyOutputToCurrentDirectory(tempDirPath, process.cwd(), result.config.output.filePath);

    logger.trace(`Repository obtained via ${downloadMethod} method`);
  } finally {
    // Cleanup the temporary directory
    await cleanupTempDirectory(tempDirPath);
  }

  return result;
};

/**
 * Performs git clone operation with spinner and error handling
 */
const performGitClone = async (
  repoUrl: string,
  tempDirPath: string,
  cliOptions: CliOptions,
  deps: {
    isGitInstalled: typeof isGitInstalled;
    getRemoteRefs: typeof getRemoteRefs;
    execGitShallowClone: typeof execGitShallowClone;
  },
): Promise<void> => {
  // Check if git is installed only when we actually need to use git
  if (!(await deps.isGitInstalled())) {
    throw new RepomixError('Git is not installed or not in the system PATH.');
  }
  // Get remote refs
  let refs: string[] = [];
  try {
    refs = await deps.getRemoteRefs(parseRemoteValue(repoUrl).repoUrl);
    logger.trace(`Retrieved ${refs.length} refs from remote repository`);
  } catch (error) {
    logger.trace('Failed to get remote refs, proceeding without them:', (error as Error).message);
  }

  // Parse the remote URL with the refs information
  const parsedFields = parseRemoteValue(repoUrl, refs);

  const spinner = new Spinner('Cloning repository...', cliOptions);

  try {
    spinner.start();

    // Clone the repository
    await cloneRepository(parsedFields.repoUrl, tempDirPath, cliOptions.remoteBranch || parsedFields.remoteBranch, {
      execGitShallowClone: deps.execGitShallowClone,
    });

    spinner.succeed('Repository cloned successfully!');
    logger.log('');
  } catch (error) {
    spinner.fail('Error during repository cloning. cleanup...');
    throw error;
  }
};

export const createTempDirectory = async (): Promise<string> => {
  const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'repomix-'));
  logger.trace(`Created temporary directory. (path: ${pc.dim(tempDir)})`);
  return tempDir;
};

export const cloneRepository = async (
  url: string,
  directory: string,
  remoteBranch?: string,
  deps = {
    execGitShallowClone,
  },
): Promise<void> => {
  logger.log(`Clone repository: ${url} to temporary directory. ${pc.dim(`path: ${directory}`)}`);
  logger.log('');

  try {
    await deps.execGitShallowClone(url, directory, remoteBranch);
  } catch (error) {
    throw new RepomixError(`Failed to clone repository: ${(error as Error).message}`);
  }
};

export const cleanupTempDirectory = async (directory: string): Promise<void> => {
  logger.trace(`Cleaning up temporary directory: ${directory}`);
  await fs.rm(directory, { recursive: true, force: true });
};

export const copyOutputToCurrentDirectory = async (
  sourceDir: string,
  targetDir: string,
  outputFileName: string,
): Promise<void> => {
  const sourcePath = path.resolve(sourceDir, outputFileName);
  const targetPath = path.resolve(targetDir, outputFileName);

  try {
    logger.trace(`Copying output file from: ${sourcePath} to: ${targetPath}`);

    // Create target directory if it doesn't exist
    await fs.mkdir(path.dirname(targetPath), { recursive: true });

    await fs.copyFile(sourcePath, targetPath);
  } catch (error) {
    throw new RepomixError(`Failed to copy output file: ${(error as Error).message}`);
  }
};
</file>

<file path="src/cli/actions/versionAction.ts">
import { getVersion } from '../../core/file/packageJsonParse.js';
import { logger } from '../../shared/logger.js';

export const runVersionAction = async (): Promise<void> => {
  const version = await getVersion();
  logger.log(version);
};
</file>

<file path="src/cli/cliPrint.ts">
import path from 'node:path';
import pc from 'picocolors';
import type { RepomixConfigMerged } from '../config/configSchema.js';
import type { PackResult } from '../core/packager.js';
import type { SuspiciousFileResult } from '../core/security/securityCheck.js';
import { logger } from '../shared/logger.js';

export const printSummary = (packResult: PackResult, config: RepomixConfigMerged) => {
  let securityCheckMessage = '';
  if (config.security.enableSecurityCheck) {
    if (packResult.suspiciousFilesResults.length > 0) {
      securityCheckMessage = pc.yellow(
        `${packResult.suspiciousFilesResults.length.toLocaleString()} suspicious file(s) detected and excluded`,
      );
    } else {
      securityCheckMessage = pc.white('✔ No suspicious files detected');
    }
  } else {
    securityCheckMessage = pc.dim('Security check disabled');
  }

  logger.log(pc.white('📊 Pack Summary:'));
  logger.log(pc.dim('────────────────'));
  logger.log(`${pc.white('  Total Files:')} ${pc.white(packResult.totalFiles.toLocaleString())} files`);
  logger.log(`${pc.white(' Total Tokens:')} ${pc.white(packResult.totalTokens.toLocaleString())} tokens`);
  logger.log(`${pc.white('  Total Chars:')} ${pc.white(packResult.totalCharacters.toLocaleString())} chars`);
  logger.log(`${pc.white('       Output:')} ${pc.white(config.output.filePath)}`);
  logger.log(`${pc.white('     Security:')} ${pc.white(securityCheckMessage)}`);

  if (config.output.git?.includeDiffs) {
    let gitDiffsMessage = '';
    if (packResult.gitDiffTokenCount) {
      gitDiffsMessage = pc.white(
        `✔ Git diffs included ${pc.dim(`(${packResult.gitDiffTokenCount.toLocaleString()} tokens)`)}`,
      );
    } else {
      gitDiffsMessage = pc.dim('✖ No git diffs included');
    }
    logger.log(`${pc.white('    Git Diffs:')} ${gitDiffsMessage}`);
  }
};

export const printSecurityCheck = (
  rootDir: string,
  suspiciousFilesResults: SuspiciousFileResult[],
  suspiciousGitDiffResults: SuspiciousFileResult[],
  config: RepomixConfigMerged,
) => {
  if (!config.security.enableSecurityCheck) {
    return;
  }

  logger.log(pc.white('🔎 Security Check:'));
  logger.log(pc.dim('──────────────────'));

  // Print results for files
  if (suspiciousFilesResults.length === 0) {
    logger.log(`${pc.green('✔')} ${pc.white('No suspicious files detected.')}`);
  } else {
    logger.log(pc.yellow(`${suspiciousFilesResults.length} suspicious file(s) detected and excluded from the output:`));
    suspiciousFilesResults.forEach((suspiciousFilesResult, index) => {
      const relativeFilePath = path.relative(rootDir, suspiciousFilesResult.filePath);
      logger.log(`${pc.white(`${index + 1}.`)} ${pc.white(relativeFilePath)}`);
      logger.log(pc.dim(`   - ${suspiciousFilesResult.messages.join('\n   - ')}`));
    });
    logger.log(pc.yellow('\nThese files have been excluded from the output for security reasons.'));
    logger.log(pc.yellow('Please review these files for potential sensitive information.'));
  }

  // Print results for git diffs
  if (suspiciousGitDiffResults.length > 0) {
    logger.log('');
    logger.log(pc.yellow(`${suspiciousGitDiffResults.length} security issue(s) found in Git diffs:`));
    suspiciousGitDiffResults.forEach((suspiciousResult, index) => {
      logger.log(`${pc.white(`${index + 1}.`)} ${pc.white(suspiciousResult.filePath)}`);
      logger.log(pc.dim(`   - ${suspiciousResult.messages.join('\n   - ')}`));
    });
    logger.log(pc.yellow('\nNote: Git diffs with security issues are still included in the output.'));
    logger.log(pc.yellow('Please review the diffs before sharing the output.'));
  }
};

export const printTopFiles = (
  fileCharCounts: Record<string, number>,
  fileTokenCounts: Record<string, number>,
  topFilesLength: number,
  totalTokens: number,
) => {
  const topFilesLengthStrLen = topFilesLength.toString().length;
  logger.log(pc.white(`📈 Top ${topFilesLength} Files by Token Count:`));
  logger.log(pc.dim(`─────────────────────────────────────────────────${'─'.repeat(topFilesLengthStrLen)}`));

  // Filter files that have token counts (top candidates by char count)
  const filesWithTokenCounts = Object.entries(fileTokenCounts)
    .filter(([, tokenCount]) => tokenCount > 0)
    .sort((a, b) => b[1] - a[1])
    .slice(0, topFilesLength);

  // Use the actual total tokens from the entire output

  filesWithTokenCounts.forEach(([filePath, tokenCount], index) => {
    const charCount = fileCharCounts[filePath];
    const percentageOfTotal = totalTokens > 0 ? Number(((tokenCount / totalTokens) * 100).toFixed(1)) : 0;
    const indexString = `${index + 1}.`.padEnd(3, ' ');
    logger.log(
      `${pc.white(`${indexString}`)} ${pc.white(filePath)} ${pc.dim(`(${tokenCount.toLocaleString()} tokens, ${charCount.toLocaleString()} chars, ${percentageOfTotal}%)`)}`,
    );
  });
};

export const printCompletion = () => {
  logger.log(pc.green('🎉 All Done!'));
  logger.log(pc.white('Your repository has been successfully packed.'));

  logger.log('');
  logger.log(`💡 Repomix is now available in your browser! Try it at ${pc.underline('https://repomix.com')}`);
};
</file>

<file path="src/cli/cliRun.ts">
import process from 'node:process';
import { Command, Option, program } from 'commander';
import pc from 'picocolors';
import { getVersion } from '../core/file/packageJsonParse.js';
import { handleError } from '../shared/errorHandle.js';
import { logger, repomixLogLevels } from '../shared/logger.js';
import { runDefaultAction } from './actions/defaultAction.js';
import { runInitAction } from './actions/initAction.js';
import { runMcpAction } from './actions/mcpAction.js';
import { runRemoteAction } from './actions/remoteAction.js';
import { runVersionAction } from './actions/versionAction.js';
import type { CliOptions } from './types.js';

// Semantic mapping for CLI suggestions
// This maps conceptually related terms (not typos) to valid options
const semanticSuggestionMap: Record<string, string[]> = {
  exclude: ['--ignore'],
  reject: ['--ignore'],
  omit: ['--ignore'],
  skip: ['--ignore'],
  blacklist: ['--ignore'],
  save: ['--output'],
  export: ['--output'],
  out: ['--output'],
  file: ['--output'],
  format: ['--style'],
  type: ['--style'],
  syntax: ['--style'],
  debug: ['--verbose'],
  detailed: ['--verbose'],
  silent: ['--quiet'],
  mute: ['--quiet'],
  add: ['--include'],
  with: ['--include'],
  whitelist: ['--include'],
  clone: ['--remote'],
  git: ['--remote'],
  minimize: ['--compress'],
  reduce: ['--compress'],
  'strip-comments': ['--remove-comments'],
  'no-comments': ['--remove-comments'],
  print: ['--stdout'],
  console: ['--stdout'],
  terminal: ['--stdout'],
  pipe: ['--stdin'],
};

export const run = async () => {
  try {
    program
      .description('Repomix - Pack your repository into a single AI-friendly file')
      .argument('[directories...]', 'list of directories to process', ['.'])
      // Basic Options
      .optionsGroup('Basic Options')
      .option('-v, --version', 'show version information')
      // Output Options
      .optionsGroup('Output Options')
      .option('-o, --output <file>', 'specify the output file name')
      .addOption(new Option('--stdout', 'output to stdout instead of writing to a file').conflicts('output'))
      .option('--style <type>', 'specify the output style (xml, markdown, plain)')
      .option('--parsable-style', 'by escaping and formatting, ensure the output is parsable as a document of its type')
      .option('--compress', 'perform code compression to reduce token count')
      .option('--output-show-line-numbers', 'add line numbers to each line in the output')
      .option('--copy', 'copy generated output to system clipboard')
      .option('--no-file-summary', 'disable file summary section output')
      .option('--no-directory-structure', 'disable directory structure section output')
      .option('--no-files', 'disable files content output (metadata-only mode)')
      .option('--remove-comments', 'remove comments')
      .option('--remove-empty-lines', 'remove empty lines')
      .option('--header-text <text>', 'specify the header text')
      .option('--instruction-file-path <path>', 'path to a file containing detailed custom instructions')
      .option('--include-empty-directories', 'include empty directories in the output')
      .option('--no-git-sort-by-changes', 'disable sorting files by git change count')
      .option(
        '--include-diffs',
        'include git diffs in the output (includes both work tree and staged changes separately)',
      )
      // Filter Options
      .optionsGroup('Filter Options')
      .option('--include <patterns>', 'list of include patterns (comma-separated)')
      .option('-i, --ignore <patterns>', 'additional ignore patterns (comma-separated)')
      .option('--no-gitignore', 'disable .gitignore file usage')
      .option('--no-default-patterns', 'disable default patterns')
      .option('--stdin', 'read file list from stdin')
      // Remote Repository Options
      .optionsGroup('Remote Repository Options')
      .option('--remote <url>', 'process a remote Git repository')
      .option(
        '--remote-branch <name>',
        'specify the remote branch name, tag, or commit hash (defaults to repository default branch)',
      )
      // Configuration Options
      .optionsGroup('Configuration Options')
      .option('-c, --config <path>', 'path to a custom config file')
      .option('--init', 'initialize a new repomix.config.json file')
      .option('--global', 'use global configuration (only applicable with --init)')
      // Security Options
      .optionsGroup('Security Options')
      .option('--no-security-check', 'disable security check')
      // Token Count Options
      .optionsGroup('Token Count Options')
      .option('--token-count-encoding <encoding>', 'specify token count encoding (e.g., o200k_base, cl100k_base)')
      // MCP
      .optionsGroup('MCP')
      .option('--mcp', 'run as a MCP server')
      // Other Options
      .optionsGroup('Other Options')
      .option('--top-files-len <number>', 'specify the number of top files to display', Number.parseInt)
      .addOption(new Option('--verbose', 'enable verbose logging for detailed output').conflicts('quiet'))
      .addOption(new Option('--quiet', 'disable all output to stdout').conflicts('verbose'))
      .action(commanderActionEndpoint);

    // Custom error handling function
    const configOutput = program.configureOutput();
    const originalOutputError = configOutput.outputError || ((str, write) => write(str));

    program.configureOutput({
      outputError: (str, write) => {
        // Check if this is an unknown option error
        if (str.includes('unknown option')) {
          const match = str.match(/unknown option '?(-{1,2}[^ ']+)'?/i);
          if (match?.[1]) {
            const unknownOption = match[1];
            const cleanOption = unknownOption.replace(/^-+/, '');

            // Check if the option has a semantic match
            const semanticMatches = semanticSuggestionMap[cleanOption];
            if (semanticMatches) {
              // We have a direct semantic match
              logger.error(`✖ Unknown option: ${unknownOption}`);
              logger.info(`Did you mean: ${semanticMatches.join(' or ')}?`);
              return;
            }
          }
        }

        // Fall back to the original Commander error handler
        originalOutputError(str, write);
      },
    });

    await program.parseAsync(process.argv);
  } catch (error) {
    handleError(error);
    process.exit(1);
  }
};

const commanderActionEndpoint = async (directories: string[], options: CliOptions = {}) => {
  await runCli(directories, process.cwd(), options);
};

export const runCli = async (directories: string[], cwd: string, options: CliOptions) => {
  // Detect stdout mode
  // NOTE: For compatibility, currently not detecting pipe mode
  const isForceStdoutMode = options.output === '-';
  if (isForceStdoutMode) {
    options.stdout = true;
  }

  // Set log level based on verbose and quiet flags
  if (options.quiet) {
    logger.setLogLevel(repomixLogLevels.SILENT);
  } else if (options.verbose) {
    logger.setLogLevel(repomixLogLevels.DEBUG);
  } else {
    logger.setLogLevel(repomixLogLevels.INFO);
  }

  // In stdout mode, set log level to SILENT
  if (options.stdout) {
    logger.setLogLevel(repomixLogLevels.SILENT);
  }

  logger.trace('directories:', directories);
  logger.trace('cwd:', cwd);
  logger.trace('options:', options);

  if (options.mcp) {
    return await runMcpAction();
  }

  if (options.version) {
    await runVersionAction();
    return;
  }

  const version = await getVersion();
  logger.log(pc.dim(`\n📦 Repomix v${version}\n`));

  if (options.init) {
    await runInitAction(cwd, options.global || false);
    return;
  }

  if (options.remote) {
    return await runRemoteAction(options.remote, options);
  }

  return await runDefaultAction(directories, cwd, options);
};
</file>

<file path="src/cli/cliSpinner.ts">
import cliSpinners from 'cli-spinners';
import logUpdate from 'log-update';
import pc from 'picocolors';
import type { CliOptions } from './types.js';

export class Spinner {
  private spinner = cliSpinners.dots;
  private message: string;
  private currentFrame = 0;
  private interval: ReturnType<typeof setInterval> | null = null;
  private readonly isQuiet: boolean;

  constructor(message: string, cliOptions: CliOptions) {
    this.message = message;
    // If the user has specified the verbose flag, don't show the spinner
    this.isQuiet = cliOptions.quiet || cliOptions.verbose || cliOptions.stdout || false;
  }

  start(): void {
    if (this.isQuiet) {
      return;
    }

    const frames = this.spinner.frames;
    const framesLength = frames.length;
    this.interval = setInterval(() => {
      this.currentFrame++;
      const frame = frames[this.currentFrame % framesLength];
      logUpdate(`${pc.cyan(frame)} ${this.message}`);
    }, this.spinner.interval);
  }

  update(message: string): void {
    if (this.isQuiet) {
      return;
    }

    this.message = message;
  }

  stop(finalMessage: string): void {
    if (this.isQuiet) {
      return;
    }

    if (this.interval) {
      clearInterval(this.interval);
      this.interval = null;
    }
    logUpdate(finalMessage);
    logUpdate.done();
  }

  succeed(message: string): void {
    if (this.isQuiet) {
      return;
    }

    this.stop(`${pc.green('✔')} ${message}`);
  }

  fail(message: string): void {
    if (this.isQuiet) {
      return;
    }

    this.stop(`${pc.red('✖')} ${message}`);
  }
}
</file>

<file path="src/cli/types.ts">
import type { OptionValues } from 'commander';
import type { RepomixOutputStyle } from '../config/configSchema.js';

export interface CliOptions extends OptionValues {
  // Basic Options
  version?: boolean;

  // Output Options
  output?: string;
  stdout?: boolean;
  style?: RepomixOutputStyle;
  parsableStyle?: boolean;
  compress?: boolean;
  outputShowLineNumbers?: boolean;
  copy?: boolean;
  fileSummary?: boolean;
  directoryStructure?: boolean;
  files?: boolean;
  removeComments?: boolean;
  removeEmptyLines?: boolean;
  headerText?: string;
  instructionFilePath?: string;
  includeEmptyDirectories?: boolean;
  gitSortByChanges?: boolean;
  includeDiffs?: boolean;

  // Filter Options
  include?: string;
  ignore?: string;
  gitignore?: boolean;
  defaultPatterns?: boolean;
  stdin?: boolean;

  // Remote Repository Options
  remote?: string;
  remoteBranch?: string;

  // Configuration Options
  config?: string;
  init?: boolean;
  global?: boolean;

  // Security Options
  securityCheck?: boolean;

  // Token Count Options
  tokenCountEncoding?: string;

  // MCP
  mcp?: boolean;

  // Other Options
  topFilesLen?: number;
  verbose?: boolean;
  quiet?: boolean;
}
</file>

<file path="src/config/configLoad.ts">
import * as fs from 'node:fs/promises';
import path from 'node:path';
import JSON5 from 'json5';
import pc from 'picocolors';
import { RepomixError, rethrowValidationErrorIfZodError } from '../shared/errorHandle.js';
import { logger } from '../shared/logger.js';
import {
  type RepomixConfigCli,
  type RepomixConfigFile,
  type RepomixConfigMerged,
  defaultConfig,
  defaultFilePathMap,
  repomixConfigFileSchema,
  repomixConfigMergedSchema,
} from './configSchema.js';
import { getGlobalDirectory } from './globalDirectory.js';

const defaultConfigPaths = ['repomix.config.json5', 'repomix.config.jsonc', 'repomix.config.json'];

const getGlobalConfigPaths = () => {
  const globalDir = getGlobalDirectory();
  return defaultConfigPaths.map((configPath) => path.join(globalDir, configPath));
};

const checkFileExists = async (filePath: string): Promise<boolean> => {
  try {
    const stats = await fs.stat(filePath);
    return stats.isFile();
  } catch {
    return false;
  }
};

const findConfigFile = async (configPaths: string[], logPrefix: string): Promise<string | null> => {
  for (const configPath of configPaths) {
    logger.trace(`Checking for ${logPrefix} config at:`, configPath);

    const fileExists = await checkFileExists(configPath);

    if (fileExists) {
      logger.trace(`Found ${logPrefix} config at:`, configPath);
      return configPath;
    }
  }
  return null;
};

export const loadFileConfig = async (rootDir: string, argConfigPath: string | null): Promise<RepomixConfigFile> => {
  if (argConfigPath) {
    // If a specific config path is provided, use it directly
    const fullPath = path.resolve(rootDir, argConfigPath);
    logger.trace('Loading local config from:', fullPath);

    const isLocalFileExists = await checkFileExists(fullPath);

    if (isLocalFileExists) {
      return await loadAndValidateConfig(fullPath);
    }
    throw new RepomixError(`Config file not found at ${argConfigPath}`);
  }

  // Try to find a local config file using the priority order
  const localConfigPaths = defaultConfigPaths.map((configPath) => path.resolve(rootDir, configPath));
  const localConfigPath = await findConfigFile(localConfigPaths, 'local');

  if (localConfigPath) {
    return await loadAndValidateConfig(localConfigPath);
  }

  // Try to find a global config file using the priority order
  const globalConfigPaths = getGlobalConfigPaths();
  const globalConfigPath = await findConfigFile(globalConfigPaths, 'global');

  if (globalConfigPath) {
    return await loadAndValidateConfig(globalConfigPath);
  }

  logger.log(
    pc.dim(
      `No custom config found at ${defaultConfigPaths.join(', ')} or global config at ${globalConfigPaths.join(', ')}.\nYou can add a config file for additional settings. Please check https://github.com/yamadashy/repomix for more information.`,
    ),
  );
  return {};
};

const loadAndValidateConfig = async (filePath: string): Promise<RepomixConfigFile> => {
  try {
    const fileContent = await fs.readFile(filePath, 'utf-8');
    const config = JSON5.parse(fileContent);
    return repomixConfigFileSchema.parse(config);
  } catch (error) {
    rethrowValidationErrorIfZodError(error, 'Invalid config schema');
    if (error instanceof SyntaxError) {
      throw new RepomixError(`Invalid JSON5 in config file ${filePath}: ${error.message}`);
    }
    if (error instanceof Error) {
      throw new RepomixError(`Error loading config from ${filePath}: ${error.message}`);
    }
    throw new RepomixError(`Error loading config from ${filePath}`);
  }
};

export const mergeConfigs = (
  cwd: string,
  fileConfig: RepomixConfigFile,
  cliConfig: RepomixConfigCli,
): RepomixConfigMerged => {
  logger.trace('Default config:', defaultConfig);

  const baseConfig = defaultConfig;

  // If the output file path is not provided in the config file or CLI, use the default file path for the style
  if (cliConfig.output?.filePath == null && fileConfig.output?.filePath == null) {
    const style = cliConfig.output?.style || fileConfig.output?.style || baseConfig.output.style;
    baseConfig.output.filePath = defaultFilePathMap[style];

    logger.trace('Default output file path is set to:', baseConfig.output.filePath);
  }

  const mergedConfig = {
    cwd,
    input: {
      ...baseConfig.input,
      ...fileConfig.input,
      ...cliConfig.input,
    },
    output: {
      ...baseConfig.output,
      ...fileConfig.output,
      ...cliConfig.output,
    },
    include: [...(baseConfig.include || []), ...(fileConfig.include || []), ...(cliConfig.include || [])],
    ignore: {
      ...baseConfig.ignore,
      ...fileConfig.ignore,
      ...cliConfig.ignore,
      customPatterns: [
        ...(baseConfig.ignore.customPatterns || []),
        ...(fileConfig.ignore?.customPatterns || []),
        ...(cliConfig.ignore?.customPatterns || []),
      ],
    },
    security: {
      ...baseConfig.security,
      ...fileConfig.security,
      ...cliConfig.security,
    },
  };

  try {
    return repomixConfigMergedSchema.parse(mergedConfig);
  } catch (error) {
    rethrowValidationErrorIfZodError(error, 'Invalid merged config');
    throw error;
  }
};
</file>

<file path="src/config/configSchema.ts">
import type { TiktokenEncoding } from 'tiktoken';
import { z } from 'zod';

// Output style enum
export const repomixOutputStyleSchema = z.enum(['xml', 'markdown', 'plain']);
export type RepomixOutputStyle = z.infer<typeof repomixOutputStyleSchema>;

// Default values map
export const defaultFilePathMap: Record<RepomixOutputStyle, string> = {
  xml: 'repomix-output.xml',
  markdown: 'repomix-output.md',
  plain: 'repomix-output.txt',
} as const;

// Base config schema
export const repomixConfigBaseSchema = z.object({
  $schema: z.string().optional(),
  input: z
    .object({
      maxFileSize: z.number().optional(),
    })
    .optional(),
  output: z
    .object({
      filePath: z.string().optional(),
      style: repomixOutputStyleSchema.optional(),
      parsableStyle: z.boolean().optional(),
      headerText: z.string().optional(),
      instructionFilePath: z.string().optional(),
      fileSummary: z.boolean().optional(),
      directoryStructure: z.boolean().optional(),
      files: z.boolean().optional(),
      removeComments: z.boolean().optional(),
      removeEmptyLines: z.boolean().optional(),
      compress: z.boolean().optional(),
      topFilesLength: z.number().optional(),
      showLineNumbers: z.boolean().optional(),
      copyToClipboard: z.boolean().optional(),
      includeEmptyDirectories: z.boolean().optional(),
      git: z
        .object({
          sortByChanges: z.boolean().optional(),
          sortByChangesMaxCommits: z.number().optional(),
          includeDiffs: z.boolean().optional(),
        })
        .optional(),
    })
    .optional(),
  include: z.array(z.string()).optional(),
  ignore: z
    .object({
      useGitignore: z.boolean().optional(),
      useDefaultPatterns: z.boolean().optional(),
      customPatterns: z.array(z.string()).optional(),
    })
    .optional(),
  security: z
    .object({
      enableSecurityCheck: z.boolean().optional(),
    })
    .optional(),
  tokenCount: z
    .object({
      encoding: z.string().optional(),
    })
    .optional(),
});

// Default config schema with default values
export const repomixConfigDefaultSchema = z.object({
  input: z
    .object({
      maxFileSize: z
        .number()
        .int()
        .min(1)
        .default(50 * 1024 * 1024), // Default: 50MB
    })
    .default({}),
  output: z
    .object({
      filePath: z.string().default(defaultFilePathMap.xml),
      style: repomixOutputStyleSchema.default('xml'),
      parsableStyle: z.boolean().default(false),
      headerText: z.string().optional(),
      instructionFilePath: z.string().optional(),
      fileSummary: z.boolean().default(true),
      directoryStructure: z.boolean().default(true),
      files: z.boolean().default(true),
      removeComments: z.boolean().default(false),
      removeEmptyLines: z.boolean().default(false),
      compress: z.boolean().default(false),
      topFilesLength: z.number().int().min(0).default(5),
      showLineNumbers: z.boolean().default(false),
      copyToClipboard: z.boolean().default(false),
      includeEmptyDirectories: z.boolean().optional(),
      git: z
        .object({
          sortByChanges: z.boolean().default(true),
          sortByChangesMaxCommits: z.number().int().min(1).default(100),
          includeDiffs: z.boolean().default(false),
        })
        .default({}),
    })
    .default({}),
  include: z.array(z.string()).default([]),
  ignore: z
    .object({
      useGitignore: z.boolean().default(true),
      useDefaultPatterns: z.boolean().default(true),
      customPatterns: z.array(z.string()).default([]),
    })
    .default({}),
  security: z
    .object({
      enableSecurityCheck: z.boolean().default(true),
    })
    .default({}),
  tokenCount: z
    .object({
      encoding: z
        .string()
        .default('o200k_base')
        .transform((val) => val as TiktokenEncoding),
    })
    .default({}),
});

// File-specific schema. Add options for file path and style
export const repomixConfigFileSchema = repomixConfigBaseSchema;

// CLI-specific schema. Add options for standard output mode
export const repomixConfigCliSchema = repomixConfigBaseSchema.and(
  z.object({
    output: z
      .object({
        stdout: z.boolean().optional(),
      })
      .optional(),
  }),
);

// Merged schema for all configurations
export const repomixConfigMergedSchema = repomixConfigDefaultSchema
  .and(repomixConfigFileSchema)
  .and(repomixConfigCliSchema)
  .and(
    z.object({
      cwd: z.string(),
    }),
  );

export type RepomixConfigDefault = z.infer<typeof repomixConfigDefaultSchema>;
export type RepomixConfigFile = z.infer<typeof repomixConfigFileSchema>;
export type RepomixConfigCli = z.infer<typeof repomixConfigCliSchema>;
export type RepomixConfigMerged = z.infer<typeof repomixConfigMergedSchema>;

export const defaultConfig = repomixConfigDefaultSchema.parse({});
</file>

<file path="src/config/defaultIgnore.ts">
export const defaultIgnoreList = [
  // Version control
  '.git/**',
  '.hg/**',
  '.hgignore',
  '.svn/**',

  // Dependency directories
  '**/node_modules/**',
  '**/bower_components/**',
  '**/jspm_packages/**',
  'vendor/**',
  '**/.bundle/**',
  '**/.gradle/**',
  'target/**',

  // Logs
  'logs/**',
  '**/*.log',
  '**/npm-debug.log*',
  '**/yarn-debug.log*',
  '**/yarn-error.log*',

  // Runtime data
  'pids/**',
  '*.pid',
  '*.seed',
  '*.pid.lock',

  // Directory for instrumented libs generated by jscoverage/JSCover
  'lib-cov/**',

  // Coverage directory used by tools like istanbul
  'coverage/**',

  // nyc test coverage
  '.nyc_output/**',

  // Grunt intermediate storage
  '.grunt/**',

  // node-waf configuration
  '.lock-wscript',

  // Compiled binary addons
  'build/Release/**',

  // TypeScript v1 declaration files
  'typings/**',

  // Optional npm cache directory
  '**/.npm/**',

  // Cache directories
  '.eslintcache',
  '.rollup.cache/**',
  '.webpack.cache/**',
  '.parcel-cache/**',
  '.sass-cache/**',
  '*.cache',

  // Optional REPL history
  '.node_repl_history',

  // Output of 'npm pack'
  '*.tgz',

  // Yarn files
  '**/.yarn/**',

  // Yarn Integrity file
  '**/.yarn-integrity',

  // dotenv environment variables file
  '.env',

  // next.js build output
  '.next/**',

  // nuxt.js build output
  '.nuxt/**',

  // vuepress build output
  '.vuepress/dist/**',

  // Serverless directories
  '.serverless/**',

  // FuseBox cache
  '.fusebox/**',

  // DynamoDB Local files
  '.dynamodb/**',

  // TypeScript output
  'dist/**',

  // OS generated files
  '**/.DS_Store',
  '**/Thumbs.db',

  // Editor directories and files
  '.idea/**',
  '.vscode/**',
  '**/*.swp',
  '**/*.swo',
  '**/*.swn',
  '**/*.bak',

  // Build outputs
  'build/**',
  'out/**',

  // Temporary files
  'tmp/**',
  'temp/**',

  // repomix output
  '**/repomix-output.*',
  '**/repopack-output.*', // Legacy

  // Essential Node.js-related entries
  '**/package-lock.json',
  '**/yarn-error.log',
  '**/yarn.lock',
  '**/pnpm-lock.yaml',
  '**/bun.lockb',
  '**/bun.lock',

  // Essential Python-related entries
  '**/__pycache__/**',
  '**/*.py[cod]',
  '**/venv/**',
  '**/.venv/**',
  '**/.pytest_cache/**',
  '**/.mypy_cache/**',
  '**/.ipynb_checkpoints/**',
  '**/Pipfile.lock',
  '**/poetry.lock',
  '**/uv.lock',

  // Essential Rust-related entries
  '**/Cargo.lock',
  '**/Cargo.toml.orig',
  '**/target/**',
  '**/*.rs.bk',

  // Essential PHP-related entries
  '**/composer.lock',

  // Essential Ruby-related entries
  '**/Gemfile.lock',

  // Essential Go-related entries
  '**/go.sum',

  // Essential Elixir-related entries
  '**/mix.lock',

  // Essential Haskell-related entries
  '**/stack.yaml.lock',
  '**/cabal.project.freeze',
];
</file>

<file path="src/config/globalDirectory.ts">
import os from 'node:os';
import path from 'node:path';

export const getGlobalDirectory = () => {
  if (process.platform === 'win32') {
    const localAppData = process.env.LOCALAPPDATA || path.join(os.homedir(), 'AppData', 'Local');
    return path.join(localAppData, 'Repomix');
  }

  if (process.env.XDG_CONFIG_HOME) {
    return path.join(process.env.XDG_CONFIG_HOME, 'repomix');
  }

  return path.join(os.homedir(), '.config', 'repomix');
};
</file>

<file path="src/core/file/workers/fileCollectWorker.ts">
import path from 'node:path';
import { logger, setLogLevelByEnv } from '../../../shared/logger.js';
import { readRawFile } from '../fileRead.js';

export interface FileCollectTask {
  filePath: string;
  rootDir: string;
  maxFileSize: number;
}

// Set logger log level from environment variable if provided
setLogLevelByEnv();

export default async ({ filePath, rootDir, maxFileSize }: FileCollectTask) => {
  const fullPath = path.resolve(rootDir, filePath);
  const content = await readRawFile(fullPath, maxFileSize);

  if (content) {
    return {
      path: filePath,
      content,
    };
  }

  return null;
};
</file>

<file path="src/core/file/workers/fileProcessWorker.ts">
import type { RepomixConfigMerged } from '../../../config/configSchema.js';
import { logger, setLogLevelByEnv } from '../../../shared/logger.js';
import { processContent } from '../fileProcessContent.js';
import type { ProcessedFile, RawFile } from '../fileTypes.js';

export interface FileProcessTask {
  rawFile: RawFile;
  config: RepomixConfigMerged;
}

// Set logger log level from environment variable if provided
setLogLevelByEnv();

export default async ({ rawFile, config }: FileProcessTask): Promise<ProcessedFile> => {
  const processedContent = await processContent(rawFile, config);
  return {
    path: rawFile.path,
    content: processedContent,
  };
};
</file>

<file path="src/core/file/fileCollect.ts">
import pc from 'picocolors';
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import { logger } from '../../shared/logger.js';
import { initPiscina } from '../../shared/processConcurrency.js';
import type { RepomixProgressCallback } from '../../shared/types.js';
import type { RawFile } from './fileTypes.js';
import type { FileCollectTask } from './workers/fileCollectWorker.js';

const initTaskRunner = (numOfTasks: number) => {
  const pool = initPiscina(numOfTasks, new URL('./workers/fileCollectWorker.js', import.meta.url).href);
  return (task: FileCollectTask) => pool.run(task);
};

export const collectFiles = async (
  filePaths: string[],
  rootDir: string,
  config: RepomixConfigMerged,
  progressCallback: RepomixProgressCallback = () => {},
  deps = {
    initTaskRunner,
  },
): Promise<RawFile[]> => {
  const runTask = deps.initTaskRunner(filePaths.length);
  const tasks = filePaths.map(
    (filePath) =>
      ({
        filePath,
        rootDir,
        maxFileSize: config.input.maxFileSize,
      }) satisfies FileCollectTask,
  );

  try {
    const startTime = process.hrtime.bigint();
    logger.trace(`Starting file collection for ${filePaths.length} files using worker pool`);

    let completedTasks = 0;
    const totalTasks = tasks.length;

    const results = await Promise.all(
      tasks.map((task) =>
        runTask(task).then((result) => {
          completedTasks++;
          progressCallback(`Collect file... (${completedTasks}/${totalTasks}) ${pc.dim(task.filePath)}`);
          logger.trace(`Collect files... (${completedTasks}/${totalTasks}) ${task.filePath}`);
          return result;
        }),
      ),
    );

    const endTime = process.hrtime.bigint();
    const duration = Number(endTime - startTime) / 1e6;
    logger.trace(`File collection completed in ${duration.toFixed(2)}ms`);

    return results.filter((file): file is RawFile => file !== null);
  } catch (error) {
    logger.error('Error during file collection:', error);
    throw error;
  }
};
</file>

<file path="src/core/file/fileManipulate.ts">
import path from 'node:path';
import strip from 'strip-comments';

export interface FileManipulator {
  removeComments(content: string): string;
  removeEmptyLines(content: string): string;
}

const rtrimLines = (content: string): string =>
  content
    .split('\n')
    .map((line) => line.trimEnd())
    .join('\n');

class BaseManipulator implements FileManipulator {
  removeComments(content: string): string {
    return content;
  }

  removeEmptyLines(content: string): string {
    return content
      .split('\n')
      .filter((line) => line.trim() !== '')
      .join('\n');
  }
}

class StripCommentsManipulator extends BaseManipulator {
  private language: string;

  constructor(language: string) {
    super();
    this.language = language;
  }

  removeComments(content: string): string {
    const result = strip(content, {
      language: this.language,
      preserveNewlines: true,
    });
    return rtrimLines(result);
  }
}

class CppManipulator extends BaseManipulator {
  removeComments(content: string): string {
    let result = strip(content, {
      language: 'c',
      preserveNewlines: true,
    });

    result = result
      .split('\n')
      .map((line) => {
        const tripleSlashIndex = line.indexOf('///');
        if (tripleSlashIndex !== -1) {
          return line.substring(0, tripleSlashIndex).trimEnd();
        }
        return line;
      })
      .join('\n');

    return rtrimLines(result);
  }
}

class PythonManipulator extends BaseManipulator {
  removeDocStrings(content: string): string {
    if (!content) return '';
    const lines = content.split('\n');

    let result = '';

    let buffer = '';
    let quoteType: '' | "'" | '"' = '';
    let tripleQuotes = 0;

    const doubleQuoteRegex = /^\s*(?<!\\)(?:""")\s*(?:\n)?[\s\S]*?(?<!("""))(?<!\\)(?:""")/gm;
    const singleQuoteRegex = /^\s*(?<!\\)(?:''')\s*(?:\n)?[\s\S]*?(?<!('''))(?<!\\)(?:''')/gm;

    const sz = lines.length;
    for (let i = 0; i < sz; i++) {
      const line = lines[i] + (i !== sz - 1 ? '\n' : '');
      buffer += line;
      if (quoteType === '') {
        const indexSingle = line.search(/(?<![\"])(?<!\\)'''(?![\"])/g);
        const indexDouble = line.search(/(?<![\'])(?<!\\)"""(?![\'])/g);
        if (indexSingle !== -1 && (indexDouble === -1 || indexSingle < indexDouble)) {
          quoteType = "'";
        } else if (indexDouble !== -1 && (indexSingle === -1 || indexDouble < indexSingle)) {
          quoteType = '"';
        }
      }
      if (quoteType === "'") {
        tripleQuotes += (line.match(/(?<![\"])(?<!\\)'''(?!["])/g) || []).length;
      }
      if (quoteType === '"') {
        tripleQuotes += (line.match(/(?<![\'])(?<!\\)"""(?![\'])/g) || []).length;
      }

      if (tripleQuotes % 2 === 0) {
        const docstringRegex = quoteType === '"' ? doubleQuoteRegex : singleQuoteRegex;
        buffer = buffer.replace(docstringRegex, '');
        result += buffer;
        buffer = '';
        tripleQuotes = 0;
        quoteType = '';
      }
    }

    result += buffer;
    return result;
  }

  removeHashComments(content: string): string {
    const searchInPairs = (pairs: [number, number][], hashIndex: number): boolean => {
      return pairs.some(([start, end]) => hashIndex > start && hashIndex < end);
    };

    let result = '';
    const pairs: [number, number][] = [];
    let prevQuote = 0;
    while (prevQuote < content.length) {
      const openingQuote = content.slice(prevQuote + 1).search(/(?<!\\)(?:"|'|'''|""")/g) + prevQuote + 1;
      if (openingQuote === prevQuote) break;

      let closingQuote = -1;
      if (content.startsWith('"""', openingQuote) || content.startsWith("'''", openingQuote)) {
        const quoteType = content.slice(openingQuote, openingQuote + 3);
        closingQuote = content.indexOf(quoteType, openingQuote + 3);
      } else {
        const quoteType = content[openingQuote];
        closingQuote = content.indexOf(quoteType, openingQuote + 1);
      }

      if (closingQuote === -1) break;
      pairs.push([openingQuote, closingQuote]);
      prevQuote = closingQuote;
    }
    let prevHash = 0;
    while (prevHash < content.length) {
      const hashIndex = content.slice(prevHash).search(/(?<!\\)#/g) + prevHash;
      if (hashIndex === prevHash - 1) {
        result += content.slice(prevHash);
        break;
      }

      const isInsideString = searchInPairs(pairs, hashIndex);
      const nextNewLine = content.indexOf('\n', hashIndex);

      if (!isInsideString) {
        if (nextNewLine === -1) {
          result += content.slice(prevHash);
          break;
        }
        result += `${content.slice(prevHash, hashIndex)}\n`;
      } else {
        if (nextNewLine === -1) {
          result += content.slice(prevHash);
          break;
        }
        result += `${content.slice(prevHash, nextNewLine)}\n`;
      }

      prevHash = nextNewLine + 1;
    }
    return result;
  }

  removeComments(content: string): string {
    let result = this.removeDocStrings(content);
    result = this.removeHashComments(result);
    return rtrimLines(result);
  }
}

class CompositeManipulator extends BaseManipulator {
  private manipulators: FileManipulator[];

  constructor(...manipulators: FileManipulator[]) {
    super();
    this.manipulators = manipulators;
  }

  removeComments(content: string): string {
    return this.manipulators.reduce((acc, manipulator) => manipulator.removeComments(acc), content);
  }
}

const manipulators: Record<string, FileManipulator> = {
  '.c': new StripCommentsManipulator('c'),
  '.h': new StripCommentsManipulator('c'),
  '.hpp': new CppManipulator(),
  '.cpp': new CppManipulator(),
  '.cc': new CppManipulator(),
  '.cxx': new CppManipulator(),
  '.cs': new StripCommentsManipulator('csharp'),
  '.css': new StripCommentsManipulator('css'),
  '.dart': new StripCommentsManipulator('c'),
  '.go': new StripCommentsManipulator('c'),
  '.html': new StripCommentsManipulator('html'),
  '.java': new StripCommentsManipulator('java'),
  '.js': new StripCommentsManipulator('javascript'),
  '.jsx': new StripCommentsManipulator('javascript'),
  '.kt': new StripCommentsManipulator('c'),
  '.less': new StripCommentsManipulator('less'),
  '.php': new StripCommentsManipulator('php'),
  '.rb': new StripCommentsManipulator('ruby'),
  '.rs': new StripCommentsManipulator('c'),
  '.sass': new StripCommentsManipulator('sass'),
  '.scss': new StripCommentsManipulator('sass'),
  '.sh': new StripCommentsManipulator('perl'),
  '.sol': new StripCommentsManipulator('c'),
  '.sql': new StripCommentsManipulator('sql'),
  '.swift': new StripCommentsManipulator('swift'),
  '.ts': new StripCommentsManipulator('javascript'),
  '.tsx': new StripCommentsManipulator('javascript'),
  '.xml': new StripCommentsManipulator('xml'),
  '.yaml': new StripCommentsManipulator('perl'),
  '.yml': new StripCommentsManipulator('perl'),

  '.py': new PythonManipulator(),

  '.vue': new CompositeManipulator(
    new StripCommentsManipulator('html'),
    new StripCommentsManipulator('css'),
    new StripCommentsManipulator('javascript'),
  ),
  '.svelte': new CompositeManipulator(
    new StripCommentsManipulator('html'),
    new StripCommentsManipulator('css'),
    new StripCommentsManipulator('javascript'),
  ),
};

export const getFileManipulator = (filePath: string): FileManipulator | null => {
  const ext = path.extname(filePath);
  return manipulators[ext] || null;
};
</file>

<file path="src/core/file/filePathSort.ts">
import path from 'node:path';

// Sort paths for general use (not affected by git change count)
export const sortPaths = (filePaths: string[]): string[] => {
  return filePaths.sort((a, b) => {
    const partsA = a.split(path.sep);
    const partsB = b.split(path.sep);

    for (let i = 0; i < Math.min(partsA.length, partsB.length); i++) {
      if (partsA[i] !== partsB[i]) {
        const isLastA = i === partsA.length - 1;
        const isLastB = i === partsB.length - 1;

        if (!isLastA && isLastB) return -1; // Directory
        if (isLastA && !isLastB) return 1; // File

        return partsA[i].localeCompare(partsB[i]); // Alphabetical order
      }
    }

    // Sort by path length when all parts are equal
    return partsA.length - partsB.length;
  });
};
</file>

<file path="src/core/file/fileProcess.ts">
import pc from 'picocolors';
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import { logger } from '../../shared/logger.js';
import { initPiscina } from '../../shared/processConcurrency.js';
import type { RepomixProgressCallback } from '../../shared/types.js';
import { type FileManipulator, getFileManipulator } from './fileManipulate.js';
import type { ProcessedFile, RawFile } from './fileTypes.js';
import type { FileProcessTask } from './workers/fileProcessWorker.js';

type GetFileManipulator = (filePath: string) => FileManipulator | null;

const initTaskRunner = (numOfTasks: number) => {
  const pool = initPiscina(numOfTasks, new URL('./workers/fileProcessWorker.js', import.meta.url).href);
  return (task: FileProcessTask) => pool.run(task);
};

export const processFiles = async (
  rawFiles: RawFile[],
  config: RepomixConfigMerged,
  progressCallback: RepomixProgressCallback,
  deps: {
    initTaskRunner: typeof initTaskRunner;
    getFileManipulator: GetFileManipulator;
  } = {
    initTaskRunner,
    getFileManipulator,
  },
): Promise<ProcessedFile[]> => {
  const runTask = deps.initTaskRunner(rawFiles.length);
  const tasks = rawFiles.map(
    (rawFile, index) =>
      ({
        rawFile,
        config,
      }) satisfies FileProcessTask,
  );

  try {
    const startTime = process.hrtime.bigint();
    logger.trace(`Starting file processing for ${rawFiles.length} files using worker pool`);

    let completedTasks = 0;
    const totalTasks = tasks.length;

    const results = await Promise.all(
      tasks.map((task) =>
        runTask(task).then((result) => {
          completedTasks++;
          progressCallback(`Processing file... (${completedTasks}/${totalTasks}) ${pc.dim(task.rawFile.path)}`);
          logger.trace(`Processing file... (${completedTasks}/${totalTasks}) ${task.rawFile.path}`);
          return result;
        }),
      ),
    );

    const endTime = process.hrtime.bigint();
    const duration = Number(endTime - startTime) / 1e6;
    logger.trace(`File processing completed in ${duration.toFixed(2)}ms`);

    return results;
  } catch (error) {
    logger.error('Error during file processing:', error);
    throw error;
  }
};
</file>

<file path="src/core/file/fileProcessContent.ts">
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import { logger } from '../../shared/logger.js';
import { parseFile } from '../treeSitter/parseFile.js';
import { getFileManipulator } from './fileManipulate.js';
import type { RawFile } from './fileTypes.js';

/**
 * Process the content of a file according to the configuration
 * Applies various transformations based on the config:
 * - Remove comments
 * - Remove empty lines
 * - Compress content using Tree-sitter
 * - Add line numbers
 *
 * @param rawFile Raw file data containing path and content
 * @param config Repomix configuration
 * @returns Processed content string
 */
export const processContent = async (rawFile: RawFile, config: RepomixConfigMerged): Promise<string> => {
  const processStartAt = process.hrtime.bigint();
  let processedContent = rawFile.content;
  const manipulator = getFileManipulator(rawFile.path);

  logger.trace(`Processing file: ${rawFile.path}`);

  if (manipulator && config.output.removeComments) {
    processedContent = manipulator.removeComments(processedContent);
  }

  if (config.output.removeEmptyLines && manipulator) {
    processedContent = manipulator.removeEmptyLines(processedContent);
  }

  processedContent = processedContent.trim();

  if (config.output.compress) {
    try {
      const parsedContent = await parseFile(processedContent, rawFile.path, config);
      if (parsedContent === undefined) {
        logger.trace(`Failed to parse ${rawFile.path} in compressed mode. Using original content.`);
      }
      processedContent = parsedContent ?? processedContent;
    } catch (error: unknown) {
      const message = error instanceof Error ? error.message : String(error);
      logger.error(`Error parsing ${rawFile.path} in compressed mode: ${message}`);
      //re-throw error
      throw error;
    }
  } else if (config.output.showLineNumbers) {
    const lines = processedContent.split('\n');
    const padding = lines.length.toString().length;
    const numberedLines = lines.map((line, i) => `${(i + 1).toString().padStart(padding)}: ${line}`);
    processedContent = numberedLines.join('\n');
  }

  const processEndAt = process.hrtime.bigint();
  logger.trace(`Processed file: ${rawFile.path}. Took: ${(Number(processEndAt - processStartAt) / 1e6).toFixed(2)}ms`);

  return processedContent;
};
</file>

<file path="src/core/file/fileRead.ts">
import * as fs from 'node:fs/promises';
import iconv from 'iconv-lite';
import { isBinary } from 'istextorbinary';
import jschardet from 'jschardet';
import { logger } from '../../shared/logger.js';

/**
 * Read a file and return its text content
 * @param filePath Path to the file
 * @param maxFileSize Maximum file size in bytes
 * @returns File content as string, or null if the file is binary or exceeds size limit
 */
export const readRawFile = async (filePath: string, maxFileSize: number): Promise<string | null> => {
  try {
    const stats = await fs.stat(filePath);

    if (stats.size > maxFileSize) {
      const sizeKB = (stats.size / 1024).toFixed(1);
      const maxSizeKB = (maxFileSize / 1024).toFixed(1);
      logger.trace(`File exceeds size limit: ${sizeKB}KB > ${maxSizeKB}KB (${filePath})`);
      return null;
    }

    if (isBinary(filePath)) {
      logger.debug(`Skipping binary file: ${filePath}`);
      return null;
    }

    logger.trace(`Reading file: ${filePath}`);

    const buffer = await fs.readFile(filePath);

    if (isBinary(null, buffer)) {
      logger.debug(`Skipping binary file (content check): ${filePath}`);
      return null;
    }

    const encoding = jschardet.detect(buffer).encoding || 'utf-8';
    const content = iconv.decode(buffer, encoding);

    return content;
  } catch (error) {
    logger.warn(`Failed to read file: ${filePath}`, error);
    return null;
  }
};
</file>

<file path="src/core/file/fileSearch.ts">
import type { Stats } from 'node:fs';
import fs from 'node:fs/promises';
import path from 'node:path';
import { globby } from 'globby';
import { minimatch } from 'minimatch';
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import { defaultIgnoreList } from '../../config/defaultIgnore.js';
import { RepomixError } from '../../shared/errorHandle.js';
import { logger } from '../../shared/logger.js';
import { sortPaths } from './filePathSort.js';
import { PermissionError, checkDirectoryPermissions } from './permissionCheck.js';

export interface FileSearchResult {
  filePaths: string[];
  emptyDirPaths: string[];
}

const findEmptyDirectories = async (
  rootDir: string,
  directories: string[],
  ignorePatterns: string[],
): Promise<string[]> => {
  const emptyDirs: string[] = [];

  for (const dir of directories) {
    const fullPath = path.join(rootDir, dir);
    try {
      const entries = await fs.readdir(fullPath);
      const hasVisibleContents = entries.some((entry) => !entry.startsWith('.'));

      if (!hasVisibleContents) {
        // This checks if the directory itself matches any ignore patterns
        const shouldIgnore = ignorePatterns.some((pattern) => minimatch(dir, pattern) || minimatch(`${dir}/`, pattern));

        if (!shouldIgnore) {
          emptyDirs.push(dir);
        }
      }
    } catch (error) {
      logger.debug(`Error checking directory ${dir}:`, error);
    }
  }

  return emptyDirs;
};

// Check if a path is a git worktree reference file
const isGitWorktreeRef = async (gitPath: string): Promise<boolean> => {
  try {
    const stats = await fs.stat(gitPath);
    if (!stats.isFile()) {
      return false;
    }

    const content = await fs.readFile(gitPath, 'utf8');
    return content.startsWith('gitdir:');
  } catch {
    return false;
  }
};

/**
 * Escapes special characters in glob patterns to handle paths with parentheses.
 * Example: "src/(categories)" -> "src/\\(categories\\)"
 */
export const escapeGlobPattern = (pattern: string): string => {
  // First escape backslashes
  const escapedBackslashes = pattern.replace(/\\/g, '\\\\');
  // Then escape special characters () and [], but NOT {}
  return escapedBackslashes.replace(/[()[\]]/g, '\\$&');
};

/**
 * Normalizes glob patterns by removing trailing slashes and ensuring consistent directory pattern handling.
 * Makes "**\/folder", "**\/folder/", and "**\/folder/**\/*" behave identically.
 *
 * @param pattern The glob pattern to normalize
 * @returns The normalized pattern
 */
export const normalizeGlobPattern = (pattern: string): string => {
  // Remove trailing slash but preserve patterns that end with "**/"
  if (pattern.endsWith('/') && !pattern.endsWith('**/')) {
    return pattern.slice(0, -1);
  }

  // Convert **/folder to **/folder/** for consistent ignore pattern behavior
  if (pattern.startsWith('**/') && !pattern.includes('/**')) {
    return `${pattern}/**`;
  }

  return pattern;
};

// Get all file paths considering the config
export const searchFiles = async (rootDir: string, config: RepomixConfigMerged): Promise<FileSearchResult> => {
  // Check if the path exists and get its type
  let pathStats: Stats;
  try {
    pathStats = await fs.stat(rootDir);
  } catch (error) {
    if (error instanceof Error && 'code' in error) {
      const errorCode = (error as NodeJS.ErrnoException).code;
      if (errorCode === 'ENOENT') {
        throw new RepomixError(`Target path does not exist: ${rootDir}`);
      }
      if (errorCode === 'EPERM' || errorCode === 'EACCES') {
        throw new PermissionError(
          `Permission denied while accessing path. Please check folder access permissions for your terminal app. path: ${rootDir}`,
          rootDir,
          errorCode,
        );
      }
      // Handle other specific error codes with more context
      throw new RepomixError(`Failed to access path: ${rootDir}. Error code: ${errorCode}. ${error.message}`);
    }
    // Preserve original error stack trace for debugging
    const repomixError = new RepomixError(
      `Failed to access path: ${rootDir}. Reason: ${error instanceof Error ? error.message : JSON.stringify(error)}`,
    );
    repomixError.cause = error;
    throw repomixError;
  }

  // Check if the path is a directory
  if (!pathStats.isDirectory()) {
    throw new RepomixError(
      `Target path is not a directory: ${rootDir}. Please specify a directory path, not a file path.`,
    );
  }

  // Now check directory permissions
  const permissionCheck = await checkDirectoryPermissions(rootDir);

  if (permissionCheck.details?.read !== true) {
    if (permissionCheck.error instanceof PermissionError) {
      throw permissionCheck.error;
    }
    throw new RepomixError(
      `Target directory is not readable or does not exist. Please check folder access permissions for your terminal app.\npath: ${rootDir}`,
    );
  }

  const includePatterns =
    config.include.length > 0 ? config.include.map((pattern) => escapeGlobPattern(pattern)) : ['**/*'];

  try {
    const [ignorePatterns, ignoreFilePatterns] = await Promise.all([
      getIgnorePatterns(rootDir, config),
      getIgnoreFilePatterns(config),
    ]);

    // Normalize ignore patterns to handle trailing slashes consistently
    const normalizedIgnorePatterns = ignorePatterns.map(normalizeGlobPattern);

    logger.trace('Include patterns:', includePatterns);
    logger.trace('Ignore patterns:', normalizedIgnorePatterns);
    logger.trace('Ignore file patterns:', ignoreFilePatterns);

    // Check if .git is a worktree reference
    const gitPath = path.join(rootDir, '.git');
    const isWorktree = await isGitWorktreeRef(gitPath);

    // Modify ignore patterns for git worktree
    const adjustedIgnorePatterns = [...normalizedIgnorePatterns];
    if (isWorktree) {
      // Remove '.git/**' pattern and add '.git' to ignore the reference file
      const gitIndex = adjustedIgnorePatterns.indexOf('.git/**');
      if (gitIndex !== -1) {
        adjustedIgnorePatterns.splice(gitIndex, 1);
        adjustedIgnorePatterns.push('.git');
      }
    }

    const filePaths = await globby(includePatterns, {
      cwd: rootDir,
      ignore: [...adjustedIgnorePatterns],
      ignoreFiles: [...ignoreFilePatterns],
      onlyFiles: true,
      absolute: false,
      dot: true,
      followSymbolicLinks: false,
    }).catch((error) => {
      // Handle EPERM errors specifically
      if (error.code === 'EPERM' || error.code === 'EACCES') {
        throw new PermissionError(
          `Permission denied while scanning directory. Please check folder access permissions for your terminal app. path: ${rootDir}`,
          rootDir,
        );
      }
      throw error;
    });

    let emptyDirPaths: string[] = [];
    if (config.output.includeEmptyDirectories) {
      const directories = await globby(includePatterns, {
        cwd: rootDir,
        ignore: [...adjustedIgnorePatterns],
        ignoreFiles: [...ignoreFilePatterns],
        onlyDirectories: true,
        absolute: false,
        dot: true,
        followSymbolicLinks: false,
      });

      emptyDirPaths = await findEmptyDirectories(rootDir, directories, adjustedIgnorePatterns);
    }

    logger.trace(`Filtered ${filePaths.length} files`);

    return {
      filePaths: sortPaths(filePaths),
      emptyDirPaths: sortPaths(emptyDirPaths),
    };
  } catch (error: unknown) {
    // Re-throw PermissionError as is
    if (error instanceof PermissionError) {
      throw error;
    }

    if (error instanceof Error) {
      logger.error('Error filtering files:', error.message);
      throw new Error(`Failed to filter files in directory ${rootDir}. Reason: ${error.message}`);
    }

    logger.error('An unexpected error occurred:', error);
    throw new Error('An unexpected error occurred while filtering files.');
  }
};

export const parseIgnoreContent = (content: string): string[] => {
  if (!content) return [];

  return content.split('\n').reduce<string[]>((acc, line) => {
    const trimmedLine = line.trim();
    if (trimmedLine && !trimmedLine.startsWith('#')) {
      acc.push(trimmedLine);
    }
    return acc;
  }, []);
};

export const getIgnoreFilePatterns = async (config: RepomixConfigMerged): Promise<string[]> => {
  const ignoreFilePatterns: string[] = [];

  if (config.ignore.useGitignore) {
    ignoreFilePatterns.push('**/.gitignore');
  }

  ignoreFilePatterns.push('**/.repomixignore');

  return ignoreFilePatterns;
};

export const getIgnorePatterns = async (rootDir: string, config: RepomixConfigMerged): Promise<string[]> => {
  const ignorePatterns = new Set<string>();

  // Add default ignore patterns
  if (config.ignore.useDefaultPatterns) {
    logger.trace('Adding default ignore patterns');
    for (const pattern of defaultIgnoreList) {
      ignorePatterns.add(pattern);
    }
  }

  // Add repomix output file
  if (config.output.filePath) {
    const absoluteOutputPath = path.resolve(config.cwd, config.output.filePath);
    const relativeToTargetPath = path.relative(rootDir, absoluteOutputPath);

    logger.trace('Adding output file to ignore patterns:', relativeToTargetPath);

    ignorePatterns.add(relativeToTargetPath);
  }

  // Add custom ignore patterns
  if (config.ignore.customPatterns) {
    logger.trace('Adding custom ignore patterns:', config.ignore.customPatterns);
    for (const pattern of config.ignore.customPatterns) {
      ignorePatterns.add(pattern);
    }
  }

  // Add patterns from .git/info/exclude if useGitignore is enabled
  if (config.ignore.useGitignore) {
    const excludeFilePath = path.join(rootDir, '.git', 'info', 'exclude');

    try {
      const excludeFileContent = await fs.readFile(excludeFilePath, 'utf8');
      const excludePatterns = parseIgnoreContent(excludeFileContent);

      for (const pattern of excludePatterns) {
        ignorePatterns.add(pattern);
      }
    } catch (error) {
      // File might not exist or might not be accessible, which is fine
      logger.trace('Could not read .git/info/exclude file:', error instanceof Error ? error.message : String(error));
    }
  }

  return Array.from(ignorePatterns);
};
</file>

<file path="src/core/file/fileStdin.ts">
import path from 'node:path';
import readline from 'node:readline/promises';
import type { Readable } from 'node:stream';
import { RepomixError } from '../../shared/errorHandle.js';
import { logger } from '../../shared/logger.js';

export interface StdinFileResult {
  filePaths: string[];
  emptyDirPaths: string[];
}

export interface StdinDependencies {
  stdin: NodeJS.ReadableStream & { isTTY?: boolean };
  createReadlineInterface: (options: { input: Readable }) => readline.Interface;
}

/**
 * Filters and validates lines from stdin input.
 * Removes empty lines and comments (lines starting with #).
 */
export const filterValidLines = (lines: string[]): string[] => {
  return lines.map((line) => line.trim()).filter((line) => line && !line.startsWith('#'));
};

/**
 * Resolves relative paths to absolute paths and deduplicates them.
 */
export const resolveAndDeduplicatePaths = (lines: string[], cwd: string): string[] => {
  const resolvedPaths = lines.map((line) => {
    const filePath = path.isAbsolute(line) ? path.normalize(line) : path.normalize(path.resolve(cwd, line));
    logger.trace(`Resolved path: ${line} -> ${filePath}`);
    return filePath;
  });

  return [...new Set(resolvedPaths)];
};

/**
 * Reads lines from a readable stream using readline interface.
 */
export const readLinesFromStream = async (
  input: Readable,
  createInterface: (options: { input: Readable }) => readline.Interface = readline.createInterface,
): Promise<string[]> => {
  const rl = createInterface({ input });
  const lines: string[] = [];

  for await (const line of rl) {
    lines.push(line);
  }

  return lines;
};

/**
 * Reads file paths from stdin, one per line.
 * Filters out empty lines and comments (lines starting with #).
 * Converts relative paths to absolute paths based on the current working directory.
 */
export const readFilePathsFromStdin = async (
  cwd: string,
  deps: StdinDependencies = {
    stdin: process.stdin,
    createReadlineInterface: readline.createInterface,
  },
): Promise<StdinFileResult> => {
  logger.trace('Reading file paths from stdin...');

  try {
    const { stdin, createReadlineInterface } = deps;

    // Check if stdin is a TTY (interactive mode)
    if (stdin.isTTY) {
      throw new RepomixError('No data provided via stdin. Please pipe file paths to repomix when using --stdin flag.');
    }

    // Read all lines from stdin
    const rawLines = await readLinesFromStream(stdin as Readable, createReadlineInterface);

    // Filter out empty lines and comments
    const validLines = filterValidLines(rawLines);

    if (validLines.length === 0) {
      throw new RepomixError('No valid file paths found in stdin input.');
    }

    // Convert relative paths to absolute paths and deduplicate
    const filePaths = resolveAndDeduplicatePaths(validLines, cwd);

    logger.trace(`Found ${filePaths.length} file paths from stdin`);

    return {
      filePaths,
      emptyDirPaths: [], // Empty directories not supported with stdin input
    };
  } catch (error) {
    if (error instanceof RepomixError) {
      throw error;
    }

    if (error instanceof Error) {
      throw new RepomixError(`Failed to read file paths from stdin: ${error.message}`);
    }

    throw new RepomixError('An unexpected error occurred while reading from stdin.');
  }
};
</file>

<file path="src/core/file/fileTreeGenerate.ts">
import nodepath from 'node:path';

export interface TreeNode {
  name: string;
  children: TreeNode[];
  isDirectory: boolean;
}

const createTreeNode = (name: string, isDirectory: boolean): TreeNode => ({ name, children: [], isDirectory });

export const generateFileTree = (files: string[], emptyDirPaths: string[] = []): TreeNode => {
  const root: TreeNode = createTreeNode('root', true);

  for (const file of files) {
    addPathToTree(root, file, false);
  }

  // Add empty directories
  for (const dir of emptyDirPaths) {
    addPathToTree(root, dir, true);
  }

  return root;
};

const addPathToTree = (root: TreeNode, path: string, isDirectory: boolean): void => {
  const parts = path.split(nodepath.sep);
  let currentNode = root;

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    const isLastPart = i === parts.length - 1;
    let child = currentNode.children.find((c) => c.name === part);

    if (!child) {
      child = createTreeNode(part, !isLastPart || isDirectory);
      currentNode.children.push(child);
    }

    currentNode = child;
  }
};

const sortTreeNodes = (node: TreeNode) => {
  node.children.sort((a, b) => {
    if (a.isDirectory === b.isDirectory) {
      return a.name.localeCompare(b.name);
    }
    return a.isDirectory ? -1 : 1;
  });

  for (const child of node.children) {
    sortTreeNodes(child);
  }
};

export const treeToString = (node: TreeNode, prefix = ''): string => {
  sortTreeNodes(node);
  let result = '';

  for (const child of node.children) {
    result += `${prefix}${child.name}${child.isDirectory ? '/' : ''}\n`;
    if (child.isDirectory) {
      result += treeToString(child, `${prefix}  `);
    }
  }

  return result;
};

export const generateTreeString = (files: string[], emptyDirPaths: string[] = []): string => {
  const tree = generateFileTree(files, emptyDirPaths);
  return treeToString(tree).trim();
};
</file>

<file path="src/core/file/fileTypes.ts">
export interface RawFile {
  path: string;
  content: string;
}

export interface ProcessedFile {
  path: string;
  content: string;
}
</file>

<file path="src/core/file/packageJsonParse.ts">
import * as fs from 'node:fs/promises';
import path from 'node:path';
import * as url from 'node:url';
import { logger } from '../../shared/logger.js';

export const getVersion = async (): Promise<string> => {
  try {
    const packageJson = await parsePackageJson();

    if (!packageJson.version) {
      logger.warn('No version found in package.json');
      return 'unknown';
    }

    return packageJson.version;
  } catch (error) {
    logger.error('Error reading package.json:', error);
    return 'unknown';
  }
};

const parsePackageJson = async (): Promise<{
  name: string;
  version: string;
}> => {
  const dirName = url.fileURLToPath(new URL('.', import.meta.url));
  const packageJsonPath = path.join(dirName, '..', '..', '..', 'package.json');
  const packageJsonFile = await fs.readFile(packageJsonPath, 'utf-8');
  const packageJson = JSON.parse(packageJsonFile);
  return packageJson;
};
</file>

<file path="src/core/file/permissionCheck.ts">
import { constants } from 'node:fs';
import * as fs from 'node:fs/promises';
import { platform } from 'node:os';
import { logger } from '../../shared/logger.js';

export interface PermissionCheckResult {
  hasAllPermission: boolean;
  error?: Error;
  details?: {
    read?: boolean;
    write?: boolean;
    execute?: boolean;
  };
}

export class PermissionError extends Error {
  constructor(
    message: string,
    public readonly path: string,
    public readonly code?: string,
  ) {
    super(message);
    this.name = 'PermissionError';
  }
}

export const checkDirectoryPermissions = async (dirPath: string): Promise<PermissionCheckResult> => {
  try {
    // First try to read directory contents
    await fs.readdir(dirPath);

    // Check specific permissions
    const details = {
      read: false,
      write: false,
      execute: false,
    };

    try {
      await fs.access(dirPath, constants.R_OK);
      details.read = true;
    } catch {}

    try {
      await fs.access(dirPath, constants.W_OK);
      details.write = true;
    } catch {}

    try {
      await fs.access(dirPath, constants.X_OK);
      details.execute = true;
    } catch {}

    const hasAllPermissions = details.read && details.write && details.execute;

    if (!hasAllPermissions) {
      return {
        hasAllPermission: false,
        details,
      };
    }

    return {
      hasAllPermission: true,
      details,
    };
  } catch (error) {
    if (error instanceof Error && 'code' in error) {
      switch (error.code) {
        case 'EPERM':
        case 'EACCES':
        case 'EISDIR':
          return {
            hasAllPermission: false,
            error: new PermissionError(getMacOSPermissionMessage(dirPath, error.code), dirPath, error.code),
          };
        default:
          logger.debug('Directory permission check error:', error);
          return {
            hasAllPermission: false,
            error: error as Error,
          };
      }
    }
    return {
      hasAllPermission: false,
      error: error instanceof Error ? error : new Error(String(error)),
    };
  }
};

const getMacOSPermissionMessage = (dirPath: string, errorCode?: string): string => {
  if (platform() === 'darwin') {
    return `Permission denied: Cannot access '${dirPath}', error code: ${errorCode}.

This error often occurs when macOS security restrictions prevent access to the directory.
To fix this:

1. Open System Settings
2. Navigate to Privacy & Security > Files and Folders
3. Find your terminal app (Terminal.app, iTerm2, VS Code, etc.)
4. Grant necessary folder access permissions

If your terminal app is not listed:
- Try running repomix command again
- When prompted by macOS, click "Allow"
- Restart your terminal app if needed
`;
  }

  return `Permission denied: Cannot access '${dirPath}'`;
};
</file>

<file path="src/core/git/gitCommand.ts">
import { execFile } from 'node:child_process';
import fs from 'node:fs/promises';
import path from 'node:path';
import { promisify } from 'node:util';
import { RepomixError } from '../../shared/errorHandle.js';
import { logger } from '../../shared/logger.js';

const execFileAsync = promisify(execFile);

export const execGitLogFilenames = async (
  directory: string,
  maxCommits = 100,
  deps = {
    execFileAsync,
  },
): Promise<string[]> => {
  try {
    const result = await deps.execFileAsync('git', [
      '-C',
      directory,
      'log',
      '--pretty=format:',
      '--name-only',
      '-n',
      maxCommits.toString(),
    ]);

    return result.stdout.split('\n').filter(Boolean);
  } catch (error) {
    logger.trace('Failed to get git log filenames:', (error as Error).message);
    return [];
  }
};

export const execGitDiff = async (
  directory: string,
  options: string[] = [],
  deps = {
    execFileAsync,
  },
): Promise<string> => {
  try {
    const result = await deps.execFileAsync('git', [
      '-C',
      directory,
      'diff',
      '--no-color', // Avoid ANSI color codes
      ...options,
    ]);

    return result.stdout || '';
  } catch (error) {
    logger.trace('Failed to execute git diff:', (error as Error).message);
    throw error;
  }
};

export const execGitVersion = async (
  deps = {
    execFileAsync,
  },
): Promise<string> => {
  try {
    const result = await deps.execFileAsync('git', ['--version']);
    return result.stdout || '';
  } catch (error) {
    logger.trace('Failed to execute git version:', (error as Error).message);
    throw error;
  }
};

export const execGitRevParse = async (
  directory: string,
  deps = {
    execFileAsync,
  },
): Promise<string> => {
  try {
    const result = await deps.execFileAsync('git', ['-C', directory, 'rev-parse', '--is-inside-work-tree']);
    return result.stdout || '';
  } catch (error) {
    logger.trace('Failed to execute git rev-parse:', (error as Error).message);
    throw error;
  }
};

export const execLsRemote = async (
  url: string,
  deps = {
    execFileAsync,
  },
): Promise<string> => {
  validateGitUrl(url);

  try {
    const result = await deps.execFileAsync('git', ['ls-remote', '--heads', '--tags', url]);
    return result.stdout || '';
  } catch (error) {
    logger.trace('Failed to execute git ls-remote:', (error as Error).message);
    throw error;
  }
};

export const execGitShallowClone = async (
  url: string,
  directory: string,
  remoteBranch?: string,
  deps = {
    execFileAsync,
  },
) => {
  validateGitUrl(url);

  if (remoteBranch) {
    await deps.execFileAsync('git', ['-C', directory, 'init']);
    await deps.execFileAsync('git', ['-C', directory, 'remote', 'add', 'origin', url]);
    try {
      await deps.execFileAsync('git', ['-C', directory, 'fetch', '--depth', '1', 'origin', remoteBranch]);
      await deps.execFileAsync('git', ['-C', directory, 'checkout', 'FETCH_HEAD']);
    } catch (err: unknown) {
      // git fetch --depth 1 origin <short SHA> always throws "couldn't find remote ref" error
      const isRefNotfoundError =
        err instanceof Error && err.message.includes(`couldn't find remote ref ${remoteBranch}`);

      if (!isRefNotfoundError) {
        // Rethrow error as nothing else we can do
        throw err;
      }

      // Short SHA detection - matches a hexadecimal string of 4 to 39 characters
      // If the string matches this regex, it MIGHT be a short SHA
      // If the string doesn't match, it is DEFINITELY NOT a short SHA
      const isNotShortSHA = !remoteBranch.match(/^[0-9a-f]{4,39}$/i);

      if (isNotShortSHA) {
        // Rethrow error as nothing else we can do
        throw err;
      }

      // Maybe the error is due to a short SHA, let's try again
      // Can't use --depth 1 here as we need to fetch the specific commit
      await deps.execFileAsync('git', ['-C', directory, 'fetch', 'origin']);
      await deps.execFileAsync('git', ['-C', directory, 'checkout', remoteBranch]);
    }
  } else {
    await deps.execFileAsync('git', ['clone', '--depth', '1', url, directory]);
  }

  // Clean up .git directory
  await fs.rm(path.join(directory, '.git'), { recursive: true, force: true });
};

/**
 * Validates a Git URL for security and format
 * @throws {RepomixError} If the URL is invalid or contains potentially dangerous parameters
 */
export const validateGitUrl = (url: string): void => {
  if (url.includes('--upload-pack') || url.includes('--config') || url.includes('--exec')) {
    throw new RepomixError(`Invalid repository URL. URL contains potentially dangerous parameters: ${url}`);
  }

  // Check if the URL starts with git@ or https://
  if (!(url.startsWith('git@') || url.startsWith('https://'))) {
    throw new RepomixError(`Invalid URL protocol for '${url}'. URL must start with 'git@' or 'https://'`);
  }

  try {
    if (url.startsWith('https://')) {
      new URL(url);
    }
  } catch (error) {
    throw new RepomixError(`Invalid repository URL. Please provide a valid URL: ${url}`);
  }
};
</file>

<file path="src/core/git/gitDiffHandle.ts">
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import { RepomixError } from '../../shared/errorHandle.js';
import { logger } from '../../shared/logger.js';
import { execGitDiff } from './gitCommand.js';
import { isGitRepository } from './gitRepositoryHandle.js';

export interface GitDiffResult {
  workTreeDiffContent: string;
  stagedDiffContent: string;
}

export const getWorkTreeDiff = async (
  directory: string,
  deps = {
    execGitDiff,
    isGitRepository,
  },
): Promise<string> => {
  return getDiff(directory, [], deps);
};

export const getStagedDiff = async (
  directory: string,
  deps = {
    execGitDiff,
    isGitRepository,
  },
): Promise<string> => {
  return getDiff(directory, ['--cached'], deps);
};

/**
 * Helper function to get git diff with common repository check and error handling
 */
const getDiff = async (
  directory: string,
  options: string[],
  deps = {
    execGitDiff,
    isGitRepository,
  },
): Promise<string> => {
  try {
    // Check if the directory is a git repository
    const isGitRepo = await deps.isGitRepository(directory);
    if (!isGitRepo) {
      logger.trace('Not a git repository, skipping diff generation');
      return '';
    }

    // Get the diff with provided options
    const result = await deps.execGitDiff(directory, options);

    return result;
  } catch (error) {
    logger.trace('Failed to get git diff:', (error as Error).message);
    return '';
  }
};

export const getGitDiffs = async (
  rootDirs: string[],
  config: RepomixConfigMerged,
  deps = {
    getWorkTreeDiff,
    getStagedDiff,
  },
): Promise<GitDiffResult | undefined> => {
  // Get git diffs if enabled
  let gitDiffResult: GitDiffResult | undefined;

  if (config.output.git?.includeDiffs) {
    try {
      // Use the first directory as the git repository root
      // Usually this would be the root of the project
      const gitRoot = rootDirs[0] || config.cwd;
      const [workTreeDiffContent, stagedDiffContent] = await Promise.all([
        deps.getWorkTreeDiff(gitRoot),
        deps.getStagedDiff(gitRoot),
      ]);

      gitDiffResult = {
        workTreeDiffContent,
        stagedDiffContent,
      };
    } catch (error) {
      if (error instanceof Error) {
        throw new RepomixError(`Failed to get git diffs: ${error.message}`);
      }
    }
  }

  return gitDiffResult;
};
</file>

<file path="src/core/git/gitHubArchive.ts">
import { createWriteStream } from 'node:fs';
import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import { Readable, Transform } from 'node:stream';
import { pipeline } from 'node:stream/promises';
import { unzip } from 'fflate';
import { RepomixError } from '../../shared/errorHandle.js';
import { logger } from '../../shared/logger.js';
import {
  buildGitHubArchiveUrl,
  buildGitHubMasterArchiveUrl,
  buildGitHubTagArchiveUrl,
  checkGitHubResponse,
  getArchiveFilename,
} from './gitHubArchiveApi.js';
import type { GitHubRepoInfo } from './gitRemoteParse.js';

export interface ArchiveDownloadOptions {
  timeout?: number; // Download timeout in milliseconds (default: 30000)
  retries?: number; // Number of retry attempts (default: 3)
}

export interface ArchiveDownloadProgress {
  downloaded: number;
  total: number | null;
  percentage: number | null;
}

export type ProgressCallback = (progress: ArchiveDownloadProgress) => void;

/**
 * Downloads and extracts a GitHub repository archive
 */
export const downloadGitHubArchive = async (
  repoInfo: GitHubRepoInfo,
  targetDirectory: string,
  options: ArchiveDownloadOptions = {},
  onProgress?: ProgressCallback,
  deps = {
    fetch: globalThis.fetch,
    fs,
    pipeline,
    Transform,
    createWriteStream,
  },
): Promise<void> => {
  const { timeout = 30000, retries = 3 } = options;

  // Ensure target directory exists
  await deps.fs.mkdir(targetDirectory, { recursive: true });

  let lastError: Error | null = null;

  // Try downloading with multiple URL formats: main branch, master branch (fallback), then tag format
  const archiveUrls = [
    buildGitHubArchiveUrl(repoInfo),
    buildGitHubMasterArchiveUrl(repoInfo),
    buildGitHubTagArchiveUrl(repoInfo),
  ].filter(Boolean) as string[];

  for (const archiveUrl of archiveUrls) {
    for (let attempt = 1; attempt <= retries; attempt++) {
      try {
        logger.trace(`Downloading GitHub archive from: ${archiveUrl} (attempt ${attempt}/${retries})`);

        await downloadAndExtractArchive(archiveUrl, targetDirectory, repoInfo, timeout, onProgress, deps);

        logger.trace('Successfully downloaded and extracted GitHub archive');
        return; // Success - exit early
      } catch (error) {
        lastError = error as Error;
        logger.trace(`Archive download attempt ${attempt} failed:`, lastError.message);

        // If it's a 404-like error and we have more URLs to try, don't retry this URL
        const isNotFoundError =
          lastError instanceof RepomixError &&
          (lastError.message.includes('not found') || lastError.message.includes('404'));
        if (isNotFoundError && archiveUrls.length > 1) {
          break;
        }

        // If it's the last attempt, don't wait
        if (attempt < retries) {
          const delay = Math.min(1000 * 2 ** (attempt - 1), 5000); // Exponential backoff, max 5s
          logger.trace(`Retrying in ${delay}ms...`);
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
    }
  }

  // If we get here, all attempts failed
  throw new RepomixError(
    `Failed to download GitHub archive after ${retries} attempts. ${lastError?.message || 'Unknown error'}`,
  );
};

/**
 * Downloads and extracts archive from a single URL
 */
const downloadAndExtractArchive = async (
  archiveUrl: string,
  targetDirectory: string,
  repoInfo: GitHubRepoInfo,
  timeout: number,
  onProgress?: ProgressCallback,
  deps = {
    fetch: globalThis.fetch,
    fs,
    pipeline,
    Transform,
    createWriteStream,
  },
): Promise<void> => {
  // Download the archive
  const tempArchivePath = path.join(targetDirectory, getArchiveFilename(repoInfo));

  await downloadFile(archiveUrl, tempArchivePath, timeout, onProgress, deps);

  try {
    // Extract the archive
    await extractZipArchive(tempArchivePath, targetDirectory, repoInfo, { fs: deps.fs });
  } finally {
    // Clean up the downloaded archive file
    try {
      await deps.fs.unlink(tempArchivePath);
    } catch (error) {
      logger.trace('Failed to cleanup archive file:', (error as Error).message);
    }
  }
};

/**
 * Downloads a file from URL with progress tracking
 */
const downloadFile = async (
  url: string,
  filePath: string,
  timeout: number,
  onProgress?: ProgressCallback,
  deps = {
    fetch: globalThis.fetch,
    fs,
    pipeline,
    Transform,
    createWriteStream,
  },
): Promise<void> => {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  try {
    const response = await deps.fetch(url, {
      signal: controller.signal,
    });

    checkGitHubResponse(response);

    if (!response.body) {
      throw new RepomixError('No response body received');
    }

    const totalSize = response.headers.get('content-length');
    const total = totalSize ? Number.parseInt(totalSize, 10) : null;
    let downloaded = 0;
    let lastProgressUpdate = 0;

    // Use Readable.fromWeb for better stream handling
    const nodeStream = Readable.fromWeb(response.body);

    // Transform stream for progress tracking
    const progressStream = new deps.Transform({
      transform(chunk, _encoding, callback) {
        downloaded += chunk.length;

        // Update progress at most every 100ms to avoid too frequent updates
        const now = Date.now();
        if (onProgress && now - lastProgressUpdate > 100) {
          lastProgressUpdate = now;
          onProgress({
            downloaded,
            total,
            percentage: total ? Math.round((downloaded / total) * 100) : null,
          });
        }

        callback(null, chunk);
      },
      flush(callback) {
        // Send final progress update
        if (onProgress) {
          onProgress({
            downloaded,
            total,
            percentage: total ? 100 : null,
          });
        }
        callback();
      },
    });

    // Write to file
    const writeStream = deps.createWriteStream(filePath);
    await deps.pipeline(nodeStream, progressStream, writeStream);
  } finally {
    clearTimeout(timeoutId);
  }
};

/**
 * Extracts a ZIP archive using fflate library
 */
const extractZipArchive = async (
  archivePath: string,
  targetDirectory: string,
  repoInfo: GitHubRepoInfo,
  deps = {
    fs,
  },
): Promise<void> => {
  try {
    // Always use in-memory extraction for simplicity and reliability
    await extractZipArchiveInMemory(archivePath, targetDirectory, repoInfo, deps);
  } catch (error) {
    throw new RepomixError(`Failed to extract archive: ${(error as Error).message}`);
  }
};

/**
 * Extracts ZIP archive by loading it entirely into memory (faster for small files)
 */
const extractZipArchiveInMemory = async (
  archivePath: string,
  targetDirectory: string,
  repoInfo: GitHubRepoInfo,
  deps = {
    fs,
  },
): Promise<void> => {
  // Read the ZIP file as a buffer
  const zipBuffer = await deps.fs.readFile(archivePath);
  const zipUint8Array = new Uint8Array(zipBuffer);

  // Extract ZIP using fflate
  await new Promise<void>((resolve, reject) => {
    unzip(zipUint8Array, (err, extracted) => {
      if (err) {
        reject(new RepomixError(`Failed to extract ZIP archive: ${err.message}`));
        return;
      }

      // Process extracted files concurrently in the callback
      processExtractedFiles(extracted, targetDirectory, repoInfo, deps).then(resolve).catch(reject);
    });
  });
};

/**
 * Process extracted files sequentially to avoid EMFILE errors
 */
const processExtractedFiles = async (
  extracted: Record<string, Uint8Array>,
  targetDirectory: string,
  repoInfo: GitHubRepoInfo,
  deps = {
    fs,
  },
): Promise<void> => {
  const repoPrefix = `${repoInfo.repo}-`;
  const createdDirs = new Set<string>();

  // Process files sequentially to avoid EMFILE errors completely
  for (const [filePath, fileData] of Object.entries(extracted)) {
    // GitHub archives have a top-level directory like "repo-branch/"
    // We need to remove this prefix from the file paths
    let relativePath = filePath;

    // Find and remove the repo prefix
    const pathParts = filePath.split('/');
    if (pathParts.length > 0 && pathParts[0].startsWith(repoPrefix)) {
      // Remove the first directory (repo-branch/)
      relativePath = pathParts.slice(1).join('/');
    }

    // Skip empty paths (root directory)
    if (!relativePath) {
      continue;
    }

    // Sanitize relativePath to prevent path traversal attacks
    const sanitized = path.normalize(relativePath).replace(/^(\.\.([\/\\]|$))+/, '');

    // Reject absolute paths outright
    if (path.isAbsolute(sanitized)) {
      logger.trace(`Absolute path detected in archive, skipping: ${relativePath}`);
      continue;
    }

    const targetPath = path.resolve(targetDirectory, sanitized);
    if (!targetPath.startsWith(path.resolve(targetDirectory))) {
      logger.trace(`Unsafe path detected in archive, skipping: ${relativePath}`);
      continue;
    }

    // Check if this entry is a directory (ends with /) or empty file data indicates directory
    const isDirectory = filePath.endsWith('/') || (fileData.length === 0 && relativePath.endsWith('/'));

    if (isDirectory) {
      // Create directory immediately
      if (!createdDirs.has(targetPath)) {
        logger.trace(`Creating directory: ${targetPath}`);
        await deps.fs.mkdir(targetPath, { recursive: true });
        createdDirs.add(targetPath);
      }
    } else {
      // Create parent directory if needed and write file
      const parentDir = path.dirname(targetPath);
      if (!createdDirs.has(parentDir)) {
        logger.trace(`Creating parent directory for file: ${parentDir}`);
        await deps.fs.mkdir(parentDir, { recursive: true });
        createdDirs.add(parentDir);
      }

      // Write file sequentially
      logger.trace(`Writing file: ${targetPath}`);
      try {
        await deps.fs.writeFile(targetPath, fileData);
      } catch (fileError) {
        logger.trace(`Failed to write file ${targetPath}: ${(fileError as Error).message}`);
        throw fileError;
      }
    }
  }
};

/**
 * Checks if archive download is supported for the given repository info
 */
export const isArchiveDownloadSupported = (_repoInfo: GitHubRepoInfo): boolean => {
  // Archive download is supported for all GitHub repositories
  // In the future, we might add conditions here (e.g., size limits, private repos)
  return true;
};
</file>

<file path="src/core/git/gitHubArchiveApi.ts">
import { RepomixError } from '../../shared/errorHandle.js';
import type { GitHubRepoInfo } from './gitRemoteParse.js';

/**
 * Constructs GitHub archive download URL
 * Format: https://github.com/owner/repo/archive/refs/heads/branch.zip
 * For tags: https://github.com/owner/repo/archive/refs/tags/tag.zip
 * For commits: https://github.com/owner/repo/archive/commit.zip
 */
export const buildGitHubArchiveUrl = (repoInfo: GitHubRepoInfo): string => {
  const { owner, repo, ref } = repoInfo;
  const baseUrl = `https://github.com/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/archive`;

  if (!ref) {
    // Default to main branch - fallback to master will be handled by the caller
    return `${baseUrl}/refs/heads/main.zip`;
  }

  // Check if ref looks like a commit SHA (40 hex chars or shorter)
  const isCommitSha = /^[0-9a-f]{4,40}$/i.test(ref);
  if (isCommitSha) {
    return `${baseUrl}/${encodeURIComponent(ref)}.zip`;
  }

  // For branches and tags, we need to determine the type
  // Default to branch format, will fallback to tag if needed
  return `${baseUrl}/refs/heads/${encodeURIComponent(ref)}.zip`;
};

/**
 * Builds alternative archive URL for master branch as fallback
 */
export const buildGitHubMasterArchiveUrl = (repoInfo: GitHubRepoInfo): string | null => {
  const { owner, repo, ref } = repoInfo;
  if (ref) {
    return null; // Only applicable when no ref is specified
  }

  return `https://github.com/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/archive/refs/heads/master.zip`;
};

/**
 * Builds alternative archive URL for tags
 */
export const buildGitHubTagArchiveUrl = (repoInfo: GitHubRepoInfo): string | null => {
  const { owner, repo, ref } = repoInfo;
  if (!ref || /^[0-9a-f]{4,40}$/i.test(ref)) {
    return null; // Not applicable for commits or no ref
  }

  return `https://github.com/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/archive/refs/tags/${encodeURIComponent(ref)}.zip`;
};

/**
 * Gets the expected archive filename from GitHub
 * Format: repo-branch.zip or repo-sha.zip
 */
export const getArchiveFilename = (repoInfo: GitHubRepoInfo): string => {
  const { repo, ref } = repoInfo;
  const refPart = ref || 'main';

  // GitHub uses the last part of the ref for the filename
  const refName = refPart.includes('/') ? refPart.split('/').pop() : refPart;

  return `${repo}-${refName}.zip`;
};

/**
 * Checks if a response indicates a GitHub API rate limit or error
 */
export const checkGitHubResponse = (response: Response): void => {
  if (response.status === 404) {
    throw new RepomixError(
      'Repository not found or is private. Please check the repository URL and your access permissions.',
    );
  }

  if (response.status === 403) {
    const rateLimitRemaining = response.headers.get('X-RateLimit-Remaining');
    if (rateLimitRemaining === '0') {
      const resetTime = response.headers.get('X-RateLimit-Reset');
      const resetDate = resetTime ? new Date(Number.parseInt(resetTime) * 1000) : null;
      throw new RepomixError(
        `GitHub API rate limit exceeded. ${resetDate ? `Rate limit resets at ${resetDate.toISOString()}` : 'Please try again later.'}`,
      );
    }
    throw new RepomixError(
      'Access denied. The repository might be private or you might not have permission to access it.',
    );
  }

  if (response.status === 500 || response.status === 502 || response.status === 503 || response.status === 504) {
    throw new RepomixError('GitHub server error. Please try again later.');
  }

  if (!response.ok) {
    throw new RepomixError(`GitHub API error: ${response.status} ${response.statusText}`);
  }
};
</file>

<file path="src/core/git/gitRemoteHandle.ts">
import { RepomixError } from '../../shared/errorHandle.js';
import { logger } from '../../shared/logger.js';
import { execLsRemote, validateGitUrl } from './gitCommand.js';

export const getRemoteRefs = async (
  url: string,
  deps = {
    execLsRemote,
  },
): Promise<string[]> => {
  validateGitUrl(url);

  try {
    const stdout = await deps.execLsRemote(url);

    // Extract ref names from the output
    // Format is: hash\tref_name
    const refs = stdout
      .split('\n')
      .filter(Boolean)
      .map((line) => {
        // Skip the hash part and extract only the ref name
        const parts = line.split('\t');
        if (parts.length < 2) return '';

        // Remove 'refs/heads/' or 'refs/tags/' prefix
        return parts[1].replace(/^refs\/(heads|tags)\//, '');
      })
      .filter(Boolean);

    logger.trace(`Found ${refs.length} refs in repository: ${url}`);
    return refs;
  } catch (error) {
    logger.trace('Failed to get remote refs:', (error as Error).message);
    throw new RepomixError(`Failed to get remote refs: ${(error as Error).message}`);
  }
};
</file>

<file path="src/core/git/gitRemoteParse.ts">
import gitUrlParse, { type GitUrl } from 'git-url-parse';
import { RepomixError } from '../../shared/errorHandle.js';
import { logger } from '../../shared/logger.js';

interface IGitUrl extends GitUrl {
  commit: string | undefined;
}

export interface GitHubRepoInfo {
  owner: string;
  repo: string;
  ref?: string; // branch, tag, or commit SHA
}

// Check the short form of the GitHub URL. e.g. yamadashy/repomix
const VALID_NAME_PATTERN = '[a-zA-Z0-9](?:[a-zA-Z0-9._-]*[a-zA-Z0-9])?';
const validShorthandRegex = new RegExp(`^${VALID_NAME_PATTERN}/${VALID_NAME_PATTERN}$`);
export const isValidShorthand = (remoteValue: string): boolean => {
  return validShorthandRegex.test(remoteValue);
};

export const parseRemoteValue = (
  remoteValue: string,
  refs: string[] = [],
): { repoUrl: string; remoteBranch: string | undefined } => {
  if (isValidShorthand(remoteValue)) {
    logger.trace(`Formatting GitHub shorthand: ${remoteValue}`);
    return {
      repoUrl: `https://github.com/${remoteValue}.git`,
      remoteBranch: undefined,
    };
  }

  try {
    const parsedFields = gitUrlParse(remoteValue, refs) as IGitUrl;

    // This will make parsedFields.toString() automatically append '.git' to the returned url
    parsedFields.git_suffix = true;

    const ownerSlashRepo =
      parsedFields.full_name.split('/').length > 1 ? parsedFields.full_name.split('/').slice(-2).join('/') : '';

    if (ownerSlashRepo !== '' && !isValidShorthand(ownerSlashRepo)) {
      throw new RepomixError('Invalid owner/repo in repo URL');
    }

    const repoUrl = parsedFields.toString(parsedFields.protocol);

    if (parsedFields.ref) {
      return {
        repoUrl: repoUrl,
        remoteBranch: parsedFields.ref,
      };
    }

    if (parsedFields.commit) {
      return {
        repoUrl: repoUrl,
        remoteBranch: parsedFields.commit,
      };
    }

    return {
      repoUrl: repoUrl,
      remoteBranch: undefined,
    };
  } catch (error) {
    throw new RepomixError('Invalid remote repository URL or repository shorthand (owner/repo)');
  }
};

export const isValidRemoteValue = (remoteValue: string, refs: string[] = []): boolean => {
  try {
    parseRemoteValue(remoteValue, refs);
    return true;
  } catch (error) {
    return false;
  }
};

/**
 * Parses remote value and extracts GitHub repository information if it's a GitHub repo
 * Returns null if the remote value is not a GitHub repository
 */
export const parseGitHubRepoInfo = (remoteValue: string): GitHubRepoInfo | null => {
  try {
    // Handle shorthand format: owner/repo
    if (isValidShorthand(remoteValue)) {
      const [owner, repo] = remoteValue.split('/');
      return { owner, repo };
    }

    // For GitHub URLs with branch/tag/commit info, extract directly from URL
    try {
      const url = new URL(remoteValue);
      const allowedHosts = ['github.com', 'www.github.com'];

      if (allowedHosts.includes(url.hostname)) {
        const pathParts = url.pathname.split('/').filter(Boolean);

        if (pathParts.length >= 2) {
          const owner = pathParts[0];
          const repo = pathParts[1].replace(/\.git$/, '');

          const result: GitHubRepoInfo = { owner, repo };

          // Extract ref from URL patterns like /tree/branch or /commit/sha
          if (pathParts.length >= 4 && (pathParts[2] === 'tree' || pathParts[2] === 'commit')) {
            result.ref = pathParts.slice(3).join('/');
          }

          return result;
        }
      }
    } catch (urlError) {
      // Fall back to git-url-parse if URL parsing fails
      logger.trace('URL parsing failed, falling back to git-url-parse:', (urlError as Error).message);
    }

    // Parse using git-url-parse for other cases
    const parsed = gitUrlParse(remoteValue) as IGitUrl;

    // Only proceed if it's a GitHub repository
    if (parsed.source !== 'github.com') {
      return null;
    }

    // Extract owner and repo from full_name (e.g., "owner/repo")
    const [owner, repo] = parsed.full_name.split('/');
    if (!owner || !repo) {
      return null;
    }

    const result: GitHubRepoInfo = {
      owner,
      repo: repo.replace(/\.git$/, ''), // Remove .git suffix
    };

    // Add ref if available
    if (parsed.ref) {
      result.ref = parsed.ref;
    } else if (parsed.commit) {
      result.ref = parsed.commit;
    }

    return result;
  } catch (error) {
    logger.trace('Failed to parse GitHub repo info:', (error as Error).message);
    return null;
  }
};

/**
 * Checks if a remote value represents a GitHub repository
 */
export const isGitHubRepository = (remoteValue: string): boolean => {
  return parseGitHubRepoInfo(remoteValue) !== null;
};
</file>

<file path="src/core/git/gitRepositoryHandle.ts">
import { logger } from '../../shared/logger.js';
import { execGitLogFilenames, execGitRevParse, execGitVersion } from './gitCommand.js';

export const getFileChangeCount = async (
  directory: string,
  maxCommits = 100,
  deps = {
    execGitLogFilenames,
  },
): Promise<Record<string, number>> => {
  try {
    const filenames = await deps.execGitLogFilenames(directory, maxCommits);

    const fileChangeCounts: Record<string, number> = {};

    for (const filename of filenames) {
      fileChangeCounts[filename] = (fileChangeCounts[filename] || 0) + 1;
    }

    return fileChangeCounts;
  } catch (error) {
    logger.trace('Failed to get file change counts:', (error as Error).message);
    return {};
  }
};

export const isGitRepository = async (
  directory: string,
  deps = {
    execGitRevParse,
  },
): Promise<boolean> => {
  try {
    await deps.execGitRevParse(directory);
    return true;
  } catch (error) {
    return false;
  }
};

export const isGitInstalled = async (
  deps = {
    execGitVersion,
  },
): Promise<boolean> => {
  try {
    const result = await deps.execGitVersion();
    return !result.includes('error') && result.includes('git version');
  } catch (error) {
    logger.trace('Git is not installed:', (error as Error).message);
    return false;
  }
};
</file>

<file path="src/core/metrics/workers/fileMetricsWorker.ts">
import type { TiktokenEncoding } from 'tiktoken';
import { logger, setLogLevelByEnv } from '../../../shared/logger.js';
import type { ProcessedFile } from '../../file/fileTypes.js';
import { TokenCounter } from '../TokenCounter.js';
import type { FileMetrics } from './types.js';

export interface FileMetricsTask {
  file: ProcessedFile;
  index: number;
  totalFiles: number;
  encoding: TiktokenEncoding;
}

// Worker-level singleton for TokenCounter
let tokenCounter: TokenCounter | null = null;

const getTokenCounter = (encoding: TiktokenEncoding): TokenCounter => {
  if (!tokenCounter) {
    tokenCounter = new TokenCounter(encoding);
  }
  return tokenCounter;
};

// Set logger log level from environment variable if provided
setLogLevelByEnv();

export default async ({ file, encoding }: FileMetricsTask): Promise<FileMetrics> => {
  const processStartAt = process.hrtime.bigint();
  const metrics = await calculateIndividualFileMetrics(file, encoding);
  const processEndAt = process.hrtime.bigint();
  logger.trace(
    `Calculated metrics for ${file.path}. Took: ${(Number(processEndAt - processStartAt) / 1e6).toFixed(2)}ms`,
  );

  return metrics;
};

export const calculateIndividualFileMetrics = async (
  file: ProcessedFile,
  encoding: TiktokenEncoding,
): Promise<FileMetrics> => {
  const charCount = file.content.length;
  const tokenCounter = getTokenCounter(encoding);
  const tokenCount = tokenCounter.countTokens(file.content, file.path);

  return { path: file.path, charCount, tokenCount };
};

// Cleanup when worker is terminated
process.on('exit', () => {
  if (tokenCounter) {
    tokenCounter.free();
    tokenCounter = null;
  }
});
</file>

<file path="src/core/metrics/workers/outputMetricsWorker.ts">
import type { TiktokenEncoding } from 'tiktoken';
import { logger, setLogLevelByEnv } from '../../../shared/logger.js';
import { TokenCounter } from '../TokenCounter.js';

export interface OutputMetricsTask {
  content: string;
  encoding: TiktokenEncoding;
  path?: string;
}

// Worker-level singleton for TokenCounter
let tokenCounter: TokenCounter | null = null;

const getTokenCounter = (encoding: TiktokenEncoding): TokenCounter => {
  if (!tokenCounter) {
    tokenCounter = new TokenCounter(encoding);
  }
  return tokenCounter;
};

// Set logger log level from environment variable if provided
setLogLevelByEnv();

export default async ({ content, encoding, path }: OutputMetricsTask): Promise<number> => {
  const processStartAt = process.hrtime.bigint();
  const counter = getTokenCounter(encoding);
  const tokenCount = counter.countTokens(content, path);

  const processEndAt = process.hrtime.bigint();
  logger.trace(
    `Counted output tokens. Count: ${tokenCount}. Took: ${(Number(processEndAt - processStartAt) / 1e6).toFixed(2)}ms`,
  );

  return tokenCount;
};

// Cleanup when worker is terminated
process.on('exit', () => {
  if (tokenCounter) {
    tokenCounter.free();
    tokenCounter = null;
  }
});
</file>

<file path="src/core/metrics/workers/types.ts">
export interface FileMetrics {
  path: string;
  charCount: number;
  tokenCount: number;
}
</file>

<file path="src/core/metrics/calculateAllFileMetrics.ts">
import pc from 'picocolors';
import type { TiktokenEncoding } from 'tiktoken';
import { logger } from '../../shared/logger.js';
import { initPiscina } from '../../shared/processConcurrency.js';
import type { RepomixProgressCallback } from '../../shared/types.js';
import type { ProcessedFile } from '../file/fileTypes.js';
import type { FileMetricsTask } from './workers/fileMetricsWorker.js';
import type { FileMetrics } from './workers/types.js';

const initTaskRunner = (numOfTasks: number) => {
  const pool = initPiscina(numOfTasks, new URL('./workers/fileMetricsWorker.js', import.meta.url).href);
  return (task: FileMetricsTask) => pool.run(task);
};

export const calculateAllFileMetrics = async (
  processedFiles: ProcessedFile[],
  tokenCounterEncoding: TiktokenEncoding,
  progressCallback: RepomixProgressCallback,
  deps = {
    initTaskRunner,
  },
): Promise<FileMetrics[]> => {
  const runTask = deps.initTaskRunner(processedFiles.length);
  const tasks = processedFiles.map(
    (file, index) =>
      ({
        file,
        index,
        totalFiles: processedFiles.length,
        encoding: tokenCounterEncoding,
      }) satisfies FileMetricsTask,
  );

  try {
    const startTime = process.hrtime.bigint();
    logger.trace(`Starting metrics calculation for ${processedFiles.length} files using worker pool`);

    let completedTasks = 0;
    const results = await Promise.all(
      tasks.map((task) =>
        runTask(task).then((result) => {
          completedTasks++;
          progressCallback(`Calculating metrics... (${completedTasks}/${task.totalFiles}) ${pc.dim(task.file.path)}`);
          logger.trace(`Calculating metrics... (${completedTasks}/${task.totalFiles}) ${task.file.path}`);
          return result;
        }),
      ),
    );

    const endTime = process.hrtime.bigint();
    const duration = Number(endTime - startTime) / 1e6;
    logger.trace(`Metrics calculation completed in ${duration.toFixed(2)}ms`);

    return results;
  } catch (error) {
    logger.error('Error during metrics calculation:', error);
    throw error;
  }
};

export const calculateSelectiveFileMetrics = async (
  processedFiles: ProcessedFile[],
  targetFilePaths: string[],
  tokenCounterEncoding: TiktokenEncoding,
  progressCallback: RepomixProgressCallback,
  deps = {
    initTaskRunner,
  },
): Promise<FileMetrics[]> => {
  const targetFileSet = new Set(targetFilePaths);
  const filesToProcess = processedFiles.filter((file) => targetFileSet.has(file.path));

  if (filesToProcess.length === 0) {
    return [];
  }

  const runTask = deps.initTaskRunner(filesToProcess.length);
  const tasks = filesToProcess.map(
    (file, index) =>
      ({
        file,
        index,
        totalFiles: filesToProcess.length,
        encoding: tokenCounterEncoding,
      }) satisfies FileMetricsTask,
  );

  try {
    const startTime = process.hrtime.bigint();
    logger.trace(`Starting selective metrics calculation for ${filesToProcess.length} files using worker pool`);

    let completedTasks = 0;
    const results = await Promise.all(
      tasks.map((task) =>
        runTask(task).then((result) => {
          completedTasks++;
          progressCallback(`Calculating metrics... (${completedTasks}/${task.totalFiles}) ${pc.dim(task.file.path)}`);
          logger.trace(`Calculating metrics... (${completedTasks}/${task.totalFiles}) ${task.file.path}`);
          return result;
        }),
      ),
    );

    const endTime = process.hrtime.bigint();
    const duration = Number(endTime - startTime) / 1e6;
    logger.trace(`Selective metrics calculation completed in ${duration.toFixed(2)}ms`);

    return results;
  } catch (error) {
    logger.error('Error during selective metrics calculation:', error);
    throw error;
  }
};
</file>

<file path="src/core/metrics/calculateMetrics.ts">
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import type { RepomixProgressCallback } from '../../shared/types.js';
import type { ProcessedFile } from '../file/fileTypes.js';
import type { GitDiffResult } from '../git/gitDiffHandle.js';
import { calculateAllFileMetrics, calculateSelectiveFileMetrics } from './calculateAllFileMetrics.js';
import { calculateOutputMetrics } from './calculateOutputMetrics.js';

export interface CalculateMetricsResult {
  totalFiles: number;
  totalCharacters: number;
  totalTokens: number;
  fileCharCounts: Record<string, number>;
  fileTokenCounts: Record<string, number>;
  gitDiffTokenCount: number;
}

import { TokenCounter } from './TokenCounter.js';

export const calculateMetrics = async (
  processedFiles: ProcessedFile[],
  output: string,
  progressCallback: RepomixProgressCallback,
  config: RepomixConfigMerged,
  gitDiffResult: GitDiffResult | undefined,
  deps = {
    calculateAllFileMetrics,
    calculateSelectiveFileMetrics,
    calculateOutputMetrics,
  },
): Promise<CalculateMetricsResult> => {
  progressCallback('Calculating metrics...');

  // Calculate token count for git diffs if included
  let gitDiffTokenCount = 0;
  if (config.output.git?.includeDiffs && gitDiffResult) {
    const tokenCounter = new TokenCounter(config.tokenCount.encoding);

    const countPromises = [];
    if (gitDiffResult.workTreeDiffContent) {
      countPromises.push(Promise.resolve().then(() => tokenCounter.countTokens(gitDiffResult.workTreeDiffContent)));
    }
    if (gitDiffResult.stagedDiffContent) {
      countPromises.push(Promise.resolve().then(() => tokenCounter.countTokens(gitDiffResult.stagedDiffContent)));
    }

    gitDiffTokenCount = (await Promise.all(countPromises)).reduce((sum, count) => sum + count, 0);
    tokenCounter.free();
  }

  // For top files display optimization: calculate token counts only for top files by character count
  const topFilesLength = config.output.topFilesLength;
  const candidateFilesCount = Math.min(processedFiles.length, Math.max(topFilesLength * 10, topFilesLength));

  // Get top files by character count first
  const topFilesByChar = [...processedFiles]
    .sort((a, b) => b.content.length - a.content.length)
    .slice(0, candidateFilesCount);

  const topFilePaths = topFilesByChar.map((file) => file.path);

  const [selectiveFileMetrics, totalTokens] = await Promise.all([
    deps.calculateSelectiveFileMetrics(processedFiles, topFilePaths, config.tokenCount.encoding, progressCallback),
    deps.calculateOutputMetrics(output, config.tokenCount.encoding, config.output.filePath),
  ]);

  const totalFiles = processedFiles.length;
  const totalCharacters = output.length;

  // Build character counts for all files
  const fileCharCounts: Record<string, number> = {};
  for (const file of processedFiles) {
    fileCharCounts[file.path] = file.content.length;
  }

  // Build token counts only for top files
  const fileTokenCounts: Record<string, number> = {};
  for (const file of selectiveFileMetrics) {
    fileTokenCounts[file.path] = file.tokenCount;
  }

  return {
    totalFiles,
    totalCharacters,
    totalTokens,
    fileCharCounts,
    fileTokenCounts,
    gitDiffTokenCount: gitDiffTokenCount,
  };
};
</file>

<file path="src/core/metrics/calculateOutputMetrics.ts">
import type { TiktokenEncoding } from 'tiktoken';
import { logger } from '../../shared/logger.js';
import { initPiscina } from '../../shared/processConcurrency.js';
import type { OutputMetricsTask } from './workers/outputMetricsWorker.js';

const CHUNK_SIZE = 1000;
const MIN_CONTENT_LENGTH_FOR_PARALLEL = 1_000_000; // 1000KB

const initTaskRunner = (numOfTasks: number) => {
  const pool = initPiscina(numOfTasks, new URL('./workers/outputMetricsWorker.js', import.meta.url).href);
  return (task: OutputMetricsTask) => pool.run(task);
};

export const calculateOutputMetrics = async (
  content: string,
  encoding: TiktokenEncoding,
  path?: string,
  deps = {
    initTaskRunner,
  },
): Promise<number> => {
  const shouldRunInParallel = content.length > MIN_CONTENT_LENGTH_FOR_PARALLEL;
  const numOfTasks = shouldRunInParallel ? CHUNK_SIZE : 1;
  const runTask = deps.initTaskRunner(numOfTasks);

  try {
    logger.trace(`Starting output token count for ${path || 'output'}`);
    const startTime = process.hrtime.bigint();

    let result: number;

    if (shouldRunInParallel) {
      // Split content into chunks for parallel processing
      const chunkSize = Math.ceil(content.length / CHUNK_SIZE);
      const chunks: string[] = [];

      for (let i = 0; i < content.length; i += chunkSize) {
        chunks.push(content.slice(i, i + chunkSize));
      }

      // Process chunks in parallel
      const chunkResults = await Promise.all(
        chunks.map((chunk, index) =>
          runTask({
            content: chunk,
            encoding,
            path: path ? `${path}-chunk-${index}` : undefined,
          }),
        ),
      );

      // Sum up the results
      result = chunkResults.reduce((sum, count) => sum + count, 0);
    } else {
      // Process small content directly
      result = await runTask({ content, encoding, path });
    }

    const endTime = process.hrtime.bigint();
    const duration = Number(endTime - startTime) / 1e6;
    logger.trace(`Output token count completed in ${duration.toFixed(2)}ms`);

    return result;
  } catch (error) {
    logger.error('Error during token count:', error);
    throw error;
  }
};
</file>

<file path="src/core/metrics/TokenCounter.ts">
import { type Tiktoken, type TiktokenEncoding, get_encoding } from 'tiktoken';
import { logger } from '../../shared/logger.js';

export class TokenCounter {
  private encoding: Tiktoken;

  constructor(encodingName: TiktokenEncoding) {
    // Setup encoding with the specified model
    this.encoding = get_encoding(encodingName);
  }

  public countTokens(content: string, filePath?: string): number {
    try {
      return this.encoding.encode(content).length;
    } catch (error) {
      let message = '';
      if (error instanceof Error) {
        message = error.message;
      } else {
        message = String(error);
      }

      if (filePath) {
        logger.warn(`Failed to count tokens. path: ${filePath}, error: ${message}`);
      } else {
        logger.warn(`Failed to count tokens. error: ${message}`);
      }

      return 0;
    }
  }

  public free(): void {
    this.encoding.free();
  }
}
</file>

<file path="src/core/output/outputStyles/markdownStyle.ts">
import Handlebars from 'handlebars';

export const getMarkdownTemplate = () => {
  return /* md */ `
{{#if fileSummaryEnabled}}
{{{generationHeader}}}

# File Summary

## Purpose
{{{summaryPurpose}}}

## File Format
{{{summaryFileFormat}}}
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
{{{summaryUsageGuidelines}}}

## Notes
{{{summaryNotes}}}

{{/if}}
{{#if headerText}}
# User Provided Header
{{{headerText}}}

{{/if}}
{{#if directoryStructureEnabled}}
# Directory Structure
\`\`\`
{{{treeString}}}
\`\`\`

{{/if}}
{{#if filesEnabled}}
# Files

{{#each processedFiles}}
## File: {{{this.path}}}
{{{../markdownCodeBlockDelimiter}}}{{{getFileExtension this.path}}}
{{{this.content}}}
{{{../markdownCodeBlockDelimiter}}}

{{/each}}
{{/if}}

{{#if gitDiffEnabled}}
# Git Diffs
## Git Diffs Working Tree
\`\`\`diff
{{{gitDiffWorkTree}}}
\`\`\`

## Git Diffs Staged
\`\`\`diff
{{{gitDiffStaged}}}
\`\`\`

{{/if}}

{{#if instruction}}
# Instruction
{{{instruction}}}
{{/if}}
`;
};

Handlebars.registerHelper('getFileExtension', (filePath) => {
  const extension = filePath.split('.').pop()?.toLowerCase();
  switch (extension) {
    case 'js':
    case 'jsx':
      return 'javascript';
    case 'ts':
    case 'tsx':
      return 'typescript';
    case 'vue':
      return 'vue';
    case 'py':
      return 'python';
    case 'rb':
      return 'ruby';
    case 'java':
      return 'java';
    case 'c':
    case 'cpp':
      return 'cpp';
    case 'cs':
      return 'csharp';
    case 'go':
      return 'go';
    case 'rs':
      return 'rust';
    case 'php':
      return 'php';
    case 'swift':
      return 'swift';
    case 'kt':
      return 'kotlin';
    case 'scala':
      return 'scala';
    case 'html':
      return 'html';
    case 'css':
      return 'css';
    case 'scss':
    case 'sass':
      return 'scss';
    case 'json':
      return 'json';
    case 'json5':
      return 'json5';
    case 'xml':
      return 'xml';
    case 'yaml':
    case 'yml':
      return 'yaml';
    case 'md':
      return 'markdown';
    case 'sh':
    case 'bash':
      return 'bash';
    case 'sql':
      return 'sql';
    case 'dockerfile':
      return 'dockerfile';
    case 'dart':
      return 'dart';
    case 'fs':
    case 'fsx':
      return 'fsharp';
    case 'r':
      return 'r';
    case 'pl':
    case 'pm':
      return 'perl';
    case 'lua':
      return 'lua';
    case 'groovy':
      return 'groovy';
    case 'hs':
      return 'haskell';
    case 'ex':
    case 'exs':
      return 'elixir';
    case 'erl':
      return 'erlang';
    case 'clj':
    case 'cljs':
      return 'clojure';
    case 'ps1':
      return 'powershell';
    case 'vb':
      return 'vb';
    case 'coffee':
      return 'coffeescript';
    case 'tf':
    case 'tfvars':
      return 'hcl';
    case 'proto':
      return 'protobuf';
    case 'pug':
      return 'pug';
    case 'graphql':
    case 'gql':
      return 'graphql';
    case 'toml':
      return 'toml';
    default:
      return '';
  }
});
</file>

<file path="src/core/output/outputStyles/plainStyle.ts">
const PLAIN_SEPARATOR = '='.repeat(16);
const PLAIN_LONG_SEPARATOR = '='.repeat(64);

export const getPlainTemplate = () => {
  return `
{{#if fileSummaryEnabled}}
{{{generationHeader}}}

${PLAIN_LONG_SEPARATOR}
File Summary
${PLAIN_LONG_SEPARATOR}

Purpose:
--------
{{{summaryPurpose}}}

File Format:
------------
{{{summaryFileFormat}}}
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
{{{summaryUsageGuidelines}}}

Notes:
------
{{{summaryNotes}}}

{{/if}}

{{#if headerText}}
${PLAIN_LONG_SEPARATOR}
User Provided Header
${PLAIN_LONG_SEPARATOR}
{{{headerText}}}

{{/if}}
{{#if directoryStructureEnabled}}
${PLAIN_LONG_SEPARATOR}
Directory Structure
${PLAIN_LONG_SEPARATOR}
{{{treeString}}}

{{/if}}
{{#if filesEnabled}}
${PLAIN_LONG_SEPARATOR}
Files
${PLAIN_LONG_SEPARATOR}

{{#each processedFiles}}
${PLAIN_SEPARATOR}
File: {{{this.path}}}
${PLAIN_SEPARATOR}
{{{this.content}}}

{{/each}}
{{/if}}

{{#if gitDiffEnabled}}
${PLAIN_LONG_SEPARATOR}
Git Diffs
${PLAIN_LONG_SEPARATOR}
${PLAIN_SEPARATOR}
{{{gitDiffWorkTree}}}
${PLAIN_SEPARATOR}

${PLAIN_SEPARATOR}
Git Diffs Staged
${PLAIN_SEPARATOR}
{{{gitDiffStaged}}}

{{/if}}

{{#if instruction}}
${PLAIN_LONG_SEPARATOR}
Instruction
${PLAIN_LONG_SEPARATOR}
{{{instruction}}}
{{/if}}

${PLAIN_LONG_SEPARATOR}
End of Codebase
${PLAIN_LONG_SEPARATOR}
`;
};
</file>

<file path="src/core/output/outputStyles/xmlStyle.ts">
export const getXmlTemplate = () => {
  return /* xml */ `
{{#if fileSummaryEnabled}}
{{{generationHeader}}}

<file_summary>
This section contains a summary of this file.

<purpose>
{{{summaryPurpose}}}
</purpose>

<file_format>
{{{summaryFileFormat}}}
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
{{{summaryUsageGuidelines}}}
</usage_guidelines>

<notes>
{{{summaryNotes}}}
</notes>

</file_summary>

{{/if}}
{{#if headerText}}
<user_provided_header>
{{{headerText}}}
</user_provided_header>

{{/if}}
{{#if directoryStructureEnabled}}
<directory_structure>
{{{treeString}}}
</directory_structure>

{{/if}}
{{#if filesEnabled}}
<files>
This section contains the contents of the repository's files.

{{#each processedFiles}}
<file path="{{{this.path}}}">
{{{this.content}}}
</file>

{{/each}}
</files>
{{/if}}

{{#if gitDiffEnabled}}
<git_diffs>
<git_diff_work_tree>
{{{gitDiffWorkTree}}}
</git_diff_work_tree>
<git_diff_staged>
{{{gitDiffStaged}}}
</git_diff_staged>
</git_diffs>
{{/if}}

{{#if instruction}}
<instruction>
{{{instruction}}}
</instruction>
{{/if}}
`;
};
</file>

<file path="src/core/output/outputGenerate.ts">
import fs from 'node:fs/promises';
import path from 'node:path';
import { XMLBuilder } from 'fast-xml-parser';
import Handlebars from 'handlebars';
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import { RepomixError } from '../../shared/errorHandle.js';
import { type FileSearchResult, searchFiles } from '../file/fileSearch.js';
import { generateTreeString } from '../file/fileTreeGenerate.js';
import type { ProcessedFile } from '../file/fileTypes.js';
import type { GitDiffResult } from '../git/gitDiffHandle.js';
import type { OutputGeneratorContext, RenderContext } from './outputGeneratorTypes.js';
import { sortOutputFiles } from './outputSort.js';
import {
  generateHeader,
  generateSummaryFileFormat,
  generateSummaryNotes,
  generateSummaryPurpose,
  generateSummaryUsageGuidelines,
} from './outputStyleDecorate.js';
import { getMarkdownTemplate } from './outputStyles/markdownStyle.js';
import { getPlainTemplate } from './outputStyles/plainStyle.js';
import { getXmlTemplate } from './outputStyles/xmlStyle.js';

const calculateMarkdownDelimiter = (files: ReadonlyArray<ProcessedFile>): string => {
  const maxBackticks = files
    .flatMap((file) => file.content.match(/`+/g) ?? [])
    .reduce((max, match) => Math.max(max, match.length), 0);
  return '`'.repeat(Math.max(3, maxBackticks + 1));
};

const createRenderContext = (outputGeneratorContext: OutputGeneratorContext): RenderContext => {
  return {
    generationHeader: generateHeader(outputGeneratorContext.config, outputGeneratorContext.generationDate),
    summaryPurpose: generateSummaryPurpose(),
    summaryFileFormat: generateSummaryFileFormat(),
    summaryUsageGuidelines: generateSummaryUsageGuidelines(
      outputGeneratorContext.config,
      outputGeneratorContext.instruction,
    ),
    summaryNotes: generateSummaryNotes(outputGeneratorContext.config),
    headerText: outputGeneratorContext.config.output.headerText,
    instruction: outputGeneratorContext.instruction,
    treeString: outputGeneratorContext.treeString,
    processedFiles: outputGeneratorContext.processedFiles,
    fileSummaryEnabled: outputGeneratorContext.config.output.fileSummary,
    directoryStructureEnabled: outputGeneratorContext.config.output.directoryStructure,
    filesEnabled: outputGeneratorContext.config.output.files,
    escapeFileContent: outputGeneratorContext.config.output.parsableStyle,
    markdownCodeBlockDelimiter: calculateMarkdownDelimiter(outputGeneratorContext.processedFiles),
    gitDiffEnabled: outputGeneratorContext.config.output.git?.includeDiffs,
    gitDiffWorkTree: outputGeneratorContext.gitDiffResult?.workTreeDiffContent,
    gitDiffStaged: outputGeneratorContext.gitDiffResult?.stagedDiffContent,
  };
};

const generateParsableXmlOutput = async (renderContext: RenderContext): Promise<string> => {
  const xmlBuilder = new XMLBuilder({ ignoreAttributes: false });
  const xmlDocument = {
    repomix: {
      file_summary: renderContext.fileSummaryEnabled
        ? {
            '#text': renderContext.generationHeader,
            purpose: renderContext.summaryPurpose,
            file_format: `${renderContext.summaryFileFormat}
5. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file`,
            usage_guidelines: renderContext.summaryUsageGuidelines,
            notes: renderContext.summaryNotes,
          }
        : undefined,
      user_provided_header: renderContext.headerText,
      directory_structure: renderContext.directoryStructureEnabled ? renderContext.treeString : undefined,
      files: renderContext.filesEnabled
        ? {
            '#text': "This section contains the contents of the repository's files.",
            file: renderContext.processedFiles.map((file) => ({
              '#text': file.content,
              '@_path': file.path,
            })),
          }
        : undefined,
      git_diffs: renderContext.gitDiffEnabled
        ? {
            git_diff_work_tree: renderContext.gitDiffWorkTree,
            git_diff_staged: renderContext.gitDiffStaged,
          }
        : undefined,
      instruction: renderContext.instruction ? renderContext.instruction : undefined,
    },
  };
  try {
    return xmlBuilder.build(xmlDocument);
  } catch (error) {
    throw new RepomixError(
      `Failed to generate XML output: ${error instanceof Error ? error.message : 'Unknown error'}`,
    );
  }
};

const generateHandlebarOutput = async (config: RepomixConfigMerged, renderContext: RenderContext): Promise<string> => {
  let template: string;
  switch (config.output.style) {
    case 'xml':
      template = getXmlTemplate();
      break;
    case 'markdown':
      template = getMarkdownTemplate();
      break;
    case 'plain':
      template = getPlainTemplate();
      break;
    default:
      throw new RepomixError(`Unknown output style: ${config.output.style}`);
  }

  try {
    const compiledTemplate = Handlebars.compile(template);
    return `${compiledTemplate(renderContext).trim()}\n`;
  } catch (error) {
    throw new RepomixError(`Failed to compile template: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
};

export const generateOutput = async (
  rootDirs: string[],
  config: RepomixConfigMerged,
  processedFiles: ProcessedFile[],
  allFilePaths: string[],
  gitDiffResult: GitDiffResult | undefined = undefined,
  deps = {
    buildOutputGeneratorContext,
    generateHandlebarOutput,
    generateParsableXmlOutput,
    sortOutputFiles,
  },
): Promise<string> => {
  // Sort processed files by git change count if enabled
  const sortedProcessedFiles = await deps.sortOutputFiles(processedFiles, config);

  const outputGeneratorContext = await deps.buildOutputGeneratorContext(
    rootDirs,
    config,
    allFilePaths,
    sortedProcessedFiles,
    gitDiffResult,
  );
  const renderContext = createRenderContext(outputGeneratorContext);

  if (!config.output.parsableStyle) return deps.generateHandlebarOutput(config, renderContext);
  switch (config.output.style) {
    case 'xml':
      return deps.generateParsableXmlOutput(renderContext);
    case 'markdown':
      return deps.generateHandlebarOutput(config, renderContext);
    default:
      return deps.generateHandlebarOutput(config, renderContext);
  }
};

export const buildOutputGeneratorContext = async (
  rootDirs: string[],
  config: RepomixConfigMerged,
  allFilePaths: string[],
  processedFiles: ProcessedFile[],
  gitDiffResult: GitDiffResult | undefined = undefined,
): Promise<OutputGeneratorContext> => {
  let repositoryInstruction = '';

  if (config.output.instructionFilePath) {
    const instructionPath = path.resolve(config.cwd, config.output.instructionFilePath);
    try {
      repositoryInstruction = await fs.readFile(instructionPath, 'utf-8');
    } catch {
      throw new RepomixError(`Instruction file not found at ${instructionPath}`);
    }
  }

  let emptyDirPaths: string[] = [];
  if (config.output.includeEmptyDirectories) {
    try {
      emptyDirPaths = (await Promise.all(rootDirs.map((rootDir) => searchFiles(rootDir, config)))).reduce(
        (acc: FileSearchResult, curr: FileSearchResult) =>
          ({
            filePaths: [...acc.filePaths, ...curr.filePaths],
            emptyDirPaths: [...acc.emptyDirPaths, ...curr.emptyDirPaths],
          }) as FileSearchResult,
        { filePaths: [], emptyDirPaths: [] },
      ).emptyDirPaths;
    } catch (error) {
      if (error instanceof Error) {
        throw new RepomixError(`Failed to search for empty directories: ${error.message}`);
      }
    }
  }

  return {
    generationDate: new Date().toISOString(),
    treeString: generateTreeString(allFilePaths, emptyDirPaths),
    processedFiles,
    config,
    instruction: repositoryInstruction,
    gitDiffResult,
  };
};
</file>

<file path="src/core/output/outputGeneratorTypes.ts">
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import type { ProcessedFile } from '../file/fileTypes.js';
import type { GitDiffResult } from '../git/gitDiffHandle.js';

export interface OutputGeneratorContext {
  generationDate: string;
  treeString: string;
  processedFiles: ProcessedFile[];
  config: RepomixConfigMerged;
  instruction: string;
  gitDiffResult: GitDiffResult | undefined;
}

export interface RenderContext {
  readonly generationHeader: string;
  readonly summaryPurpose: string;
  readonly summaryFileFormat: string;
  readonly summaryUsageGuidelines: string;
  readonly summaryNotes: string;
  readonly headerText: string | undefined;
  readonly instruction: string;
  readonly treeString: string;
  readonly processedFiles: ReadonlyArray<ProcessedFile>;
  readonly fileSummaryEnabled: boolean;
  readonly directoryStructureEnabled: boolean;
  readonly filesEnabled: boolean;
  readonly escapeFileContent: boolean;
  readonly markdownCodeBlockDelimiter: string;
  readonly gitDiffEnabled: boolean;
  readonly gitDiffWorkTree: string | undefined;
  readonly gitDiffStaged: string | undefined;
}
</file>

<file path="src/core/output/outputSort.ts">
import fs from 'node:fs/promises';
import path from 'node:path';
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import { logger } from '../../shared/logger.js';
import type { ProcessedFile } from '../file/fileTypes.js';
import { getFileChangeCount, isGitInstalled } from '../git/gitRepositoryHandle.js';

// Sort files by git change count for output
export const sortOutputFiles = async (
  files: ProcessedFile[],
  config: RepomixConfigMerged,
  deps = {
    getFileChangeCount,
    isGitInstalled,
  },
): Promise<ProcessedFile[]> => {
  // If git sort is not enabled, return original order
  if (!config.output.git?.sortByChanges) {
    logger.trace('Git sort is not enabled');
    return files;
  }

  // Check if Git is installed
  const gitInstalled = await deps.isGitInstalled();
  if (!gitInstalled) {
    logger.trace('Git is not installed');
    return files;
  }

  // If `.git` directory is not found, return original order
  const gitFolderPath = path.resolve(config.cwd, '.git');
  try {
    await fs.access(gitFolderPath);
  } catch {
    logger.trace('Git folder not found');
    return files;
  }

  try {
    // Get file change counts
    const fileChangeCounts = await deps.getFileChangeCount(config.cwd, config.output.git?.sortByChangesMaxCommits);

    const sortedFileChangeCounts = Object.entries(fileChangeCounts).sort((a, b) => b[1] - a[1]);
    logger.trace('Git File change counts max commits:', config.output.git?.sortByChangesMaxCommits);
    logger.trace('Git File change counts:', sortedFileChangeCounts);

    // Sort files by change count (files with more changes go to the bottom)
    return [...files].sort((a, b) => {
      const countA = fileChangeCounts[a.path] || 0;
      const countB = fileChangeCounts[b.path] || 0;
      return countA - countB;
    });
  } catch (error) {
    // If git command fails, return original order
    return files;
  }
};
</file>

<file path="src/core/output/outputStyleDecorate.ts">
import type { RepomixConfigMerged } from '../../config/configSchema.js';

interface ContentInfo {
  selection: {
    isEntireCodebase: boolean;
    include?: boolean;
    ignore?: boolean;
    gitignore?: boolean;
    defaultIgnore?: boolean;
  };
  processing: {
    commentsRemoved: boolean;
    emptyLinesRemoved: boolean;
    securityCheckEnabled: boolean;
    showLineNumbers: boolean;
    parsableStyle: boolean;
    compressed: boolean;
  };
  sorting: {
    gitChanges: boolean;
  };
}

export const analyzeContent = (config: RepomixConfigMerged): ContentInfo => {
  return {
    selection: {
      isEntireCodebase: !config.include.length && !config.ignore.customPatterns.length,
      include: config.include.length > 0,
      ignore: config.ignore.customPatterns.length > 0,
      gitignore: config.ignore.useGitignore,
      defaultIgnore: config.ignore.useDefaultPatterns,
    },
    processing: {
      commentsRemoved: config.output.removeComments,
      emptyLinesRemoved: config.output.removeEmptyLines,
      securityCheckEnabled: config.security.enableSecurityCheck,
      showLineNumbers: config.output.showLineNumbers,
      parsableStyle: config.output.parsableStyle,
      compressed: config.output.compress,
    },
    sorting: {
      gitChanges: config.output.git?.sortByChanges ?? false,
    },
  };
};

export const generateHeader = (config: RepomixConfigMerged, generationDate: string): string => {
  const info = analyzeContent(config);

  // Generate selection description
  let description: string;
  if (info.selection.isEntireCodebase) {
    description = 'This file is a merged representation of the entire codebase';
  } else {
    const parts = [];
    if (info.selection.include) {
      parts.push('specifically included files');
    }
    if (info.selection.ignore) {
      parts.push('files not matching ignore patterns');
    }
    description = `This file is a merged representation of a subset of the codebase, containing ${parts.join(' and ')}`;
  }

  // Add processing information
  const processingNotes = [];
  if (info.processing.commentsRemoved) {
    processingNotes.push('comments have been removed');
  }
  if (info.processing.emptyLinesRemoved) {
    processingNotes.push('empty lines have been removed');
  }
  if (info.processing.showLineNumbers) {
    processingNotes.push('line numbers have been added');
  }
  if (info.processing.parsableStyle) {
    processingNotes.push(`content has been formatted for parsing in ${config.output.style} style`);
  }
  if (info.processing.compressed) {
    processingNotes.push('content has been compressed (code blocks are separated by ⋮---- delimiter)');
  }
  if (!info.processing.securityCheckEnabled) {
    processingNotes.push('security check has been disabled');
  }

  const processingInfo =
    processingNotes.length > 0 ? `The content has been processed where ${processingNotes.join(', ')}.` : '';

  return `${description}, combined into a single document by Repomix.\n${processingInfo}`.trim();
};

export const generateSummaryPurpose = (): string => {
  return `
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
`.trim();
};

export const generateSummaryFileFormat = (): string => {
  return `
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
`.trim();
};

export const generateSummaryUsageGuidelines = (config: RepomixConfigMerged, repositoryInstruction: string): string => {
  return `
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
${config.output.headerText ? '- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.' : ''}
${repositoryInstruction ? '- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.' : ''}
`.trim();
};

export const generateSummaryNotes = (config: RepomixConfigMerged): string => {
  const info = analyzeContent(config);
  const notes = [
    "- Some files may have been excluded based on .gitignore rules and Repomix's configuration",
    '- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files',
  ];

  // File selection notes
  if (info.selection.include) {
    notes.push(`- Only files matching these patterns are included: ${config.include.join(', ')}`);
  }
  if (info.selection.ignore) {
    notes.push(`- Files matching these patterns are excluded: ${config.ignore.customPatterns.join(', ')}`);
  }
  if (info.selection.gitignore) {
    notes.push('- Files matching patterns in .gitignore are excluded');
  }
  if (info.selection.defaultIgnore) {
    notes.push('- Files matching default ignore patterns are excluded');
  }

  // Processing notes
  if (info.processing.commentsRemoved) {
    notes.push('- Code comments have been removed from supported file types');
  }
  if (info.processing.emptyLinesRemoved) {
    notes.push('- Empty lines have been removed from all files');
  }
  if (info.processing.showLineNumbers) {
    notes.push('- Line numbers have been added to the beginning of each line');
  }
  if (info.processing.parsableStyle) {
    notes.push(`- Content has been formatted for parsing in ${config.output.style} style`);
  }
  if (info.processing.compressed) {
    notes.push('- Content has been compressed - code blocks are separated by ⋮---- delimiter');
  }
  if (!info.processing.securityCheckEnabled) {
    notes.push('- Security check has been disabled - content may contain sensitive information');
  }

  // Sorting notes
  if (info.sorting.gitChanges) {
    notes.push('- Files are sorted by Git change count (files with more changes are at the bottom)');
  }

  // Git diffs notes
  if (config.output.git?.includeDiffs) {
    notes.push('- Git diffs from the worktree and staged changes are included');
  }

  return notes.join('\n');
};
</file>

<file path="src/core/packager/copyToClipboardIfEnabled.ts">
import { spawn } from 'node:child_process';
import clipboard from 'clipboardy';
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import { logger } from '../../shared/logger.js';
import type { RepomixProgressCallback } from '../../shared/types.js';

export const copyToClipboardIfEnabled = async (
  output: string,
  progressCallback: RepomixProgressCallback,
  config: RepomixConfigMerged,
): Promise<void> => {
  if (!config.output.copyToClipboard) return;
  progressCallback('Copying to clipboard...');

  if (process.env.NODE_ENV !== 'test' && process.env.WAYLAND_DISPLAY) {
    logger.trace('Wayland detected; attempting wl-copy.');
    try {
      await new Promise<void>((resolve, reject) => {
        const proc = spawn('wl-copy', [], { stdio: ['pipe', 'ignore', 'ignore'] });
        proc.on('error', (err) => reject(new Error(`Failed to execute wl-copy: ${err.message}`)));
        proc.on('close', (code) => (code ? reject(new Error(`wl-copy exited with code ${code}`)) : resolve()));
        proc.stdin.end(output);
      });
      logger.trace('Copied using wl-copy.');
      return;
    } catch (err: unknown) {
      const msg = err instanceof Error ? err.message : 'unknown error';
      logger.warn(`wl-copy failed (${msg}); falling back.`);
    }
  }

  try {
    logger.trace('Using clipboardy.');
    await clipboard.write(output);
    logger.trace('Copied using clipboardy.');
  } catch (err: unknown) {
    const msg = err instanceof Error ? err.message : 'unknown error';
    logger.error(`clipboardy failed: ${msg}`);
  }
};
</file>

<file path="src/core/packager/writeOutputToDisk.ts">
import fs from 'node:fs/promises';
import path from 'node:path';
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import { logger } from '../../shared/logger.js';

// Write output to file or stdout
export const writeOutputToDisk = async (output: string, config: RepomixConfigMerged): Promise<undefined> => {
  // Write to stdout
  if (config.output.stdout === true) {
    process.stdout.write(output);
    return;
  }

  // Normal case: write to file
  const outputPath = path.resolve(config.cwd, config.output.filePath);
  logger.trace(`Writing output to: ${outputPath}`);

  // Create output directory if it doesn't exist
  await fs.mkdir(path.dirname(outputPath), { recursive: true });

  await fs.writeFile(outputPath, output);
};
</file>

<file path="src/core/security/workers/securityCheckWorker.ts">
import { lintSource } from '@secretlint/core';
import { creator } from '@secretlint/secretlint-rule-preset-recommend';
import type { SecretLintCoreConfig } from '@secretlint/types';
import { logger, setLogLevelByEnv } from '../../../shared/logger.js';

// Security check type to distinguish between regular files and git diffs
export type SecurityCheckType = 'file' | 'gitDiff';

export interface SecurityCheckTask {
  filePath: string;
  content: string;
  type: SecurityCheckType;
}

export interface SuspiciousFileResult {
  filePath: string;
  messages: string[];
  type: SecurityCheckType;
}

// Set logger log level from environment variable if provided
setLogLevelByEnv();

export default async ({ filePath, content, type }: SecurityCheckTask) => {
  const config = createSecretLintConfig();

  try {
    const processStartAt = process.hrtime.bigint();
    const secretLintResult = await runSecretLint(filePath, content, type, config);
    const processEndAt = process.hrtime.bigint();

    logger.trace(
      `Checked security on ${filePath}. Took: ${(Number(processEndAt - processStartAt) / 1e6).toFixed(2)}ms`,
    );

    return secretLintResult;
  } catch (error) {
    logger.error(`Error checking security on ${filePath}:`, error);
    throw error;
  }
};

export const runSecretLint = async (
  filePath: string,
  content: string,
  type: SecurityCheckType,
  config: SecretLintCoreConfig,
): Promise<SuspiciousFileResult | null> => {
  const result = await lintSource({
    source: {
      filePath: filePath,
      content: content,
      ext: filePath.split('.').pop() || '',
      contentType: 'text',
    },
    options: {
      config: config,
    },
  });

  if (result.messages.length > 0) {
    logger.trace(`Found ${result.messages.length} issues in ${filePath}`);
    logger.trace(result.messages.map((message) => `  - ${message.message}`).join('\n'));

    return {
      filePath,
      messages: result.messages.map((message) => message.message),
      type,
    };
  }

  return null;
};

export const createSecretLintConfig = (): SecretLintCoreConfig => ({
  rules: [
    {
      id: '@secretlint/secretlint-rule-preset-recommend',
      rule: creator,
    },
  ],
});
</file>

<file path="src/core/security/filterOutUntrustedFiles.ts">
import type { RawFile } from '../file/fileTypes.js';
import type { SuspiciousFileResult } from './securityCheck.js';

export const filterOutUntrustedFiles = (
  rawFiles: RawFile[],
  suspiciousFilesResults: SuspiciousFileResult[],
): RawFile[] =>
  rawFiles.filter((rawFile) => !suspiciousFilesResults.some((result) => result.filePath === rawFile.path));
</file>

<file path="src/core/security/securityCheck.ts">
import pc from 'picocolors';
import { logger } from '../../shared/logger.js';
import { initPiscina } from '../../shared/processConcurrency.js';
import type { RepomixProgressCallback } from '../../shared/types.js';
import type { RawFile } from '../file/fileTypes.js';
import type { GitDiffResult } from '../git/gitDiffHandle.js';
import type { SecurityCheckTask, SecurityCheckType } from './workers/securityCheckWorker.js';

export interface SuspiciousFileResult {
  filePath: string;
  messages: string[];
  type: SecurityCheckType;
}

const initTaskRunner = (numOfTasks: number) => {
  const pool = initPiscina(numOfTasks, new URL('./workers/securityCheckWorker.js', import.meta.url).href);
  return (task: SecurityCheckTask) => pool.run(task);
};

export const runSecurityCheck = async (
  rawFiles: RawFile[],
  progressCallback: RepomixProgressCallback = () => {},
  gitDiffResult?: GitDiffResult,
  deps = {
    initTaskRunner,
  },
): Promise<SuspiciousFileResult[]> => {
  const gitDiffTasks: SecurityCheckTask[] = [];

  // Add Git diff content for security checking if available
  if (gitDiffResult) {
    if (gitDiffResult.workTreeDiffContent) {
      gitDiffTasks.push({
        filePath: 'Working tree changes',
        content: gitDiffResult.workTreeDiffContent,
        type: 'gitDiff',
      });
    }

    if (gitDiffResult.stagedDiffContent) {
      gitDiffTasks.push({
        filePath: 'Staged changes',
        content: gitDiffResult.stagedDiffContent,
        type: 'gitDiff',
      });
    }
  }

  const runTask = deps.initTaskRunner(rawFiles.length + gitDiffTasks.length);
  const fileTasks = rawFiles.map(
    (file) =>
      ({
        filePath: file.path,
        content: file.content,
        type: 'file',
      }) satisfies SecurityCheckTask,
  );

  // Combine file tasks and Git diff tasks
  const tasks = [...fileTasks, ...gitDiffTasks];

  try {
    logger.trace(`Starting security check for ${tasks.length} files/content`);
    const startTime = process.hrtime.bigint();

    let completedTasks = 0;
    const totalTasks = tasks.length;

    const results = await Promise.all(
      tasks.map((task) =>
        runTask(task).then((result) => {
          completedTasks++;
          progressCallback(`Running security check... (${completedTasks}/${totalTasks}) ${pc.dim(task.filePath)}`);
          logger.trace(`Running security check... (${completedTasks}/${totalTasks}) ${task.filePath}`);
          return result;
        }),
      ),
    );

    const endTime = process.hrtime.bigint();
    const duration = Number(endTime - startTime) / 1e6;
    logger.trace(`Security check completed in ${duration.toFixed(2)}ms`);

    return results.filter((result): result is SuspiciousFileResult => result !== null);
  } catch (error) {
    logger.error('Error during security check:', error);
    throw error;
  }
};
</file>

<file path="src/core/security/validateFileSafety.ts">
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import { logger } from '../../shared/logger.js';
import type { RepomixProgressCallback } from '../../shared/types.js';
import type { ProcessedFile, RawFile } from '../file/fileTypes.js';
import type { GitDiffResult } from '../git/gitDiffHandle.js';
import { filterOutUntrustedFiles } from './filterOutUntrustedFiles.js';
import { type SuspiciousFileResult, runSecurityCheck } from './securityCheck.js';

// Marks which files are suspicious and which are safe
// Returns Git diff results separately so they can be included in the output
// even if they contain sensitive information
export const validateFileSafety = async (
  rawFiles: RawFile[],
  progressCallback: RepomixProgressCallback,
  config: RepomixConfigMerged,
  gitDiffResult?: GitDiffResult,
  deps = {
    runSecurityCheck,
    filterOutUntrustedFiles,
  },
) => {
  let suspiciousFilesResults: SuspiciousFileResult[] = [];
  let suspiciousGitDiffResults: SuspiciousFileResult[] = [];

  if (config.security.enableSecurityCheck) {
    progressCallback('Running security check...');
    const allResults = await deps.runSecurityCheck(rawFiles, progressCallback, gitDiffResult);

    // Separate Git diff results from regular file results
    suspiciousFilesResults = allResults.filter((result) => result.type === 'file');
    suspiciousGitDiffResults = allResults.filter((result) => result.type === 'gitDiff');

    if (suspiciousGitDiffResults.length > 0) {
      logger.warn('Security issues found in Git diffs, but they will still be included in the output');
      for (const result of suspiciousGitDiffResults) {
        logger.warn(`  - ${result.filePath}: ${result.messages.join(', ')}`);
      }
    }
  }

  const safeRawFiles = deps.filterOutUntrustedFiles(rawFiles, suspiciousFilesResults);
  const safeFilePaths = safeRawFiles.map((file) => file.path);
  logger.trace('Safe files count:', safeRawFiles.length);

  return {
    safeRawFiles,
    safeFilePaths,
    suspiciousFilesResults,
    suspiciousGitDiffResults,
  };
};
</file>

<file path="src/core/treeSitter/parseStrategies/CssParseStrategy.ts">
import type { SyntaxNode } from 'web-tree-sitter';
import type { ParseContext, ParseStrategy } from './ParseStrategy.js';

export class CssParseStrategy implements ParseStrategy {
  parseCapture(
    capture: { node: SyntaxNode; name: string },
    lines: string[],
    processedChunks: Set<string>,
    context: ParseContext,
  ): string | null {
    const { node, name } = capture;
    const startRow = node.startPosition.row;
    const endRow = node.endPosition.row;

    if (!lines[startRow]) {
      return null;
    }

    // Process CSS-specific capture names
    const isCommentCapture = name.includes('comment');
    const isSelectorCapture = name.includes('selector') || name.includes('definition.selector');
    const isAtRuleCapture = name.includes('at_rule') || name.includes('definition.at_rule');

    const shouldSelect = isCommentCapture || isSelectorCapture || isAtRuleCapture;

    if (!shouldSelect) {
      return null;
    }

    // Extract all lines for comments, only the first line for others
    let selectedLines: string[];
    if (isCommentCapture) {
      selectedLines = lines.slice(startRow, endRow + 1);
    } else {
      // For selectors and at-rules, extract only the first line
      selectedLines = [lines[startRow]];
    }

    if (selectedLines.length < 1) {
      return null;
    }

    const chunk = selectedLines.join('\n');
    const normalizedChunk = chunk.trim();

    if (processedChunks.has(normalizedChunk)) {
      return null;
    }

    processedChunks.add(normalizedChunk);
    return chunk;
  }
}
</file>

<file path="src/core/treeSitter/parseStrategies/DefaultParseStrategy.ts">
import type { SyntaxNode } from 'web-tree-sitter';
import type { ParseContext, ParseStrategy } from './ParseStrategy.js';

export class DefaultParseStrategy implements ParseStrategy {
  parseCapture(
    capture: { node: SyntaxNode; name: string },
    lines: string[],
    processedChunks: Set<string>,
    context: ParseContext,
  ): string | null {
    const { node, name } = capture;
    const startRow = node.startPosition.row;
    const endRow = node.endPosition.row;

    if (!lines[startRow]) {
      return null;
    }

    const isNameCapture = name.includes('name');
    const isCommentCapture = name.includes('comment');
    const isImportCapture = name.includes('import') || name.includes('require');
    const shouldSelect = isNameCapture || isCommentCapture || isImportCapture;

    if (!shouldSelect) {
      return null;
    }

    const selectedLines = lines.slice(startRow, endRow + 1);
    if (selectedLines.length < 1) {
      return null;
    }

    const chunk = selectedLines.join('\n');
    const normalizedChunk = chunk.trim();

    if (processedChunks.has(normalizedChunk)) {
      return null;
    }

    processedChunks.add(normalizedChunk);
    return chunk;
  }
}
</file>

<file path="src/core/treeSitter/parseStrategies/GoParseStrategy.ts">
import type { SyntaxNode } from 'web-tree-sitter';
import type { ParseContext, ParseStrategy } from './ParseStrategy.js';

enum CaptureType {
  Comment = 'comment',
  Type = 'definition.type',
  Interface = 'definition.interface',
  Struct = 'definition.struct',
  Package = 'definition.package',
  Import = 'definition.import',
  Function = 'definition.function',
  Method = 'definition.method',
  Module = 'definition.module',
  Variable = 'definition.variable',
  Constant = 'definition.constant',
}

type ParseResult = {
  content: string | null;
  processedSignatures?: Set<string>;
};

export class GoParseStrategy implements ParseStrategy {
  parseCapture(
    capture: { node: SyntaxNode; name: string },
    lines: string[],
    processedChunks: Set<string>,
    context: ParseContext,
  ): string | null {
    const { node, name } = capture;
    const startRow = node.startPosition.row;
    const endRow = node.endPosition.row;

    if (!lines[startRow]) {
      return null;
    }

    const captureTypes = this.getCaptureType(name);

    // Comments
    if (captureTypes.has(CaptureType.Comment)) {
      return this.parseBlockDeclaration(lines, startRow, endRow, processedChunks).content;
    }

    // Package declarations
    if (captureTypes.has(CaptureType.Package) || captureTypes.has(CaptureType.Module)) {
      return this.parseSimpleDeclaration(lines, startRow, processedChunks).content;
    }

    // Import declarations
    if (captureTypes.has(CaptureType.Import)) {
      return lines[startRow].includes('(')
        ? this.parseBlockDeclaration(lines, startRow, endRow, processedChunks).content
        : this.parseSimpleDeclaration(lines, startRow, processedChunks).content;
    }

    // Variable declarations
    if (captureTypes.has(CaptureType.Variable)) {
      return this.parseBlockDeclaration(lines, startRow, endRow, processedChunks).content;
    }

    // Constant declarations
    if (captureTypes.has(CaptureType.Constant)) {
      return this.parseBlockDeclaration(lines, startRow, endRow, processedChunks).content;
    }

    // Type definitions
    if (
      captureTypes.has(CaptureType.Type) ||
      captureTypes.has(CaptureType.Interface) ||
      captureTypes.has(CaptureType.Struct)
    ) {
      return this.parseTypeDefinition(lines, startRow, endRow, processedChunks).content;
    }

    // Function declarations
    if (captureTypes.has(CaptureType.Function)) {
      return this.parseFunctionOrMethod(lines, startRow, endRow, processedChunks, false).content;
    }

    // Method declarations
    if (captureTypes.has(CaptureType.Method)) {
      return this.parseFunctionOrMethod(lines, startRow, endRow, processedChunks, true).content;
    }

    return null;
  }

  private getCaptureType(name: string): Set<CaptureType> {
    const types = new Set<CaptureType>();
    for (const type of Object.values(CaptureType)) {
      if (name.includes(type)) {
        types.add(type);
      }
    }
    return types;
  }

  private getFunctionName(lines: string[], startRow: number): string | null {
    const line = lines[startRow];
    // "func funcName(" pattern detection
    const match = line.match(/func\s+([A-Za-z0-9_]+)\s*\(/);
    if (match?.[1]) {
      return match[1];
    }
    return null;
  }

  // Helper to get method name including receiver type
  private getMethodWithReceiver(lines: string[], startRow: number): string | null {
    const line = lines[startRow];
    // "func (r ReceiverType) methodName(" pattern detection
    const match = line.match(/func\s+\(([^)]+)\)\s+([A-Za-z0-9_]+)\s*\(/);
    if (match?.[2]) {
      return match[2];
    }
    return null;
  }

  private findClosingToken(
    lines: string[],
    startRow: number,
    endRow: number,
    openToken: string,
    closeToken: string,
  ): number {
    for (let i = startRow; i <= endRow; i++) {
      if (lines[i].includes(closeToken)) {
        return i;
      }
    }
    return startRow;
  }

  private parseSimpleDeclaration(lines: string[], startRow: number, processedChunks: Set<string>): ParseResult {
    const declaration = lines[startRow].trim();
    if (processedChunks.has(declaration)) {
      return { content: null };
    }
    processedChunks.add(declaration);
    return { content: declaration };
  }

  private parseBlockDeclaration(
    lines: string[],
    startRow: number,
    endRow: number,
    processedChunks: Set<string>,
  ): ParseResult {
    const blockEndRow = lines[startRow].includes('(')
      ? this.findClosingToken(lines, startRow, endRow, '(', ')')
      : endRow;

    const declaration = lines.slice(startRow, blockEndRow + 1).join('\n');
    if (processedChunks.has(declaration)) {
      return { content: null };
    }
    processedChunks.add(declaration);
    return { content: declaration };
  }

  private parseFunctionOrMethod(
    lines: string[],
    startRow: number,
    endRow: number,
    processedChunks: Set<string>,
    isMethod: boolean,
  ): ParseResult {
    const nameKey = isMethod ? 'method' : 'func';
    const getName = isMethod ? this.getMethodWithReceiver : this.getFunctionName;
    const name = getName.call(this, lines, startRow);

    if (name && processedChunks.has(`${nameKey}:${name}`)) {
      return { content: null };
    }

    const signatureEndRow = this.findClosingToken(lines, startRow, endRow, '{', '{');
    const signature = lines
      .slice(startRow, signatureEndRow + 1)
      .join('\n')
      .trim();
    const cleanSignature = signature.split('{')[0].trim();

    if (processedChunks.has(cleanSignature)) {
      return { content: null };
    }

    processedChunks.add(cleanSignature);
    if (name) {
      processedChunks.add(`${nameKey}:${name}`);
    }
    return { content: cleanSignature };
  }

  private parseTypeDefinition(
    lines: string[],
    startRow: number,
    endRow: number,
    processedChunks: Set<string>,
  ): ParseResult {
    const signatureEndRow = lines[startRow].includes('{')
      ? this.findClosingToken(lines, startRow, endRow, '{', '}')
      : endRow;

    const definition = lines.slice(startRow, signatureEndRow + 1).join('\n');
    if (processedChunks.has(definition)) {
      return { content: null };
    }
    processedChunks.add(definition);
    return { content: definition };
  }
}
</file>

<file path="src/core/treeSitter/parseStrategies/ParseStrategy.ts">
import type { Query, SyntaxNode, Tree } from 'web-tree-sitter';
import type { RepomixConfigMerged } from '../../../config/configSchema.js';
import type { SupportedLang } from '../lang2Query.js';
import { CssParseStrategy } from './CssParseStrategy.js';
import { DefaultParseStrategy } from './DefaultParseStrategy.js';
import { GoParseStrategy } from './GoParseStrategy.js';
import { PythonParseStrategy } from './PythonParseStrategy.js';
import { TypeScriptParseStrategy } from './TypeScriptParseStrategy.js';
import { VueParseStrategy } from './VueParseStrategy.js';

export interface ParseContext {
  fileContent: string;
  lines: string[];
  tree: Tree;
  query: Query;
  config: RepomixConfigMerged;
}

export interface ParseStrategy {
  parseCapture(
    capture: { node: SyntaxNode; name: string },
    lines: string[],
    processedChunks: Set<string>,
    context: ParseContext,
  ): string | null;
}

export function createParseStrategy(lang: SupportedLang): ParseStrategy {
  switch (lang) {
    case 'typescript':
      return new TypeScriptParseStrategy();
    case 'python':
      return new PythonParseStrategy();
    case 'go':
      return new GoParseStrategy();
    case 'css':
      return new CssParseStrategy();
    case 'vue':
      return new VueParseStrategy();
    default:
      return new DefaultParseStrategy();
  }
}
</file>

<file path="src/core/treeSitter/parseStrategies/PythonParseStrategy.ts">
import type { SyntaxNode } from 'web-tree-sitter';
import type { ParseContext, ParseStrategy } from './ParseStrategy.js';

enum CaptureType {
  Comment = 'comment',
  Class = 'definition.class',
  Function = 'definition.function',
  Docstring = 'docstring',
  TypeAlias = 'definition.type_alias',
}

type ParseResult = {
  content: string | null;
  processedSignatures?: Set<string>;
};

export class PythonParseStrategy implements ParseStrategy {
  parseCapture(
    capture: { node: SyntaxNode; name: string },
    lines: string[],
    processedChunks: Set<string>,
    context: ParseContext,
  ): string | null {
    const { node, name } = capture;
    const startRow = node.startPosition.row;
    const endRow = node.endPosition.row;

    if (!lines[startRow]) {
      return null;
    }

    const captureTypes = this.getCaptureType(name);

    // Class definition
    if (captureTypes.has(CaptureType.Class)) {
      return this.parseClassDefinition(lines, startRow, processedChunks).content;
    }

    // Function definition
    if (captureTypes.has(CaptureType.Function)) {
      return this.parseFunctionDefinition(lines, startRow, processedChunks).content;
    }

    // Docstring
    if (captureTypes.has(CaptureType.Docstring)) {
      return this.parseDocstringOrComment(lines, startRow, endRow, processedChunks).content;
    }

    // Comment
    if (captureTypes.has(CaptureType.Comment)) {
      return this.parseDocstringOrComment(lines, startRow, endRow, processedChunks).content;
    }

    // Type alias
    if (captureTypes.has(CaptureType.TypeAlias)) {
      return this.parseTypeAlias(lines, startRow, processedChunks).content;
    }

    return null;
  }

  private getCaptureType(name: string): Set<CaptureType> {
    const types = new Set<CaptureType>();
    for (const type of Object.values(CaptureType)) {
      if (name.includes(type)) {
        types.add(type);
      }
    }
    return types;
  }

  private getDecorators(lines: string[], startRow: number): string[] {
    const decorators: string[] = [];
    let currentRow = startRow - 1;

    while (currentRow >= 0) {
      const line = lines[currentRow].trim();
      if (line.startsWith('@')) {
        decorators.unshift(line); // Add to beginning to maintain order
      } else {
        break;
      }
      currentRow--;
    }

    return decorators;
  }

  private getClassInheritance(lines: string[], startRow: number): string | null {
    const line = lines[startRow];
    const match = line.match(/class\s+\w+\s*\((.*?)\):/);
    return match ? line.replace(/:\s*$/, '') : line.replace(/:\s*$/, '');
  }

  private getFunctionSignature(lines: string[], startRow: number): string | null {
    const line = lines[startRow];
    const match = line.match(/def\s+(\w+)\s*\((.*?)\)(\s*->\s*[^:]+)?:/);
    if (!match) return null;
    return line.replace(/:\s*$/, '');
  }

  private parseClassDefinition(lines: string[], startRow: number, processedChunks: Set<string>): ParseResult {
    const decorators = this.getDecorators(lines, startRow);
    const classDefinition = this.getClassInheritance(lines, startRow);
    const fullDefinition = [...decorators, classDefinition].join('\n');

    if (processedChunks.has(fullDefinition)) {
      return { content: null };
    }

    processedChunks.add(fullDefinition);
    return { content: fullDefinition };
  }

  private parseFunctionDefinition(lines: string[], startRow: number, processedChunks: Set<string>): ParseResult {
    const decorators = this.getDecorators(lines, startRow);
    const signature = this.getFunctionSignature(lines, startRow);

    if (!signature) {
      return { content: null };
    }

    const fullDefinition = [...decorators, signature].join('\n');
    if (processedChunks.has(fullDefinition)) {
      return { content: null };
    }

    processedChunks.add(fullDefinition);
    return { content: fullDefinition };
  }

  private parseDocstringOrComment(
    lines: string[],
    startRow: number,
    endRow: number,
    processedChunks: Set<string>,
  ): ParseResult {
    const content = lines.slice(startRow, endRow + 1).join('\n');

    if (processedChunks.has(content)) {
      return { content: null };
    }

    processedChunks.add(content);
    return { content };
  }

  private parseTypeAlias(lines: string[], startRow: number, processedChunks: Set<string>): ParseResult {
    const typeAlias = lines[startRow].trim();

    if (processedChunks.has(typeAlias)) {
      return { content: null };
    }

    processedChunks.add(typeAlias);
    return { content: typeAlias };
  }
}
</file>

<file path="src/core/treeSitter/parseStrategies/TypeScriptParseStrategy.ts">
import type { SyntaxNode } from 'web-tree-sitter';
import type { ParseContext, ParseStrategy } from './ParseStrategy.js';

enum CaptureType {
  Comment = 'comment',
  Interface = 'definition.interface',
  Type = 'definition.type',
  Enum = 'definition.enum',
  Class = 'definition.class',
  Import = 'definition.import',
  Function = 'definition.function',
  Method = 'definition.method',
  Property = 'definition.property',
}

type ParseResult = {
  content: string | null;
  processedSignatures?: Set<string>;
};

export class TypeScriptParseStrategy implements ParseStrategy {
  private static readonly FUNCTION_NAME_PATTERN = /(?:export\s+)?(?:const|let|var)\s+([a-zA-Z0-9_$]+)\s*=/;

  parseCapture(
    capture: { node: SyntaxNode; name: string },
    lines: string[],
    processedChunks: Set<string>,
    context: ParseContext,
  ): string | null {
    const { node, name } = capture;
    const startRow = node.startPosition.row;
    const endRow = node.endPosition.row;

    if (!lines[startRow]) {
      return null;
    }

    const captureTypes = this.getCaptureType(name);

    // Function capture
    if (captureTypes.has(CaptureType.Function) || captureTypes.has(CaptureType.Method)) {
      return this.parseFunctionDefinition(lines, startRow, endRow, processedChunks).content;
    }

    // Class capture
    if (captureTypes.has(CaptureType.Class)) {
      return this.parseClassDefinition(lines, startRow, endRow, processedChunks).content;
    }

    // Type definition or import capture
    if (
      captureTypes.has(CaptureType.Interface) ||
      captureTypes.has(CaptureType.Type) ||
      captureTypes.has(CaptureType.Enum) ||
      captureTypes.has(CaptureType.Import)
    ) {
      return this.parseTypeOrImport(lines, startRow, endRow, processedChunks).content;
    }

    // Comment capture
    if (captureTypes.has(CaptureType.Comment)) {
      return lines
        .slice(startRow, endRow + 1)
        .join('\n')
        .trim();
    }

    return null;
  }

  private getFunctionName(lines: string[], startRow: number): string | null {
    const line = lines[startRow];
    const match = line.match(TypeScriptParseStrategy.FUNCTION_NAME_PATTERN);
    return match?.[1] ?? null;
  }

  private getCaptureType(name: string): Set<CaptureType> {
    const types = new Set<CaptureType>();
    for (const type of Object.values(CaptureType)) {
      if (name.includes(type)) {
        types.add(type);
      }
    }
    return types;
  }

  private parseFunctionDefinition(
    lines: string[],
    startRow: number,
    endRow: number,
    processedChunks: Set<string>,
  ): ParseResult {
    const functionName = this.getFunctionName(lines, startRow);
    if (functionName && processedChunks.has(`func:${functionName}`)) {
      return { content: null };
    }

    const signatureEndRow = this.findSignatureEnd(lines, startRow, endRow);
    const selectedLines = lines.slice(startRow, signatureEndRow + 1);
    const cleanedSignature = this.cleanFunctionSignature(selectedLines);

    if (processedChunks.has(cleanedSignature)) {
      return { content: null };
    }

    processedChunks.add(cleanedSignature);
    if (functionName) {
      processedChunks.add(`func:${functionName}`);
    }

    return { content: cleanedSignature };
  }

  private findSignatureEnd(lines: string[], startRow: number, endRow: number): number {
    for (let i = startRow; i <= endRow; i++) {
      const line = lines[i].trim();
      if (line.includes(')') && (line.endsWith('{') || line.endsWith('=>') || line.endsWith(';'))) {
        return i;
      }
    }
    return startRow;
  }

  private cleanFunctionSignature(lines: string[]): string {
    const result = [...lines];
    const lastLineIndex = result.length - 1;
    const lastLine = result[lastLineIndex];

    if (lastLine) {
      if (lastLine.includes('{')) {
        result[lastLineIndex] = lastLine.substring(0, lastLine.indexOf('{')).trim();
      } else if (lastLine.includes('=>')) {
        result[lastLineIndex] = lastLine.substring(0, lastLine.indexOf('=>')).trim();
      }
    }

    return result.join('\n').trim();
  }

  private parseClassDefinition(
    lines: string[],
    startRow: number,
    endRow: number,
    processedChunks: Set<string>,
  ): ParseResult {
    const selectedLines = [lines[startRow]];

    if (startRow + 1 <= endRow) {
      const nextLine = lines[startRow + 1].trim();
      if (nextLine.includes('extends') || nextLine.includes('implements')) {
        selectedLines.push(nextLine);
      }
    }

    const cleanedLines = selectedLines.map((line) => line.replace(/\{.*$/, '').trim());
    const definition = cleanedLines.join('\n').trim();

    if (processedChunks.has(definition)) {
      return { content: null };
    }

    processedChunks.add(definition);
    return { content: definition };
  }

  private parseTypeOrImport(
    lines: string[],
    startRow: number,
    endRow: number,
    processedChunks: Set<string>,
  ): ParseResult {
    const selectedLines = lines.slice(startRow, endRow + 1);
    const definition = selectedLines.join('\n').trim();

    if (processedChunks.has(definition)) {
      return { content: null };
    }

    processedChunks.add(definition);
    return { content: definition };
  }
}
</file>

<file path="src/core/treeSitter/parseStrategies/VueParseStrategy.ts">
import type { SyntaxNode } from 'web-tree-sitter';
import type { ParseContext, ParseStrategy } from './ParseStrategy.js';

export class VueParseStrategy implements ParseStrategy {
  parseCapture(
    capture: { node: SyntaxNode; name: string },
    lines: string[],
    processedChunks: Set<string>,
    context: ParseContext,
  ): string | null {
    const { node, name } = capture;
    const startRow = node.startPosition.row;
    const endRow = node.endPosition.row;

    if (!lines[startRow]) {
      return null;
    }

    // Extract the content based on the capture type
    const selectedLines = lines.slice(startRow, endRow + 1);
    if (selectedLines.length < 1) {
      return null;
    }

    const chunk = selectedLines.join('\n');
    const normalizedChunk = chunk.trim();

    // Create a unique ID for this chunk
    const chunkId = `${name}:${startRow}`;
    if (processedChunks.has(chunkId)) {
      return null;
    }

    processedChunks.add(chunkId);
    return chunk;
  }
}
</file>

<file path="src/core/treeSitter/queries/queryC.ts">
export const queryC = `
(comment) @comment

(struct_specifier name: (type_identifier) @name.definition.class body:(_)) @definition.class

(declaration type: (union_specifier name: (type_identifier) @name.definition.class)) @definition.class

(function_declarator declarator: (identifier) @name.definition.function) @definition.function

(type_definition declarator: (type_identifier) @name.definition.type) @definition.type

(enum_specifier name: (type_identifier) @name.definition.type) @definition.type
`;
</file>

<file path="src/core/treeSitter/queries/queryCpp.ts">
export const queryCpp = `
(comment) @comment

(struct_specifier name: (type_identifier) @name.definition.class body:(_)) @definition.class

(declaration type: (union_specifier name: (type_identifier) @name.definition.class)) @definition.class

(function_declarator declarator: (identifier) @name.definition.function) @definition.function

(function_declarator declarator: (field_identifier) @name.definition.function) @definition.function

(function_declarator declarator: (qualified_identifier scope: (namespace_identifier) @scope name: (identifier) @name.definition.method)) @definition.method

(type_definition declarator: (type_identifier) @name.definition.type) @definition.type

(enum_specifier name: (type_identifier) @name.definition.type) @definition.type

(class_specifier name: (type_identifier) @name.definition.class) @definition.class
`;
</file>

<file path="src/core/treeSitter/queries/queryCSharp.ts">
export const queryCSharp = `
(comment) @comment

(class_declaration
  name: (identifier) @name.definition.class
) @definition.class

(class_declaration
  bases: (base_list (_) @name.reference.class)
) @reference.class

(interface_declaration
  name: (identifier) @name.definition.interface
) @definition.interface

(interface_declaration
  bases: (base_list (_) @name.reference.interface)
) @reference.interface

(method_declaration
  name: (identifier) @name.definition.method
) @definition.method

(object_creation_expression
  type: (identifier) @name.reference.class
) @reference.class

(type_parameter_constraints_clause
  target: (identifier) @name.reference.class
) @reference.class

(type_constraint
  type: (identifier) @name.reference.class
) @reference.class

(variable_declaration
  type: (identifier) @name.reference.class
) @reference.class

(invocation_expression
  function:
    (member_access_expression
      name: (identifier) @name.reference.send
    )
) @reference.send

(namespace_declaration
  name: (identifier) @name.definition.module
) @definition.module
`;
</file>

<file path="src/core/treeSitter/queries/queryCss.ts">
export const queryCss = `
(comment) @comment

(rule_set
  (selectors) @name.definition.selector
) @definition.selector

(at_rule) @definition.at_rule
`;
</file>

<file path="src/core/treeSitter/queries/queryGo.ts">
export const queryGo = `
; For repomix
(comment) @comment
(package_clause) @definition.package
(import_declaration) @definition.import
(import_spec) @definition.import
(var_declaration) @definition.variable
(const_declaration) @definition.constant

; tree-sitter-go
(
  (comment)* @doc
  .
  (function_declaration
    name: (identifier) @name) @definition.function
  (#strip! @doc "^//\\\\s*")
  (#set-adjacent! @doc @definition.function)
)

(
  (comment)* @doc
  .
  (method_declaration
    name: (field_identifier) @name) @definition.method
  (#strip! @doc "^//\\\\s*")
  (#set-adjacent! @doc @definition.method)
)

(call_expression
  function: [
    (identifier) @name
    (parenthesized_expression (identifier) @name)
    (selector_expression field: (field_identifier) @name)
    (parenthesized_expression (selector_expression field: (field_identifier) @name))
  ]) @reference.call

(type_spec
  name: (type_identifier) @name) @definition.type

(type_identifier) @name @reference.type

(package_clause "package" (package_identifier) @name)

(type_declaration (type_spec name: (type_identifier) @name type: (interface_type)))

(type_declaration (type_spec name: (type_identifier) @name type: (struct_type)))

; Import statements
(import_declaration
  (import_spec_list
    (import_spec
      path: (interpreted_string_literal) @name.reference.module))) @definition.import

(import_declaration
  (import_spec
    path: (interpreted_string_literal) @name.reference.module)) @definition.import

(package_clause
  (package_identifier) @name.reference.module) @definition.package

(var_declaration (var_spec name: (identifier) @name))

(const_declaration (const_spec name: (identifier) @name))
`;
</file>

<file path="src/core/treeSitter/queries/queryJava.ts">
export const queryJava = `
(line_comment) @comment
(block_comment) @comment

(import_declaration
  .
  (identifier) @name.reference.module) @definition.import

(package_declaration
  .
  (identifier) @name.reference.module) @definition.import

(class_declaration
  name: (identifier) @name.definition.class) @definition.class

(method_declaration
  name: (identifier) @name.definition.method) @definition.method

(method_invocation
  name: (identifier) @name.reference.call
  arguments: (argument_list) @reference.call)

(interface_declaration
  name: (identifier) @name.definition.interface) @definition.interface

(type_list
  (type_identifier) @name.reference.implementation) @reference.implementation

(object_creation_expression
  type: (type_identifier) @name.reference.class) @reference.class

(superclass (type_identifier) @name.reference.class) @reference.class
`;
</file>

<file path="src/core/treeSitter/queries/queryJavascript.ts">
export const queryJavascript = `
(comment) @comment

(
  (comment)* @doc
  .
  (method_definition
    name: (property_identifier) @name.definition.method) @definition.method
  (#not-eq? @name.definition.method "constructor")
  (#strip! @doc "^[\\s\\*/]+|^[\\s\\*/]$")
  (#select-adjacent! @doc @definition.method)
)

(
  (comment)* @doc
  .
  [
    (class
      name: (_) @name.definition.class)
    (class_declaration
      name: (_) @name.definition.class)
  ] @definition.class
  (#strip! @doc "^[\\s\\*/]+|^[\\s\\*/]$")
  (#select-adjacent! @doc @definition.class)
)

(
  (comment)* @doc
  .
  [
    (function_declaration
      name: (identifier) @name.definition.function)
    (generator_function
      name: (identifier) @name.definition.function)
    (generator_function_declaration
      name: (identifier) @name.definition.function)
  ] @definition.function
  (#strip! @doc "^[\\s\\*/]+|^[\\s\\*/]$")
  (#select-adjacent! @doc @definition.function)
)

(
  (comment)* @doc
  .
  (lexical_declaration
    (variable_declarator
      name: (identifier) @name.definition.function
      value: [(arrow_function) (function_declaration)]) @definition.function)
  (#strip! @doc "^[\\s\\*/]+|^[\\s\\*/]$")
  (#select-adjacent! @doc @definition.function)
)

(
  (comment)* @doc
  .
  (variable_declaration
    (variable_declarator
      name: (identifier) @name.definition.function
      value: [(arrow_function) (function_declaration)]) @definition.function)
  (#strip! @doc "^[\\s\\*/]+|^[\\s\\*/]$")
  (#select-adjacent! @doc @definition.function)
)

(assignment_expression
  left: [
    (identifier) @name.definition.function
    (member_expression
      property: (property_identifier) @name.definition.function)
  ]
  right: [(arrow_function) (function_declaration)]
) @definition.function

(pair
  key: (property_identifier) @name.definition.function
  value: [(arrow_function) (function_declaration)]) @definition.function

(
  (call_expression
    function: (identifier) @name.reference.call) @reference.call
  (#not-match? @name.reference.call "^(require)$")
)

(call_expression
  function: (member_expression
    property: (property_identifier) @name.reference.call)
  arguments: (_) @reference.call)

(new_expression
  constructor: (_) @name.reference.class) @reference.class
`;
</file>

<file path="src/core/treeSitter/queries/queryPhp.ts">
export const queryPhp = `
; For repomix
(comment) @comment
(namespace_use_clause) @definition.import
(enum_declaration name: (name) @name) @definition.enum

; tree-sitter-php
(namespace_definition
  name: (namespace_name) @name) @definition.module

(interface_declaration
  name: (name) @name) @definition.interface

(trait_declaration
  name: (name) @name) @definition.interface

(class_declaration
  name: (name) @name) @definition.class

(class_interface_clause [(name) (qualified_name)] @name) @reference.implementation

(property_declaration
  (property_element (variable_name (name) @name))) @definition.field

(function_definition
  name: (name) @name) @definition.function

(method_declaration
  name: (name) @name) @definition.function

(object_creation_expression
  [
    (qualified_name (name) @name)
    (variable_name (name) @name)
  ]) @reference.class

(function_call_expression
  function: [
    (qualified_name (name) @name)
    (variable_name (name)) @name
  ]) @reference.call

(scoped_call_expression
  name: (name) @name) @reference.call

(member_call_expression
  name: (name) @name) @reference.call
`;
</file>

<file path="src/core/treeSitter/queries/queryPython.ts">
export const queryPython = `
(comment) @comment

(expression_statement
  (string) @comment) @docstring

; Import statements
(import_statement
  name: (dotted_name) @name.reference.module) @definition.import

(import_from_statement
  module_name: (dotted_name) @name.reference.module) @definition.import

(import_from_statement
  name: (dotted_name) @name.reference.module) @definition.import

(class_definition
  name: (identifier) @name.definition.class) @definition.class

(function_definition
  name: (identifier) @name.definition.function) @definition.function

(call
  function: [
      (identifier) @name.reference.call
      (attribute
        attribute: (identifier) @name.reference.call)
  ]) @reference.call

(assignment
  left: (identifier) @name.definition.type_alias) @definition.type_alias
`;
</file>

<file path="src/core/treeSitter/queries/queryRuby.ts">
export const queryRuby = `
(comment) @comment

; Import statements
(call
  (identifier) @name.reference.module) @definition.import

; Method definitions

(
  (comment)* @doc
  .
  [
    (method
      name: (_) @name.definition.method) @definition.method
    (singleton_method
      name: (_) @name.definition.method) @definition.method
  ]
  (#strip! @doc "^#\\s*")
  (#select-adjacent! @doc @definition.method)
)

(alias
  name: (_) @name.definition.method) @definition.method

(setter
  (identifier) @ignore)

; Class definitions

(
  (comment)* @doc
  .
  [
    (class
      name: [
        (constant) @name.definition.class
        (scope_resolution
          name: (_) @name.definition.class)
      ]) @definition.class
    (singleton_class
      value: [
        (constant) @name.definition.class
        (scope_resolution
          name: (_) @name.definition.class)
      ]) @definition.class
  ]
  (#strip! @doc "^#\\s*")
  (#select-adjacent! @doc @definition.class)
)

; Module definitions

(
  (module
    name: [
      (constant) @name.definition.module
      (scope_resolution
        name: (_) @name.definition.module)
    ]) @definition.module
)

; Calls

(call method: (identifier) @name.reference.call) @reference.call

(
  [(identifier) (constant)] @name.reference.call @reference.call
  (#is-not? local)
  (#not-match? @name.reference.call "^(lambda|load|require|require_relative|__FILE__|__LINE__)$")
)
`;
</file>

<file path="src/core/treeSitter/queries/queryRust.ts">
export const queryRust = `
(line_comment) @comment
(block_comment) @comment

; Import statements
(use_declaration
  (scoped_identifier) @name.reference.module) @definition.import

(use_declaration
  (identifier) @name.reference.module) @definition.import

(extern_crate_declaration
  (identifier) @name.reference.module) @definition.import

; ADT definitions

(struct_item
    name: (type_identifier) @name.definition.class) @definition.class

(enum_item
    name: (type_identifier) @name.definition.class) @definition.class

(union_item
    name: (type_identifier) @name.definition.class) @definition.class

; type aliases

(type_item
    name: (type_identifier) @name.definition.class) @definition.class

; method definitions

(declaration_list
    (function_item
        name: (identifier) @name.definition.method)) @definition.method

; function definitions

(function_item
    name: (identifier) @name.definition.function) @definition.function

; trait definitions
(trait_item
    name: (type_identifier) @name.definition.interface) @definition.interface

; module definitions
(mod_item
    name: (identifier) @name.definition.module) @definition.module

; macro definitions

(macro_definition
    name: (identifier) @name.definition.macro) @definition.macro

; references

(call_expression
    function: (identifier) @name.reference.call) @reference.call

(call_expression
    function: (field_expression
        field: (field_identifier) @name.reference.call)) @reference.call

(macro_invocation
    macro: (identifier) @name.reference.call) @reference.call

; implementations

(impl_item
    trait: (type_identifier) @name.reference.implementation) @reference.implementation

(impl_item
    type: (type_identifier) @name.reference.implementation
    !trait) @reference.implementation
`;
</file>

<file path="src/core/treeSitter/queries/querySolidity.ts">
export const querySolidity = `
;; Comments
(comment) @comment

;; Contract declarations
(contract_declaration
  name: (identifier) @name.definition.class) @definition.class

;; Interface declarations
(interface_declaration
  name: (identifier) @name.definition.interface) @definition.interface

;; Function declarations
(function_definition
  name: (identifier) @name.definition.function) @definition.function

;; Import statements
(import_directive) @definition.import

; Event definitions
(event_definition
  name: (identifier) @name.definition.event) @definition.event

; Modifier definitions
(modifier_definition
  name: (identifier) @name.definition.modifier) @definition.modifier
`;
</file>

<file path="src/core/treeSitter/queries/querySwift.ts">
export const querySwift = `
(comment) @comment

(class_declaration
  name: (type_identifier) @name) @definition.class

(protocol_declaration
  name: (type_identifier) @name) @definition.interface

(class_declaration
    (class_body
        [
            (function_declaration
                name: (simple_identifier) @name
            )
            (subscript_declaration
                (parameter (simple_identifier) @name)
            )
            (init_declaration "init" @name)
            (deinit_declaration "deinit" @name)
        ]
    )
) @definition.method

(class_declaration
    (class_body
        [
            (property_declaration
                (pattern (simple_identifier) @name)
            )
        ]
    )
) @definition.property

(property_declaration
    (pattern (simple_identifier) @name)
) @definition.property

(function_declaration
    name: (simple_identifier) @name) @definition.function
`;
</file>

<file path="src/core/treeSitter/queries/queryTypescript.ts">
export const queryTypescript = `
(import_statement
  (import_clause (identifier) @name.reference.module)) @definition.import

(import_statement
  (import_clause
    (named_imports
      (import_specifier
        name: (identifier) @name.reference.module))) @definition.import)

(comment) @comment

(function_signature
  name: (identifier) @name.definition.function) @definition.function

(method_signature
  name: (property_identifier) @name.definition.method) @definition.method

(abstract_method_signature
  name: (property_identifier) @name.definition.method) @definition.method

(abstract_class_declaration
  name: (type_identifier) @name.definition.class) @definition.class

(module
  name: (identifier) @name.definition.module) @definition.module

(interface_declaration
  name: (type_identifier) @name.definition.interface) @definition.interface

(type_annotation
  (type_identifier) @name.reference.type) @reference.type

(new_expression
  constructor: (identifier) @name.reference.class) @reference.class

(function_declaration
  name: (identifier) @name.definition.function) @definition.function

(method_definition
  name: (property_identifier) @name.definition.method) @definition.method

(class_declaration
  name: (type_identifier) @name.definition.class) @definition.class

(interface_declaration
  name: (type_identifier) @name.definition.class) @definition.class

(type_alias_declaration
  name: (type_identifier) @name.definition.type) @definition.type

(enum_declaration
  name: (identifier) @name.definition.enum) @definition.enum

(lexical_declaration
    (variable_declarator
      name: (identifier) @name.definition.function
      value: (arrow_function)
    )
  ) @definition.function

(variable_declaration
    (variable_declarator
      name: (identifier) @name.definition.function
      value: (arrow_function)
    )
) @definition.function

(assignment_expression
    left: [(identifier) @name.definition.function]
    right: (arrow_function)
) @definition.function
`;
</file>

<file path="src/core/treeSitter/queries/queryVue.ts">
export const queryVue = `
(comment) @comment

(template_element) @template

(script_element) @script

(style_element) @style

(interpolation) @interpolation
`;
</file>

<file path="src/core/treeSitter/queries/README.md">
# Credits
Repomix uses modified versions of tree-sitter queries from Aider and Cline:
* [https://github.com/Aider-AI/aider](https://github.com/Aider-AI/aider) — licensed under the Apache License 2.0.
* [https://github.com/cline/cline](https://github.com/cline/cline) — licensed under the Apache License 2.0.

Aider uses modified versions of the tags.scm files from these open source 
tree-sitter language implementations:

* [https://github.com/tree-sitter/tree-sitter-c](https://github.com/tree-sitter/tree-sitter-c) — licensed under the MIT License.
* [https://github.com/tree-sitter/tree-sitter-c-sharp](https://github.com/tree-sitter/tree-sitter-c-sharp) — licensed under the MIT License.
* [https://github.com/tree-sitter/tree-sitter-cpp](https://github.com/tree-sitter/tree-sitter-cpp) — licensed under the MIT License.
* [https://github.com/Wilfred/tree-sitter-elisp](https://github.com/Wilfred/tree-sitter-elisp) — licensed under the MIT License.
* [https://github.com/elixir-lang/tree-sitter-elixir](https://github.com/elixir-lang/tree-sitter-elixir) — licensed under the Apache License, Version 2.0.
* [https://github.com/elm-tooling/tree-sitter-elm](https://github.com/elm-tooling/tree-sitter-elm) — licensed under the MIT License.
* [https://github.com/tree-sitter/tree-sitter-go](https://github.com/tree-sitter/tree-sitter-go) — licensed under the MIT License.
* [https://github.com/tree-sitter/tree-sitter-java](https://github.com/tree-sitter/tree-sitter-java) — licensed under the MIT License.
* [https://github.com/tree-sitter/tree-sitter-javascript](https://github.com/tree-sitter/tree-sitter-javascript) — licensed under the MIT License.
* [https://github.com/tree-sitter/tree-sitter-ocaml](https://github.com/tree-sitter/tree-sitter-ocaml) — licensed under the MIT License.
* [https://github.com/tree-sitter/tree-sitter-php](https://github.com/tree-sitter/tree-sitter-php) — licensed under the MIT License.
* [https://github.com/tree-sitter/tree-sitter-python](https://github.com/tree-sitter/tree-sitter-python) — licensed under the MIT License.
* [https://github.com/tree-sitter/tree-sitter-ql](https://github.com/tree-sitter/tree-sitter-ql) — licensed under the MIT License.
* [https://github.com/r-lib/tree-sitter-r](https://github.com/r-lib/tree-sitter-r) — licensed under the MIT License.
* [https://github.com/tree-sitter/tree-sitter-ruby](https://github.com/tree-sitter/tree-sitter-ruby) — licensed under the MIT License.
* [https://github.com/tree-sitter/tree-sitter-rust](https://github.com/tree-sitter/tree-sitter-rust) — licensed under the MIT License.
* [https://github.com/tree-sitter/tree-sitter-typescript](https://github.com/tree-sitter/tree-sitter-typescript) — licensed under the MIT License.
</file>

<file path="src/core/treeSitter/ext2Lang.ts">
/**
 * @see https://unpkg.com/browse/tree-sitter-wasms@latest/out/
 */
export const ext2Lang = {
  vue: 'vue',
  cjs: 'javascript',
  mjs: 'javascript',
  mjsx: 'javascript',
  js: 'javascript',
  jsx: 'javascript',
  ctx: 'typescript',
  mts: 'typescript',
  mtsx: 'typescript',
  ts: 'typescript',
  tsx: 'typescript',
  h: 'c',
  c: 'c',
  hpp: 'cpp',
  cpp: 'cpp',
  py: 'python',
  rs: 'rust',
  java: 'java',
  go: 'go',
  cs: 'c_sharp',
  rb: 'ruby',
  php: 'php',
  swift: 'swift',
  css: 'css',
  sol: 'solidity',
};
</file>

<file path="src/core/treeSitter/lang2Query.ts">
import { queryC } from './queries/queryC.js';
import { queryCSharp } from './queries/queryCSharp.js';
import { queryCpp } from './queries/queryCpp.js';
import { queryCss } from './queries/queryCss.js';
import { queryGo } from './queries/queryGo.js';
import { queryJava } from './queries/queryJava.js';
import { queryJavascript } from './queries/queryJavascript.js';
import { queryPhp } from './queries/queryPhp.js';
import { queryPython } from './queries/queryPython.js';
import { queryRuby } from './queries/queryRuby.js';
import { queryRust } from './queries/queryRust.js';
import { querySolidity } from './queries/querySolidity.js';
import { querySwift } from './queries/querySwift.js';
import { queryTypescript } from './queries/queryTypescript.js';
import { queryVue } from './queries/queryVue.js';

export const lang2Query = {
  javascript: queryJavascript,
  typescript: queryTypescript,
  c: queryC,
  cpp: queryCpp,
  python: queryPython,
  rust: queryRust,
  go: queryGo,
  c_sharp: queryCSharp,
  ruby: queryRuby,
  java: queryJava,
  php: queryPhp,
  swift: querySwift,
  solidity: querySolidity,
  css: queryCss,
  vue: queryVue,
};

export type SupportedLang = keyof typeof lang2Query;
</file>

<file path="src/core/treeSitter/languageParser.ts">
import * as path from 'node:path';
import Parser from 'web-tree-sitter';

import { RepomixError } from '../../shared/errorHandle.js';
import { ext2Lang } from './ext2Lang.js';
import { type SupportedLang, lang2Query } from './lang2Query.js';
import { loadLanguage } from './loadLanguage.js';
import { type ParseStrategy, createParseStrategy } from './parseStrategies/ParseStrategy.js';

interface LanguageResources {
  parser: Parser;
  query: Parser.Query;
  strategy: ParseStrategy;
}

export class LanguageParser {
  private loadedResources: Map<SupportedLang, LanguageResources> = new Map();
  private initialized = false;

  private getFileExtension(filePath: string): string {
    return path.extname(filePath).toLowerCase().slice(1);
  }

  private async prepareLang(name: SupportedLang): Promise<LanguageResources> {
    try {
      const lang = await loadLanguage(name);
      const parser = new Parser();
      parser.setLanguage(lang);
      const query = lang.query(lang2Query[name]);
      const strategy = createParseStrategy(name);

      const resources: LanguageResources = {
        parser,
        query,
        strategy,
      };

      this.loadedResources.set(name, resources);
      return resources;
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      throw new RepomixError(`Failed to prepare language ${name}: ${message}`);
    }
  }

  private async getResources(name: SupportedLang): Promise<LanguageResources> {
    if (!this.initialized) {
      throw new RepomixError('LanguageParser is not initialized. Call init() first.');
    }

    const resources = this.loadedResources.get(name);
    if (!resources) {
      return this.prepareLang(name);
    }
    return resources;
  }

  public async getParserForLang(name: SupportedLang): Promise<Parser> {
    const resources = await this.getResources(name);
    return resources.parser;
  }

  public async getQueryForLang(name: SupportedLang): Promise<Parser.Query> {
    const resources = await this.getResources(name);
    return resources.query;
  }

  public async getStrategyForLang(name: SupportedLang): Promise<ParseStrategy> {
    const resources = await this.getResources(name);
    return resources.strategy;
  }

  public guessTheLang(filePath: string): SupportedLang | undefined {
    const ext = this.getFileExtension(filePath);
    if (!Object.keys(ext2Lang).includes(ext)) {
      return undefined;
    }
    return ext2Lang[ext as keyof typeof ext2Lang] as SupportedLang;
  }

  public async init(): Promise<void> {
    if (this.initialized) {
      return;
    }

    try {
      await Parser.init();
      this.initialized = true;
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      throw new RepomixError(`Failed to initialize parser: ${message}`);
    }
  }

  public async dispose(): Promise<void> {
    for (const resources of this.loadedResources.values()) {
      resources.parser.delete();
    }
    this.loadedResources.clear();
    this.initialized = false;
  }
}
</file>

<file path="src/core/treeSitter/loadLanguage.ts">
import fs from 'node:fs/promises';
import { createRequire } from 'node:module';
import path from 'node:path';
import Parser from 'web-tree-sitter';

const require = createRequire(import.meta.url);

export async function loadLanguage(langName: string): Promise<Parser.Language> {
  if (!langName) {
    throw new Error('Invalid language name');
  }

  try {
    const wasmPath = await getWasmPath(langName);
    return await Parser.Language.load(wasmPath);
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to load language ${langName}: ${message}`);
  }
}

async function getWasmPath(langName: string): Promise<string> {
  const wasmPath = require.resolve(`tree-sitter-wasms/out/tree-sitter-${langName}.wasm`);
  try {
    await fs.access(wasmPath);
    return wasmPath;
  } catch {
    throw new Error(`WASM file not found for language ${langName}: ${wasmPath}`);
  }
}
</file>

<file path="src/core/treeSitter/parseFile.ts">
import type { QueryCapture } from 'web-tree-sitter';
import type { RepomixConfigMerged } from '../../config/configSchema.js';
import { logger } from '../../shared/logger.js';
import type { SupportedLang } from './lang2Query.js';
import { LanguageParser } from './languageParser.js';
import { type ParseContext, createParseStrategy } from './parseStrategies/ParseStrategy.js';

interface CapturedChunk {
  content: string;
  startRow: number;
  endRow: number;
}

let languageParserSingleton: LanguageParser | null = null;

export const CHUNK_SEPARATOR = '⋮----';

// TODO: Do something with config: RepomixConfigMerged, it is not used (yet)
export const parseFile = async (fileContent: string, filePath: string, config: RepomixConfigMerged) => {
  const languageParser = await getLanguageParserSingleton();

  // Split the file content into individual lines
  const lines = fileContent.split('\n');
  if (lines.length < 1) {
    return '';
  }

  const lang: SupportedLang | undefined = languageParser.guessTheLang(filePath);
  if (lang === undefined) {
    // Language not supported
    return undefined;
  }

  const query = await languageParser.getQueryForLang(lang);
  const parser = await languageParser.getParserForLang(lang);
  const processedChunks = new Set<string>();
  const capturedChunks: CapturedChunk[] = [];

  try {
    // Parse the file content into an Abstract Syntax Tree (AST)
    const tree = parser.parse(fileContent);

    // Get the appropriate parse strategy for the language
    const parseStrategy = createParseStrategy(lang);

    // Create parse context
    const context: ParseContext = {
      fileContent,
      lines,
      tree,
      query,
      config,
    };

    // Apply the query to the AST and get the captures
    const captures = query.captures(tree.rootNode);

    // Sort captures by their start position
    captures.sort((a, b) => a.node.startPosition.row - b.node.startPosition.row);

    for (const capture of captures) {
      const capturedChunkContent = parseStrategy.parseCapture(capture, lines, processedChunks, context);
      if (capturedChunkContent !== null) {
        capturedChunks.push({
          content: capturedChunkContent.trim(),
          startRow: capture.node.startPosition.row,
          endRow: capture.node.endPosition.row,
        });
      }
    }
  } catch (error: unknown) {
    logger.log(`Error parsing file: ${error}\n`);
  }

  const filteredChunks = filterDuplicatedChunks(capturedChunks);
  const mergedChunks = mergeAdjacentChunks(filteredChunks);

  return mergedChunks
    .map((chunk) => chunk.content)
    .join(`\n${CHUNK_SEPARATOR}\n`)
    .trim();
};

const getLanguageParserSingleton = async () => {
  if (!languageParserSingleton) {
    languageParserSingleton = new LanguageParser();
    await languageParserSingleton.init();
  }
  return languageParserSingleton;
};

const filterDuplicatedChunks = (chunks: CapturedChunk[]): CapturedChunk[] => {
  // Group chunks by their start row
  const chunksByStartRow = new Map<number, CapturedChunk[]>();

  for (const chunk of chunks) {
    const startRow = chunk.startRow;
    if (!chunksByStartRow.has(startRow)) {
      chunksByStartRow.set(startRow, []);
    }
    chunksByStartRow.get(startRow)?.push(chunk);
  }

  // For each start row, keep the chunk with the most content
  const filteredChunks: CapturedChunk[] = [];
  for (const [_, rowChunks] of chunksByStartRow) {
    rowChunks.sort((a, b) => b.content.length - a.content.length);
    filteredChunks.push(rowChunks[0]);
  }

  // Sort filtered chunks by start row
  return filteredChunks.sort((a, b) => a.startRow - b.startRow);
};

const mergeAdjacentChunks = (chunks: CapturedChunk[]): CapturedChunk[] => {
  if (chunks.length <= 1) {
    return chunks;
  }

  const merged: CapturedChunk[] = [chunks[0]];

  for (let i = 1; i < chunks.length; i++) {
    const current = chunks[i];
    const previous = merged[merged.length - 1];

    // Merge the current chunk with the previous one
    if (previous.endRow + 1 === current.startRow) {
      previous.content += `\n${current.content}`;
      previous.endRow = current.endRow;
    } else {
      merged.push(current);
    }
  }

  return merged;
};
</file>

<file path="src/core/packager.ts">
import type { RepomixConfigMerged } from '../config/configSchema.js';
import type { RepomixProgressCallback } from '../shared/types.js';
import { collectFiles } from './file/fileCollect.js';
import { sortPaths } from './file/filePathSort.js';
import { processFiles } from './file/fileProcess.js';
import { searchFiles } from './file/fileSearch.js';
import type { ProcessedFile, RawFile } from './file/fileTypes.js';
import { GitDiffResult, getGitDiffs } from './git/gitDiffHandle.js';
import { calculateMetrics } from './metrics/calculateMetrics.js';
import { generateOutput } from './output/outputGenerate.js';
import { copyToClipboardIfEnabled } from './packager/copyToClipboardIfEnabled.js';
import { writeOutputToDisk } from './packager/writeOutputToDisk.js';
import type { SuspiciousFileResult } from './security/securityCheck.js';
import { validateFileSafety } from './security/validateFileSafety.js';

export interface PackResult {
  totalFiles: number;
  totalCharacters: number;
  totalTokens: number;
  fileCharCounts: Record<string, number>;
  fileTokenCounts: Record<string, number>;
  gitDiffTokenCount: number;
  suspiciousFilesResults: SuspiciousFileResult[];
  suspiciousGitDiffResults: SuspiciousFileResult[];
  processedFiles: ProcessedFile[];
  safeFilePaths: string[];
}

const defaultDeps = {
  searchFiles,
  collectFiles,
  processFiles,
  generateOutput,
  validateFileSafety,
  handleOutput: writeOutputToDisk,
  copyToClipboardIfEnabled,
  calculateMetrics,
  sortPaths,
  getGitDiffs,
};

export const pack = async (
  rootDirs: string[],
  config: RepomixConfigMerged,
  progressCallback: RepomixProgressCallback = () => {},
  overrideDeps: Partial<typeof defaultDeps> = {},
): Promise<PackResult> => {
  const deps = {
    ...defaultDeps,
    ...overrideDeps,
  };

  progressCallback('Searching for files...');
  const filePathsByDir = await Promise.all(
    rootDirs.map(async (rootDir) => ({
      rootDir,
      filePaths: (await deps.searchFiles(rootDir, config)).filePaths,
    })),
  );

  // Sort file paths
  progressCallback('Sorting files...');
  const allFilePaths = filePathsByDir.flatMap(({ filePaths }) => filePaths);
  const sortedFilePaths = await deps.sortPaths(allFilePaths);

  // Regroup sorted file paths by rootDir
  const sortedFilePathsByDir = rootDirs.map((rootDir) => ({
    rootDir,
    filePaths: sortedFilePaths.filter((filePath) =>
      filePathsByDir.find((item) => item.rootDir === rootDir)?.filePaths.includes(filePath),
    ),
  }));

  progressCallback('Collecting files...');
  const rawFiles = (
    await Promise.all(
      sortedFilePathsByDir.map(({ rootDir, filePaths }) =>
        deps.collectFiles(filePaths, rootDir, config, progressCallback),
      ),
    )
  ).reduce((acc: RawFile[], curr: RawFile[]) => acc.concat(...curr), []);

  // Get git diffs if enabled - run this before security check
  progressCallback('Getting git diffs...');
  const gitDiffResult = await deps.getGitDiffs(rootDirs, config);

  // Run security check and get filtered safe files
  const { safeFilePaths, safeRawFiles, suspiciousFilesResults, suspiciousGitDiffResults } =
    await deps.validateFileSafety(rawFiles, progressCallback, config, gitDiffResult);

  // Process files (remove comments, etc.)
  progressCallback('Processing files...');
  const processedFiles = await deps.processFiles(safeRawFiles, config, progressCallback);

  progressCallback('Generating output...');
  const output = await deps.generateOutput(rootDirs, config, processedFiles, safeFilePaths, gitDiffResult);

  progressCallback('Writing output file...');
  await deps.handleOutput(output, config);

  await deps.copyToClipboardIfEnabled(output, progressCallback, config);

  const metrics = await deps.calculateMetrics(processedFiles, output, progressCallback, config, gitDiffResult);

  // Create a result object that includes metrics and security results
  const result = {
    ...metrics,
    suspiciousFilesResults,
    suspiciousGitDiffResults,
    processedFiles,
    safeFilePaths,
  };

  return result;
};
</file>

<file path="src/mcp/prompts/packRemoteRepositoryPrompts.ts">
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';

/**
 * Register Repomix-related prompts to the MCP server
 */
export const registerPackRemoteRepositoryPrompt = (mcpServer: McpServer) => {
  // Pack Remote Repository Prompt
  mcpServer.prompt(
    'pack_remote_repository',
    'Pack a remote GitHub repository for analysis',
    {
      repository: z.string().describe('GitHub repository URL or owner/repo format (e.g., "yamadashy/repomix")'),
      includePatterns: z
        .string()
        .optional()
        .describe(
          'Comma-separated list of glob patterns to include (e.g., "src/**,lib/**"). It is recommended to pack only necessary files.',
        ),
      ignorePatterns: z
        .string()
        .optional()
        .describe(
          'Comma-separated list of glob patterns to ignore (e.g., "**/*.test.js,**/*.spec.js"). It is recommended to pack only necessary files.',
        ),
    },
    async ({ repository, includePatterns, ignorePatterns }) => {
      // Convert compress string to boolean
      return {
        messages: [
          {
            role: 'user',
            content: {
              type: 'text',
              text: `Please analyze the GitHub repository at ${repository}.

First, use the pack_remote_repository tool with these parameters:
- repository: "${repository}"
${includePatterns ? `- includePatterns: "${includePatterns}"` : ''}
${ignorePatterns ? `- ignorePatterns: "${ignorePatterns}"` : ''}

Once you have the packed repository:
1. Read the code using the outputId from the tool response
2. Give me a high-level overview of this project
3. Explain its architecture and main components
4. Identify the key technologies and dependencies used
5. Highlight any interesting patterns or design decisions

Please be thorough in your analysis.`,
            },
          },
        ],
      };
    },
  );
};
</file>

<file path="src/mcp/tools/fileSystemReadDirectoryTool.ts">
import fs from 'node:fs/promises';
import path from 'node:path';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { z } from 'zod';
import { logger } from '../../shared/logger.js';
import { buildMcpToolErrorResponse, buildMcpToolSuccessResponse } from './mcpToolRuntime.js';

/**
 * Register file system directory listing tool
 */
export const registerFileSystemReadDirectoryTool = (mcpServer: McpServer) => {
  mcpServer.tool(
    'file_system_read_directory',
    'List the contents of a directory using an absolute path. Returns a formatted list showing files and subdirectories with clear [FILE]/[DIR] indicators. Useful for exploring project structure and understanding codebase organization.',
    {
      path: z.string().describe('Absolute path to the directory to list'),
    },
    {
      title: 'Read Directory',
      readOnlyHint: true,
      destructiveHint: false,
      idempotentHint: true,
      openWorldHint: false,
    },
    async ({ path: directoryPath }): Promise<CallToolResult> => {
      try {
        logger.trace(`Listing directory at absolute path: ${directoryPath}`);

        // Ensure path is absolute
        if (!path.isAbsolute(directoryPath)) {
          return buildMcpToolErrorResponse([`Error: Path must be absolute. Received: ${directoryPath}`]);
        }

        // Check if directory exists
        try {
          const stats = await fs.stat(directoryPath);
          if (!stats.isDirectory()) {
            return buildMcpToolErrorResponse([
              `Error: The specified path is not a directory: ${directoryPath}. Use file_system_read_file for files.`,
            ]);
          }
        } catch {
          return buildMcpToolErrorResponse([`Error: Directory not found at path: ${directoryPath}`]);
        }

        // Read directory contents
        const entries = await fs.readdir(directoryPath, { withFileTypes: true });
        const formatted = entries
          .map((entry) => `${entry.isDirectory() ? '[DIR]' : '[FILE]'} ${entry.name}`)
          .join('\n');

        return buildMcpToolSuccessResponse([`Contents of ${directoryPath}:`, formatted || '(empty directory)']);
      } catch (error) {
        logger.error(`Error in file_system_read_directory tool: ${error}`);
        return buildMcpToolErrorResponse([
          `Error listing directory: ${error instanceof Error ? error.message : String(error)}`,
        ]);
      }
    },
  );
};
</file>

<file path="src/mcp/tools/fileSystemReadFileTool.ts">
import fs from 'node:fs/promises';
import path from 'node:path';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { z } from 'zod';
import type { SuspiciousFileResult } from '../../core/security/securityCheck.js';
import { createSecretLintConfig, runSecretLint } from '../../core/security/workers/securityCheckWorker.js';
import { logger } from '../../shared/logger.js';
import { buildMcpToolErrorResponse, buildMcpToolSuccessResponse } from './mcpToolRuntime.js';

/**
 * Register file system read file tool with security checks
 */
export const registerFileSystemReadFileTool = (mcpServer: McpServer) => {
  mcpServer.tool(
    'file_system_read_file',
    'Read a file from the local file system using an absolute path. Includes built-in security validation to detect and prevent access to files containing sensitive information (API keys, passwords, secrets).',
    {
      path: z.string().describe('Absolute path to the file to read'),
    },
    {
      title: 'Read File',
      readOnlyHint: true,
      destructiveHint: false,
      idempotentHint: true,
      openWorldHint: false,
    },
    async ({ path: filePath }): Promise<CallToolResult> => {
      try {
        logger.trace(`Reading file at absolute path: ${filePath}`);

        // Ensure path is absolute
        if (!path.isAbsolute(filePath)) {
          return buildMcpToolErrorResponse([`Error: Path must be absolute. Received: ${filePath}`]);
        }

        // Check if file exists
        try {
          await fs.access(filePath);
        } catch {
          return buildMcpToolErrorResponse([`Error: File not found at path: ${filePath}`]);
        }

        // Check if it's a directory
        const stats = await fs.stat(filePath);
        if (stats.isDirectory()) {
          return buildMcpToolErrorResponse([
            `Error: The specified path is a directory, not a file: ${filePath}. Use file_system_read_directory for directories.`,
          ]);
        }

        // Read file content
        const fileContent = await fs.readFile(filePath, 'utf8');

        // Perform security check using the existing worker
        const config = createSecretLintConfig();
        const securityCheckResult = await runSecretLint(filePath, fileContent, 'file', config);

        // If security check found issues, block the file
        if (securityCheckResult !== null) {
          return buildMcpToolErrorResponse([
            `Error: Security check failed. The file at ${filePath} may contain sensitive information.`,
          ]);
        }

        return buildMcpToolSuccessResponse([`Content of ${filePath}:`, fileContent]);
      } catch (error) {
        logger.error(`Error in file_system_read_file tool: ${error}`);
        return buildMcpToolErrorResponse([
          `Error reading file: ${error instanceof Error ? error.message : String(error)}`,
        ]);
      }
    },
  );
};
</file>

<file path="src/mcp/tools/grepRepomixOutputTool.ts">
import fs from 'node:fs/promises';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { z } from 'zod';
import { logger } from '../../shared/logger.js';
import { buildMcpToolErrorResponse, buildMcpToolSuccessResponse, getOutputFilePath } from './mcpToolRuntime.js';

/**
 * Search options for grep functionality
 */
interface SearchOptions {
  pattern: string;
  contextLines: number;
  beforeLines: number;
  afterLines: number;
  ignoreCase: boolean;
}

/**
 * Search match result
 */
interface SearchMatch {
  lineNumber: number;
  line: string;
  matchedText: string;
}

/**
 * Search result containing matches and formatted output
 */
interface SearchResult {
  matches: SearchMatch[];
  formattedOutput: string[];
}

/**
 * Register the tool to search Repomix output files with grep-like functionality
 */
export const registerGrepRepomixOutputTool = (mcpServer: McpServer) => {
  mcpServer.tool(
    'grep_repomix_output',
    'Search for patterns in a Repomix output file using grep-like functionality with JavaScript RegExp syntax. Returns matching lines with optional context lines around matches.',
    {
      outputId: z.string().describe('ID of the Repomix output file to search'),
      pattern: z.string().describe('Search pattern (JavaScript RegExp regular expression syntax)'),
      contextLines: z
        .number()
        .default(0)
        .describe(
          'Number of context lines to show before and after each match (default: 0). Overridden by beforeLines/afterLines if specified.',
        ),
      beforeLines: z
        .number()
        .optional()
        .describe(
          'Number of context lines to show before each match (like grep -B). Takes precedence over contextLines.',
        ),
      afterLines: z
        .number()
        .optional()
        .describe(
          'Number of context lines to show after each match (like grep -A). Takes precedence over contextLines.',
        ),
      ignoreCase: z.boolean().default(false).describe('Perform case-insensitive matching (default: false)'),
    },
    {
      title: 'Grep Repomix Output',
      readOnlyHint: true,
      destructiveHint: false,
      idempotentHint: true,
      openWorldHint: false,
    },
    async ({
      outputId,
      pattern,
      contextLines = 0,
      beforeLines,
      afterLines,
      ignoreCase = false,
    }): Promise<CallToolResult> => {
      try {
        logger.trace(`Searching Repomix output with ID: ${outputId}, pattern: ${pattern}`);

        const filePath = getOutputFilePath(outputId);
        if (!filePath) {
          return buildMcpToolErrorResponse([
            `Error: Output file with ID ${outputId} not found. The output file may have been deleted or the ID is invalid.`,
          ]);
        }

        try {
          await fs.access(filePath);
        } catch (error) {
          return buildMcpToolErrorResponse([
            `Error: Output file does not exist at path: ${filePath}. The temporary file may have been cleaned up.`,
          ]);
        }

        const content = await fs.readFile(filePath, 'utf8');

        // Determine before and after lines
        const finalBeforeLines = beforeLines !== undefined ? beforeLines : contextLines;
        const finalAfterLines = afterLines !== undefined ? afterLines : contextLines;

        // Perform grep search using separated functions
        let searchResult: SearchResult;
        try {
          searchResult = performGrepSearch(content, {
            pattern,
            contextLines,
            beforeLines: finalBeforeLines,
            afterLines: finalAfterLines,
            ignoreCase,
          });
        } catch (error) {
          return buildMcpToolErrorResponse([`Error: ${error instanceof Error ? error.message : String(error)}`]);
        }

        if (searchResult.matches.length === 0) {
          return buildMcpToolSuccessResponse([
            `No matches found for pattern "${pattern}" in Repomix output file (ID: ${outputId}).`,
          ]);
        }

        return buildMcpToolSuccessResponse([
          `Found ${searchResult.matches.length} match(es) for pattern "${pattern}" in Repomix output file (ID: ${outputId}):`,
          searchResult.formattedOutput.join('\n'),
        ]);
      } catch (error) {
        logger.error(`Error in grep_repomix_output: ${error}`);
        return buildMcpToolErrorResponse([
          `Error searching Repomix output: ${error instanceof Error ? error.message : String(error)}`,
        ]);
      }
    },
  );
};

/**
 * Create and validate a regular expression pattern
 */
export const createRegexPattern = (
  pattern: string,
  ignoreCase: boolean,
  deps = {
    RegExp,
  },
): RegExp => {
  const regexFlags = ignoreCase ? 'gi' : 'g';
  try {
    return new deps.RegExp(pattern, regexFlags);
  } catch (error) {
    throw new Error(
      `Invalid regular expression pattern: ${pattern}. ${error instanceof Error ? error.message : String(error)}`,
    );
  }
};

/**
 * Search for pattern matches in file content
 */
export const searchInContent = (
  content: string,
  options: SearchOptions,
  deps = {
    createRegexPattern,
  },
): SearchMatch[] => {
  const lines = content.split('\n');
  const regex = deps.createRegexPattern(options.pattern, options.ignoreCase);

  const matches: SearchMatch[] = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const match = line.match(regex);
    if (match) {
      matches.push({
        lineNumber: i + 1,
        line,
        matchedText: match[0],
      });
    }
  }

  return matches;
};

/**
 * Format search results with separate before and after context lines
 */
export const formatSearchResults = (
  lines: string[],
  matches: SearchMatch[],
  beforeLines: number,
  afterLines: number,
): string[] => {
  if (matches.length === 0) {
    return [];
  }

  const resultLines: string[] = [];
  const addedLines = new Set<number>();

  for (const match of matches) {
    const start = Math.max(0, match.lineNumber - 1 - beforeLines);
    const end = Math.min(lines.length - 1, match.lineNumber - 1 + afterLines);

    // Add separator if there's a gap between previous and current context
    if (resultLines.length > 0 && start > Math.min(...addedLines) + 1) {
      resultLines.push('--');
    }

    for (let i = start; i <= end; i++) {
      if (!addedLines.has(i)) {
        const lineNum = i + 1;
        const prefix = i === match.lineNumber - 1 ? `${lineNum}:` : `${lineNum}-`;
        resultLines.push(`${prefix}${lines[i]}`);
        addedLines.add(i);
      }
    }
  }

  return resultLines;
};

/**
 * Perform grep-like search on content
 */
export const performGrepSearch = (
  content: string,
  options: SearchOptions,
  deps = {
    searchInContent,
    formatSearchResults,
  },
): SearchResult => {
  const matches = deps.searchInContent(content, options);
  const lines = content.split('\n');
  const formattedOutput = deps.formatSearchResults(lines, matches, options.beforeLines, options.afterLines);

  return {
    matches,
    formattedOutput,
  };
};
</file>

<file path="src/mcp/tools/mcpToolRuntime.ts">
import crypto from 'node:crypto';
import fs from 'node:fs/promises';
import os from 'node:os';
import path from 'node:path';
import type { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { generateFileTree, generateTreeString } from '../../core/file/fileTreeGenerate.js';
import type { ProcessedFile } from '../../core/file/fileTypes.js';
import { logger } from '../../shared/logger.js';

// Map to store generated output files
const outputFileRegistry = new Map<string, string>();

// Register an output file
export const registerOutputFile = (id: string, filePath: string): void => {
  outputFileRegistry.set(id, filePath);
};

// Get file path from output ID
export const getOutputFilePath = (id: string): string | undefined => {
  return outputFileRegistry.get(id);
};

export interface McpToolMetrics {
  totalFiles: number;
  totalCharacters: number;
  totalTokens: number;
  fileCharCounts: Record<string, number>;
  fileTokenCounts: Record<string, number>;
  processedFiles: ProcessedFile[];
  safeFilePaths: string[];
}

export interface McpToolContext {
  directory?: string;
  repository?: string;
}

/**
 * Creates a temporary directory for MCP tool operations
 */
export const createToolWorkspace = async (): Promise<string> => {
  try {
    const tmpBaseDir = path.join(os.tmpdir(), 'repomix', 'mcp-outputs');
    await fs.mkdir(tmpBaseDir, { recursive: true });
    const tempDir = await fs.mkdtemp(`${tmpBaseDir}/`);
    return tempDir;
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to create temporary directory: ${message}`);
  }
};

/**
 * Generate a unique output ID
 */
export const generateOutputId = (): string => {
  return crypto.randomBytes(8).toString('hex');
};

/**
 * Creates a result object with metrics information for MCP tools
 */
export const formatToolResponse = async (
  context: McpToolContext,
  metrics: McpToolMetrics,
  outputFilePath: string,
  topFilesLen = 5,
): Promise<CallToolResult> => {
  // Generate output ID and register the file
  const outputId = generateOutputId();
  registerOutputFile(outputId, outputFilePath);

  // Calculate total lines from the output file
  const outputContent = await fs.readFile(outputFilePath, 'utf8');
  const totalLines = outputContent.split('\n').length;

  // Get top files by character count
  const topFiles = Object.entries(metrics.fileCharCounts)
    .map(([filePath, charCount]) => ({
      path: filePath,
      charCount,
      tokenCount: metrics.fileTokenCounts[filePath] || 0,
    }))
    .sort((a, b) => b.charCount - a.charCount)
    .slice(0, topFilesLen);

  // Directory Structure
  const directoryStructure = generateTreeString(metrics.safeFilePaths, []);

  // Create JSON string with all the metrics information
  const jsonResult = JSON.stringify(
    {
      ...(context.directory ? { directory: context.directory } : {}),
      ...(context.repository ? { repository: context.repository } : {}),
      outputFilePath,
      outputId,
      metrics: {
        totalFiles: metrics.totalFiles,
        totalCharacters: metrics.totalCharacters,
        totalTokens: metrics.totalTokens,
        totalLines,
        topFiles,
      },
    },
    null,
    2,
  );

  return {
    content: [
      {
        type: 'text',
        text: '🎉 Successfully packed codebase!\nPlease review the metrics below and consider adjusting compress/includePatterns/ignorePatterns if the token count is too high and you need to reduce it before reading the file content.',
      },
      {
        type: 'text',
        text: jsonResult,
      },
      {
        type: 'text',
        text: `Directory Structure\n\n${directoryStructure}`,
      },
      {
        type: 'text',
        text: `For environments with direct file system access, you can read the file directly using path: ${outputFilePath}`,
      },
      {
        type: 'text',
        text: `For environments without direct file access (e.g., web browsers or sandboxed apps), use the \`read_repomix_output\` tool with this outputId: ${outputId} to access the packed codebase contents.`,
      },
      {
        type: 'text',
        text: `The output retrieved with \`read_repomix_output\` has the following structure:

\`\`\`xml
This file is a merged representation of the entire codebase, combining all repository files into a single document.

<file_summary>
  (Metadata and usage AI instructions)
</file_summary>

<directory_structure>
src/
cli/
cliOutput.ts
index.ts

(...remaining directories)
</directory_structure>

<files>
<file path="src/index.js">
  // File contents here
</file>

(...remaining files)
</files>

<instruction>
(Custom instructions from output.instructionFilePath)
</instruction>
\`\`\`

You can use grep with \`path="<file-path>"\` to locate specific files within the output.`,
      },
    ],
  };
};

/**
 * Creates an error result for MCP tools
 */
export const formatToolError = (error: unknown): CallToolResult => {
  logger.error(`Error in MCP tool: ${error instanceof Error ? error.message : String(error)}`);

  return {
    isError: true,
    content: [
      {
        type: 'text',
        text: JSON.stringify(
          {
            success: false,
            error: error instanceof Error ? error.message : String(error),
          },
          null,
          2,
        ),
      },
    ],
  };
};

/**
 * Creates a successful MCP tool response with type safety
 */
export const buildMcpToolSuccessResponse = (messages: string[]): CallToolResult => {
  return {
    content: messages.map((message) => ({
      type: 'text' as const,
      text: message,
    })),
  };
};

/**
 * Creates an error MCP tool response with type safety
 */
export const buildMcpToolErrorResponse = (errorMessages: string[]): CallToolResult => {
  return {
    isError: true,
    content: errorMessages.map((message) => ({
      type: 'text' as const,
      text: message,
    })),
  };
};
</file>

<file path="src/mcp/tools/packCodebaseTool.ts">
import path from 'node:path';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { z } from 'zod';
import { runCli } from '../../cli/cliRun.js';
import type { CliOptions } from '../../cli/types.js';
import {
  buildMcpToolErrorResponse,
  createToolWorkspace,
  formatToolError,
  formatToolResponse,
} from './mcpToolRuntime.js';

export const registerPackCodebaseTool = (mcpServer: McpServer) => {
  mcpServer.tool(
    'pack_codebase',
    'Package a local code directory into a consolidated XML file for AI analysis. This tool analyzes the codebase structure, extracts relevant code content, and generates a comprehensive report including metrics, file tree, and formatted code content. Supports Tree-sitter compression for efficient token usage.',
    {
      directory: z.string().describe('Directory to pack (Absolute path)'),
      compress: z
        .boolean()
        .default(false)
        .describe(
          'Enable Tree-sitter compression to extract essential code signatures and structure while removing implementation details. Reduces token usage by ~70% while preserving semantic meaning. Generally not needed since grep_repomix_output allows incremental content retrieval. Use only when you specifically need the entire codebase content for large repositories (default: false).',
        ),
      includePatterns: z
        .string()
        .optional()
        .describe(
          'Specify files to include using fast-glob patterns. Multiple patterns can be comma-separated (e.g., "**/*.{js,ts}", "src/**,docs/**"). Only matching files will be processed. Useful for focusing on specific parts of the codebase.',
        ),
      ignorePatterns: z
        .string()
        .optional()
        .describe(
          'Specify additional files to exclude using fast-glob patterns. Multiple patterns can be comma-separated (e.g., "test/**,*.spec.js", "node_modules/**,dist/**"). These patterns supplement .gitignore and built-in exclusions.',
        ),
      topFilesLength: z
        .number()
        .optional()
        .default(10)
        .describe(
          'Number of largest files by size to display in the metrics summary for codebase analysis (default: 10)',
        ),
    },
    {
      title: 'Pack Local Codebase',
      readOnlyHint: true,
      destructiveHint: false,
      idempotentHint: false,
      openWorldHint: false,
    },
    async ({ directory, compress, includePatterns, ignorePatterns, topFilesLength }): Promise<CallToolResult> => {
      let tempDir = '';

      try {
        tempDir = await createToolWorkspace();
        const outputFilePath = path.join(tempDir, 'repomix-output.xml');

        const cliOptions = {
          compress,
          include: includePatterns,
          ignore: ignorePatterns,
          output: outputFilePath,
          style: 'xml',
          securityCheck: true,
          topFilesLen: topFilesLength,
          quiet: true,
        } as CliOptions;

        const result = await runCli(['.'], directory, cliOptions);
        if (!result) {
          return buildMcpToolErrorResponse(['Failed to return a result']);
        }

        // Extract metrics information from the pack result
        const { packResult } = result;

        return await formatToolResponse({ directory }, packResult, outputFilePath, topFilesLength);
      } catch (error) {
        return formatToolError(error);
      }
    },
  );
};
</file>

<file path="src/mcp/tools/packRemoteRepositoryTool.ts">
import path from 'node:path';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { z } from 'zod';
import { runCli } from '../../cli/cliRun.js';
import type { CliOptions } from '../../cli/types.js';
import {
  buildMcpToolErrorResponse,
  createToolWorkspace,
  formatToolError,
  formatToolResponse,
} from './mcpToolRuntime.js';

export const registerPackRemoteRepositoryTool = (mcpServer: McpServer) => {
  mcpServer.tool(
    'pack_remote_repository',
    'Fetch, clone, and package a GitHub repository into a consolidated XML file for AI analysis. This tool automatically clones the remote repository, analyzes its structure, and generates a comprehensive report. Supports various GitHub URL formats and includes security checks to prevent exposure of sensitive information.',
    {
      remote: z
        .string()
        .describe(
          'GitHub repository URL or user/repo format (e.g., "yamadashy/repomix", "https://github.com/user/repo", or "https://github.com/user/repo/tree/branch")',
        ),
      compress: z
        .boolean()
        .default(false)
        .describe(
          'Enable Tree-sitter compression to extract essential code signatures and structure while removing implementation details. Reduces token usage by ~70% while preserving semantic meaning. Generally not needed since grep_repomix_output allows incremental content retrieval. Use only when you specifically need the entire codebase content for large repositories (default: false).',
        ),
      includePatterns: z
        .string()
        .optional()
        .describe(
          'Specify files to include using fast-glob patterns. Multiple patterns can be comma-separated (e.g., "**/*.{js,ts}", "src/**,docs/**"). Only matching files will be processed. Useful for focusing on specific parts of the codebase.',
        ),
      ignorePatterns: z
        .string()
        .optional()
        .describe(
          'Specify additional files to exclude using fast-glob patterns. Multiple patterns can be comma-separated (e.g., "test/**,*.spec.js", "node_modules/**,dist/**"). These patterns supplement .gitignore and built-in exclusions.',
        ),
      topFilesLength: z
        .number()
        .optional()
        .default(10)
        .describe(
          'Number of largest files by size to display in the metrics summary for codebase analysis (default: 10)',
        ),
    },
    {
      title: 'Pack Remote Repository',
      readOnlyHint: true,
      destructiveHint: false,
      idempotentHint: false,
      openWorldHint: true,
    },
    async ({ remote, compress, includePatterns, ignorePatterns, topFilesLength }): Promise<CallToolResult> => {
      let tempDir = '';

      try {
        tempDir = await createToolWorkspace();
        const outputFilePath = path.join(tempDir, 'repomix-output.xml');

        const cliOptions = {
          remote,
          compress,
          include: includePatterns,
          ignore: ignorePatterns,
          output: outputFilePath,
          style: 'xml',
          securityCheck: true,
          topFilesLen: topFilesLength,
          quiet: true,
        } as CliOptions;

        const result = await runCli(['.'], process.cwd(), cliOptions);
        if (!result) {
          return buildMcpToolErrorResponse(['Failed to return a result']);
        }

        // Extract metrics information from the pack result
        const { packResult } = result;

        return await formatToolResponse({ repository: remote }, packResult, outputFilePath, topFilesLength);
      } catch (error) {
        return formatToolError(error);
      }
    },
  );
};
</file>

<file path="src/mcp/tools/readRepomixOutputTool.ts">
import fs from 'node:fs/promises';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { z } from 'zod';
import { logger } from '../../shared/logger.js';
import { buildMcpToolErrorResponse, buildMcpToolSuccessResponse, getOutputFilePath } from './mcpToolRuntime.js';

/**
 * Register the tool to read Repomix output files
 */
export const registerReadRepomixOutputTool = (mcpServer: McpServer) => {
  mcpServer.tool(
    'read_repomix_output',
    'Read the contents of a Repomix-generated output file. Supports partial reading with line range specification for large files. This tool is designed for environments where direct file system access is limited (e.g., web-based environments, sandboxed applications). For direct file system access, use standard file operations.',
    {
      outputId: z.string().describe('ID of the Repomix output file to read'),
      startLine: z
        .number()
        .optional()
        .describe('Starting line number (1-based, inclusive). If not specified, reads from beginning.'),
      endLine: z
        .number()
        .optional()
        .describe('Ending line number (1-based, inclusive). If not specified, reads to end.'),
    },
    {
      title: 'Read Repomix Output',
      readOnlyHint: true,
      destructiveHint: false,
      idempotentHint: true,
      openWorldHint: false,
    },
    async ({ outputId, startLine, endLine }): Promise<CallToolResult> => {
      try {
        logger.trace(`Reading Repomix output with ID: ${outputId}`);

        // Get the file path from the registry
        const filePath = getOutputFilePath(outputId);
        if (!filePath) {
          return buildMcpToolErrorResponse([
            `Error: Output file with ID ${outputId} not found. The output file may have been deleted or the ID is invalid.`,
          ]);
        }

        // Check if the file exists
        try {
          await fs.access(filePath);
        } catch (error) {
          return buildMcpToolErrorResponse([
            `Error: Output file does not exist at path: ${filePath}. The temporary file may have been cleaned up.`,
          ]);
        }

        // Read the file content
        const content = await fs.readFile(filePath, 'utf8');

        let processedContent = content;
        if (startLine !== undefined || endLine !== undefined) {
          // Validate that startLine is less than or equal to endLine when both are provided
          if (startLine !== undefined && endLine !== undefined && startLine > endLine) {
            return buildMcpToolErrorResponse([
              `Error: Start line (${startLine}) cannot be greater than end line (${endLine}).`,
            ]);
          }

          const lines = content.split('\n');
          const start = Math.max(0, (startLine || 1) - 1);
          const end = endLine ? Math.min(lines.length, endLine) : lines.length;

          if (start >= lines.length) {
            return buildMcpToolErrorResponse([
              `Error: Start line ${startLine} exceeds total lines (${lines.length}) in the file.`,
            ]);
          }

          processedContent = lines.slice(start, end).join('\n');
        }

        return buildMcpToolSuccessResponse([
          `Content of Repomix output file (ID: ${outputId})${startLine || endLine ? ` (lines ${startLine || 1}-${endLine || 'end'})` : ''}:`,
          processedContent,
        ]);
      } catch (error) {
        logger.error(`Error reading Repomix output: ${error}`);
        return buildMcpToolErrorResponse([
          `Error reading Repomix output: ${error instanceof Error ? error.message : String(error)}`,
        ]);
      }
    },
  );
};
</file>

<file path="src/mcp/mcpServer.ts">
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { getVersion } from '../core/file/packageJsonParse.js';
import { logger } from '../shared/logger.js';
import { registerPackRemoteRepositoryPrompt } from './prompts/packRemoteRepositoryPrompts.js';
import { registerFileSystemReadDirectoryTool } from './tools/fileSystemReadDirectoryTool.js';
import { registerFileSystemReadFileTool } from './tools/fileSystemReadFileTool.js';
import { registerGrepRepomixOutputTool } from './tools/grepRepomixOutputTool.js';
import { registerPackCodebaseTool } from './tools/packCodebaseTool.js';
import { registerPackRemoteRepositoryTool } from './tools/packRemoteRepositoryTool.js';
import { registerReadRepomixOutputTool } from './tools/readRepomixOutputTool.js';

export const createMcpServer = async () => {
  const mcpServer = new McpServer({
    name: 'repomix-mcp-server',
    version: await getVersion(),
  });

  // Register the prompts
  registerPackRemoteRepositoryPrompt(mcpServer);

  // Register the tools
  registerPackCodebaseTool(mcpServer);
  registerPackRemoteRepositoryTool(mcpServer);
  registerReadRepomixOutputTool(mcpServer);
  registerGrepRepomixOutputTool(mcpServer);
  registerFileSystemReadFileTool(mcpServer);
  registerFileSystemReadDirectoryTool(mcpServer);

  return mcpServer;
};

type Dependencies = {
  processExit?: (code?: number) => never;
};

const defaultDependencies: Dependencies = {
  processExit: process.exit,
};

export const runMcpServer = async (deps: Dependencies = defaultDependencies) => {
  const server = await createMcpServer();
  const transport = new StdioServerTransport();
  const processExit = deps.processExit ?? process.exit;

  const handleExit = async () => {
    try {
      await server.close();
      logger.trace('Repomix MCP Server shutdown complete');
      processExit(0);
    } catch (error) {
      logger.error('Error during MCP server shutdown:', error);
      processExit(1);
    }
  };

  process.on('SIGINT', handleExit);
  process.on('SIGTERM', handleExit);

  try {
    await server.connect(transport);
    logger.trace('Repomix MCP Server running on stdio');
  } catch (error) {
    logger.error('Failed to start MCP server:', error);
    processExit(1);
  }
};
</file>

<file path="src/shared/constants.ts">
export const REPOMIX_GITHUB_URL = 'https://github.com/yamadashy/repomix';
export const REPOMIX_ISSUES_URL = `${REPOMIX_GITHUB_URL}/issues`;
export const REPOMIX_DISCORD_URL = 'https://discord.gg/wNYzTwZFku';
</file>

<file path="src/shared/errorHandle.ts">
import { z } from 'zod';
import { REPOMIX_DISCORD_URL, REPOMIX_ISSUES_URL } from './constants.js';
import { logger, repomixLogLevels } from './logger.js';

export class RepomixError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'RepomixError';
  }
}

export class RepomixConfigValidationError extends RepomixError {
  constructor(message: string) {
    super(message);
    this.name = 'RepomixConfigValidationError';
  }
}

export const handleError = (error: unknown): void => {
  logger.log('');

  if (error instanceof RepomixError) {
    logger.error(`✖ ${error.message}`);
    // If expected error, show stack trace for debugging
    logger.debug('Stack trace:', error.stack);
  } else if (error instanceof Error) {
    logger.error(`✖ Unexpected error: ${error.message}`);
    // If unexpected error, show stack trace by default
    logger.note('Stack trace:', error.stack);

    if (logger.getLogLevel() < repomixLogLevels.DEBUG) {
      logger.log('');
      logger.note('For detailed debug information, use the --verbose flag');
    }
  } else {
    // Unknown errors
    logger.error('✖ An unknown error occurred');

    if (logger.getLogLevel() < repomixLogLevels.DEBUG) {
      logger.note('For detailed debug information, use the --verbose flag');
    }
  }

  // Community support information
  logger.log('');
  logger.info('Need help?');
  logger.info(`• File an issue on GitHub: ${REPOMIX_ISSUES_URL}`);
  logger.info(`• Join our Discord community: ${REPOMIX_DISCORD_URL}`);
};

export const rethrowValidationErrorIfZodError = (error: unknown, message: string): void => {
  if (error instanceof z.ZodError) {
    const zodErrorText = error.errors.map((err) => `[${err.path.join('.')}] ${err.message}`).join('\n  ');
    throw new RepomixConfigValidationError(
      `${message}\n\n  ${zodErrorText}\n\n  Please check the config file and try again.`,
    );
  }
};
</file>

<file path="src/shared/logger.ts">
import util from 'node:util';
import pc from 'picocolors';

export const repomixLogLevels = {
  SILENT: -1, // No output
  ERROR: 0, // error
  WARN: 1, // warn
  INFO: 2, // success, info, log, note
  DEBUG: 3, // debug, trace
} as const;

export type RepomixLogLevel = (typeof repomixLogLevels)[keyof typeof repomixLogLevels];

class RepomixLogger {
  private level: RepomixLogLevel = repomixLogLevels.INFO;

  constructor() {
    this.init();
  }

  init() {
    this.setLogLevel(repomixLogLevels.INFO);
  }

  setLogLevel(level: RepomixLogLevel) {
    this.level = level;
  }

  getLogLevel(): RepomixLogLevel {
    return this.level;
  }

  error(...args: unknown[]) {
    if (this.level >= repomixLogLevels.ERROR) {
      console.error(pc.red(this.formatArgs(args)));
    }
  }

  warn(...args: unknown[]) {
    if (this.level >= repomixLogLevels.WARN) {
      console.log(pc.yellow(this.formatArgs(args)));
    }
  }

  success(...args: unknown[]) {
    if (this.level >= repomixLogLevels.INFO) {
      console.log(pc.green(this.formatArgs(args)));
    }
  }

  info(...args: unknown[]) {
    if (this.level >= repomixLogLevels.INFO) {
      console.log(pc.cyan(this.formatArgs(args)));
    }
  }

  log(...args: unknown[]) {
    if (this.level >= repomixLogLevels.INFO) {
      console.log(this.formatArgs(args));
    }
  }

  note(...args: unknown[]) {
    if (this.level >= repomixLogLevels.INFO) {
      console.log(pc.dim(this.formatArgs(args)));
    }
  }

  debug(...args: unknown[]) {
    if (this.level >= repomixLogLevels.DEBUG) {
      console.log(pc.blue(this.formatArgs(args)));
    }
  }

  trace(...args: unknown[]) {
    if (this.level >= repomixLogLevels.DEBUG) {
      console.log(pc.gray(this.formatArgs(args)));
    }
  }

  private formatArgs(args: unknown[]): string {
    return args
      .map((arg) => (typeof arg === 'object' ? util.inspect(arg, { depth: null, colors: true }) : arg))
      .join(' ');
  }
}

export const logger = new RepomixLogger();

export const setLogLevel = (level: RepomixLogLevel) => {
  logger.setLogLevel(level);
};

/**
 * Set logger log level from REPOMIX_LOGLEVEL environment variable if valid.
 */
export const setLogLevelByEnv = () => {
  const logLevelStr = process.env.REPOMIX_LOGLEVEL;
  const logLevelNum = Number(logLevelStr);
  if (
    logLevelNum === repomixLogLevels.SILENT ||
    logLevelNum === repomixLogLevels.ERROR ||
    logLevelNum === repomixLogLevels.WARN ||
    logLevelNum === repomixLogLevels.INFO ||
    logLevelNum === repomixLogLevels.DEBUG
  ) {
    setLogLevel(logLevelNum);
  }
};
</file>

<file path="src/shared/patternUtils.ts">
/**
 * Splits comma-separated glob patterns while preserving brace expansion patterns.
 * This ensures patterns with braces are treated as a single pattern,
 * rather than being split at commas inside the braces.
 * Whitespace around patterns is also trimmed.
 */
export const splitPatterns = (patterns?: string): string[] => {
  if (!patterns) return [];

  const result: string[] = [];
  let currentPattern = '';
  let braceLevel = 0;

  for (let i = 0; i < patterns.length; i++) {
    const char = patterns[i];

    if (char === '{') {
      braceLevel++;
      currentPattern += char;
    } else if (char === '}') {
      braceLevel--;
      currentPattern += char;
    } else if (char === ',' && braceLevel === 0) {
      // Only split on commas when not inside braces
      if (currentPattern) {
        result.push(currentPattern.trim());
        currentPattern = '';
      }
    } else {
      currentPattern += char;
    }
  }

  // Add the last pattern
  if (currentPattern) {
    result.push(currentPattern.trim());
  }

  return result;
};
</file>

<file path="src/shared/processConcurrency.ts">
import os from 'node:os';
import { Piscina } from 'piscina';
import { logger } from './logger.js';

export const getProcessConcurrency = (): number => {
  return typeof os.availableParallelism === 'function' ? os.availableParallelism() : os.cpus().length;
};

export const getWorkerThreadCount = (numOfTasks: number): { minThreads: number; maxThreads: number } => {
  const processConcurrency = getProcessConcurrency();

  const minThreads = 1;

  // Limit max threads based on number of tasks
  const maxThreads = Math.max(minThreads, Math.min(processConcurrency, Math.ceil(numOfTasks / 100)));

  return {
    minThreads,
    maxThreads,
  };
};

export const initPiscina = (numOfTasks: number, workerPath: string): Piscina => {
  const { minThreads, maxThreads } = getWorkerThreadCount(numOfTasks);

  logger.trace(
    `Initializing worker pool with min=${minThreads}, max=${maxThreads} threads. Worker path: ${workerPath}`,
  );

  return new Piscina({
    filename: workerPath,
    minThreads,
    maxThreads,
    idleTimeout: 5000,
    env: {
      ...process.env,
      REPOMIX_LOGLEVEL: logger.getLogLevel().toString(),
    },
  });
};
</file>

<file path="src/shared/types.ts">
export type RepomixProgressCallback = (message: string) => void;
</file>

<file path="src/types/git-url-parse.d.ts">
/**
 * Type definition extension for git-url-parse library
 *
 * This file exists because the git-url-parse library's built-in type definitions
 * are incomplete. The library supports a second 'refs' parameter for the gitUrlParse
 * function, which is documented in the library's README but not included in its
 * type definitions.
 *
 * Without this type definition extension, we would need to use @ts-ignore when
 * calling gitUrlParse with the refs parameter, which reduces type safety and
 * makes the code harder to maintain.
 *
 * This file uses TypeScript's module augmentation feature to extend the existing
 * type definitions without modifying the original library code.
 */

declare module 'git-url-parse' {
  import gitUp = require('git-up');

  namespace gitUrlParse {
    interface GitUrl extends gitUp.ParsedUrl {
      /** The Git provider (e.g. `"github.com"`). */
      source: string;
      /** The repository owner. */
      owner: string;
      /** The repository name. */
      name: string;
      /** The repository ref (e.g., "master" or "dev"). */
      ref: string;
      /** A filepath relative to the repository root. */
      filepath: string;
      /** The type of filepath in the url ("blob" or "tree"). */
      filepathtype: string;
      /** The owner and name values in the `owner/name` format. */
      full_name: string;
      /** The organization the owner belongs to. This is CloudForge specific. */
      organization: string;
      /** Whether to add the `.git` suffix or not. */
      git_suffix?: boolean | undefined;
      toString(type?: string): string;
    }

    function stringify(url: GitUrl, type?: string): string;
  }

  /**
   * Parses a Git url.
   * @param url The Git url to parse.
   * @param refs An array of strings representing the refs. This is helpful for URLs with branches containing slashes.
   * @returns The GitUrl object containing parsed information.
   */
  function gitUrlParse(url: string, refs?: string[]): gitUrlParse.GitUrl;

  export = gitUrlParse;
}
</file>

<file path="src/index.ts">
// ---------------------------------------------------------------------------------------------------------------------
// Core
// ---------------------------------------------------------------------------------------------------------------------
export { pack } from './core/packager.js';
export type { PackResult } from './core/packager.js';

// File
export { collectFiles } from './core/file/fileCollect.js';
export { sortPaths } from './core/file/filePathSort.js';
export { processFiles } from './core/file/fileProcess.js';
export { searchFiles } from './core/file/fileSearch.js';
export type { FileSearchResult } from './core/file/fileSearch.js';
export { generateFileTree, generateTreeString, treeToString, type TreeNode } from './core/file/fileTreeGenerate.js';

// Git
export { isValidRemoteValue, isValidShorthand, parseRemoteValue } from './core/git/gitRemoteParse.js';

// Security
export { runSecurityCheck } from './core/security/securityCheck.js';
export type { SuspiciousFileResult } from './core/security/securityCheck.js';

// Token Count
export { TokenCounter } from './core/metrics/TokenCounter.js';

// Tree-sitter
export { parseFile } from './core/treeSitter/parseFile.js';

// ---------------------------------------------------------------------------------------------------------------------
// Config
// ---------------------------------------------------------------------------------------------------------------------
export { loadFileConfig, mergeConfigs } from './config/configLoad.js';
export type { RepomixConfigFile as RepomixConfig } from './config/configSchema.js';
export { defaultIgnoreList } from './config/defaultIgnore.js';

// ---------------------------------------------------------------------------------------------------------------------
// Shard
// ---------------------------------------------------------------------------------------------------------------------
export { setLogLevel } from './shared/logger.js';
export type { RepomixProgressCallback } from './shared/types.js';

// ---------------------------------------------------------------------------------------------------------------------
// CLI
// ---------------------------------------------------------------------------------------------------------------------
export { run as cli } from './cli/cliRun.js';
export type { CliOptions } from './cli/types.js';

// Run CLI Repomix
export { runCli } from './cli/cliRun.js';

// Init action
export { runInitAction } from './cli/actions/initAction.js';

// Default action
export { runDefaultAction, buildCliConfig } from './cli/actions/defaultAction.js';

// Remote action
export { runRemoteAction } from './cli/actions/remoteAction.js';
</file>

<file path="tests/cli/actions/defaultAction.test.ts">
import path from 'node:path';
import process from 'node:process';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import {
  buildCliConfig,
  handleDirectoryProcessing,
  handleStdinProcessing,
  runDefaultAction,
} from '../../../src/cli/actions/defaultAction.js';
import type { CliOptions } from '../../../src/cli/types.js';
import * as configLoader from '../../../src/config/configLoad.js';
import * as fileStdin from '../../../src/core/file/fileStdin.js';
import * as packageJsonParser from '../../../src/core/file/packageJsonParse.js';
import * as packager from '../../../src/core/packager.js';
import type { PackResult } from '../../../src/core/packager.js';

vi.mock('../../../src/core/packager');
vi.mock('../../../src/config/configLoad');
vi.mock('../../../src/core/file/packageJsonParse');
vi.mock('../../../src/core/file/fileStdin');
vi.mock('../../../src/shared/logger');
vi.mock('../../../src/cli/cliSpinner');
vi.mock('../../../src/cli/cliPrint');

describe('defaultAction', () => {
  beforeEach(() => {
    vi.resetAllMocks();
    vi.mocked(packageJsonParser.getVersion).mockResolvedValue('1.0.0');
    vi.mocked(configLoader.loadFileConfig).mockResolvedValue({});
    vi.mocked(configLoader.mergeConfigs).mockReturnValue({
      cwd: process.cwd(),
      input: {
        maxFileSize: 50 * 1024 * 1024,
      },
      output: {
        filePath: 'output.txt',
        style: 'plain',
        parsableStyle: false,
        fileSummary: true,
        directoryStructure: true,
        topFilesLength: 5,
        showLineNumbers: false,
        removeComments: false,
        removeEmptyLines: false,
        compress: false,
        copyToClipboard: false,
        stdout: false,
        git: {
          sortByChanges: true,
          sortByChangesMaxCommits: 100,
          includeDiffs: false,
        },
        files: true,
      },
      ignore: {
        useGitignore: true,
        useDefaultPatterns: true,
        customPatterns: [],
      },
      include: [],
      security: {
        enableSecurityCheck: true,
      },
      tokenCount: {
        encoding: 'o200k_base',
      },
    });
    vi.mocked(packager.pack).mockResolvedValue({
      totalFiles: 10,
      totalCharacters: 1000,
      totalTokens: 200,
      fileCharCounts: {},
      fileTokenCounts: {},
      suspiciousFilesResults: [],
      suspiciousGitDiffResults: [],
      processedFiles: [],
      safeFilePaths: [],
      gitDiffTokenCount: 0,
    });
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  it('should run the default command successfully', async () => {
    const options: CliOptions = {
      output: 'custom-output.txt',
      verbose: true,
    };

    await runDefaultAction(['.'], process.cwd(), options);

    expect(configLoader.loadFileConfig).toHaveBeenCalled();
    expect(configLoader.mergeConfigs).toHaveBeenCalled();
    expect(packager.pack).toHaveBeenCalled();
  });

  it('should handle custom include patterns', async () => {
    const options: CliOptions = {
      include: '*.js,*.ts',
    };

    await runDefaultAction(['.'], process.cwd(), options);

    expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
      process.cwd(),
      expect.anything(),
      expect.objectContaining({
        include: ['*.js', '*.ts'],
      }),
    );
  });

  it('should handle custom ignore patterns', async () => {
    const options: CliOptions = {
      ignore: 'node_modules,*.log',
    };

    await runDefaultAction(['.'], process.cwd(), options);

    expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
      process.cwd(),
      expect.anything(),
      expect.objectContaining({
        ignore: {
          customPatterns: ['node_modules', '*.log'],
        },
      }),
    );
  });

  it('should handle custom output style', async () => {
    const options: CliOptions = {
      style: 'xml',
    };

    await runDefaultAction(['.'], process.cwd(), options);

    expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
      process.cwd(),
      expect.anything(),
      expect.objectContaining({
        output: expect.objectContaining({
          style: 'xml',
        }),
      }),
    );
  });

  it('should handle errors gracefully', async () => {
    vi.mocked(packager.pack).mockRejectedValue(new Error('Test error'));

    const options: CliOptions = {};

    await expect(runDefaultAction(['.'], process.cwd(), options)).rejects.toThrow('Test error');
  });

  describe('parsableStyle flag', () => {
    it('should handle --parsable-style flag', async () => {
      const options: CliOptions = {
        parsableStyle: true,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            parsableStyle: true,
          },
        }),
      );
    });

    it('should handle explicit --no-parsable-style flag', async () => {
      const options: CliOptions = {
        parsableStyle: false,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            parsableStyle: false,
          },
        }),
      );
    });
  });

  describe('stdout flag', () => {
    it('should set stdout to true when --stdout flag is set', async () => {
      const options: CliOptions = {
        stdout: true,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: expect.objectContaining({
            stdout: true,
          }),
        }),
      );
    });

    it('should handle both --stdout and custom style', async () => {
      const options: CliOptions = {
        stdout: true,
        style: 'markdown',
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: expect.objectContaining({
            stdout: true,
            style: 'markdown',
          }),
        }),
      );
    });
  });

  describe('security check flag', () => {
    it('should handle --no-security-check flag', async () => {
      const options: CliOptions = {
        securityCheck: false,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          security: {
            enableSecurityCheck: false,
          },
        }),
      );
    });

    it('should handle explicit --security-check flag', async () => {
      const options: CliOptions = {
        securityCheck: true,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({}),
      );
    });
  });

  describe('gitignore flag', () => {
    it('should handle explicit --no-gitignore flag', async () => {
      const options: CliOptions = {
        gitignore: false,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          ignore: {
            useGitignore: false,
          },
        }),
      );
    });

    it('should handle explicit --no-gitignore flag', async () => {
      const options: CliOptions = {
        gitignore: false,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({}),
      );
    });
  });

  describe('defaultPatterns flag', () => {
    it('should handle explicit --no-default-patterns flag', async () => {
      const options: CliOptions = {
        defaultPatterns: false,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          ignore: {
            useDefaultPatterns: false,
          },
        }),
      );
    });

    it('should handle explicit --no-default-patterns flag', async () => {
      const options: CliOptions = {
        defaultPatterns: false,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({}),
      );
    });
  });

  describe('fileSummary flag', () => {
    it('should handle --no-file-summary flag', async () => {
      const options: CliOptions = {
        fileSummary: false,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            fileSummary: false,
          },
        }),
      );
    });

    it('should handle explicit --file-summary flag', async () => {
      const options: CliOptions = {
        fileSummary: true,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({}),
      );
    });
  });

  describe('directoryStructure flag', () => {
    it('should handle --no-directory-structure flag', async () => {
      const options: CliOptions = {
        directoryStructure: false,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            directoryStructure: false,
          },
        }),
      );
    });

    it('should handle explicit --directory-structure flag', async () => {
      const options: CliOptions = {
        directoryStructure: true,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({}),
      );
    });
  });

  describe('removeComments flag', () => {
    it('should handle --remove-comments flag', async () => {
      const options: CliOptions = {
        removeComments: true,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            removeComments: true,
          },
        }),
      );
    });

    it('should handle explicit --no-remove-comments flag', async () => {
      const options: CliOptions = {
        removeComments: false,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            removeComments: false,
          },
        }),
      );
    });
  });

  describe('removeEmptyLines flag', () => {
    it('should handle --remove-empty-lines flag', async () => {
      const options: CliOptions = {
        removeEmptyLines: true,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            removeEmptyLines: true,
          },
        }),
      );
    });

    it('should handle explicit --no-remove-empty-lines flag', async () => {
      const options: CliOptions = {
        removeEmptyLines: false,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            removeEmptyLines: false,
          },
        }),
      );
    });
  });

  describe('headerText flag', () => {
    it('should handle --header-text flag', async () => {
      const options: CliOptions = {
        headerText: 'Another header text',
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            headerText: 'Another header text',
          },
        }),
      );
    });
  });

  describe('instructionFilePath flag', () => {
    it('should handle --instruction-file-path flag', async () => {
      const options: CliOptions = {
        instructionFilePath: 'path/to/instruction.txt',
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            instructionFilePath: 'path/to/instruction.txt',
          },
        }),
      );
    });
  });

  describe('includeEmptyDirectories flag', () => {
    it('should handle --include-empty-directories flag', async () => {
      const options: CliOptions = {
        includeEmptyDirectories: true,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            includeEmptyDirectories: true,
          },
        }),
      );
    });
  });

  it('should properly trim whitespace from comma-separated patterns', () => {
    const options = {
      include: 'src/**/*,  tests/**/*,   examples/**/*',
      ignore: 'node_modules/**,  dist/**,  coverage/**',
    };
    const config = buildCliConfig(options);

    expect(config.include).toEqual(['src/**/*', 'tests/**/*', 'examples/**/*']);
    expect(config.ignore?.customPatterns).toEqual(['node_modules/**', 'dist/**', 'coverage/**']);
  });

  describe('files flag', () => {
    it('should handle --no-files flag', async () => {
      const options: CliOptions = {
        files: false,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({
          output: {
            files: false,
          },
        }),
      );
    });

    it('should handle explicit --files flag', async () => {
      const options: CliOptions = {
        files: true,
      };

      await runDefaultAction(['.'], process.cwd(), options);

      expect(configLoader.mergeConfigs).toHaveBeenCalledWith(
        process.cwd(),
        expect.anything(),
        expect.objectContaining({}),
      );
    });
  });

  describe('handleStdinProcessing', () => {
    const testCwd = path.resolve('/test/cwd');
    const mockConfig = {
      cwd: testCwd,
      input: { maxFileSize: 50 * 1024 * 1024 },
      output: {
        filePath: 'output.txt',
        style: 'plain' as const,
        parsableStyle: false,
        fileSummary: true,
        directoryStructure: true,
        topFilesLength: 5,
        showLineNumbers: false,
        removeComments: false,
        removeEmptyLines: false,
        compress: false,
        copyToClipboard: false,
        stdout: false,
        git: { sortByChanges: true, sortByChangesMaxCommits: 100, includeDiffs: false },
        files: true,
      },
      ignore: { useGitignore: true, useDefaultPatterns: true, customPatterns: [] },
      include: [],
      security: { enableSecurityCheck: true },
      tokenCount: { encoding: 'cl100k_base' as const },
    };

    const mockCliOptions: CliOptions = {
      verbose: false,
      progress: true,
      stdin: true,
    };

    beforeEach(() => {
      vi.mocked(packager.pack).mockResolvedValue({
        totalTokens: 1000,
        totalFiles: 3,
        totalChars: 2500,
        totalCharacters: 2500,
        gitDiffTokenCount: 0,
        processedFiles: [],
        safeFilePaths: [],
        suspiciousFilesResults: [],
        suspiciousGitDiffResults: [],
        fileCharCounts: {},
        fileTokenCounts: {},
        outputFilePath: 'output.txt',
      } as PackResult);
    });

    it('should validate directory arguments and throw error for multiple directories', async () => {
      await expect(handleStdinProcessing(['dir1', 'dir2'], testCwd, mockConfig, mockCliOptions)).rejects.toThrow(
        'When using --stdin, do not specify directory arguments',
      );
    });

    it('should validate directory arguments and throw error for non-default directory', async () => {
      await expect(handleStdinProcessing(['src'], testCwd, mockConfig, mockCliOptions)).rejects.toThrow(
        'When using --stdin, do not specify directory arguments',
      );
    });

    it('should accept default directory argument', async () => {
      vi.mocked(fileStdin.readFilePathsFromStdin).mockResolvedValue({
        filePaths: [path.resolve(testCwd, 'file1.txt')],
        emptyDirPaths: [],
      });

      const result = await handleStdinProcessing(['.'], testCwd, mockConfig, mockCliOptions);

      expect(result).toEqual({
        packResult: expect.any(Object),
        config: mockConfig,
      });
      expect(fileStdin.readFilePathsFromStdin).toHaveBeenCalledWith(testCwd);
    });

    it('should handle empty directories array', async () => {
      vi.mocked(fileStdin.readFilePathsFromStdin).mockResolvedValue({
        filePaths: [path.resolve(testCwd, 'file1.txt')],
        emptyDirPaths: [],
      });

      const result = await handleStdinProcessing([], testCwd, mockConfig, mockCliOptions);

      expect(result).toEqual({
        packResult: expect.any(Object),
        config: mockConfig,
      });
    });

    it('should call pack with correct arguments from stdin result', async () => {
      const stdinResult = {
        filePaths: [path.resolve(testCwd, 'file1.txt'), path.resolve(testCwd, 'subdir/file2.txt')],
        emptyDirPaths: [path.resolve(testCwd, 'emptydir')],
      };

      vi.mocked(fileStdin.readFilePathsFromStdin).mockResolvedValue(stdinResult);

      await handleStdinProcessing(['.'], testCwd, mockConfig, mockCliOptions);

      expect(packager.pack).toHaveBeenCalledWith([testCwd], mockConfig, expect.any(Function), {
        searchFiles: expect.any(Function),
      });

      // Test the searchFiles function
      const packCall = vi.mocked(packager.pack).mock.calls[0];
      const searchFiles = packCall[3]?.searchFiles;
      expect(searchFiles).toBeDefined();

      if (searchFiles) {
        const searchResult = await searchFiles(testCwd, mockConfig);
        expect(searchResult).toEqual({
          filePaths: ['file1.txt', path.join('subdir', 'file2.txt')],
          emptyDirPaths: [path.resolve(testCwd, 'emptydir')],
        });
      }
    });

    it('should propagate errors from readFilePathsFromStdin', async () => {
      const error = new Error('stdin read error');
      vi.mocked(fileStdin.readFilePathsFromStdin).mockRejectedValue(error);

      await expect(handleStdinProcessing(['.'], testCwd, mockConfig, mockCliOptions)).rejects.toThrow(
        'stdin read error',
      );
    });

    it('should propagate errors from pack operation', async () => {
      vi.mocked(fileStdin.readFilePathsFromStdin).mockResolvedValue({
        filePaths: [path.resolve(testCwd, 'file1.txt')],
        emptyDirPaths: [],
      });

      const error = new Error('pack error');
      vi.mocked(packager.pack).mockRejectedValue(error);

      await expect(handleStdinProcessing(['.'], testCwd, mockConfig, mockCliOptions)).rejects.toThrow('pack error');
    });
  });

  describe('handleDirectoryProcessing', () => {
    const testCwd = path.resolve('/test/cwd');
    const mockConfig = {
      cwd: testCwd,
      input: { maxFileSize: 50 * 1024 * 1024 },
      output: {
        filePath: 'output.txt',
        style: 'plain' as const,
        parsableStyle: false,
        fileSummary: true,
        directoryStructure: true,
        topFilesLength: 5,
        showLineNumbers: false,
        removeComments: false,
        removeEmptyLines: false,
        compress: false,
        copyToClipboard: false,
        stdout: false,
        git: { sortByChanges: true, sortByChangesMaxCommits: 100, includeDiffs: false },
        files: true,
      },
      ignore: { useGitignore: true, useDefaultPatterns: true, customPatterns: [] },
      include: [],
      security: { enableSecurityCheck: true },
      tokenCount: { encoding: 'cl100k_base' as const },
    };

    const mockCliOptions: CliOptions = {
      verbose: false,
      progress: true,
    };

    beforeEach(() => {
      vi.mocked(packager.pack).mockResolvedValue({
        totalTokens: 1000,
        totalFiles: 3,
        totalChars: 2500,
        totalCharacters: 2500,
        gitDiffTokenCount: 0,
        processedFiles: [],
        safeFilePaths: [],
        suspiciousFilesResults: [],
        suspiciousGitDiffResults: [],
        fileCharCounts: {},
        fileTokenCounts: {},
        outputFilePath: 'output.txt',
      } as PackResult);
    });

    it('should resolve directory paths and call pack with absolute paths', async () => {
      const directories = ['src', 'lib', './docs'];

      const result = await handleDirectoryProcessing(directories, testCwd, mockConfig, mockCliOptions);

      expect(packager.pack).toHaveBeenCalledWith(
        [path.resolve(testCwd, 'src'), path.resolve(testCwd, 'lib'), path.resolve(testCwd, 'docs')],
        mockConfig,
        expect.any(Function),
      );

      expect(result).toEqual({
        packResult: expect.any(Object),
        config: mockConfig,
      });
    });

    it('should handle single directory', async () => {
      const directories = ['.'];

      await handleDirectoryProcessing(directories, testCwd, mockConfig, mockCliOptions);

      expect(packager.pack).toHaveBeenCalledWith([testCwd], mockConfig, expect.any(Function));
    });

    it('should handle absolute directory paths', async () => {
      const absolutePath1 = path.resolve('/absolute/path');
      const absolutePath2 = path.resolve('/another/absolute');
      const directories = [absolutePath1, absolutePath2];

      await handleDirectoryProcessing(directories, testCwd, mockConfig, mockCliOptions);

      expect(packager.pack).toHaveBeenCalledWith([absolutePath1, absolutePath2], mockConfig, expect.any(Function));
    });

    it('should propagate errors from pack operation', async () => {
      const error = new Error('pack error');
      vi.mocked(packager.pack).mockRejectedValue(error);

      await expect(handleDirectoryProcessing(['.'], testCwd, mockConfig, mockCliOptions)).rejects.toThrow('pack error');
    });

    it('should call progress callback during packing', async () => {
      let progressCallback: ((message: string) => void) | undefined;

      vi.mocked(packager.pack).mockImplementation(async (paths, config, callback) => {
        progressCallback = callback;
        // Simulate progress callback
        if (callback) {
          callback('Processing files...');
        }
        return {
          totalTokens: 1000,
          totalFiles: 3,
          totalChars: 2500,
          totalCharacters: 2500,
          gitDiffTokenCount: 0,
          processedFiles: [],
          safeFilePaths: [],
          suspiciousFilesResults: [],
          suspiciousGitDiffResults: [],
          fileCharCounts: {},
          fileTokenCounts: {},
          outputFilePath: 'output.txt',
        } as PackResult;
      });

      await handleDirectoryProcessing(['.'], testCwd, mockConfig, mockCliOptions);

      expect(progressCallback).toBeDefined();
      expect(packager.pack).toHaveBeenCalledWith(expect.any(Array), expect.any(Object), expect.any(Function));
    });
  });
});
</file>

<file path="tests/cli/actions/diffsFlag.test.ts">
import { describe, expect, test, vi } from 'vitest';
import { buildCliConfig } from '../../../src/cli/actions/defaultAction.js';
import type { CliOptions } from '../../../src/cli/types.js';

describe('Diffs Flag in CLI', () => {
  test('should set includeDiffs to true when --include-diffs flag is provided', () => {
    const options: CliOptions = {
      includeDiffs: true,
    };

    const config = buildCliConfig(options);

    expect(config.output?.git?.includeDiffs).toBe(true);
  });

  test('should not set includeDiffs when --include-diffs flag is not provided', () => {
    const options: CliOptions = {};

    const config = buildCliConfig(options);

    expect(config.output?.git?.includeDiffs).toBeUndefined();
  });

  test('should include other git options when provided alongside --include-diffs', () => {
    const options: CliOptions = {
      includeDiffs: true,
      gitSortByChanges: false,
    };

    const config = buildCliConfig(options);

    expect(config.output?.git?.includeDiffs).toBe(true);
    expect(config.output?.git?.sortByChanges).toBe(false);
  });
});
</file>

<file path="tests/cli/actions/initAction.test.ts">
import * as fs from 'node:fs/promises';
import path from 'node:path';
import * as prompts from '@clack/prompts';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { createConfigFile, createIgnoreFile } from '../../../src/cli/actions/initAction.js';
import { getGlobalDirectory } from '../../../src/config/globalDirectory.js';

vi.mock('node:fs/promises');
vi.mock('@clack/prompts');
vi.mock('../../../src/shared/folderUtils');
vi.mock('../../../src/config/globalDirectory.js');

describe('initAction', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  describe('createConfigFile', () => {
    it('should create a new local config file when one does not exist', async () => {
      vi.mocked(fs.access).mockRejectedValue(new Error('File does not exist'));
      vi.mocked(prompts.group).mockResolvedValue({
        outputFilePath: 'custom-output.txt',
        outputStyle: 'xml',
      });
      vi.mocked(prompts.confirm).mockResolvedValue(true);

      await createConfigFile('/test/dir', false);

      const configPath = path.resolve('/test/dir/repomix.config.json');

      expect(fs.writeFile).toHaveBeenCalledWith(configPath, expect.stringContaining('"filePath": "custom-output.txt"'));
      expect(fs.writeFile).toHaveBeenCalledWith(configPath, expect.stringContaining('"style": "xml"'));
    });

    it('should create a new global config file when one does not exist', async () => {
      vi.mocked(fs.access).mockRejectedValue(new Error('File does not exist'));
      vi.mocked(prompts.group).mockResolvedValue({
        outputFilePath: 'global-output.txt',
        outputStyle: 'plain',
      });
      vi.mocked(prompts.confirm).mockResolvedValue(true);
      vi.mocked(getGlobalDirectory).mockImplementation(() => '/global/repomix');

      await createConfigFile('/test/dir', true);

      const configPath = path.resolve('/global/repomix/repomix.config.json');

      expect(fs.mkdir).toHaveBeenCalledWith(path.dirname(configPath), { recursive: true });
      expect(fs.writeFile).toHaveBeenCalledWith(configPath, expect.stringContaining('"filePath": "global-output.txt"'));
      expect(fs.writeFile).toHaveBeenCalledWith(configPath, expect.stringContaining('"style": "plain"'));
    });

    it('should prompt to overwrite when config file already exists', async () => {
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(prompts.confirm).mockResolvedValue(true);
      vi.mocked(prompts.group).mockResolvedValue({
        outputFilePath: 'new-output.txt',
        outputStyle: 'xml',
      });

      await createConfigFile('/test/dir', false);

      expect(prompts.confirm).toHaveBeenCalled();
      expect(fs.writeFile).toHaveBeenCalled();
    });

    it('should not overwrite when user chooses not to', async () => {
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(prompts.confirm).mockResolvedValue(false);

      await createConfigFile('/test/dir', false);

      expect(prompts.confirm).toHaveBeenCalled();
      expect(fs.writeFile).not.toHaveBeenCalled();
    });

    it('should handle user cancellation', async () => {
      vi.mocked(fs.access).mockRejectedValue(new Error('File does not exist'));
      vi.mocked(prompts.group).mockImplementation(() => {
        throw new Error('User cancelled');
      });

      await createConfigFile('/test/dir', false);

      expect(fs.writeFile).not.toHaveBeenCalled();
    });
  });

  describe('createIgnoreFile', () => {
    it('should not create a new .repomixignore file when global flag is set', async () => {
      const result = await createIgnoreFile('/test/dir', true);

      expect(result).toBe(false);
      expect(fs.writeFile).not.toHaveBeenCalled();
    });

    it('should create a new .repomixignore file when one does not exist', async () => {
      vi.mocked(fs.access).mockRejectedValue(new Error('File does not exist'));
      vi.mocked(prompts.confirm).mockResolvedValue(true);

      await createIgnoreFile('/test/dir', false);

      const ignorePath = path.resolve('/test/dir/.repomixignore');

      expect(fs.writeFile).toHaveBeenCalledWith(
        ignorePath,
        expect.stringContaining('# Add patterns to ignore here, one per line'),
      );
    });

    it('should prompt to overwrite when .repomixignore file already exists', async () => {
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(prompts.confirm)
        .mockResolvedValueOnce(true) // First call for creating the file
        .mockResolvedValueOnce(true); // Second call for overwriting

      await createIgnoreFile('/test/dir', false);

      expect(prompts.confirm).toHaveBeenCalledTimes(2);
      expect(fs.writeFile).toHaveBeenCalled();
    });

    it('should not overwrite when user chooses not to', async () => {
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(prompts.confirm)
        .mockResolvedValueOnce(true) // First call for creating the file
        .mockResolvedValueOnce(false); // Second call for overwriting

      await createIgnoreFile('/test/dir', false);

      expect(prompts.confirm).toHaveBeenCalledTimes(2);
      expect(fs.writeFile).not.toHaveBeenCalled();
    });

    it('should return false when user chooses not to create .repomixignore', async () => {
      vi.mocked(prompts.confirm).mockResolvedValue(false);

      const result = await createIgnoreFile('/test/dir', false);

      expect(result).toBe(false);
      expect(fs.writeFile).not.toHaveBeenCalled();
    });

    it('should handle user cancellation', async () => {
      vi.mocked(prompts.confirm).mockResolvedValue(false);

      await createIgnoreFile('/test/dir', false);

      expect(fs.writeFile).not.toHaveBeenCalled();
    });
  });
});
</file>

<file path="tests/cli/actions/mcpAction.test.ts">
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { runMcpAction } from '../../../src/cli/actions/mcpAction.js';
import { runMcpServer } from '../../../src/mcp/mcpServer.js';
import { logger } from '../../../src/shared/logger.js';

vi.mock('../../../src/mcp/mcpServer');
vi.mock('../../../src/shared/logger');

describe('mcpAction', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  test('should start MCP server and log trace message', async () => {
    const mockRunMcpServer = vi.mocked(runMcpServer);
    mockRunMcpServer.mockResolvedValue();

    await runMcpAction();

    expect(logger.trace).toHaveBeenCalledWith('Starting Repomix MCP server...');
    expect(mockRunMcpServer).toHaveBeenCalled();
  });

  test('should handle MCP server startup error', async () => {
    const mockRunMcpServer = vi.mocked(runMcpServer);
    mockRunMcpServer.mockRejectedValue(new Error('Server startup failed'));

    await expect(runMcpAction()).rejects.toThrow('Server startup failed');

    expect(logger.trace).toHaveBeenCalledWith('Starting Repomix MCP server...');
    expect(mockRunMcpServer).toHaveBeenCalled();
  });
});
</file>

<file path="tests/cli/actions/migrationAction.test.ts">
import * as fs from 'node:fs/promises';
import path from 'node:path';
import * as prompts from '@clack/prompts';
import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
import { runMigrationAction } from '../../../src/cli/actions/migrationAction.js';
import { logger } from '../../../src/shared/logger.js';

vi.mock('node:fs/promises');
vi.mock('@clack/prompts');
vi.mock('../../../src/shared/logger');

describe('migrationAction', () => {
  const mockRootDir = '/test/dir';
  const oldConfigPath = path.join(mockRootDir, 'repopack.config.json');
  const newConfigPath = path.join(mockRootDir, 'repomix.config.json');
  const oldIgnorePath = path.join(mockRootDir, '.repopackignore');
  const newIgnorePath = path.join(mockRootDir, '.repomixignore');
  const oldInstructionPath = path.join(mockRootDir, 'repopack-instruction.md');
  const newInstructionPath = path.join(mockRootDir, 'repomix-instruction.md');
  const gitignorePath = path.join(mockRootDir, '.gitignore');

  const mockOutputPaths = {
    oldTxt: path.join(mockRootDir, 'repopack-output.txt'),
    newTxt: path.join(mockRootDir, 'repomix-output.txt'),
    oldXml: path.join(mockRootDir, 'repopack-output.xml'),
    newXml: path.join(mockRootDir, 'repomix-output.xml'),
    oldMd: path.join(mockRootDir, 'repopack-output.md'),
    newMd: path.join(mockRootDir, 'repomix-output.md'),
  };

  beforeEach(() => {
    vi.resetAllMocks();
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  test('should migrate all files when they exist', async () => {
    // Mock file existence checks
    vi.mocked(fs.access).mockImplementation(async (path) => {
      if (
        path === oldConfigPath ||
        path === oldIgnorePath ||
        path === oldInstructionPath ||
        path === mockOutputPaths.oldTxt ||
        path === mockOutputPaths.oldXml
      ) {
        return Promise.resolve();
      }
      return Promise.reject(new Error('File not found'));
    });

    // Mock file content
    const mockConfigContent = JSON.stringify({
      output: {
        filePath: 'repopack-output.txt',
        instructionFilePath: 'repopack-instruction.md',
      },
    });
    const mockIgnoreContent = 'repopack-output.txt\n*.log';
    const mockInstructionContent = '# Repopack Instructions';
    const mockOutputContent = 'Repopack output content';

    vi.mocked(fs.readFile).mockImplementation(async (path) => {
      if (path === oldConfigPath) return mockConfigContent;
      if (path === oldIgnorePath) return mockIgnoreContent;
      if (path === oldInstructionPath) return mockInstructionContent;
      if (path === mockOutputPaths.oldTxt || path === mockOutputPaths.oldXml) {
        return mockOutputContent;
      }
      return '';
    });

    // Mock user confirmation
    vi.mocked(prompts.confirm).mockResolvedValue(true);

    // Run migration
    const result = await runMigrationAction(mockRootDir);

    // Verify results
    expect(result.configMigrated).toBe(true);
    expect(result.ignoreMigrated).toBe(true);
    expect(result.instructionMigrated).toBe(true);
    expect(result.outputFilesMigrated).toContain(mockOutputPaths.newTxt);
    expect(result.outputFilesMigrated).toContain(mockOutputPaths.newXml);
    expect(result.error).toBeUndefined();

    // Verify file operations for config
    expect(fs.writeFile).toHaveBeenCalledWith(
      newConfigPath,
      JSON.stringify(
        {
          output: {
            filePath: 'repomix-output.txt',
            instructionFilePath: 'repomix-instruction.md',
          },
        },
        null,
        2,
      ),
      'utf8',
    );

    // Verify other file operations
    expect(fs.writeFile).toHaveBeenCalledWith(newIgnorePath, 'repomix-output.txt\n*.log', 'utf8');
    expect(fs.writeFile).toHaveBeenCalledWith(newInstructionPath, '# Repomix Instructions', 'utf8');

    // Verify old files were removed
    expect(fs.unlink).toHaveBeenCalledWith(oldConfigPath);
    expect(fs.unlink).toHaveBeenCalledWith(oldIgnorePath);
    expect(fs.unlink).toHaveBeenCalledWith(oldInstructionPath);
    expect(fs.unlink).toHaveBeenCalledWith(mockOutputPaths.oldTxt);
    expect(fs.unlink).toHaveBeenCalledWith(mockOutputPaths.oldXml);
  });

  test('should update gitignore content when it exists and contains repopack references', async () => {
    // Mock file existence only for gitignore and oldConfig
    vi.mocked(fs.access).mockImplementation(async (path) => {
      if (path === gitignorePath || path === oldConfigPath) {
        return Promise.resolve();
      }
      return Promise.reject(new Error('File not found'));
    });

    // Mock file content only for gitignore
    const mockGitignoreContent = 'node_modules/\nrepopack-output.txt';
    vi.mocked(fs.readFile).mockImplementation(async (path) => {
      if (path === gitignorePath) return mockGitignoreContent;
      if (path === oldConfigPath) return '{}';
      return '';
    });

    // Mock user confirmation
    vi.mocked(prompts.confirm).mockResolvedValue(true);

    // Run migration
    await runMigrationAction(mockRootDir);

    // Verify gitignore was updated
    expect(fs.writeFile).toHaveBeenCalledWith(gitignorePath, 'node_modules/\nrepomix-output.txt', 'utf8');
    expect(logger.log).toHaveBeenCalledWith(expect.stringContaining('Updated repopack references in'));
  });

  test('should handle non-updated files correctly', async () => {
    // Mock file existence only for gitignore and oldConfig
    vi.mocked(fs.access).mockImplementation(async (path) => {
      if (path === gitignorePath || path === oldConfigPath) {
        return Promise.resolve();
      }
      return Promise.reject(new Error('File not found'));
    });

    // Mock file content with no repopack references
    vi.mocked(fs.readFile).mockImplementation(async (path) => {
      if (path === gitignorePath) return 'node_modules/\n*.log';
      if (path === oldConfigPath) return '{}';
      return '';
    });

    // Mock user confirmation
    vi.mocked(prompts.confirm).mockResolvedValue(true);

    // Run migration
    await runMigrationAction(mockRootDir);

    // Verify no gitignore update was performed
    expect(fs.writeFile).not.toHaveBeenCalledWith(gitignorePath, expect.any(String), expect.any(String));
    // Verify debug message was logged
    expect(logger.debug).toHaveBeenCalledWith(expect.stringContaining('No changes needed in'));
  });

  test('should skip migration when no old files exist', async () => {
    // Mock all files not existing
    vi.mocked(fs.access).mockRejectedValue(new Error('File not found'));

    // Run migration
    const result = await runMigrationAction(mockRootDir);

    // Verify no migration occurred
    expect(result.configMigrated).toBe(false);
    expect(result.ignoreMigrated).toBe(false);
    expect(result.instructionMigrated).toBe(false);
    expect(result.outputFilesMigrated).toHaveLength(0);
    expect(prompts.confirm).not.toHaveBeenCalled();
    expect(logger.debug).toHaveBeenCalledWith('No Repopack files found to migrate.');
  });

  test('should skip files when they already exist and user declines overwrite', async () => {
    // Mock old and new files existing
    vi.mocked(fs.access).mockResolvedValue(undefined);

    // Mock user confirming migration but declining overwrites
    vi.mocked(prompts.confirm)
      .mockResolvedValueOnce(true) // Migration confirmation
      .mockResolvedValue(false); // All overwrite confirmations

    // Run migration
    const result = await runMigrationAction(mockRootDir);

    // Verify nothing was migrated
    expect(result.configMigrated).toBe(false);
    expect(result.ignoreMigrated).toBe(false);
    expect(result.instructionMigrated).toBe(false);
    expect(result.outputFilesMigrated).toHaveLength(0);
    expect(logger.info).toHaveBeenCalledWith(expect.stringContaining('Skipping migration'));
  });
});
</file>

<file path="tests/cli/actions/remoteAction.test.ts">
import * as fs from 'node:fs/promises';
import path from 'node:path';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import type { DefaultActionRunnerResult } from '../../../src/cli/actions/defaultAction.js';
import { copyOutputToCurrentDirectory, runRemoteAction } from '../../../src/cli/actions/remoteAction.js';
import { createMockConfig } from '../../testing/testUtils.js';

vi.mock('node:fs/promises', async (importOriginal) => {
  const actual = await importOriginal<typeof import('node:fs/promises')>();
  return {
    ...actual,
    copyFile: vi.fn(),
    mkdir: vi.fn(),
  };
});
vi.mock('../../../src/shared/logger');
vi.mock('../../../src/cli/cliSpinner');

describe('remoteAction functions', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  describe('runRemoteAction', () => {
    test('should clone the repository when not a GitHub repo', async () => {
      const execGitShallowCloneMock = vi.fn(async (_url: string, directory: string) => {
        await fs.writeFile(path.join(directory, 'README.md'), 'Hello, world!');
      });

      vi.mocked(fs.copyFile).mockResolvedValue(undefined);
      await runRemoteAction(
        'https://gitlab.com/owner/repo.git',
        {},
        {
          isGitInstalled: async () => Promise.resolve(true),
          execGitShallowClone: execGitShallowCloneMock,
          getRemoteRefs: async () => Promise.resolve(['main']),
          runDefaultAction: async () => {
            return {
              packResult: {
                totalFiles: 1,
                totalCharacters: 1,
                totalTokens: 1,
                fileCharCounts: {},
                fileTokenCounts: {},
                suspiciousFilesResults: [],
                suspiciousGitDiffResults: [],
                processedFiles: [],
                safeFilePaths: [],
                gitDiffTokenCount: 0,
              },
              config: createMockConfig(),
            } satisfies DefaultActionRunnerResult;
          },
          downloadGitHubArchive: vi.fn().mockRejectedValue(new Error('Archive download not implemented in test')),
          isGitHubRepository: vi.fn().mockReturnValue(false),
          parseGitHubRepoInfo: vi.fn().mockReturnValue(null),
          isArchiveDownloadSupported: vi.fn().mockReturnValue(false),
        },
      );

      expect(execGitShallowCloneMock).toHaveBeenCalledTimes(1);
    });

    test('should download GitHub archive successfully without git installed', async () => {
      const downloadGitHubArchiveMock = vi.fn().mockResolvedValue(undefined);
      const execGitShallowCloneMock = vi.fn();
      const isGitInstalledMock = vi.fn().mockResolvedValue(false); // Git is NOT installed

      vi.mocked(fs.copyFile).mockResolvedValue(undefined);
      await runRemoteAction(
        'yamadashy/repomix',
        {},
        {
          isGitInstalled: isGitInstalledMock,
          execGitShallowClone: execGitShallowCloneMock,
          getRemoteRefs: async () => Promise.resolve(['main']),
          runDefaultAction: async () => {
            return {
              packResult: {
                totalFiles: 1,
                totalCharacters: 1,
                totalTokens: 1,
                fileCharCounts: {},
                fileTokenCounts: {},
                suspiciousFilesResults: [],
                suspiciousGitDiffResults: [],
                processedFiles: [],
                safeFilePaths: [],
                gitDiffTokenCount: 0,
              },
              config: createMockConfig(),
            } satisfies DefaultActionRunnerResult;
          },
          downloadGitHubArchive: downloadGitHubArchiveMock,
          isGitHubRepository: vi.fn().mockReturnValue(true),
          parseGitHubRepoInfo: vi.fn().mockReturnValue({ owner: 'yamadashy', repo: 'repomix' }),
          isArchiveDownloadSupported: vi.fn().mockReturnValue(true),
        },
      );

      expect(downloadGitHubArchiveMock).toHaveBeenCalledTimes(1);
      expect(execGitShallowCloneMock).not.toHaveBeenCalled();
      expect(isGitInstalledMock).not.toHaveBeenCalled(); // Git check should not be called when archive succeeds
    });

    test('should fallback to git clone when archive download fails', async () => {
      const downloadGitHubArchiveMock = vi.fn().mockRejectedValue(new Error('Archive download failed'));
      const execGitShallowCloneMock = vi.fn(async (_url: string, directory: string) => {
        await fs.writeFile(path.join(directory, 'README.md'), 'Hello, world!');
      });

      vi.mocked(fs.copyFile).mockResolvedValue(undefined);
      await runRemoteAction(
        'yamadashy/repomix',
        {},
        {
          isGitInstalled: async () => Promise.resolve(true),
          execGitShallowClone: execGitShallowCloneMock,
          getRemoteRefs: async () => Promise.resolve(['main']),
          runDefaultAction: async () => {
            return {
              packResult: {
                totalFiles: 1,
                totalCharacters: 1,
                totalTokens: 1,
                fileCharCounts: {},
                fileTokenCounts: {},
                suspiciousFilesResults: [],
                suspiciousGitDiffResults: [],
                processedFiles: [],
                safeFilePaths: [],
                gitDiffTokenCount: 0,
              },
              config: createMockConfig(),
            } satisfies DefaultActionRunnerResult;
          },
          downloadGitHubArchive: downloadGitHubArchiveMock,
          isGitHubRepository: vi.fn().mockReturnValue(true),
          parseGitHubRepoInfo: vi.fn().mockReturnValue({ owner: 'yamadashy', repo: 'repomix' }),
          isArchiveDownloadSupported: vi.fn().mockReturnValue(true),
        },
      );

      expect(downloadGitHubArchiveMock).toHaveBeenCalledTimes(1);
      expect(execGitShallowCloneMock).toHaveBeenCalledTimes(1);
    });

    test('should fail when archive download fails and git is not installed', async () => {
      const downloadGitHubArchiveMock = vi.fn().mockRejectedValue(new Error('Archive download failed'));
      const execGitShallowCloneMock = vi.fn();
      const isGitInstalledMock = vi.fn().mockResolvedValue(false); // Git is NOT installed

      vi.mocked(fs.copyFile).mockResolvedValue(undefined);

      await expect(
        runRemoteAction(
          'yamadashy/repomix',
          {},
          {
            isGitInstalled: isGitInstalledMock,
            execGitShallowClone: execGitShallowCloneMock,
            getRemoteRefs: async () => Promise.resolve(['main']),
            runDefaultAction: async () => {
              return {
                packResult: {
                  totalFiles: 1,
                  totalCharacters: 1,
                  totalTokens: 1,
                  fileCharCounts: {},
                  fileTokenCounts: {},
                  suspiciousFilesResults: [],
                  suspiciousGitDiffResults: [],
                  processedFiles: [],
                  safeFilePaths: [],
                  gitDiffTokenCount: 0,
                },
                config: createMockConfig(),
              } satisfies DefaultActionRunnerResult;
            },
            downloadGitHubArchive: downloadGitHubArchiveMock,
            isGitHubRepository: vi.fn().mockReturnValue(true),
            parseGitHubRepoInfo: vi.fn().mockReturnValue({ owner: 'yamadashy', repo: 'repomix' }),
            isArchiveDownloadSupported: vi.fn().mockReturnValue(true),
          },
        ),
      ).rejects.toThrow('Git is not installed or not in the system PATH.');

      expect(downloadGitHubArchiveMock).toHaveBeenCalledTimes(1);
      expect(isGitInstalledMock).toHaveBeenCalledTimes(1); // Git check should be called when fallback to git clone
      expect(execGitShallowCloneMock).not.toHaveBeenCalled();
    });
  });

  describe('copyOutputToCurrentDirectory', () => {
    test('should copy output file', async () => {
      const sourceDir = '/source/dir';
      const targetDir = '/target/dir';
      const fileName = 'output.txt';

      vi.mocked(fs.copyFile).mockResolvedValue();

      await copyOutputToCurrentDirectory(sourceDir, targetDir, fileName);

      expect(fs.copyFile).toHaveBeenCalledWith(path.resolve(sourceDir, fileName), path.resolve(targetDir, fileName));
    });

    test('should throw error when copy fails', async () => {
      const sourceDir = '/source/dir';
      const targetDir = '/target/dir';
      const fileName = 'output.txt';

      vi.mocked(fs.copyFile).mockRejectedValue(new Error('Permission denied'));

      await expect(copyOutputToCurrentDirectory(sourceDir, targetDir, fileName)).rejects.toThrow(
        'Failed to copy output file',
      );
    });
  });
});
</file>

<file path="tests/cli/actions/versionAction.test.ts">
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { runVersionAction } from '../../../src/cli/actions/versionAction.js';
import * as packageJsonParser from '../../../src/core/file/packageJsonParse.js';
import { logger } from '../../../src/shared/logger.js';

vi.mock('../../../src/core/file/packageJsonParse');

describe('versionAction', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  it('should print the correct version', async () => {
    vi.mocked(packageJsonParser.getVersion).mockResolvedValue('1.2.3');

    const loggerSpy = vi.spyOn(logger, 'log').mockImplementation(vi.fn());
    await runVersionAction();

    expect(packageJsonParser.getVersion).toHaveBeenCalled();
    expect(loggerSpy).toHaveBeenCalledWith('1.2.3');
  });
});
</file>

<file path="tests/cli/cliPrint.test.ts">
import path from 'node:path';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { printCompletion, printSecurityCheck, printSummary, printTopFiles } from '../../src/cli/cliPrint.js';
import type { SuspiciousFileResult } from '../../src/core/security/securityCheck.js';
import type { PackResult } from '../../src/index.js';
import { logger } from '../../src/shared/logger.js';
import { createMockConfig } from '../testing/testUtils.js';

vi.mock('../../src/shared/logger');
vi.mock('picocolors', () => ({
  default: {
    white: (str: string) => `WHITE:${str}`,
    dim: (str: string) => `DIM:${str}`,
    green: (str: string) => `GREEN:${str}`,
    yellow: (str: string) => `YELLOW:${str}`,
    red: (str: string) => `RED:${str}`,
    cyan: (str: string) => `CYAN:${str}`,
    underline: (str: string) => `UNDERLINE:${str}`,
  },
}));

describe('cliPrint', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  describe('printSummary', () => {
    test('should print summary with suspicious files and security check enabled', () => {
      const config = createMockConfig({
        security: { enableSecurityCheck: true },
      });
      const suspiciousFiles: SuspiciousFileResult[] = [
        { filePath: 'suspicious.txt', messages: ['Contains sensitive data'], type: 'file' },
      ];

      const packResult: PackResult = {
        totalFiles: 10,
        totalCharacters: 1000,
        totalTokens: 200,
        fileCharCounts: { 'file1.txt': 100 },
        fileTokenCounts: { 'file1.txt': 50 },
        suspiciousFilesResults: suspiciousFiles,
        suspiciousGitDiffResults: [],
        processedFiles: [],
        safeFilePaths: [],
        gitDiffTokenCount: 0,
      };

      printSummary(packResult, config);

      expect(logger.log).toHaveBeenCalledWith(expect.stringContaining('1 suspicious file(s) detected and excluded'));
    });

    test('should print summary with security check disabled', () => {
      const config = createMockConfig({
        security: { enableSecurityCheck: false },
      });

      const packResult: PackResult = {
        totalFiles: 10,
        totalCharacters: 1000,
        totalTokens: 200,
        fileCharCounts: { 'file1.txt': 100 },
        fileTokenCounts: { 'file1.txt': 50 },
        suspiciousFilesResults: [],
        suspiciousGitDiffResults: [],
        processedFiles: [],
        safeFilePaths: [],
        gitDiffTokenCount: 0,
      };

      printSummary(packResult, config);

      expect(logger.log).toHaveBeenCalledWith(expect.stringContaining('Security check disabled'));
    });
  });

  describe('printSecurityCheck', () => {
    test('should skip printing when security check is disabled', () => {
      const config = createMockConfig({
        security: { enableSecurityCheck: false },
      });

      printSecurityCheck('/root', [], [], config);
      expect(logger.log).not.toHaveBeenCalled();
    });

    test('should print message when no suspicious files found', () => {
      const config = createMockConfig({
        security: { enableSecurityCheck: true },
      });

      printSecurityCheck('/root', [], [], config);

      expect(logger.log).toHaveBeenCalledWith('WHITE:🔎 Security Check:');
      expect(logger.log).toHaveBeenCalledWith('DIM:──────────────────');
      expect(logger.log).toHaveBeenCalledWith('GREEN:✔ WHITE:No suspicious files detected.');
    });

    test('should print details of suspicious files when found', () => {
      const config = createMockConfig({
        security: { enableSecurityCheck: true },
      });
      const configRelativePath = path.join('config', 'secrets.txt');
      const suspiciousFiles: SuspiciousFileResult[] = [
        {
          filePath: path.join('/root', configRelativePath),
          messages: ['Contains API key', 'Contains password'],
          type: 'file',
        },
      ];

      printSecurityCheck('/root', suspiciousFiles, [], config);

      expect(logger.log).toHaveBeenCalledWith('YELLOW:1 suspicious file(s) detected and excluded from the output:');
      expect(logger.log).toHaveBeenCalledWith(`WHITE:1. WHITE:${configRelativePath}`);
      expect(logger.log).toHaveBeenCalledWith(expect.stringContaining('Contains API key'));
      expect(logger.log).toHaveBeenCalledWith(expect.stringContaining('Contains password'));
      expect(logger.log).toHaveBeenCalledWith(
        expect.stringContaining('Please review these files for potential sensitive information.'),
      );
    });
  });

  describe('printTopFiles', () => {
    test('should print top files sorted by character count', () => {
      const fileCharCounts = {
        'src/index.ts': 1000,
        'src/utils.ts': 500,
        'README.md': 2000,
      };
      const fileTokenCounts = {
        'src/index.ts': 200,
        'src/utils.ts': 100,
        'README.md': 400,
      };

      printTopFiles(fileCharCounts, fileTokenCounts, 2, 60);

      expect(logger.log).toHaveBeenCalledWith(expect.stringContaining('Top 2 Files'));
      expect(logger.log).toHaveBeenCalledWith(expect.stringContaining('README.md'));
      expect(logger.log).toHaveBeenCalledWith(expect.stringContaining('src/index.ts'));
      expect(logger.log).not.toHaveBeenCalledWith(expect.stringContaining('src/utils.ts'));
    });

    test('should handle empty file list', () => {
      printTopFiles({}, {}, 5, 0);

      expect(logger.log).toHaveBeenCalledWith(expect.stringContaining('Top 5 Files'));
    });
  });

  describe('printCompletion', () => {
    test('should print completion message', () => {
      printCompletion();

      expect(logger.log).toHaveBeenCalledWith('GREEN:🎉 All Done!');
      expect(logger.log).toHaveBeenCalledWith('WHITE:Your repository has been successfully packed.');
    });
  });
});
</file>

<file path="tests/cli/cliRun.test.ts">
import { program } from 'commander';
import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
import * as defaultAction from '../../src/cli/actions/defaultAction.js';
import * as initAction from '../../src/cli/actions/initAction.js';
import * as remoteAction from '../../src/cli/actions/remoteAction.js';
import * as versionAction from '../../src/cli/actions/versionAction.js';
import { run, runCli } from '../../src/cli/cliRun.js';
import type { CliOptions } from '../../src/cli/types.js';
import type { RepomixConfigMerged } from '../../src/config/configSchema.js';
import type { PackResult } from '../../src/core/packager.js';
import { type RepomixLogLevel, logger, repomixLogLevels } from '../../src/shared/logger.js';

let logLevel: RepomixLogLevel;

vi.mock('../../src/shared/logger', () => ({
  repomixLogLevels: {
    SILENT: -1,
    ERROR: 0,
    WARN: 1,
    INFO: 2,
    DEBUG: 3,
  },
  logger: {
    log: vi.fn(),
    trace: vi.fn(),
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
    success: vi.fn(),
    note: vi.fn(),
    setLogLevel: vi.fn((level: RepomixLogLevel) => {
      logLevel = level;
    }),
    getLogLevel: vi.fn(() => logLevel),
  },
  setLogLevelByEnv: vi.fn(),
}));

vi.mock('../../src/cli/actions/defaultAction');
vi.mock('../../src/cli/actions/initAction');
vi.mock('../../src/cli/actions/remoteAction');
vi.mock('../../src/cli/actions/versionAction');

describe('cliRun', () => {
  beforeEach(() => {
    vi.resetAllMocks();

    vi.mocked(defaultAction.runDefaultAction).mockResolvedValue({
      config: {
        cwd: process.cwd(),
        input: {
          maxFileSize: 50 * 1024 * 1024,
        },
        output: {
          filePath: 'repomix-output.txt',
          style: 'plain',
          stdout: false,
          parsableStyle: false,
          fileSummary: true,
          directoryStructure: true,
          topFilesLength: 5,
          showLineNumbers: false,
          removeComments: false,
          removeEmptyLines: false,
          compress: false,
          copyToClipboard: false,
          files: true,
          git: {
            sortByChanges: true,
            sortByChangesMaxCommits: 100,
            includeDiffs: false,
          },
        },
        include: [],
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
          customPatterns: [],
        },
        security: {
          enableSecurityCheck: true,
        },
        tokenCount: {
          encoding: 'o200k_base',
        },
      } satisfies RepomixConfigMerged,
      packResult: {
        totalFiles: 0,
        totalCharacters: 0,
        totalTokens: 0,
        fileCharCounts: {},
        fileTokenCounts: {},
        suspiciousFilesResults: [],
        gitDiffTokenCount: 0,
        suspiciousGitDiffResults: [],
        processedFiles: [],
        safeFilePaths: [],
      } satisfies PackResult,
    });
    vi.mocked(initAction.runInitAction).mockResolvedValue();
    vi.mocked(remoteAction.runRemoteAction).mockResolvedValue({
      config: {
        cwd: process.cwd(),
        input: {
          maxFileSize: 50 * 1024 * 1024,
        },
        output: {
          filePath: 'repomix-output.txt',
          stdout: false,
          style: 'plain',
          parsableStyle: false,
          fileSummary: true,
          directoryStructure: true,
          topFilesLength: 5,
          showLineNumbers: false,
          removeComments: false,
          removeEmptyLines: false,
          compress: false,
          copyToClipboard: false,
          files: true,
          git: {
            sortByChanges: true,
            sortByChangesMaxCommits: 100,
            includeDiffs: false,
          },
        },
        include: [],
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
          customPatterns: [],
        },
        security: {
          enableSecurityCheck: true,
        },
        tokenCount: {
          encoding: 'o200k_base',
        },
      } satisfies RepomixConfigMerged,
      packResult: {
        totalFiles: 0,
        totalCharacters: 0,
        totalTokens: 0,
        fileCharCounts: {},
        fileTokenCounts: {},
        suspiciousFilesResults: [],
        gitDiffTokenCount: 0,
        suspiciousGitDiffResults: [],
        processedFiles: [],
        safeFilePaths: [],
      } satisfies PackResult,
    });
    vi.mocked(versionAction.runVersionAction).mockResolvedValue();
  });

  test('should call process.exit(1) on error', async () => {
    const exitSpy = vi.spyOn(process, 'exit').mockImplementationOnce(() => undefined as never);
    const parseSpy = vi.spyOn(program, 'description').mockImplementationOnce(() => {
      throw Error();
    });
    const handleErrorSpy = vi.spyOn(logger, 'error');
    await expect(run()).resolves.not.toThrow();
    expect(exitSpy).toHaveBeenCalledWith(1);
    expect(handleErrorSpy).toHaveBeenCalled();
    exitSpy.mockReset();
    parseSpy.mockReset();
    handleErrorSpy.mockReset();
  });

  describe('executeAction', () => {
    test('should execute default action when no special options provided', async () => {
      await runCli(['.'], process.cwd(), {});

      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith(['.'], process.cwd(), expect.any(Object));
    });

    test('should enable verbose logging when verbose option is true', async () => {
      await runCli(['.'], process.cwd(), { verbose: true });

      expect(logger.setLogLevel).toHaveBeenCalledWith(repomixLogLevels.DEBUG);
    });

    test('should execute version action when version option is true', async () => {
      await runCli(['.'], process.cwd(), { version: true });

      expect(versionAction.runVersionAction).toHaveBeenCalled();
      expect(defaultAction.runDefaultAction).not.toHaveBeenCalled();
    });

    test('should execute init action when init option is true', async () => {
      await runCli(['.'], process.cwd(), { init: true });

      expect(initAction.runInitAction).toHaveBeenCalledWith(process.cwd(), false);
      expect(defaultAction.runDefaultAction).not.toHaveBeenCalled();
    });

    test('should execute remote action when remote option is provided', async () => {
      await runCli(['.'], process.cwd(), {
        remote: 'yamadashy/repomix',
      });

      expect(remoteAction.runRemoteAction).toHaveBeenCalledWith('yamadashy/repomix', expect.any(Object));
      expect(defaultAction.runDefaultAction).not.toHaveBeenCalled();
    });
  });

  describe('parsable style flag', () => {
    test('should disable parsable style by default', async () => {
      await runCli(['.'], process.cwd(), {});

      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith(
        ['.'],
        process.cwd(),
        expect.not.objectContaining({
          parsableStyle: false,
        }),
      );
    });

    test('should handle --parsable-style flag', async () => {
      await runCli(['.'], process.cwd(), { parsableStyle: true });

      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith(
        ['.'],
        process.cwd(),
        expect.objectContaining({
          parsableStyle: true,
        }),
      );
    });
  });

  describe('security check flag', () => {
    test('should enable security check by default', async () => {
      await runCli(['.'], process.cwd(), {});

      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith(
        ['.'],
        process.cwd(),
        expect.not.objectContaining({
          securityCheck: false,
        }),
      );
    });

    test('should handle --no-security-check flag', async () => {
      await runCli(['.'], process.cwd(), { securityCheck: false });

      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith(
        ['.'],
        process.cwd(),
        expect.objectContaining({
          securityCheck: false,
        }),
      );
    });

    test('should handle explicit --security-check flag', async () => {
      await runCli(['.'], process.cwd(), { securityCheck: true });

      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith(
        ['.'],
        process.cwd(),
        expect.objectContaining({
          securityCheck: true,
        }),
      );
    });

    test('should handle explicit --no-gitignore flag', async () => {
      await runCli(['.'], process.cwd(), { gitignore: false });

      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith(
        ['.'],
        process.cwd(),
        expect.objectContaining({
          gitignore: false,
        }),
      );
    });

    test('should handle explicit --no-default-patterns flag', async () => {
      await runCli(['.'], process.cwd(), { defaultPatterns: false });

      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith(
        ['.'],
        process.cwd(),
        expect.objectContaining({
          defaultPatterns: false,
        }),
      );
    });

    test('should handle explicit --header-text flag', async () => {
      await runCli(['.'], process.cwd(), {
        headerText: 'I am a good header text',
      });

      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith(
        ['.'],
        process.cwd(),
        expect.objectContaining({
          headerText: 'I am a good header text',
        }),
      );
    });

    test('should handle --instruction-file-path flag', async () => {
      await runCli(['.'], process.cwd(), {
        instructionFilePath: 'path/to/instruction.txt',
      });

      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith(
        ['.'],
        process.cwd(),
        expect.objectContaining({
          instructionFilePath: 'path/to/instruction.txt',
        }),
      );
    });

    test('should handle --include-empty-directories flag', async () => {
      await runCli(['.'], process.cwd(), {
        includeEmptyDirectories: true,
      });

      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith(
        ['.'],
        process.cwd(),
        expect.objectContaining({
          includeEmptyDirectories: true,
        }),
      );
    });
  });

  describe('quiet mode', () => {
    test('should set log level to SILENT when quiet option is true', async () => {
      const options: CliOptions = {
        quiet: true,
      };

      await runCli(['.'], process.cwd(), options);

      expect(logger.getLogLevel()).toBe(repomixLogLevels.SILENT);
    });

    test('should set log level to DEBUG when verbose option is true', async () => {
      const options: CliOptions = {
        verbose: true,
      };

      await runCli(['.'], process.cwd(), options);

      expect(logger.getLogLevel()).toBe(repomixLogLevels.DEBUG);
    });

    test('should set log level to INFO by default', async () => {
      const options: CliOptions = {};

      await runCli(['.'], process.cwd(), options);

      expect(logger.getLogLevel()).toBe(repomixLogLevels.INFO);
    });
  });

  describe('stdout mode', () => {
    const originalIsTTY = process.stdout.isTTY;

    afterEach(() => {
      process.stdout.isTTY = originalIsTTY;
    });

    test('should handle --stdout flag', async () => {
      const options: CliOptions = {
        stdout: true,
      };

      await runCli(['.'], process.cwd(), options);

      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith(
        ['.'],
        process.cwd(),
        expect.objectContaining({
          stdout: true,
        }),
      );
    });

    test('should not enable stdout mode when explicitly setting output', async () => {
      // Mock pipe detection
      process.stdout.isTTY = false;
      const options: CliOptions = {
        output: 'custom-output.txt',
      };

      await runCli(['.'], process.cwd(), options);

      // stdout should not be set
      expect(defaultAction.runDefaultAction).toHaveBeenCalledWith(
        ['.'],
        process.cwd(),
        expect.objectContaining({
          output: 'custom-output.txt',
        }),
      );
      expect(defaultAction.runDefaultAction).not.toHaveBeenCalledWith(
        ['.'],
        process.cwd(),
        expect.objectContaining({
          stdout: true,
        }),
      );
    });
  });
});
</file>

<file path="tests/config/configLoad.test.ts">
import type { Stats } from 'node:fs';
import * as fs from 'node:fs/promises';
import path from 'node:path';
import process from 'node:process';
import pc from 'picocolors';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { loadFileConfig, mergeConfigs } from '../../src/config/configLoad.js';
import type { RepomixConfigCli, RepomixConfigFile } from '../../src/config/configSchema.js';
import { getGlobalDirectory } from '../../src/config/globalDirectory.js';
import { RepomixConfigValidationError, RepomixError } from '../../src/shared/errorHandle.js';
import { logger } from '../../src/shared/logger.js';

vi.mock('node:fs/promises');
vi.mock('../../src/shared/logger', () => ({
  logger: {
    trace: vi.fn(),
    note: vi.fn(),
    log: vi.fn(),
  },
}));
vi.mock('../../src/config/globalDirectory', () => ({
  getGlobalDirectory: vi.fn(),
}));

describe('configLoad', () => {
  beforeEach(() => {
    vi.resetAllMocks();
    process.env = {};
  });

  describe('loadFileConfig', () => {
    test('should load and parse a valid local config file', async () => {
      const mockConfig = {
        output: { filePath: 'test-output.txt' },
        ignore: { useDefaultPatterns: true },
      };
      vi.mocked(fs.readFile).mockResolvedValue(JSON.stringify(mockConfig));
      vi.mocked(fs.stat).mockResolvedValue({ isFile: () => true } as Stats);

      const result = await loadFileConfig(process.cwd(), 'test-config.json');
      expect(result).toEqual(mockConfig);
    });

    test('should throw RepomixConfigValidationError for invalid config', async () => {
      const invalidConfig = {
        output: { filePath: 123, style: 'invalid' }, // Invalid filePath type and invalid style
        ignore: { useDefaultPatterns: 'not a boolean' }, // Invalid type
      };
      vi.mocked(fs.readFile).mockResolvedValue(JSON.stringify(invalidConfig));
      vi.mocked(fs.stat).mockResolvedValue({ isFile: () => true } as Stats);

      await expect(loadFileConfig(process.cwd(), 'test-config.json')).rejects.toThrow(RepomixConfigValidationError);
    });

    test('should load global config when local config is not found', async () => {
      const mockGlobalConfig = {
        output: { filePath: 'global-output.txt' },
        ignore: { useDefaultPatterns: false },
      };
      vi.mocked(getGlobalDirectory).mockReturnValue('/global/repomix');
      vi.mocked(fs.stat)
        .mockRejectedValueOnce(new Error('File not found')) // Local repomix.config.json5
        .mockRejectedValueOnce(new Error('File not found')) // Local repomix.config.jsonc
        .mockRejectedValueOnce(new Error('File not found')) // Local repomix.config.json
        .mockResolvedValueOnce({ isFile: () => true } as Stats); // Global repomix.config.json5
      vi.mocked(fs.readFile).mockResolvedValue(JSON.stringify(mockGlobalConfig));

      const result = await loadFileConfig(process.cwd(), null);
      expect(result).toEqual(mockGlobalConfig);
      expect(fs.readFile).toHaveBeenCalledWith(path.join('/global/repomix', 'repomix.config.json5'), 'utf-8');
    });

    test('should return an empty object if no config file is found', async () => {
      const loggerSpy = vi.spyOn(logger, 'log').mockImplementation(vi.fn());
      vi.mocked(getGlobalDirectory).mockReturnValue('/global/repomix');
      vi.mocked(fs.stat).mockRejectedValue(new Error('File not found'));

      const result = await loadFileConfig(process.cwd(), null);
      expect(result).toEqual({});

      expect(loggerSpy).toHaveBeenCalledWith(expect.stringContaining('No custom config found'));
      expect(loggerSpy).toHaveBeenCalledWith(expect.stringContaining('repomix.config.json5'));
      expect(loggerSpy).toHaveBeenCalledWith(expect.stringContaining('repomix.config.jsonc'));
      expect(loggerSpy).toHaveBeenCalledWith(expect.stringContaining('repomix.config.json'));
    });

    test('should throw an error for invalid JSON', async () => {
      vi.mocked(fs.readFile).mockResolvedValue('invalid json');
      vi.mocked(fs.stat).mockResolvedValue({ isFile: () => true } as Stats);

      await expect(loadFileConfig(process.cwd(), 'test-config.json')).rejects.toThrow('Invalid JSON');
    });

    test('should parse config file with comments', async () => {
      const configWithComments = `{
        // Output configuration
        "output": {
          "filePath": "test-output.txt"
        },
        /* Ignore configuration */
        "ignore": {
          "useGitignore": true // Use .gitignore file
        }
      }`;

      vi.mocked(fs.readFile).mockResolvedValue(configWithComments);
      vi.mocked(fs.stat).mockResolvedValue({ isFile: () => true } as Stats);

      const result = await loadFileConfig(process.cwd(), 'test-config.json');
      expect(result).toEqual({
        output: { filePath: 'test-output.txt' },
        ignore: { useGitignore: true },
      });
    });

    test('should parse config file with JSON5 features', async () => {
      const configWithJSON5Features = `{
        // Output configuration
        output: {
          filePath: 'test-output.txt',
          style: 'plain',
        },
        /* Ignore configuration */
        ignore: {
          useGitignore: true, // Use .gitignore file
          customPatterns: [
            '*.log',
            '*.tmp',
            '*.temp', // Trailing comma
          ],
        },
      }`;

      vi.mocked(fs.readFile).mockResolvedValue(configWithJSON5Features);
      vi.mocked(fs.stat).mockResolvedValue({ isFile: () => true } as Stats);

      const result = await loadFileConfig(process.cwd(), 'test-config.json');
      expect(result).toEqual({
        output: { filePath: 'test-output.txt', style: 'plain' },
        ignore: {
          useGitignore: true,
          customPatterns: ['*.log', '*.tmp', '*.temp'],
        },
      });
    });

    test('should load .jsonc config file with priority order', async () => {
      const mockConfig = {
        output: { filePath: 'jsonc-output.txt' },
        ignore: { useDefaultPatterns: true },
      };
      vi.mocked(fs.stat)
        .mockRejectedValueOnce(new Error('File not found')) // repomix.config.json5
        .mockResolvedValueOnce({ isFile: () => true } as Stats); // repomix.config.jsonc
      vi.mocked(fs.readFile).mockResolvedValue(JSON.stringify(mockConfig));

      const result = await loadFileConfig(process.cwd(), null);
      expect(result).toEqual(mockConfig);
      expect(fs.readFile).toHaveBeenCalledWith(path.resolve(process.cwd(), 'repomix.config.jsonc'), 'utf-8');
    });

    test('should prioritize .json5 over .jsonc and .json', async () => {
      const mockConfig = {
        output: { filePath: 'json5-output.txt' },
        ignore: { useDefaultPatterns: true },
      };
      vi.mocked(fs.stat).mockResolvedValueOnce({ isFile: () => true } as Stats); // repomix.config.json5 exists
      vi.mocked(fs.readFile).mockResolvedValue(JSON.stringify(mockConfig));

      const result = await loadFileConfig(process.cwd(), null);
      expect(result).toEqual(mockConfig);
      expect(fs.readFile).toHaveBeenCalledWith(path.resolve(process.cwd(), 'repomix.config.json5'), 'utf-8');
      // Should not check for .jsonc or .json since .json5 was found
      expect(fs.stat).toHaveBeenCalledTimes(1);
    });

    test('should throw RepomixError when specific config file does not exist', async () => {
      const nonExistentConfigPath = 'non-existent-config.json';
      vi.mocked(fs.stat).mockRejectedValue(new Error('File not found'));

      await expect(loadFileConfig(process.cwd(), nonExistentConfigPath)).rejects.toThrow(
        `Config file not found at ${nonExistentConfigPath}`,
      );
    });
  });

  describe('mergeConfigs', () => {
    test('should correctly merge configs', () => {
      const fileConfig: RepomixConfigFile = {
        output: { filePath: 'file-output.txt' },
        ignore: { useDefaultPatterns: true, customPatterns: ['file-ignore'] },
      };
      const cliConfig: RepomixConfigCli = {
        output: { filePath: 'cli-output.txt' },
        ignore: { customPatterns: ['cli-ignore'] },
      };

      const result = mergeConfigs(process.cwd(), fileConfig, cliConfig);

      expect(result.output.filePath).toBe('cli-output.txt');
      expect(result.ignore.useDefaultPatterns).toBe(true);
      expect(result.ignore.customPatterns).toContain('file-ignore');
      expect(result.ignore.customPatterns).toContain('cli-ignore');
    });

    test('should throw RepomixConfigValidationError for invalid merged config', () => {
      const fileConfig: RepomixConfigFile = {
        output: { filePath: 'file-output.txt', style: 'plain' },
      };
      const cliConfig: RepomixConfigCli = {
        // @ts-ignore
        output: { style: 'invalid' }, // Invalid style
      };

      expect(() => mergeConfigs(process.cwd(), fileConfig, cliConfig)).toThrow(RepomixConfigValidationError);
    });
  });
});
</file>

<file path="tests/config/configSchema.test.ts">
import { describe, expect, it } from 'vitest';
import { z } from 'zod';
import {
  repomixConfigBaseSchema,
  repomixConfigCliSchema,
  repomixConfigDefaultSchema,
  repomixConfigFileSchema,
  repomixConfigMergedSchema,
  repomixOutputStyleSchema,
} from '../../src/config/configSchema.js';

describe('configSchema', () => {
  describe('repomixOutputStyleSchema', () => {
    it('should accept valid output styles', () => {
      expect(repomixOutputStyleSchema.parse('plain')).toBe('plain');
      expect(repomixOutputStyleSchema.parse('xml')).toBe('xml');
    });

    it('should reject invalid output styles', () => {
      expect(() => repomixOutputStyleSchema.parse('invalid')).toThrow(z.ZodError);
    });
  });

  describe('repomixConfigBaseSchema', () => {
    it('should accept valid base config', () => {
      const validConfig = {
        output: {
          filePath: 'output.txt',
          style: 'plain',
          removeComments: true,
        },
        include: ['**/*.js'],
        ignore: {
          useGitignore: true,
          customPatterns: ['node_modules'],
        },
        security: {
          enableSecurityCheck: true,
        },
      };
      expect(repomixConfigBaseSchema.parse(validConfig)).toEqual(validConfig);
    });

    it('should accept empty object', () => {
      expect(repomixConfigBaseSchema.parse({})).toEqual({});
    });

    it('should reject invalid types', () => {
      const invalidConfig = {
        output: {
          filePath: 123, // Should be string
          style: 'invalid', // Should be 'plain' or 'xml'
        },
        include: 'not-an-array', // Should be an array
      };
      expect(() => repomixConfigBaseSchema.parse(invalidConfig)).toThrow(z.ZodError);
    });
  });

  describe('repomixConfigDefaultSchema', () => {
    it('should accept valid default config', () => {
      const validConfig = {
        input: {
          maxFileSize: 50 * 1024 * 1024,
        },
        output: {
          filePath: 'output.txt',
          style: 'plain',
          parsableStyle: false,
          fileSummary: true,
          directoryStructure: true,
          files: true,
          removeComments: false,
          removeEmptyLines: false,
          compress: false,
          topFilesLength: 5,
          showLineNumbers: false,
          copyToClipboard: true,
          git: {
            sortByChanges: true,
            sortByChangesMaxCommits: 100,
            includeDiffs: false,
          },
        },
        include: [],
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
          customPatterns: [],
        },
        security: {
          enableSecurityCheck: true,
        },
        tokenCount: {
          encoding: 'o200k_base',
        },
      };
      expect(repomixConfigDefaultSchema.parse(validConfig)).toEqual(validConfig);
    });

    it('should reject incomplete config', () => {
      const validConfig = {};
      expect(() => repomixConfigDefaultSchema.parse(validConfig)).not.toThrow();
    });
  });

  describe('repomixConfigFileSchema', () => {
    it('should accept valid file config', () => {
      const validConfig = {
        output: {
          filePath: 'custom-output.txt',
          style: 'xml',
        },
        ignore: {
          customPatterns: ['*.log'],
        },
      };
      expect(repomixConfigFileSchema.parse(validConfig)).toEqual(validConfig);
    });

    it('should accept partial config', () => {
      const partialConfig = {
        output: {
          filePath: 'partial-output.txt',
        },
      };
      expect(repomixConfigFileSchema.parse(partialConfig)).toEqual(partialConfig);
    });
  });

  describe('repomixConfigCliSchema', () => {
    it('should accept valid CLI config', () => {
      const validConfig = {
        output: {
          filePath: 'cli-output.txt',
          showLineNumbers: true,
        },
        include: ['src/**/*.ts'],
      };
      expect(repomixConfigCliSchema.parse(validConfig)).toEqual(validConfig);
    });

    it('should reject invalid CLI options', () => {
      const invalidConfig = {
        output: {
          filePath: 123, // Should be string
        },
      };
      expect(() => repomixConfigCliSchema.parse(invalidConfig)).toThrow(z.ZodError);
    });
  });

  describe('repomixConfigMergedSchema', () => {
    it('should accept valid merged config', () => {
      const validConfig = {
        cwd: '/path/to/project',
        input: {
          maxFileSize: 50 * 1024 * 1024,
        },
        output: {
          filePath: 'merged-output.txt',
          style: 'plain',
          parsableStyle: false,
          fileSummary: true,
          directoryStructure: true,
          files: true,
          removeComments: true,
          removeEmptyLines: false,
          compress: false,
          topFilesLength: 10,
          showLineNumbers: true,
          copyToClipboard: false,
          git: {
            sortByChanges: true,
            sortByChangesMaxCommits: 100,
            includeDiffs: false,
          },
        },
        include: ['**/*.js', '**/*.ts'],
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
          customPatterns: ['*.log'],
        },
        security: {
          enableSecurityCheck: true,
        },
        tokenCount: {
          encoding: 'o200k_base',
        },
      };
      expect(repomixConfigMergedSchema.parse(validConfig)).toEqual(validConfig);
    });

    it('should reject merged config missing required fields', () => {
      const invalidConfig = {
        output: {
          filePath: 'output.txt',
          // Missing required fields
        },
      };
      expect(() => repomixConfigMergedSchema.parse(invalidConfig)).toThrow(z.ZodError);
    });

    it('should reject merged config with invalid types', () => {
      const invalidConfig = {
        cwd: '/path/to/project',
        output: {
          filePath: 'output.txt',
          style: 'plain',
          removeComments: 'not-a-boolean', // Should be boolean
          removeEmptyLines: false,
          compress: false,
          topFilesLength: '5', // Should be number
          showLineNumbers: false,
        },
        include: ['**/*.js'],
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
        },
        security: {
          enableSecurityCheck: true,
        },
      };
      expect(() => repomixConfigMergedSchema.parse(invalidConfig)).toThrow(z.ZodError);
    });
  });
});
</file>

<file path="tests/config/globalDirectory.test.ts">
import os from 'node:os';
import path from 'node:path';
import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
import { getGlobalDirectory } from '../../src/config/globalDirectory.js';

vi.mock('node:os');

describe('getGlobalDirectory', () => {
  const originalPlatform = process.platform;
  const originalEnv = process.env;

  beforeEach(() => {
    vi.resetAllMocks();
    process.env = { ...originalEnv };
  });

  afterEach(() => {
    Object.defineProperty(process, 'platform', { value: originalPlatform });
    process.env = originalEnv;
  });

  describe('Windows platform', () => {
    test('should use LOCALAPPDATA when available', () => {
      Object.defineProperty(process, 'platform', { value: 'win32' });
      process.env.LOCALAPPDATA = 'C:\\Users\\Test\\AppData\\Local';

      const result = getGlobalDirectory();
      expect(result).toBe(path.join('C:\\Users\\Test\\AppData\\Local', 'Repomix'));
    });

    test('should fall back to homedir when LOCALAPPDATA is not available', () => {
      Object.defineProperty(process, 'platform', { value: 'win32' });
      process.env.LOCALAPPDATA = undefined;
      vi.mocked(os.homedir).mockReturnValue('C:\\Users\\Test');

      const result = getGlobalDirectory();
      expect(result).toBe(path.join('C:\\Users\\Test', 'AppData', 'Local', 'Repomix'));
    });
  });

  describe('Unix platforms', () => {
    test('should use XDG_CONFIG_HOME when available', () => {
      Object.defineProperty(process, 'platform', { value: 'linux' });
      process.env.XDG_CONFIG_HOME = '/custom/config';

      const result = getGlobalDirectory();
      expect(result).toBe(path.join('/custom/config', 'repomix'));
    });

    test('should fall back to ~/.config on Linux', () => {
      Object.defineProperty(process, 'platform', { value: 'linux' });
      process.env.XDG_CONFIG_HOME = undefined;
      vi.mocked(os.homedir).mockReturnValue('/home/test');

      const result = getGlobalDirectory();
      expect(result).toBe(path.join('/home/test', '.config', 'repomix'));
    });

    test('should fall back to ~/.config on macOS', () => {
      Object.defineProperty(process, 'platform', { value: 'darwin' });
      process.env.XDG_CONFIG_HOME = undefined;
      vi.mocked(os.homedir).mockReturnValue('/Users/test');

      const result = getGlobalDirectory();
      expect(result).toBe(path.join('/Users/test', '.config', 'repomix'));
    });
  });

  describe('Edge cases', () => {
    test('should handle empty homedir', () => {
      Object.defineProperty(process, 'platform', { value: 'linux' });
      process.env.XDG_CONFIG_HOME = undefined;
      vi.mocked(os.homedir).mockReturnValue('');

      const result = getGlobalDirectory();
      expect(result).toBe(path.join('', '.config', 'repomix'));
    });

    test('should handle unusual XDG_CONFIG_HOME paths', () => {
      Object.defineProperty(process, 'platform', { value: 'linux' });
      process.env.XDG_CONFIG_HOME = '////multiple///slashes///';

      const result = getGlobalDirectory();
      expect(result).toBe(path.join('////multiple///slashes///', 'repomix'));
    });
  });
});
</file>

<file path="tests/core/file/fileCollect.test.ts">
import type { Stats } from 'node:fs';
import * as fs from 'node:fs/promises';
import path from 'node:path';
import iconv from 'iconv-lite';
import { isBinary } from 'istextorbinary';
import jschardet from 'jschardet';
import pc from 'picocolors';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { collectFiles } from '../../../src/core/file/fileCollect.js';
import type { FileCollectTask } from '../../../src/core/file/workers/fileCollectWorker.js';
import fileCollectWorker from '../../../src/core/file/workers/fileCollectWorker.js';
import { logger } from '../../../src/shared/logger.js';
import { createMockConfig } from '../../testing/testUtils.js';

// Define the max file size constant for tests
const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB

vi.mock('node:fs/promises');
vi.mock('istextorbinary');
vi.mock('jschardet');
vi.mock('iconv-lite');
vi.mock('../../../src/shared/logger');

const mockInitTaskRunner = () => {
  return async (task: FileCollectTask) => {
    return await fileCollectWorker(task);
  };
};

describe('fileCollect', () => {
  beforeEach(() => {
    vi.resetAllMocks();

    // Setup basic file size mock to fix stat
    vi.mocked(fs.stat).mockResolvedValue({
      size: 1024,
      isFile: () => true,
    } as Stats);
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  it('should collect non-binary files', async () => {
    const mockFilePaths = ['file1.txt', 'file2.txt'];
    const mockRootDir = '/root';
    const mockConfig = createMockConfig();

    vi.mocked(isBinary).mockReturnValue(false);
    vi.mocked(fs.readFile).mockResolvedValue(Buffer.from('file content'));
    vi.mocked(jschardet.detect).mockReturnValue({ encoding: 'utf-8', confidence: 0.99 });
    vi.mocked(iconv.decode).mockReturnValue('decoded content');

    const result = await collectFiles(mockFilePaths, mockRootDir, mockConfig, () => {}, {
      initTaskRunner: mockInitTaskRunner,
    });

    expect(result).toEqual([
      { path: 'file1.txt', content: 'decoded content' },
      { path: 'file2.txt', content: 'decoded content' },
    ]);
  });

  it('should skip binary files', async () => {
    const mockFilePaths = ['binary.bin', 'text.txt'];
    const mockRootDir = '/root';
    const mockConfig = createMockConfig();

    vi.mocked(isBinary)
      .mockReturnValueOnce(true) // for binary.bin
      .mockReturnValueOnce(false); // for text.txt
    vi.mocked(fs.readFile).mockResolvedValue(Buffer.from('file content'));
    vi.mocked(jschardet.detect).mockReturnValue({ encoding: 'utf-8', confidence: 0.99 });
    vi.mocked(iconv.decode).mockReturnValue('decoded content');

    const result = await collectFiles(mockFilePaths, mockRootDir, mockConfig, () => {}, {
      initTaskRunner: mockInitTaskRunner,
    });

    expect(result).toEqual([{ path: 'text.txt', content: 'decoded content' }]);
    expect(logger.debug).toHaveBeenCalledWith(`Skipping binary file: ${path.resolve('/root/binary.bin')}`);
  });

  it('should skip large files based on default maxFileSize', async () => {
    const mockFilePaths = ['large.txt', 'normal.txt'];
    const mockRootDir = '/root';
    const mockConfig = createMockConfig();
    const largePath = path.resolve('/root/large.txt');

    vi.mocked(fs.stat)
      .mockResolvedValueOnce({
        // for large.txt
        size: MAX_FILE_SIZE + 1024, // Slightly over limit
        isFile: () => true,
      } as Stats)
      .mockResolvedValueOnce({
        // for normal.txt
        size: 1024,
        isFile: () => true,
      } as Stats);
    vi.mocked(isBinary).mockReturnValue(false);
    vi.mocked(fs.readFile).mockResolvedValue(Buffer.from('file content'));
    vi.mocked(jschardet.detect).mockReturnValue({ encoding: 'utf-8', confidence: 0.99 });
    vi.mocked(iconv.decode).mockReturnValue('decoded content');

    const result = await collectFiles(mockFilePaths, mockRootDir, mockConfig, () => {}, {
      initTaskRunner: mockInitTaskRunner,
    });

    expect(result).toEqual([{ path: 'normal.txt', content: 'decoded content' }]);
    expect(logger.trace).toHaveBeenCalledWith(expect.stringContaining('File exceeds size limit:'));
    expect(logger.trace).toHaveBeenCalledWith(expect.stringContaining(largePath));

    // Verify fs.readFile is not called for the large file
    expect(fs.readFile).not.toHaveBeenCalledWith(largePath);
    expect(fs.readFile).toHaveBeenCalledTimes(1);
  });

  it('should respect custom maxFileSize setting', async () => {
    const mockFilePaths = ['medium.txt', 'small.txt'];
    const mockRootDir = '/root';
    const customMaxFileSize = 5 * 1024 * 1024; // 5MB
    const mockConfig = createMockConfig({
      input: {
        maxFileSize: customMaxFileSize,
      },
    });
    const mediumPath = path.resolve('/root/medium.txt');

    vi.mocked(fs.stat)
      .mockResolvedValueOnce({
        // for medium.txt
        size: 10 * 1024 * 1024, // 10MB (exceeds custom 5MB limit)
        isFile: () => true,
      } as Stats)
      .mockResolvedValueOnce({
        // for small.txt
        size: 1024, // 1KB (within limit)
        isFile: () => true,
      } as Stats);
    vi.mocked(isBinary).mockReturnValue(false);
    vi.mocked(fs.readFile).mockResolvedValue(Buffer.from('file content'));
    vi.mocked(jschardet.detect).mockReturnValue({ encoding: 'utf-8', confidence: 0.99 });
    vi.mocked(iconv.decode).mockReturnValue('decoded content');

    const result = await collectFiles(mockFilePaths, mockRootDir, mockConfig, () => {}, {
      initTaskRunner: mockInitTaskRunner,
    });

    expect(result).toEqual([{ path: 'small.txt', content: 'decoded content' }]);
    expect(logger.trace).toHaveBeenCalledWith(expect.stringContaining('File exceeds size limit:'));
    expect(logger.trace).toHaveBeenCalledWith(expect.stringContaining('10240.0KB > 5120.0KB'));
    expect(logger.trace).toHaveBeenCalledWith(expect.stringContaining(mediumPath));

    // Verify fs.readFile is not called for the medium file
    expect(fs.readFile).not.toHaveBeenCalledWith(mediumPath);
    expect(fs.readFile).toHaveBeenCalledTimes(1);
  });

  it('should handle file read errors', async () => {
    const mockFilePaths = ['error.txt'];
    const mockRootDir = '/root';
    const mockConfig = createMockConfig();

    vi.mocked(isBinary).mockReturnValue(false);
    vi.mocked(fs.readFile).mockRejectedValue(new Error('Read error'));

    const result = await collectFiles(mockFilePaths, mockRootDir, mockConfig, () => {}, {
      initTaskRunner: mockInitTaskRunner,
    });

    expect(result).toEqual([]);
    expect(logger.warn).toHaveBeenCalledWith(
      `Failed to read file: ${path.resolve('/root/error.txt')}`,
      expect.any(Error),
    );
  });
});
</file>

<file path="tests/core/file/fileManipulate.test.ts">
import { describe, expect, test } from 'vitest';
import { getFileManipulator } from '../../../src/core/file/fileManipulate.js';

describe('fileManipulate', () => {
  const testCases = [
    {
      name: 'C comment removal',
      ext: '.c',
      input: `
        // Single line comment
        int main() {
          /* Multi-line
             comment */
          return 0;
        }
      `,
      expected: `

        int main() {


          return 0;
        }
`,
    },
    {
      name: 'C++ header file comment removal',
      ext: '.h',
      input: `
        // Single line comment
        #ifndef MY_HEADER_H
        #define MY_HEADER_H
        /* Multi-line
           comment block */
        class MyClass {
          // Method comment
          void method();
          /**
           * Documentation comment
           */
          int value;
        };
        #endif // MY_HEADER_H
      `,
      expected: `

        #ifndef MY_HEADER_H
        #define MY_HEADER_H


        class MyClass {

          void method();



          int value;
        };
        #endif
`,
    },
    {
      name: 'C++ source file comment removal',
      ext: '.cc',
      input: `
        // Single line comment
        #include "myheader.h"
        /* Multi-line
           comment block */
        void MyClass::method() {
          // Implementation comment
          /* Another
             multi-line comment */
          int x = 0; // Inline comment
        }
      `,
      expected: `

        #include "myheader.h"


        void MyClass::method() {



          int x = 0;
        }
`,
    },
    {
      name: 'C++ .cpp file comment removal',
      ext: '.cpp',
      input: `
        // Single line comment
        #include <iostream>
        /* Multi-line
           comment block */
        int main() {
          // Implementation comment
          std::cout << "Hello, world!" << std::endl; // Inline comment
          /* Another
             multi-line comment */
          return 0;
        }
      `,
      expected: `

        #include <iostream>


        int main() {

          std::cout << "Hello, world!" << std::endl;


          return 0;
        }
`,
    },
    {
      name: 'C++ .hpp file comment removal',
      ext: '.hpp',
      input: `
        // Single line comment
        #pragma once
        /* Multi-line
           comment block */
        namespace test {
          // Class comment
          template <typename T>
          class Test {
            /**
             * Documentation comment
             */
            public:
              T value;
          };
        } // namespace test
      `,
      expected: `

        #pragma once


        namespace test {

          template <typename T>
          class Test {



            public:
              T value;
          };
        }
`,
    },
    {
      name: 'C# comment removal',
      ext: '.cs',
      input: `
        // Single line comment
        public class Test {
          /* Multi-line
             comment */
          public void Method() {}
        }
      `,
      expected: `

        public class Test {


          public void Method() {}
        }
`,
    },
    {
      name: 'CSS comment removal',
      ext: '.css',
      input: `
        /* Comment */
        body {
          color: red; /* Inline comment */
        }
      `,
      expected: `

        body {
          color: red;
        }
`,
    },
    {
      name: 'HTML comment removal',
      ext: '.html',
      input: '<div><!-- Comment -->Content</div>',
      expected: '<div>Content</div>',
    },
    {
      name: 'Java comment removal',
      ext: '.java',
      input: `
        // Single line comment
        public class Test {
          /* Multi-line
             comment */
          public void method() {}
        }
      `,
      expected: `

        public class Test {


          public void method() {}
        }
`,
    },
    {
      name: 'JavaScript comment removal',
      ext: '.js',
      input: `
        // Single line comment
        function test() {
          /* Multi-line
             comment */
          return true;
        }
      `,
      expected: `

        function test() {


          return true;
        }
`,
    },
    {
      name: 'Less comment removal',
      ext: '.less',
      input: `
        // Single line comment
        @variable: #888;
        /* Multi-line
           comment */
        body { color: @variable; }
      `,
      expected: `

        @variable: #888;


        body { color: @variable; }
`,
    },
    {
      name: 'PHP comment removal',
      ext: '.php',
      input: `
        <?php
        // Single line comment
        # Another single line comment
        function test() {
          /* Multi-line
             comment */
          return true;
        }
        ?>
      `,
      expected: `
        <?php


        function test() {


          return true;
        }
        ?>
`,
    },
    {
      name: 'Python comment, docstring removal',
      ext: '.py',
      input: `
        # Single line comment
        def test():
          '''
          docstring
          '''
          return True
        """
        Another docstring
        """
      `,
      expected: `

        def test():

          return True

`,
    },
    {
      name: 'Python docstring removal mixing string declaration',
      ext: '.py',
      input: `
        var = """
        string variable
        """
        """
        docstring
        """
      `,
      expected: `
        var = """
        string variable
        """

`,
    },
    {
      name: 'Python comment f-string is not removed',
      ext: '.py',
      input: `
        # Single line comment
        def test():
          f'f-string'
          f"""
          f-string
          """
          return True
      `,
      expected: `

        def test():
          f'f-string'
          f"""
          f-string
          """
          return True
`,
    },
    {
      name: 'Python comment multi-line string literal is not removed',
      ext: '.py',
      input: `
        def test():
          hoge = """
          multi-line
          string
          """
          return True
      `,
      expected: `
        def test():
          hoge = """
          multi-line
          string
          """
          return True
`,
    },
    {
      name: 'Python nested quotes',
      ext: '.py',
      input: `
        """
        '''
        docstring
        '''
        """
      `,
      expected: `

`,
    },
    {
      name: 'Python nested triple quotes with different types',
      ext: '.py',
      input: `
      def func():
        """
        Outer docstring
        '''
        Inner single quotes
        '''
        Still in outer docstring
        """
        return True
    `,
      expected: `
      def func():

        return True
`,
    },
    {
      name: 'Python inline comments',
      ext: '.py',
      input: `
      x = 5  # This is an inline comment
      y = 10  # Another inline comment
      z = x + y
    `,
      expected: `
      x = 5
      y = 10
      z = x + y
`,
    },
    {
      name: 'Python multi-line statement with string',
      ext: '.py',
      input: `
      long_string = "This is a long string that spans " \\
                    "multiple lines in the code, " \\
                    "but is actually a single string"
      # Comment after multi-line statement
    `,
      expected: `
      long_string = "This is a long string that spans " \\
                    "multiple lines in the code, " \\
                    "but is actually a single string"

`,
    },
    {
      name: 'Python docstring with triple quotes inside string literals',
      ext: '.py',
      input: `
      def func():
        """This is a docstring"""
        x = "This is not a docstring: '''"
        y = '"""This is also not a docstring: """'
        return x + y
    `,
      expected: `
      def func():

        x = "This is not a docstring: '''"
        y = '"""This is also not a docstring: """'
        return x + y
`,
    },
    {
      name: 'Python mixed comments and docstrings',
      ext: '.py',
      input: `
      # This is a comment
      def func():
        '''
        This is a docstring
        '''
        x = 5  # Inline comment
        """
        This is another docstring
        """
        # Another comment
        return x
    `,
      expected: `

      def func():

        x = 5


        return x
`,
    },
    {
      name: 'Python f-strings with triple quotes',
      ext: '.py',
      input: `
      x = 10
      y = 20
      f"""
      This f-string contains a calculation: {x + y}
      """
      # Comment after f-string
    `,
      expected: `
      x = 10
      y = 20
      f"""
      This f-string contains a calculation: {x + y}
      """

`,
    },
    {
      name: 'Python escaped hash in string',
      ext: '.py',
      input: `
      text = "This string contains an \# escaped hash"
      # This is a real comment
    `,
      expected: `
      text = "This string contains an \# escaped hash"

`,
    },
    {
      name: 'Python nested function with docstrings',
      ext: '.py',
      input: `
      def outer():
        """Outer docstring"""
        def inner():
          """Inner docstring"""
          pass
        return inner
    `,
      expected: `
      def outer():

        def inner():

          pass
        return inner
`,
    },
    {
      name: 'Python comment-like content in string',
      ext: '.py',
      input: `
      x = "This is not a # comment"
      y = 'Neither is this # comment'
      z = """
      This is not a # comment
      Neither is this # comment
      """
    `,
      expected: `
      x = "This is not a # comment"
      y = 'Neither is this # comment'
      z = """
      This is not a # comment
      Neither is this # comment
      """
`,
    },
    {
      name: 'Python docstring with backslashes',
      ext: '.py',
      input: `
      def func():
        """
        This docstring has \\ backslashes
        It shouldn't \\""" confuse the parser
        """
        return True
    `,
      expected: `
      def func():

        return True
`,
    },
    {
      name: 'Python mixed single and double quotes',
      ext: '.py',
      input: `
      x = '\"\"\""'  # This is not a docstring start
      y = "'''"  # Neither is this
      """But this is a docstring"""
    `,
      expected: `
      x = '\"\"\""'
      y = "'''"

`,
    },
    {
      name: 'Ruby comment removal',
      ext: '.rb',
      input: `
        # Single line comment
        def test
          =begin
          Multi-line comment
          =end
          true
        end
      `,
      expected: `

        def test



          true
        end
`,
    },
    {
      name: 'Sass comment removal',
      ext: '.sass',
      input: `
        // Single line comment
        $variable: #888
        /* Multi-line
           comment */
        body
          color: $variable
      `,
      expected: `

        $variable: #888


        body
          color: $variable
`,
    },
    {
      name: 'SCSS comment removal',
      ext: '.scss',
      input: `
        // Single line comment
        $variable: #888;
        /* Multi-line
           comment */
        body { color: $variable; }
      `,
      expected: `

        $variable: #888;


        body { color: $variable; }
`,
    },
    {
      name: 'SQL comment removal',
      ext: '.sql',
      input: `
        -- Single line comment
        SELECT * FROM table WHERE id = 1;
      `,
      expected: `

        SELECT * FROM table WHERE id = 1;
`,
    },
    {
      name: 'Swift comment removal',
      ext: '.swift',
      input: `
        // Single line comment
        func test() {
          /* Multi-line
             comment */
          return true
        }
      `,
      expected: `

        func test() {


          return true
        }
`,
    },
    {
      name: 'TypeScript comment removal',
      ext: '.ts',
      input: `
        // Single line comment
        function test(): boolean {
          /* Multi-line
             comment */
          return true;
        }
      `,
      expected: `

        function test(): boolean {


          return true;
        }
`,
    },
    {
      name: 'XML comment removal',
      ext: '.xml',
      input: '<root><!-- Comment --><element>Content</element></root>',
      expected: '<root><element>Content</element></root>',
    },
    {
      name: 'Dart comment removal',
      ext: '.dart',
      input: `
        // Single line comment
        void main() {
          /* Multi-line
             comment */
          print('Hello');
        }
      `,
      expected: `

        void main() {


          print('Hello');
        }
`,
    },
    {
      name: 'Go comment removal',
      ext: '.go',
      input: `
        // Single line comment
        func main() {
          /* Multi-line
             comment */
          fmt.Println("Hello")
        }
      `,
      expected: `

        func main() {


          fmt.Println("Hello")
        }
`,
    },
    {
      name: 'Kotlin comment removal',
      ext: '.kt',
      input: `
        // Single line comment
        fun main() {
          /* Multi-line
             comment */
          println("Hello")
        }
      `,
      expected: `

        fun main() {


          println("Hello")
        }
`,
    },
    {
      name: 'Rust comment removal',
      ext: '.rs',
      input: `
        // Single line comment
        fn main() {
          /* Multi-line
             comment */
          println!("Hello");
        }
      `,
      expected: `

        fn main() {


          println!("Hello");
        }
`,
    },
    {
      name: 'Shell script comment removal',
      ext: '.sh',
      input: `
        # Single line comment
        echo "Hello"
      `,
      expected: `

        echo "Hello"
`,
    },
    {
      name: 'YAML comment removal',
      ext: '.yml',
      input: `
        key: value  # Comment
        another_key: another_value
      `,
      expected: `
        key: value
        another_key: another_value
`,
    },
    {
      name: 'Vue file comment removal',
      ext: '.vue',
      input: `
        <template>
          <!-- HTML comment -->
          <div>{{ message }}</div>
        </template>
        <script>
        // JavaScript comment
        export default {
          data() {
            return {
              message: 'Hello'
            }
          }
        }
        </script>
        <style>
        /* CSS comment */
        .test { color: red; }
        </style>
      `,
      expected: `
        <template>

          <div>{{ message }}</div>
        </template>
        <script>

        export default {
          data() {
            return {
              message: 'Hello'
            }
          }
        }
        </script>
        <style>

        .test { color: red; }
        </style>
`,
    },
    {
      name: 'Svelte file comment removal',
      ext: '.svelte',
      input: `
        <!-- HTML comment -->
        <div>{message}</div>
        <script>
        // JavaScript comment
        let message = 'Hello';
        </script>
        <style>
        /* CSS comment */
        div { color: red; }
        </style>
      `,
      expected: `

        <div>{message}</div>
        <script>

        let message = 'Hello';
        </script>
        <style>

        div { color: red; }
        </style>
`,
    },
    {
      name: 'C++ triple slash comment removal (.cpp)',
      ext: '.cpp',
      input: `
        /// Triple slash documentation comment
        #include <iostream>
        // Single line comment
        int main() {
          std::cout << "Hello, world!" << std::endl; /// Inline triple slash comment
          return 0; // Normal comment
        }
      `,
      expected: `

        #include <iostream>

        int main() {
          std::cout << "Hello, world!" << std::endl;
          return 0;
        }
`,
    },
    {
      name: 'C++ triple slash comment removal (.hpp)',
      ext: '.hpp',
      input: `
        /// Class documentation with triple slash
        class Test {
          public:
            /// Method documentation
            void method();
            int value; /// Variable documentation
        };
      `,
      expected: `

        class Test {
          public:

            void method();
            int value;
        };
`,
    },
    {
      name: 'C++ triple slash comment removal',
      ext: '.cpp',
      input: `
        /// This is a triple slash comment.\n        int foo = 1; /// Another triple slash comment.\n// Regular single line comment\n/* Multi-line\n   comment */\nint bar = 2; /// Comment with trailing spaces  \n`,
      expected: `

        int foo = 1;\n\n\n\nint bar = 2;\n`,
    },
  ];

  for (const { name, ext, input, expected } of testCases) {
    test(name, () => {
      const manipulator = getFileManipulator(`test${ext}`);
      expect(manipulator?.removeComments(input)).toBe(expected);
    });
  }

  test('Unsupported file type', () => {
    const manipulator = getFileManipulator('test.unsupported');
    expect(manipulator).toBeNull();
  });
});
</file>

<file path="tests/core/file/filePathSort.test.ts">
import path from 'node:path';
import { describe, expect, test } from 'vitest';
import { sortPaths } from '../../../src/core/file/filePathSort.js';

describe('filePathSort', () => {
  const sep = path.sep;

  test('should sort directories before files', () => {
    const input = ['file.txt', `dir${sep}`, 'another_file.js', `another_dir${sep}`];
    const expected = [`another_dir${sep}`, `dir${sep}`, 'another_file.js', 'file.txt'];
    expect(sortPaths(input)).toEqual(expected);
  });

  test('should sort subdirectories correctly', () => {
    const input = [`dir${sep}subdir${sep}file.txt`, `dir${sep}file.js`, `dir${sep}subdir${sep}`, 'file.txt'];
    const expected = [`dir${sep}subdir${sep}`, `dir${sep}subdir${sep}file.txt`, `dir${sep}file.js`, 'file.txt'];
    expect(sortPaths(input)).toEqual(expected);
  });

  test('should sort files alphabetically within the same directory', () => {
    const input = [`dir${sep}c.txt`, `dir${sep}a.txt`, `dir${sep}b.txt`];
    const expected = [`dir${sep}a.txt`, `dir${sep}b.txt`, `dir${sep}c.txt`];
    expect(sortPaths(input)).toEqual(expected);
  });

  test('should handle empty input', () => {
    expect(sortPaths([])).toEqual([]);
  });

  test('should handle complex directory structure', () => {
    const input = [
      `src${sep}utils${sep}file3.ts`,
      `src${sep}index.ts`,
      `tests${sep}utils${sep}a.ts`,
      `src${sep}utils${sep}b.ts`,
      'package.json',
      'README.md',
      `src${sep}components${sep}Component.tsx`,
    ];
    const expected = [
      `src${sep}components${sep}Component.tsx`,
      `src${sep}utils${sep}b.ts`,
      `src${sep}utils${sep}file3.ts`,
      `src${sep}index.ts`,
      `tests${sep}utils${sep}a.ts`,
      'package.json',
      'README.md',
    ];
    expect(sortPaths(input)).toEqual(expected);
  });

  test('should handle paths with multiple separators', () => {
    const input = [`a${sep}b${sep}c`, `a${sep}b`, `a${sep}b${sep}`];
    const expected = [`a${sep}b`, `a${sep}b${sep}`, `a${sep}b${sep}c`];
    expect(sortPaths(input)).toEqual(expected);
  });

  test('should be case-insensitive', () => {
    const input = [`B${sep}`, `a${sep}`, 'C', 'd'];
    const expected = [`a${sep}`, `B${sep}`, 'C', 'd'];
    expect(sortPaths(input)).toEqual(expected);
  });
});
</file>

<file path="tests/core/file/fileProcess.test.ts">
import { describe, expect, it, vi } from 'vitest';
import type { FileManipulator } from '../../../src/core/file/fileManipulate.js';
import { processFiles } from '../../../src/core/file/fileProcess.js';
import { processContent } from '../../../src/core/file/fileProcessContent.js';
import type { RawFile } from '../../../src/core/file/fileTypes.js';
import type { FileProcessTask } from '../../../src/core/file/workers/fileProcessWorker.js';
import fileProcessWorker from '../../../src/core/file/workers/fileProcessWorker.js';
import { createMockConfig } from '../../testing/testUtils.js';

const createMockFileManipulator = (): FileManipulator => ({
  removeComments: (content: string) => content.replace(/\/\/.*|\/\*[\s\S]*?\*\//g, ''),
  removeEmptyLines: (content: string) => content.replace(/^\s*[\r\n]/gm, ''),
});

const mockGetFileManipulator = (filePath: string): FileManipulator | null => {
  if (filePath.endsWith('.js')) {
    return createMockFileManipulator();
  }
  return null;
};

const mockInitTaskRunner = (numOfTasks: number) => {
  return async (task: FileProcessTask) => {
    return await fileProcessWorker(task);
  };
};

describe('fileProcess', () => {
  describe('processFiles', () => {
    it('should process multiple files', async () => {
      const mockRawFiles: RawFile[] = [
        { path: 'file1.js', content: '// comment\nconst a = 1;' },
        { path: 'file2.js', content: '/* comment */\nconst b = 2;' },
      ];
      const config = createMockConfig({
        output: {
          removeComments: true,
          removeEmptyLines: true,
        },
      });

      const result = await processFiles(mockRawFiles, config, () => {}, {
        initTaskRunner: mockInitTaskRunner,
        getFileManipulator: mockGetFileManipulator,
      });

      expect(result).toEqual([
        { path: 'file1.js', content: 'const a = 1;' },
        { path: 'file2.js', content: 'const b = 2;' },
      ]);
    });
  });

  describe('processContent', () => {
    it('should remove comments and empty lines when configured', async () => {
      const content = '// comment\nconst a = 1;\n\n/* multi-line\ncomment */\nconst b = 2;';
      const filePath = 'test.js';
      const config = createMockConfig({
        output: {
          removeComments: true,
          removeEmptyLines: true,
        },
      });

      const result = await processContent({ path: filePath, content }, config);

      expect(result).toBe('const a = 1;\nconst b = 2;');
    });

    it('should not remove comments or empty lines when not configured', async () => {
      const content = '// comment\nconst a = 1;\n\n/* multi-line\ncomment */\nconst b = 2;';
      const filePath = 'test.js';
      const config = createMockConfig({
        output: {
          removeComments: false,
          removeEmptyLines: false,
        },
      });

      const result = await processContent({ path: filePath, content }, config);

      expect(result).toBe(content.trim());
    });

    it('should handle files without a manipulator', async () => {
      const content = 'Some content';
      const filePath = 'unknown.ext';
      const config = createMockConfig({
        output: {
          removeComments: true,
          removeEmptyLines: true,
        },
      });

      const result = await processContent({ path: filePath, content }, config);

      expect(result).toBe(content);
    });

    it('should add line numbers when showLineNumbers is true', async () => {
      const content = 'Line 1\nLine 2\nLine 3';
      const filePath = 'test.txt';
      const config = createMockConfig({
        output: {
          showLineNumbers: true,
          removeComments: false,
          removeEmptyLines: false,
        },
      });

      const result = await processContent({ path: filePath, content }, config);

      expect(result).toBe('1: Line 1\n2: Line 2\n3: Line 3');
    });

    it('should not add line numbers when showLineNumbers is false', async () => {
      const content = 'Line 1\nLine 2\nLine 3';
      const filePath = 'test.txt';
      const config = createMockConfig({
        output: {
          showLineNumbers: false,
          removeComments: false,
          removeEmptyLines: false,
        },
      });

      const result = await processContent({ path: filePath, content }, config);

      expect(result).toBe('Line 1\nLine 2\nLine 3');
    });

    it('should handle empty content when showLineNumbers is true', async () => {
      const content = '';
      const filePath = 'empty.txt';
      const config = createMockConfig({
        output: {
          showLineNumbers: true,
          removeComments: false,
          removeEmptyLines: false,
        },
      });

      const result = await processContent({ path: filePath, content }, config);

      expect(result).toBe('1: ');
    });

    it('should pad line numbers correctly for files with many lines', async () => {
      const content = Array(100).fill('Line').join('\n');
      const filePath = 'long.txt';
      const config = createMockConfig({
        output: {
          showLineNumbers: true,
          removeComments: false,
          removeEmptyLines: false,
        },
      });

      const result = await processContent({ path: filePath, content }, config);

      const lines = result.split('\n');
      expect(lines[0]).toBe('  1: Line');
      expect(lines[9]).toBe(' 10: Line');
      expect(lines[99]).toBe('100: Line');
    });
  });
});
</file>

<file path="tests/core/file/fileProcessContent.test.ts">
import { beforeEach, describe, expect, it, vi } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { getFileManipulator } from '../../../src/core/file/fileManipulate.js';
import { processContent } from '../../../src/core/file/fileProcessContent.js';
import type { RawFile } from '../../../src/core/file/fileTypes.js';
import { parseFile } from '../../../src/core/treeSitter/parseFile.js';

vi.mock('../../../src/core/file/fileManipulate.js');
vi.mock('../../../src/core/treeSitter/parseFile.js');
vi.mock('../../../src/shared/logger.js');

describe('processContent', () => {
  const mockManipulator = {
    removeComments: vi.fn((content) => content.replace(/\/\/.*/g, '')),
    removeEmptyLines: vi.fn((content) => content.split('\n').filter(Boolean).join('\n')),
  };

  beforeEach(() => {
    vi.resetAllMocks();
    vi.mocked(getFileManipulator).mockReturnValue(mockManipulator);
    vi.mocked(parseFile).mockResolvedValue('parsed content');
  });

  it('should process content with default config', async () => {
    const rawFile: RawFile = {
      path: 'test.ts',
      content: 'const x = 1;\n\nconst y = 2;',
    };
    const config: RepomixConfigMerged = {
      output: {
        removeComments: false,
        removeEmptyLines: false,
        compress: false,
        showLineNumbers: false,
      },
    } as RepomixConfigMerged;

    const result = await processContent(rawFile, config);
    expect(result).toBe('const x = 1;\n\nconst y = 2;');
    expect(mockManipulator.removeComments).not.toHaveBeenCalled();
    expect(mockManipulator.removeEmptyLines).not.toHaveBeenCalled();
  });

  it('should remove comments when configured', async () => {
    const rawFile: RawFile = {
      path: 'test.ts',
      content: 'const x = 1; // comment\nconst y = 2;',
    };
    const config: RepomixConfigMerged = {
      output: {
        removeComments: true,
        removeEmptyLines: false,
        compress: false,
        showLineNumbers: false,
      },
    } as RepomixConfigMerged;

    const result = await processContent(rawFile, config);
    expect(mockManipulator.removeComments).toHaveBeenCalledWith(rawFile.content);
    expect(result).toBe('const x = 1; \nconst y = 2;');
  });

  it('should remove empty lines when configured', async () => {
    const rawFile: RawFile = {
      path: 'test.ts',
      content: 'const x = 1;\n\n\nconst y = 2;',
    };
    const config: RepomixConfigMerged = {
      output: {
        removeComments: false,
        removeEmptyLines: true,
        compress: false,
        showLineNumbers: false,
      },
    } as RepomixConfigMerged;

    const result = await processContent(rawFile, config);
    expect(mockManipulator.removeEmptyLines).toHaveBeenCalledWith(rawFile.content);
    expect(result).toBe('const x = 1;\nconst y = 2;');
  });

  it('should compress content using Tree-sitter when configured', async () => {
    const rawFile: RawFile = {
      path: 'test.ts',
      content: 'const x = 1;\nconst y = 2;',
    };
    const config: RepomixConfigMerged = {
      output: {
        removeComments: false,
        removeEmptyLines: false,
        compress: true,
        showLineNumbers: false,
      },
    } as RepomixConfigMerged;

    const result = await processContent(rawFile, config);
    expect(parseFile).toHaveBeenCalledWith(rawFile.content, rawFile.path, config);
    expect(result).toBe('parsed content');
  });

  it('should handle Tree-sitter parse failure gracefully', async () => {
    const rawFile: RawFile = {
      path: 'test.ts',
      content: 'const x = 1;\nconst y = 2;',
    };
    const config: RepomixConfigMerged = {
      output: {
        removeComments: false,
        removeEmptyLines: false,
        compress: true,
        showLineNumbers: false,
      },
    } as RepomixConfigMerged;

    vi.mocked(parseFile).mockResolvedValue(undefined);

    const result = await processContent(rawFile, config);
    expect(result).toBe(rawFile.content);
  });

  it('should handle Tree-sitter parse error', async () => {
    const rawFile: RawFile = {
      path: 'test.ts',
      content: 'const x = 1;\nconst y = 2;',
    };
    const config: RepomixConfigMerged = {
      output: {
        removeComments: false,
        removeEmptyLines: false,
        compress: true,
        showLineNumbers: false,
      },
    } as RepomixConfigMerged;

    const error = new Error('Parse error');
    vi.mocked(parseFile).mockRejectedValue(error);

    await expect(processContent(rawFile, config)).rejects.toThrow('Parse error');
  });

  it('should add line numbers when configured', async () => {
    const rawFile: RawFile = {
      path: 'test.ts',
      content: 'const x = 1;\nconst y = 2;\nconst z = 3;',
    };
    const config: RepomixConfigMerged = {
      output: {
        removeComments: false,
        removeEmptyLines: false,
        compress: false,
        showLineNumbers: true,
      },
    } as RepomixConfigMerged;

    const result = await processContent(rawFile, config);
    expect(result).toBe('1: const x = 1;\n2: const y = 2;\n3: const z = 3;');
  });

  it('should handle files without a manipulator', async () => {
    const rawFile: RawFile = {
      path: 'test.unknown',
      content: 'some content',
    };
    const config: RepomixConfigMerged = {
      output: {
        removeComments: true,
        removeEmptyLines: true,
        compress: false,
        showLineNumbers: false,
      },
    } as RepomixConfigMerged;

    vi.mocked(getFileManipulator).mockReturnValue(null);

    const result = await processContent(rawFile, config);
    expect(result).toBe('some content');
  });
});
</file>

<file path="tests/core/file/fileSearch.test.ts">
import type { Stats } from 'node:fs';
import * as fs from 'node:fs/promises';
import path from 'node:path';
import process from 'node:process';
import { globby } from 'globby';
import { minimatch } from 'minimatch';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import {
  escapeGlobPattern,
  getIgnoreFilePatterns,
  getIgnorePatterns,
  normalizeGlobPattern,
  parseIgnoreContent,
  searchFiles,
} from '../../../src/core/file/fileSearch.js';
import { PermissionError } from '../../../src/core/file/permissionCheck.js';
import { RepomixError } from '../../../src/shared/errorHandle.js';
import { createMockConfig, isWindows } from '../../testing/testUtils.js';

import { checkDirectoryPermissions } from '../../../src/core/file/permissionCheck.js';

vi.mock('fs/promises');
vi.mock('globby');
vi.mock('../../../src/core/file/permissionCheck.js', () => ({
  checkDirectoryPermissions: vi.fn(),
  PermissionError: class extends Error {
    constructor(
      message: string,
      public readonly path: string,
      public readonly code?: string,
    ) {
      super(message);
      this.name = 'PermissionError';
    }
  },
}));

describe('fileSearch', () => {
  beforeEach(() => {
    vi.resetAllMocks();
    // Default mock for fs.stat to assume directory exists and is a directory
    vi.mocked(fs.stat).mockResolvedValue({
      isDirectory: () => true,
      isFile: () => false,
    } as Stats);
    // Default mock for checkDirectoryPermissions
    vi.mocked(checkDirectoryPermissions).mockResolvedValue({
      hasAllPermission: true,
      details: { read: true, write: true, execute: true },
    });
  });

  describe('getIgnoreFilePaths', () => {
    test('should return correct paths when .gitignore and .repomixignore exist', async () => {
      vi.mocked(fs.access).mockResolvedValue(undefined);
      const mockConfig = createMockConfig({
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
          customPatterns: [],
        },
      });
      const filePatterns = await getIgnoreFilePatterns(mockConfig);
      expect(filePatterns).toEqual(['**/.gitignore', '**/.repomixignore']);
    });

    test('should not include .gitignore when useGitignore is false', async () => {
      vi.mocked(fs.access).mockResolvedValue(undefined);
      const mockConfig = createMockConfig({
        ignore: {
          useGitignore: false,
          useDefaultPatterns: true,
          customPatterns: [],
        },
      });
      const filePatterns = await getIgnoreFilePatterns(mockConfig);
      expect(filePatterns).toEqual(['**/.repomixignore']);
    });

    test('should handle empty directories when enabled', async () => {
      const mockConfig = createMockConfig({
        output: {
          includeEmptyDirectories: true,
        },
      });

      const mockFilePaths = ['src/file1.js', 'src/file2.js'];
      const mockEmptyDirs = ['src/empty', 'empty-root'];

      vi.mocked(globby).mockImplementation(async (_, options) => {
        if (options?.onlyDirectories) {
          return mockEmptyDirs;
        }
        return mockFilePaths;
      });

      vi.mocked(fs.readdir).mockResolvedValue([]);

      const result = await searchFiles('/mock/root', mockConfig);

      expect(result.filePaths).toEqual(mockFilePaths);
      expect(result.emptyDirPaths.sort()).toEqual(mockEmptyDirs.sort());
    });

    test('should not collect empty directories when disabled', async () => {
      const mockConfig = createMockConfig({
        output: {
          includeEmptyDirectories: false,
        },
      });

      const mockFilePaths = ['src/file1.js', 'src/file2.js'];

      vi.mocked(globby).mockImplementation(async (_, options) => {
        if (options?.onlyDirectories) {
          throw new Error('Should not search for directories when disabled');
        }
        return mockFilePaths;
      });

      const result = await searchFiles('/mock/root', mockConfig);

      expect(result.filePaths).toEqual(mockFilePaths);
      expect(result.emptyDirPaths).toEqual([]);
      expect(globby).toHaveBeenCalledTimes(1);
    });
  });

  describe('getIgnorePatterns', () => {
    test('should return default patterns when useDefaultPatterns is true', async () => {
      const mockConfig = createMockConfig({
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
          customPatterns: [],
        },
      });

      const patterns = await getIgnorePatterns(process.cwd(), mockConfig);

      expect(patterns.length).toBeGreaterThan(0);
      expect(patterns).toContain('**/node_modules/**');
    });

    test('should include custom patterns', async () => {
      const mockConfig = createMockConfig({
        ignore: {
          useGitignore: true,
          useDefaultPatterns: false,
          customPatterns: ['*.custom', 'temp/'],
        },
      });

      const patterns = await getIgnorePatterns(process.cwd(), mockConfig);

      expect(patterns).toEqual(['repomix-output.xml', '*.custom', 'temp/']);
    });

    test('should combine default and custom patterns', async () => {
      const mockConfig = createMockConfig({
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
          customPatterns: ['*.custom', 'temp/'],
        },
      });

      const patterns = await getIgnorePatterns(process.cwd(), mockConfig);

      expect(patterns).toContain('**/node_modules/**');
      expect(patterns).toContain('*.custom');
      expect(patterns).toContain('temp/');
    });

    test('should include patterns from .git/info/exclude when useGitignore is true', async () => {
      const mockConfig = createMockConfig({
        ignore: {
          useGitignore: true,
          useDefaultPatterns: false,
          customPatterns: [],
        },
      });

      const mockExcludeContent = `
# Test exclude file
*.ignored
temp-files/
`;

      vi.mocked(fs.readFile).mockImplementation(async (filePath) => {
        // Use path.join to create platform-specific path for testing
        const excludePath = path.join('.git', 'info', 'exclude');
        if (filePath.toString().endsWith(excludePath)) {
          return mockExcludeContent;
        }
        return '';
      });

      const patterns = await getIgnorePatterns('/mock/root', mockConfig);

      // Only test for the exclude file patterns
      expect(patterns).toContain('*.ignored');
      expect(patterns).toContain('temp-files/');
    });
  });

  describe('parseIgnoreContent', () => {
    test('should correctly parse ignore content', () => {
      const content = `
# Comment
node_modules
*.log

.DS_Store
      `;

      const patterns = parseIgnoreContent(content);

      expect(patterns).toEqual(['node_modules', '*.log', '.DS_Store']);
    });

    test('should handle mixed line endings', () => {
      const content = 'node_modules\n*.log\r\n.DS_Store\r';

      const patterns = parseIgnoreContent(content);

      expect(patterns).toEqual(['node_modules', '*.log', '.DS_Store']);
    });
  });

  describe('filterFiles', () => {
    beforeEach(() => {
      vi.resetAllMocks();
      // Re-establish default mocks after reset
      vi.mocked(fs.stat).mockResolvedValue({
        isDirectory: () => true,
        isFile: () => false,
      } as Stats);
      vi.mocked(checkDirectoryPermissions).mockResolvedValue({
        hasAllPermission: true,
        details: { read: true, write: true, execute: true },
      });
    });

    test('should call globby with correct parameters', async () => {
      const mockConfig = createMockConfig({
        include: ['**/*.js'],
        ignore: {
          useGitignore: true,
          useDefaultPatterns: false,
          customPatterns: ['*.custom'],
        },
      });

      vi.mocked(globby).mockResolvedValue(['file1.js', 'file2.js']);
      vi.mocked(fs.access).mockResolvedValue(undefined);

      await searchFiles('/mock/root', mockConfig);

      expect(globby).toHaveBeenCalledWith(
        ['**/*.js'],
        expect.objectContaining({
          cwd: '/mock/root',
          ignore: expect.arrayContaining(['*.custom']),
          ignoreFiles: expect.arrayContaining(['**/.gitignore', '**/.repomixignore']),
          onlyFiles: true,
          absolute: false,
          dot: true,
          followSymbolicLinks: false,
        }),
      );
    });

    test.runIf(!isWindows)('Honor .gitignore files in subdirectories', async () => {
      const mockConfig = createMockConfig({
        include: ['**/*.js'],
        ignore: {
          useGitignore: true,
          useDefaultPatterns: false,
          customPatterns: [],
        },
      });

      const mockFileStructure = [
        'root/file1.js',
        'root/subdir/file2.js',
        'root/subdir/ignored.js',
        'root/another/file3.js',
      ];

      const mockGitignoreContent = {
        '/mock/root/.gitignore': '*.log',
        '/mock/root/subdir/.gitignore': 'ignored.js',
      };

      vi.mocked(globby).mockImplementation(async () => {
        // Simulate filtering files based on .gitignore
        return mockFileStructure.filter((file) => {
          const relativePath = file.replace('root/', '');
          const dir = path.dirname(relativePath);
          const gitignorePath = path.join('/mock/root', dir, '.gitignore');
          const gitignoreContent = mockGitignoreContent[gitignorePath as keyof typeof mockGitignoreContent];
          if (gitignoreContent && minimatch(path.basename(file), gitignoreContent)) {
            return false;
          }
          return true;
        });
      });

      vi.mocked(fs.readFile).mockImplementation(async (filePath) => {
        return mockGitignoreContent[filePath as keyof typeof mockGitignoreContent] || '';
      });

      const result = await searchFiles('/mock/root', mockConfig);
      expect(result.filePaths).toEqual(['root/another/file3.js', 'root/subdir/file2.js', 'root/file1.js']);
      expect(result.filePaths).not.toContain('root/subdir/ignored.js');
      expect(result.emptyDirPaths).toEqual([]);
    });

    test('should not apply .gitignore when useGitignore is false', async () => {
      const mockConfig = createMockConfig({
        include: ['**/*.js'],
        ignore: {
          useGitignore: false,
          useDefaultPatterns: false,
          customPatterns: [],
        },
      });

      const mockFileStructure = [
        'root/file1.js',
        'root/another/file3.js',
        'root/subdir/file2.js',
        'root/subdir/ignored.js',
      ];

      vi.mocked(globby).mockResolvedValue(mockFileStructure);

      const result = await searchFiles('/mock/root', mockConfig);

      expect(result.filePaths).toEqual(mockFileStructure);
      expect(result.filePaths).toContain('root/subdir/ignored.js');
      expect(result.emptyDirPaths).toEqual([]);
    });

    test('should handle git worktree correctly', async () => {
      // Mock .git file content for worktree
      const gitWorktreeContent = 'gitdir: /path/to/main/repo/.git/worktrees/feature-branch';

      // Mock fs.stat - first call for rootDir, subsequent calls for .git file
      vi.mocked(fs.stat)
        .mockResolvedValueOnce({
          isDirectory: () => true,
          isFile: () => false,
        } as Stats)
        .mockResolvedValue({
          isFile: () => true,
          isDirectory: () => false,
        } as Stats);
      vi.mocked(fs.readFile).mockResolvedValue(gitWorktreeContent);

      // Override checkDirectoryPermissions mock for this test
      vi.mocked(checkDirectoryPermissions).mockResolvedValue({
        hasAllPermission: true,
        details: { read: true, write: true, execute: true },
      });

      // Mock globby to return some test files
      vi.mocked(globby).mockResolvedValue(['file1.js', 'file2.js']);

      const mockConfig = createMockConfig({
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
          customPatterns: [],
        },
      });

      const result = await searchFiles('/test/dir', mockConfig);

      // Check that globby was called with correct ignore patterns
      const globbyCall = vi.mocked(globby).mock.calls[0];
      const ignorePatterns = globbyCall[1]?.ignore as string[];

      // Verify .git file (not directory) is in ignore patterns
      expect(ignorePatterns).toContain('.git');
      // Verify .git/** is not in ignore patterns
      expect(ignorePatterns).not.toContain('.git/**');

      // Verify the files were returned correctly
      expect(result.filePaths).toEqual(['file1.js', 'file2.js']);
    });

    test('should handle regular git repository correctly', async () => {
      // Mock .git as a directory
      vi.mocked(fs.stat)
        .mockResolvedValueOnce({
          isDirectory: () => true,
          isFile: () => false,
        } as Stats)
        .mockResolvedValue({
          isFile: () => false,
          isDirectory: () => true,
        } as Stats);

      // Override checkDirectoryPermissions mock for this test
      vi.mocked(checkDirectoryPermissions).mockResolvedValue({
        hasAllPermission: true,
        details: { read: true, write: true, execute: true },
      });

      // Mock globby to return some test files
      vi.mocked(globby).mockResolvedValue(['file1.js', 'file2.js']);

      const mockConfig = createMockConfig({
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
          customPatterns: [],
        },
      });

      const result = await searchFiles('/test/dir', mockConfig);

      // Check that globby was called with correct ignore patterns
      const globbyCall = vi.mocked(globby).mock.calls[0];
      const ignorePatterns = globbyCall[1]?.ignore as string[];

      // Verify .git/** is in ignore patterns for regular git repos
      expect(ignorePatterns).toContain('.git/**');
      // Verify just .git is not in ignore patterns
      expect(ignorePatterns).not.toContain('.git');

      // Verify the files were returned correctly
      expect(result.filePaths).toEqual(['file1.js', 'file2.js']);
    });
  });

  describe('escapeGlobPattern', () => {
    test('should escape parentheses in pattern', () => {
      const pattern = 'src/(categories)/**/*.ts';
      expect(escapeGlobPattern(pattern)).toBe('src/\\(categories\\)/**/*.ts');
    });

    test('should handle nested brackets', () => {
      const pattern = 'src/(auth)/([id])/**/*.ts';
      expect(escapeGlobPattern(pattern)).toBe('src/\\(auth\\)/\\(\\[id\\]\\)/**/*.ts');
    });

    test('should handle empty string', () => {
      expect(escapeGlobPattern('')).toBe('');
    });

    test('should not modify patterns without special characters', () => {
      const pattern = 'src/components/**/*.ts';
      expect(escapeGlobPattern(pattern)).toBe(pattern);
    });

    test('should handle multiple occurrences of the same bracket type', () => {
      const pattern = 'src/(auth)/(settings)/**/*.ts';
      expect(escapeGlobPattern(pattern)).toBe('src/\\(auth\\)/\\(settings\\)/**/*.ts');
    });
  });

  test('should escape backslashes in pattern', () => {
    const pattern = 'src\\temp\\(categories)';
    expect(escapeGlobPattern(pattern)).toBe('src\\\\temp\\\\\\(categories\\)');
  });

  test('should handle patterns with already escaped special characters', () => {
    const pattern = 'src\\\\(categories)';
    expect(escapeGlobPattern(pattern)).toBe('src\\\\\\\\\\(categories\\)');
  });

  describe('normalizeGlobPattern', () => {
    test('should remove trailing slash from simple directory pattern', () => {
      expect(normalizeGlobPattern('bin/')).toBe('bin');
    });

    test('should remove trailing slash from nested directory pattern', () => {
      expect(normalizeGlobPattern('src/components/')).toBe('src/components');
    });

    test('should preserve patterns without trailing slash', () => {
      expect(normalizeGlobPattern('bin')).toBe('bin');
    });

    test('should preserve patterns ending with **/', () => {
      expect(normalizeGlobPattern('src/**/')).toBe('src/**/');
    });

    test('should preserve patterns with file extensions', () => {
      expect(normalizeGlobPattern('*.ts')).toBe('*.ts');
    });

    test('should handle patterns with special characters', () => {
      expect(normalizeGlobPattern('src/(components)/')).toBe('src/(components)');
    });

    test('should convert **/folder pattern to **/folder/** for consistency', () => {
      expect(normalizeGlobPattern('**/bin')).toBe('**/bin/**');
    });

    test('should convert **/nested/folder pattern to **/nested/folder/**', () => {
      expect(normalizeGlobPattern('**/nested/folder')).toBe('**/nested/folder/**');
    });

    test('should not convert patterns that already have /**', () => {
      expect(normalizeGlobPattern('**/folder/**')).toBe('**/folder/**');
    });

    test('should not convert patterns that already have /**/*', () => {
      expect(normalizeGlobPattern('**/folder/**/*')).toBe('**/folder/**/*');
    });
  });

  describe('searchFiles path validation', () => {
    test('should throw error when target path does not exist', async () => {
      const error = new Error('ENOENT') as Error & { code: string };
      error.code = 'ENOENT';
      vi.mocked(fs.stat).mockRejectedValue(error);

      const mockConfig = createMockConfig();

      await expect(searchFiles('/nonexistent/path', mockConfig)).rejects.toThrow(RepomixError);
      await expect(searchFiles('/nonexistent/path', mockConfig)).rejects.toThrow(
        'Target path does not exist: /nonexistent/path',
      );
    });

    test('should throw PermissionError when access is denied', async () => {
      const error = new Error('EPERM') as Error & { code: string };
      error.code = 'EPERM';
      vi.mocked(fs.stat).mockRejectedValue(error);

      const mockConfig = createMockConfig();

      await expect(searchFiles('/forbidden/path', mockConfig)).rejects.toThrow(PermissionError);
    });

    test('should throw error when target path is a file, not a directory', async () => {
      vi.mocked(fs.stat).mockResolvedValue({
        isDirectory: () => false,
        isFile: () => true,
      } as Stats);

      const mockConfig = createMockConfig();

      await expect(searchFiles('/path/to/file.txt', mockConfig)).rejects.toThrow(RepomixError);
      await expect(searchFiles('/path/to/file.txt', mockConfig)).rejects.toThrow(
        'Target path is not a directory: /path/to/file.txt. Please specify a directory path, not a file path.',
      );
    });

    test('should succeed when target path is a valid directory', async () => {
      vi.mocked(globby).mockResolvedValue(['test.js']);

      const mockConfig = createMockConfig();

      const result = await searchFiles('/valid/directory', mockConfig);

      expect(result.filePaths).toEqual(['test.js']);
      expect(result.emptyDirPaths).toEqual([]);
    });
  });
});
</file>

<file path="tests/core/file/fileStdin.test.ts">
import path from 'node:path';
import { Readable } from 'node:stream';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import {
  type StdinDependencies,
  filterValidLines,
  readFilePathsFromStdin,
  readLinesFromStream,
  resolveAndDeduplicatePaths,
} from '../../../src/core/file/fileStdin.js';
import { RepomixError } from '../../../src/shared/errorHandle.js';

describe('fileStdin', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('filterValidLines', () => {
    it('should filter out empty lines', () => {
      const lines = ['file1.txt', '', 'file2.txt', '   ', 'file3.txt'];
      const result = filterValidLines(lines);
      expect(result).toEqual(['file1.txt', 'file2.txt', 'file3.txt']);
    });

    it('should filter out comment lines starting with #', () => {
      const lines = ['file1.txt', '# This is a comment', 'file2.txt', '#another comment', 'file3.txt'];
      const result = filterValidLines(lines);
      expect(result).toEqual(['file1.txt', 'file2.txt', 'file3.txt']);
    });

    it('should trim whitespace from lines', () => {
      const lines = ['  file1.txt  ', '\tfile2.txt\t', ' file3.txt\n'];
      const result = filterValidLines(lines);
      expect(result).toEqual(['file1.txt', 'file2.txt', 'file3.txt']);
    });

    it('should return empty array when all lines are invalid', () => {
      const lines = ['', '# comment', '   ', '#another comment'];
      const result = filterValidLines(lines);
      expect(result).toEqual([]);
    });

    it('should handle mixed valid and invalid lines', () => {
      const lines = ['file1.txt', '', '# comment', '  file2.txt  ', '\t\t', '#another comment', 'file3.txt'];
      const result = filterValidLines(lines);
      expect(result).toEqual(['file1.txt', 'file2.txt', 'file3.txt']);
    });
  });

  describe('resolveAndDeduplicatePaths', () => {
    const cwd = path.resolve('/test/cwd');

    it('should resolve relative paths to absolute paths', () => {
      const lines = ['file1.txt', './file2.txt', '../file3.txt'];
      const result = resolveAndDeduplicatePaths(lines, cwd);

      const expected = [
        path.resolve(cwd, 'file1.txt'),
        path.resolve(cwd, 'file2.txt'),
        path.resolve(cwd, '../file3.txt'),
      ];
      expect(result).toEqual(expected);
    });

    it('should keep absolute paths as-is with normalization', () => {
      const absolutePath1 = path.resolve('/absolute/path/file1.txt');
      const absolutePath2 = path.resolve('/another/path/file2.txt');
      // Create a platform-specific complex path that should resolve to absolutePath2
      const complexPath = path.resolve('/another/./absolute/../path/file2.txt');
      const lines = [absolutePath1, complexPath];
      const result = resolveAndDeduplicatePaths(lines, cwd);

      expect(result).toEqual([absolutePath1, absolutePath2]);
    });

    it('should deduplicate identical paths', () => {
      const lines = ['file1.txt', './file1.txt', 'file1.txt'];
      const result = resolveAndDeduplicatePaths(lines, cwd);

      const expected = [path.resolve(cwd, 'file1.txt')];
      expect(result).toEqual(expected);
    });

    it('should handle mixed absolute and relative paths with duplicates', () => {
      const absolutePath1 = path.resolve(cwd, 'file1.txt');
      const absolutePath3 = path.resolve('/absolute/file3.txt');
      const lines = ['file1.txt', absolutePath1, './file2.txt', absolutePath3, 'file2.txt'];
      const result = resolveAndDeduplicatePaths(lines, cwd);

      const expected = [absolutePath1, path.resolve(cwd, 'file2.txt'), absolutePath3];
      expect(result).toEqual(expected);
    });

    it('should normalize paths with ./ and ../ segments', () => {
      const lines = ['./dir/../file1.txt', 'dir/./file2.txt', './dir/./sub/../file3.txt'];
      const result = resolveAndDeduplicatePaths(lines, cwd);

      const expected = [
        path.resolve(cwd, 'file1.txt'),
        path.resolve(cwd, 'dir/file2.txt'),
        path.resolve(cwd, 'dir/file3.txt'),
      ];
      expect(result).toEqual(expected);
    });
  });

  describe('readLinesFromStream', () => {
    it('should read lines from a readable stream', async () => {
      const mockInterface = {
        [Symbol.asyncIterator]: async function* () {
          yield 'line1';
          yield 'line2';
          yield 'line3';
        },
      };

      const mockCreateInterface = vi.fn().mockReturnValue(mockInterface);
      const mockStream = new Readable();

      const result = await readLinesFromStream(mockStream, mockCreateInterface);

      expect(mockCreateInterface).toHaveBeenCalledWith({ input: mockStream });
      expect(result).toEqual(['line1', 'line2', 'line3']);
    });

    it('should handle empty stream', async () => {
      const mockInterface = {
        [Symbol.asyncIterator]: async function* () {
          // Empty generator
        },
      };

      const mockCreateInterface = vi.fn().mockReturnValue(mockInterface);
      const mockStream = new Readable();

      const result = await readLinesFromStream(mockStream, mockCreateInterface);

      expect(result).toEqual([]);
    });

    it('should handle single line', async () => {
      const mockInterface = {
        [Symbol.asyncIterator]: async function* () {
          yield 'single line';
        },
      };

      const mockCreateInterface = vi.fn().mockReturnValue(mockInterface);
      const mockStream = new Readable();

      const result = await readLinesFromStream(mockStream, mockCreateInterface);

      expect(result).toEqual(['single line']);
    });
  });

  describe('readFilePathsFromStdin', () => {
    const cwd = path.resolve('/test/cwd');

    it('should throw error when stdin is TTY', async () => {
      const mockStdin = { isTTY: true } as NodeJS.ReadableStream & { isTTY?: boolean };
      const deps: StdinDependencies = {
        stdin: mockStdin,
        createReadlineInterface: vi.fn(),
      };

      await expect(readFilePathsFromStdin(cwd, deps)).rejects.toThrow(RepomixError);
      await expect(readFilePathsFromStdin(cwd, deps)).rejects.toThrow(
        'No data provided via stdin. Please pipe file paths to repomix when using --stdin flag.',
      );
    });

    it('should throw error when no valid file paths found', async () => {
      const mockInterface = {
        [Symbol.asyncIterator]: async function* () {
          yield '';
          yield '# comment';
          yield '   ';
        },
      };

      const mockCreateInterface = vi.fn().mockReturnValue(mockInterface);
      const mockStdin = { isTTY: false } as NodeJS.ReadableStream & { isTTY?: boolean };

      const deps: StdinDependencies = {
        stdin: mockStdin,
        createReadlineInterface: mockCreateInterface,
      };

      await expect(readFilePathsFromStdin(cwd, deps)).rejects.toThrow(RepomixError);
      await expect(readFilePathsFromStdin(cwd, deps)).rejects.toThrow('No valid file paths found in stdin input.');
    });

    it('should successfully read and process file paths from stdin', async () => {
      const absoluteFile3 = path.resolve('/absolute/file3.txt');
      const mockInterface = {
        [Symbol.asyncIterator]: async function* () {
          yield 'file1.txt';
          yield '# comment';
          yield './file2.txt';
          yield '';
          yield absoluteFile3;
          yield 'file1.txt'; // duplicate
        },
      };

      const mockCreateInterface = vi.fn().mockReturnValue(mockInterface);
      const mockStdin = { isTTY: false } as NodeJS.ReadableStream & { isTTY?: boolean };

      const deps: StdinDependencies = {
        stdin: mockStdin,
        createReadlineInterface: mockCreateInterface,
      };

      const result = await readFilePathsFromStdin(cwd, deps);

      expect(mockCreateInterface).toHaveBeenCalledWith({ input: mockStdin });
      expect(result).toEqual({
        filePaths: [path.resolve(cwd, 'file1.txt'), path.resolve(cwd, 'file2.txt'), absoluteFile3],
        emptyDirPaths: [],
      });
    });

    it('should handle complex path normalization', async () => {
      const absoluteFile3 = path.resolve('/absolute/file3.txt');
      // Create a complex path that resolves to the same as absoluteFile3
      const complexAbsolutePath = path.resolve('/absolute/./path/../file3.txt');
      const mockInterface = {
        [Symbol.asyncIterator]: async function* () {
          yield './dir/../file1.txt';
          yield 'dir/./file2.txt';
          yield complexAbsolutePath;
        },
      };

      const mockCreateInterface = vi.fn().mockReturnValue(mockInterface);
      const mockStdin = { isTTY: false } as NodeJS.ReadableStream & { isTTY?: boolean };

      const deps: StdinDependencies = {
        stdin: mockStdin,
        createReadlineInterface: mockCreateInterface,
      };

      const result = await readFilePathsFromStdin(cwd, deps);

      expect(result.filePaths).toEqual([
        path.resolve(cwd, 'file1.txt'),
        path.resolve(cwd, 'dir', 'file2.txt'),
        absoluteFile3,
      ]);
    });

    it('should wrap generic errors in RepomixError', async () => {
      const mockInterface = {
        // biome-ignore lint/correctness/useYield: This generator intentionally throws without yielding
        [Symbol.asyncIterator]: async function* (): AsyncGenerator<string, void, unknown> {
          throw new Error('Generic error');
        },
      };

      const mockCreateInterface = vi.fn().mockReturnValue(mockInterface);
      const mockStdin = { isTTY: false } as NodeJS.ReadableStream & { isTTY?: boolean };

      const deps: StdinDependencies = {
        stdin: mockStdin,
        createReadlineInterface: mockCreateInterface,
      };

      await expect(readFilePathsFromStdin(cwd, deps)).rejects.toThrow(RepomixError);
      await expect(readFilePathsFromStdin(cwd, deps)).rejects.toThrow(
        'Failed to read file paths from stdin: Generic error',
      );
    });

    it('should propagate RepomixError without wrapping', async () => {
      const mockStdin = { isTTY: true } as NodeJS.ReadableStream & { isTTY?: boolean };
      const deps: StdinDependencies = {
        stdin: mockStdin,
        createReadlineInterface: vi.fn(),
      };

      const error = await readFilePathsFromStdin(cwd, deps).catch((e) => e);
      expect(error).toBeInstanceOf(RepomixError);
      expect(error.message).toBe(
        'No data provided via stdin. Please pipe file paths to repomix when using --stdin flag.',
      );
    });

    it('should handle unknown error types', async () => {
      const mockInterface = {
        // biome-ignore lint/correctness/useYield: This generator intentionally throws without yielding
        [Symbol.asyncIterator]: async function* (): AsyncGenerator<string, void, unknown> {
          throw 'string error';
        },
      };

      const mockCreateInterface = vi.fn().mockReturnValue(mockInterface);
      const mockStdin = { isTTY: false } as NodeJS.ReadableStream & { isTTY?: boolean };

      const deps: StdinDependencies = {
        stdin: mockStdin,
        createReadlineInterface: mockCreateInterface,
      };

      await expect(readFilePathsFromStdin(cwd, deps)).rejects.toThrow(RepomixError);
      await expect(readFilePathsFromStdin(cwd, deps)).rejects.toThrow(
        'An unexpected error occurred while reading from stdin.',
      );
    });
  });
});
</file>

<file path="tests/core/file/packageJsonParse.test.ts">
import * as fs from 'node:fs/promises';
import path from 'node:path';
import * as url from 'node:url';
import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
import { getVersion } from '../../../src/core/file/packageJsonParse.js';
import { logger } from '../../../src/shared/logger.js';

vi.mock('fs/promises');
vi.mock('url');

describe('packageJsonParse', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  test('getVersion should return correct version from package.json', async () => {
    const mockPackageJson = {
      name: 'repomix',
      version: '1.2.3',
    };

    vi.mocked(url.fileURLToPath).mockReturnValue('/mock/path/to/src/core/file');
    vi.mocked(fs.readFile).mockResolvedValue(JSON.stringify(mockPackageJson));

    const version = await getVersion();

    expect(version).toBe('1.2.3');
    expect(url.fileURLToPath).toHaveBeenCalledWith(expect.any(URL));
    expect(fs.readFile).toHaveBeenCalledWith(
      path.join('/mock/path/to/src/core/file', '..', '..', '..', 'package.json'),
      'utf-8',
    );
  });

  test('getVersion should handle missing version in package.json', async () => {
    const mockPackageJson = {
      name: 'repomix',
    };

    const loggerSpy = vi.spyOn(logger, 'warn').mockImplementation(vi.fn());

    vi.mocked(url.fileURLToPath).mockReturnValue('/mock/path/to/src/core/file2');
    vi.mocked(fs.readFile).mockResolvedValue(JSON.stringify(mockPackageJson));

    const version = await getVersion();

    expect(loggerSpy).toHaveBeenCalledWith(expect.stringContaining('No version found in package.json'));

    expect(version).toBe('unknown');
  });
});
</file>

<file path="tests/core/file/permissionCheck.test.ts">
import { constants } from 'node:fs';
import * as fs from 'node:fs/promises';
import { platform } from 'node:os';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { PermissionError, checkDirectoryPermissions } from '../../../src/core/file/permissionCheck.js';

vi.mock('node:fs/promises');
vi.mock('node:os');

describe('permissionCheck', () => {
  const testDirPath = '/test/directory';

  beforeEach(() => {
    vi.resetAllMocks();
    vi.mocked(platform).mockReturnValue('linux');
  });

  describe('successful cases', () => {
    test('should return success when all permissions are available', async () => {
      // Mock successful readdir
      vi.mocked(fs.readdir).mockResolvedValue([]);

      // Mock successful access checks
      vi.mocked(fs.access).mockResolvedValue(undefined);

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result).toEqual({
        hasAllPermission: true,
        details: {
          read: true,
          write: true,
          execute: true,
        },
      });

      // Verify all permission checks were called
      expect(fs.access).toHaveBeenCalledWith(testDirPath, constants.R_OK);
      expect(fs.access).toHaveBeenCalledWith(testDirPath, constants.W_OK);
      expect(fs.access).toHaveBeenCalledWith(testDirPath, constants.X_OK);
    });

    test('should pass with only required permissions', async () => {
      // Mock successful readdir
      vi.mocked(fs.readdir).mockResolvedValue([]);

      // Mock mixed permission check results
      vi.mocked(fs.access).mockImplementation(async (path, mode) => {
        if (mode === constants.R_OK || mode === constants.X_OK) {
          return Promise.resolve(undefined);
        }
        return Promise.reject(new Error('Permission denied'));
      });

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result).toEqual({
        hasAllPermission: false,
        details: {
          read: true,
          write: false,
          execute: true,
        },
      });
    });
  });

  describe('error cases', () => {
    test('should handle EPERM error', async () => {
      const error = new Error('Permission denied');
      (error as NodeJS.ErrnoException).code = 'EPERM';
      vi.mocked(fs.readdir).mockRejectedValue(error);

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result).toEqual({
        hasAllPermission: false,
        error: expect.any(PermissionError),
      });
      expect(result.error).toBeInstanceOf(PermissionError);
      expect(result.error?.message).toContain('Permission denied');
    });

    test('should handle EACCES error', async () => {
      const error = new Error('Access denied');
      (error as NodeJS.ErrnoException).code = 'EACCES';
      vi.mocked(fs.readdir).mockRejectedValue(error);

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result).toEqual({
        hasAllPermission: false,
        error: expect.any(PermissionError),
      });
      expect(result.error).toBeInstanceOf(PermissionError);
      expect(result.error?.message).toContain('Permission denied');
    });

    test('should handle EISDIR error', async () => {
      const error = new Error('Is a directory');
      (error as NodeJS.ErrnoException).code = 'EISDIR';
      vi.mocked(fs.readdir).mockRejectedValue(error);

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result).toEqual({
        hasAllPermission: false,
        error: expect.any(PermissionError),
      });
    });

    test('should handle non-Error objects', async () => {
      vi.mocked(fs.readdir).mockRejectedValue('String error');

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result).toEqual({
        hasAllPermission: false,
        error: new Error('String error'),
      });
    });
  });

  describe('platform specific behavior', () => {
    test('should return macOS specific error message', async () => {
      // Mock platform as macOS
      vi.mocked(platform).mockReturnValue('darwin');

      const error = new Error('Permission denied');
      (error as NodeJS.ErrnoException).code = 'EACCES';
      vi.mocked(fs.readdir).mockRejectedValue(error);

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result.error).toBeInstanceOf(PermissionError);
      expect(result.error?.message).toContain('macOS security restrictions');
      expect(result.error?.message).toContain('System Settings');
      expect(result.error?.message).toContain('Privacy & Security');
    });

    test('should return standard error message for non-macOS platforms', async () => {
      // Mock platform as Windows
      vi.mocked(platform).mockReturnValue('win32');

      const error = new Error('Permission denied');
      (error as NodeJS.ErrnoException).code = 'EACCES';
      vi.mocked(fs.readdir).mockRejectedValue(error);

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result.error).toBeInstanceOf(PermissionError);
      expect(result.error?.message).toBe(`Permission denied: Cannot access '${testDirPath}'`);
      expect(result.error?.message).not.toContain('macOS security restrictions');
    });
  });

  describe('PermissionError class', () => {
    test('should create PermissionError with correct properties', () => {
      const message = 'Test error message';
      const path = '/test/path';
      const code = 'EACCES';

      const error = new PermissionError(message, path, code);

      expect(error).toBeInstanceOf(Error);
      expect(error.name).toBe('PermissionError');
      expect(error.message).toBe(message);
      expect(error.path).toBe(path);
      expect(error.code).toBe(code);
    });

    test('should create PermissionError without code', () => {
      const message = 'Test error message';
      const path = '/test/path';

      const error = new PermissionError(message, path);

      expect(error).toBeInstanceOf(Error);
      expect(error.name).toBe('PermissionError');
      expect(error.message).toBe(message);
      expect(error.path).toBe(path);
      expect(error.code).toBeUndefined();
    });
  });

  describe('edge cases', () => {
    test('should handle undefined error code', async () => {
      const error = new Error('Permission denied');
      vi.mocked(fs.readdir).mockRejectedValue(error);

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result).toEqual({
        hasAllPermission: false,
        error: error,
      });
    });

    test('should handle partial permission checks failing', async () => {
      // Mock successful readdir
      vi.mocked(fs.readdir).mockResolvedValue([]);

      // Mock access to fail for write permission only
      vi.mocked(fs.access).mockImplementation(async (path, mode) => {
        if (mode === constants.W_OK) {
          throw new Error('Write permission denied');
        }
        return Promise.resolve(undefined);
      });

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result).toEqual({
        hasAllPermission: false,
        details: {
          read: true,
          write: false,
          execute: true,
        },
      });
    });

    test('should handle all permission checks failing', async () => {
      // Mock successful readdir
      vi.mocked(fs.readdir).mockResolvedValue([]);

      // Mock all access checks to fail
      vi.mocked(fs.access).mockRejectedValue(new Error('Permission denied'));

      const result = await checkDirectoryPermissions(testDirPath);

      expect(result).toEqual({
        hasAllPermission: false,
        details: {
          read: false,
          write: false,
          execute: false,
        },
      });
    });
  });
});
</file>

<file path="tests/core/git/gitCommand.test.ts">
import { beforeEach, describe, expect, test, vi } from 'vitest';
import {
  execGitDiff,
  execGitLogFilenames,
  execGitRevParse,
  execGitShallowClone,
  execGitVersion,
  execLsRemote,
} from '../../../src/core/git/gitCommand.js';
import { logger } from '../../../src/shared/logger.js';

vi.mock('../../../src/shared/logger');

describe('gitCommand', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  describe('execGitLogFilenames', () => {
    test('should return filenames from git log', async () => {
      const mockOutput = `
file1.ts
file2.ts
file1.ts
file3.ts
file2.ts
`.trim();
      const mockFileExecAsync = vi.fn().mockResolvedValue({ stdout: mockOutput });

      const result = await execGitLogFilenames('/test/dir', 5, { execFileAsync: mockFileExecAsync });

      expect(result).toEqual(['file1.ts', 'file2.ts', 'file1.ts', 'file3.ts', 'file2.ts']);
      expect(mockFileExecAsync).toHaveBeenCalledWith('git', [
        '-C',
        '/test/dir',
        'log',
        '--pretty=format:',
        '--name-only',
        '-n',
        '5',
      ]);
    });

    test('should return empty array when git command fails', async () => {
      const mockFileExecAsync = vi.fn().mockRejectedValue(new Error('git command failed'));

      const result = await execGitLogFilenames('/test/dir', 5, { execFileAsync: mockFileExecAsync });

      expect(result).toEqual([]);
      expect(logger.trace).toHaveBeenCalledWith('Failed to get git log filenames:', 'git command failed');
    });
  });

  describe('execGitDiff', () => {
    test('should return git diff output', async () => {
      const mockDiff = 'diff --git a/file.txt b/file.txt\n+new line';
      const mockFileExecAsync = vi.fn().mockResolvedValue({ stdout: mockDiff });

      const result = await execGitDiff('/test/dir', [], { execFileAsync: mockFileExecAsync });

      expect(result).toBe(mockDiff);
      expect(mockFileExecAsync).toHaveBeenCalledWith('git', ['-C', '/test/dir', 'diff', '--no-color']);
    });

    test('should throw error when git diff fails', async () => {
      const mockFileExecAsync = vi.fn().mockRejectedValue(new Error('git command failed'));

      await expect(execGitDiff('/test/dir', [], { execFileAsync: mockFileExecAsync })).rejects.toThrow(
        'git command failed',
      );
      expect(logger.trace).toHaveBeenCalledWith('Failed to execute git diff:', 'git command failed');
    });
  });

  describe('execGitVersion', () => {
    test('should return git version output', async () => {
      const mockVersion = 'git version 2.34.1';
      const mockFileExecAsync = vi.fn().mockResolvedValue({ stdout: mockVersion });

      const result = await execGitVersion({ execFileAsync: mockFileExecAsync });

      expect(result).toBe(mockVersion);
      expect(mockFileExecAsync).toHaveBeenCalledWith('git', ['--version']);
    });

    test('should throw error when git version fails', async () => {
      const mockFileExecAsync = vi.fn().mockRejectedValue(new Error('Command not found: git'));

      await expect(execGitVersion({ execFileAsync: mockFileExecAsync })).rejects.toThrow('Command not found: git');
      expect(logger.trace).toHaveBeenCalledWith('Failed to execute git version:', 'Command not found: git');
    });
  });

  describe('execGitRevParse', () => {
    test('should return git rev-parse output', async () => {
      const mockOutput = 'true';
      const mockFileExecAsync = vi.fn().mockResolvedValue({ stdout: mockOutput });

      const result = await execGitRevParse('/test/dir', { execFileAsync: mockFileExecAsync });

      expect(result).toBe(mockOutput);
      expect(mockFileExecAsync).toHaveBeenCalledWith('git', ['-C', '/test/dir', 'rev-parse', '--is-inside-work-tree']);
    });

    test('should throw error when git rev-parse fails', async () => {
      const mockFileExecAsync = vi.fn().mockRejectedValue(new Error('Not a git repository'));

      await expect(execGitRevParse('/test/dir', { execFileAsync: mockFileExecAsync })).rejects.toThrow(
        'Not a git repository',
      );
      expect(logger.trace).toHaveBeenCalledWith('Failed to execute git rev-parse:', 'Not a git repository');
    });
  });

  describe('execGitShallowClone', () => {
    test('should execute without branch option if not specified by user', async () => {
      const mockFileExecAsync = vi.fn().mockResolvedValue({ stdout: '', stderr: '' });
      const url = 'https://github.com/user/repo.git';
      const directory = '/tmp/repo';
      const remoteBranch = undefined;

      await execGitShallowClone(url, directory, remoteBranch, { execFileAsync: mockFileExecAsync });

      expect(mockFileExecAsync).toHaveBeenCalledWith('git', ['clone', '--depth', '1', url, directory]);
    });

    test('should throw error when git clone fails', async () => {
      const mockFileExecAsync = vi.fn().mockRejectedValue(new Error('Authentication failed'));
      const url = 'https://github.com/user/repo.git';
      const directory = '/tmp/repo';
      const remoteBranch = undefined;

      await expect(
        execGitShallowClone(url, directory, remoteBranch, { execFileAsync: mockFileExecAsync }),
      ).rejects.toThrow('Authentication failed');

      expect(mockFileExecAsync).toHaveBeenCalledWith('git', ['clone', '--depth', '1', url, directory]);
    });

    test('should execute commands correctly when branch is specified', async () => {
      const mockFileExecAsync = vi.fn().mockResolvedValue({ stdout: '', stderr: '' });

      const url = 'https://github.com/user/repo.git';
      const directory = '/tmp/repo';
      const remoteBranch = 'main';

      await execGitShallowClone(url, directory, remoteBranch, { execFileAsync: mockFileExecAsync });

      expect(mockFileExecAsync).toHaveBeenCalledTimes(4);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(1, 'git', ['-C', directory, 'init']);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(2, 'git', ['-C', directory, 'remote', 'add', 'origin', url]);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(3, 'git', [
        '-C',
        directory,
        'fetch',
        '--depth',
        '1',
        'origin',
        remoteBranch,
      ]);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(4, 'git', ['-C', directory, 'checkout', 'FETCH_HEAD']);
    });

    test('should throw error when git fetch fails', async () => {
      const mockFileExecAsync = vi
        .fn()
        .mockResolvedValueOnce('Success on first call')
        .mockResolvedValueOnce('Success on second call')
        .mockRejectedValueOnce(new Error('Authentication failed'));

      const url = 'https://github.com/user/repo.git';
      const directory = '/tmp/repo';
      const remoteBranch = 'b188a6cb39b512a9c6da7235b880af42c78ccd0d';

      await expect(
        execGitShallowClone(url, directory, remoteBranch, { execFileAsync: mockFileExecAsync }),
      ).rejects.toThrow('Authentication failed');
      expect(mockFileExecAsync).toHaveBeenCalledTimes(3);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(1, 'git', ['-C', directory, 'init']);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(2, 'git', ['-C', directory, 'remote', 'add', 'origin', url]);
      expect(mockFileExecAsync).toHaveBeenLastCalledWith('git', [
        '-C',
        directory,
        'fetch',
        '--depth',
        '1',
        'origin',
        remoteBranch,
      ]);
    });

    test('should handle short SHA correctly', async () => {
      const url = 'https://github.com/user/repo.git';
      const directory = '/tmp/repo';
      const shortSha = 'ce9b621';
      const mockFileExecAsync = vi
        .fn()
        .mockResolvedValueOnce('Success on first call')
        .mockResolvedValueOnce('Success on second call')
        .mockRejectedValueOnce(
          new Error(
            `Command failed: git fetch --depth 1 origin ${shortSha}\nfatal: couldn't find remote ref ${shortSha}`,
          ),
        );

      await execGitShallowClone(url, directory, shortSha, { execFileAsync: mockFileExecAsync });

      expect(mockFileExecAsync).toHaveBeenCalledTimes(5);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(1, 'git', ['-C', directory, 'init']);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(2, 'git', ['-C', directory, 'remote', 'add', 'origin', url]);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(3, 'git', [
        '-C',
        directory,
        'fetch',
        '--depth',
        '1',
        'origin',
        shortSha,
      ]);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(4, 'git', ['-C', directory, 'fetch', 'origin']);
      expect(mockFileExecAsync).toHaveBeenLastCalledWith('git', ['-C', directory, 'checkout', shortSha]);
    });

    test("should throw error when remote ref is not found, and it's not due to short SHA", async () => {
      const url = 'https://github.com/user/repo.git';
      const directory = '/tmp/repo';
      const remoteBranch = 'b188a6cb39b512a9c6da7235b880af42c78ccd0d';
      const errMessage = `Command failed: git fetch --depth 1 origin ${remoteBranch}\nfatal: couldn't find remote ref ${remoteBranch}`;

      const mockFileExecAsync = vi
        .fn()
        .mockResolvedValueOnce('Success on first call')
        .mockResolvedValueOnce('Success on second call')
        .mockRejectedValueOnce(new Error(errMessage));

      await expect(
        execGitShallowClone(url, directory, remoteBranch, { execFileAsync: mockFileExecAsync }),
      ).rejects.toThrow(errMessage);
      expect(mockFileExecAsync).toHaveBeenCalledTimes(3);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(1, 'git', ['-C', directory, 'init']);
      expect(mockFileExecAsync).toHaveBeenNthCalledWith(2, 'git', ['-C', directory, 'remote', 'add', 'origin', url]);
      expect(mockFileExecAsync).toHaveBeenLastCalledWith('git', [
        '-C',
        directory,
        'fetch',
        '--depth',
        '1',
        'origin',
        remoteBranch,
      ]);
    });
  });

  test('should reject URLs with dangerous parameters', async () => {
    const mockFileExecAsync = vi.fn();

    const url = 'https://github.com/user/repo.git --upload-pack=evil-command';
    const directory = '/tmp/repo';
    const remoteBranch = undefined;

    await expect(
      execGitShallowClone(url, directory, remoteBranch, { execFileAsync: mockFileExecAsync }),
    ).rejects.toThrow('Invalid repository URL. URL contains potentially dangerous parameters');

    expect(mockFileExecAsync).not.toHaveBeenCalled();
  });

  describe('execLsRemote', () => {
    test('should return git ls-remote output', async () => {
      const mockOutput = `
a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6\trefs/heads/main
b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7\trefs/heads/develop
c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8\trefs/tags/v1.0.0
`.trim();
      const mockFileExecAsync = vi.fn().mockResolvedValue({ stdout: mockOutput });

      const result = await execLsRemote('https://github.com/user/repo.git', { execFileAsync: mockFileExecAsync });

      expect(result).toBe(mockOutput);
      expect(mockFileExecAsync).toHaveBeenCalledWith('git', [
        'ls-remote',
        '--heads',
        '--tags',
        'https://github.com/user/repo.git',
      ]);
    });

    test('should throw error when git ls-remote fails', async () => {
      const mockFileExecAsync = vi.fn().mockRejectedValue(new Error('git command failed'));

      await expect(
        execLsRemote('https://github.com/user/repo.git', { execFileAsync: mockFileExecAsync }),
      ).rejects.toThrow('git command failed');
      expect(logger.trace).toHaveBeenCalledWith('Failed to execute git ls-remote:', 'git command failed');
    });
  });
});
</file>

<file path="tests/core/git/gitDiffHandle.test.ts">
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { getGitDiffs, getStagedDiff, getWorkTreeDiff } from '../../../src/core/git/gitDiffHandle.js';
import { logger } from '../../../src/shared/logger.js';
import { createMockConfig } from '../../testing/testUtils.js';

vi.mock('../../../src/shared/logger');

describe('gitDiffHandle', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  describe('getWorkTreeDiff', () => {
    test('should return diffs when directory is a git repository', async () => {
      const mockDiff = 'diff --git a/file.txt b/file.txt\n+new line';
      const mockIsGitRepository = vi.fn().mockResolvedValue(true);
      const mockExecGitDiff = vi.fn().mockResolvedValue(mockDiff);

      const result = await getWorkTreeDiff('/test/dir', {
        execGitDiff: mockExecGitDiff,
        isGitRepository: mockIsGitRepository,
      });

      expect(result).toBe(mockDiff);
      expect(mockIsGitRepository).toHaveBeenCalledWith('/test/dir');
      expect(mockExecGitDiff).toHaveBeenCalledWith('/test/dir', []);
    });

    test('should return empty string when directory is not a git repository', async () => {
      const mockIsGitRepository = vi.fn().mockResolvedValue(false);
      const mockExecGitDiff = vi.fn();

      const result = await getWorkTreeDiff('/test/dir', {
        execGitDiff: mockExecGitDiff,
        isGitRepository: mockIsGitRepository,
      });

      expect(result).toBe('');
      expect(mockIsGitRepository).toHaveBeenCalledWith('/test/dir');
      expect(mockExecGitDiff).not.toHaveBeenCalled();
    });

    test('should return empty string when git diff command fails', async () => {
      const mockIsGitRepository = vi.fn().mockResolvedValue(true);
      const mockExecGitDiff = vi.fn().mockRejectedValue(new Error('Failed to get diff'));

      const result = await getWorkTreeDiff('/test/dir', {
        execGitDiff: mockExecGitDiff,
        isGitRepository: mockIsGitRepository,
      });

      expect(result).toBe('');
      expect(mockIsGitRepository).toHaveBeenCalledWith('/test/dir');
      expect(mockExecGitDiff).toHaveBeenCalledWith('/test/dir', []);
      expect(logger.trace).toHaveBeenCalledWith('Failed to get git diff:', 'Failed to get diff');
    });
  });

  describe('getStagedDiff', () => {
    test('should return staged diffs when directory is a git repository', async () => {
      const mockDiff = 'diff --git a/staged.txt b/staged.txt\n+staged content';
      const mockIsGitRepository = vi.fn().mockResolvedValue(true);
      const mockExecGitDiff = vi.fn().mockResolvedValue(mockDiff);

      const result = await getStagedDiff('/test/dir', {
        execGitDiff: mockExecGitDiff,
        isGitRepository: mockIsGitRepository,
      });

      expect(result).toBe(mockDiff);
      expect(mockIsGitRepository).toHaveBeenCalledWith('/test/dir');
      expect(mockExecGitDiff).toHaveBeenCalledWith('/test/dir', ['--cached']);
    });
  });

  describe('getGitDiffs', () => {
    test('should return git diffs when includeDiffs is enabled', async () => {
      const mockWorkTreeDiff = 'diff --git a/file.txt b/file.txt\n+new line';
      const mockStagedDiff = 'diff --git a/staged.txt b/staged.txt\n+staged content';
      const mockGetWorkTreeDiff = vi.fn().mockResolvedValue(mockWorkTreeDiff);
      const mockGetStagedDiff = vi.fn().mockResolvedValue(mockStagedDiff);

      const mockConfig = createMockConfig({
        cwd: '/test/repo',
        output: {
          git: {
            includeDiffs: true,
          },
        },
      });

      const result = await getGitDiffs(['/test/repo'], mockConfig, {
        getWorkTreeDiff: mockGetWorkTreeDiff,
        getStagedDiff: mockGetStagedDiff,
      });

      expect(result).toEqual({
        workTreeDiffContent: mockWorkTreeDiff,
        stagedDiffContent: mockStagedDiff,
      });
      expect(mockGetWorkTreeDiff).toHaveBeenCalledWith('/test/repo');
      expect(mockGetStagedDiff).toHaveBeenCalledWith('/test/repo');
    });

    test('should return undefined when includeDiffs is disabled', async () => {
      const mockGetWorkTreeDiff = vi.fn();
      const mockGetStagedDiff = vi.fn();

      const mockConfig = createMockConfig({
        cwd: '/test/repo',
        output: {
          git: {
            includeDiffs: false,
          },
        },
      });

      const result = await getGitDiffs(['/test/repo'], mockConfig, {
        getWorkTreeDiff: mockGetWorkTreeDiff,
        getStagedDiff: mockGetStagedDiff,
      });

      expect(result).toBeUndefined();
      expect(mockGetWorkTreeDiff).not.toHaveBeenCalled();
      expect(mockGetStagedDiff).not.toHaveBeenCalled();
    });

    test('should use cwd when rootDirs is empty', async () => {
      const mockWorkTreeDiff = 'diff content';
      const mockStagedDiff = '';
      const mockGetWorkTreeDiff = vi.fn().mockResolvedValue(mockWorkTreeDiff);
      const mockGetStagedDiff = vi.fn().mockResolvedValue(mockStagedDiff);

      const mockConfig = createMockConfig({
        cwd: '/fallback/dir',
        output: {
          git: {
            includeDiffs: true,
          },
        },
      });

      const result = await getGitDiffs([], mockConfig, {
        getWorkTreeDiff: mockGetWorkTreeDiff,
        getStagedDiff: mockGetStagedDiff,
      });

      expect(result).toEqual({
        workTreeDiffContent: mockWorkTreeDiff,
        stagedDiffContent: mockStagedDiff,
      });
      // createMockConfig sets cwd to the actual working directory, so we check the actual config value
      expect(mockGetWorkTreeDiff).toHaveBeenCalledWith(mockConfig.cwd);
      expect(mockGetStagedDiff).toHaveBeenCalledWith(mockConfig.cwd);
    });

    test('should throw error when diff operations fail', async () => {
      const mockGetWorkTreeDiff = vi.fn().mockRejectedValue(new Error('Failed to get diff'));
      const mockGetStagedDiff = vi.fn();

      const mockConfig = createMockConfig({
        cwd: '/test/repo',
        output: {
          git: {
            includeDiffs: true,
          },
        },
      });

      await expect(
        getGitDiffs(['/test/repo'], mockConfig, {
          getWorkTreeDiff: mockGetWorkTreeDiff,
          getStagedDiff: mockGetStagedDiff,
        }),
      ).rejects.toThrow('Failed to get git diffs: Failed to get diff');

      expect(mockGetWorkTreeDiff).toHaveBeenCalledWith('/test/repo');
    });
  });
});
</file>

<file path="tests/core/git/gitHubArchive.test.ts">
import * as path from 'node:path';
import { Transform } from 'node:stream';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import {
  type ArchiveDownloadOptions,
  type ProgressCallback,
  downloadGitHubArchive,
  isArchiveDownloadSupported,
} from '../../../src/core/git/gitHubArchive.js';
import type { GitHubRepoInfo } from '../../../src/core/git/gitRemoteParse.js';
import { RepomixError } from '../../../src/shared/errorHandle.js';

// Mock modules
vi.mock('../../../src/shared/logger');
vi.mock('fflate', () => ({
  unzip: vi.fn(),
}));

// Mock file system operations
const mockFs = {
  mkdir: vi.fn(),
  readFile: vi.fn(),
  writeFile: vi.fn(),
  unlink: vi.fn(),
};

// Simple ZIP test data
const mockZipData = new Uint8Array([0x50, 0x4b, 0x03, 0x04]); // Simple ZIP header

describe('gitHubArchive', () => {
  let mockFetch: ReturnType<typeof vi.fn>;
  let mockPipeline: ReturnType<typeof vi.fn>;
  let mockTransform: ReturnType<typeof vi.fn>;
  let mockCreateWriteStream: ReturnType<typeof vi.fn>;
  let mockUnzip: ReturnType<typeof vi.fn>;

  beforeEach(async () => {
    vi.clearAllMocks();

    mockFetch = vi.fn();
    mockPipeline = vi.fn();
    mockTransform = vi.fn();
    mockCreateWriteStream = vi.fn();

    // Get the mocked unzip function
    const { unzip } = await import('fflate');
    mockUnzip = vi.mocked(unzip);

    // Reset fs mocks
    for (const mock of Object.values(mockFs)) {
      mock.mockReset();
    }

    // Setup default successful behaviors
    mockFs.mkdir.mockResolvedValue(undefined);
    mockFs.unlink.mockResolvedValue(undefined);
    mockFs.readFile.mockResolvedValue(Buffer.from(mockZipData));
    mockFs.writeFile.mockResolvedValue(undefined);
    mockPipeline.mockResolvedValue(undefined);
    mockCreateWriteStream.mockReturnValue({
      write: vi.fn(),
      end: vi.fn(),
    });
    mockTransform.mockImplementation(() => new Transform());
  });

  describe('downloadGitHubArchive', () => {
    const mockRepoInfo: GitHubRepoInfo = {
      owner: 'yamadashy',
      repo: 'repomix',
      ref: 'main',
    };

    const mockTargetDirectory = '/test/target';
    const mockOptions: ArchiveDownloadOptions = {
      timeout: 30000,
      retries: 3,
    };

    test('should successfully download and extract archive', async () => {
      // Mock successful response with stream
      const mockStream = new ReadableStream({
        start(controller) {
          controller.enqueue(mockZipData);
          controller.close();
        },
      });

      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        headers: new Map([['content-length', mockZipData.length.toString()]]),
        body: mockStream,
      });

      // Mock unzip to extract files
      mockUnzip.mockImplementation((_data, callback) => {
        const extracted = {
          'repomix-main/': new Uint8Array(0), // Directory
          'repomix-main/test.txt': new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f]), // "hello"
        };
        callback(null, extracted);
      });

      await downloadGitHubArchive(mockRepoInfo, mockTargetDirectory, mockOptions, undefined, {
        fetch: mockFetch,
        // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
        fs: mockFs as any,
        pipeline: mockPipeline,
        // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
        Transform: mockTransform as any,
        createWriteStream: mockCreateWriteStream,
      });

      // Verify directory creation
      expect(mockFs.mkdir).toHaveBeenCalledWith(mockTargetDirectory, { recursive: true });

      // Verify fetch was called
      expect(mockFetch).toHaveBeenCalledWith(
        'https://github.com/yamadashy/repomix/archive/refs/heads/main.zip',
        expect.objectContaining({
          signal: expect.any(AbortSignal),
        }),
      );

      // Verify file operations
      expect(mockFs.writeFile).toHaveBeenCalledWith(
        path.resolve(mockTargetDirectory, 'test.txt'),
        expect.any(Uint8Array),
      );

      // Verify cleanup
      expect(mockFs.unlink).toHaveBeenCalledWith(path.join(mockTargetDirectory, 'repomix-main.zip'));
    });

    test('should handle progress callback', async () => {
      const mockProgressCallback: ProgressCallback = vi.fn();

      const mockStream = new ReadableStream({
        start(controller) {
          controller.enqueue(mockZipData);
          controller.close();
        },
      });

      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        headers: new Map([['content-length', mockZipData.length.toString()]]),
        body: mockStream,
      });

      mockUnzip.mockImplementation((_data, callback) => {
        callback(null, {});
      });

      await downloadGitHubArchive(mockRepoInfo, mockTargetDirectory, mockOptions, mockProgressCallback, {
        fetch: mockFetch,
        // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
        fs: mockFs as any,
        pipeline: mockPipeline,
        // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
        Transform: mockTransform as any,
        createWriteStream: mockCreateWriteStream,
      });

      // Progress callback is called via Transform stream, which is handled internally
      // Just verify the download completed successfully
      expect(mockFetch).toHaveBeenCalled();
      expect(mockUnzip).toHaveBeenCalled();
    });

    test('should retry on failure', async () => {
      // First two attempts fail, third succeeds
      mockFetch
        .mockRejectedValueOnce(new Error('Network error'))
        .mockRejectedValueOnce(new Error('Network error'))
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          headers: new Map([['content-length', mockZipData.length.toString()]]),
          body: new ReadableStream({
            start(controller) {
              controller.enqueue(mockZipData);
              controller.close();
            },
          }),
        });

      mockUnzip.mockImplementation((_data, callback) => {
        callback(null, {});
      });

      // Use fewer retries to speed up test
      await downloadGitHubArchive(mockRepoInfo, mockTargetDirectory, { retries: 2 }, undefined, {
        fetch: mockFetch,
        // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
        fs: mockFs as any,
        pipeline: mockPipeline,
        // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
        Transform: mockTransform as any,
        createWriteStream: mockCreateWriteStream,
      });

      expect(mockFetch).toHaveBeenCalledTimes(3);
    });

    test('should try fallback URLs on 404', async () => {
      // Mock 404 for main branch, success for master branch
      mockFetch
        .mockResolvedValueOnce({
          ok: false,
          status: 404,
          headers: new Map(),
          body: null,
        })
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          headers: new Map([['content-length', mockZipData.length.toString()]]),
          body: new ReadableStream({
            start(controller) {
              controller.enqueue(mockZipData);
              controller.close();
            },
          }),
        });

      mockUnzip.mockImplementation((_data, callback) => {
        callback(null, {});
      });

      const repoInfoNoRef = { owner: 'yamadashy', repo: 'repomix' };

      await downloadGitHubArchive(repoInfoNoRef, mockTargetDirectory, mockOptions, undefined, {
        fetch: mockFetch,
        // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
        fs: mockFs as any,
        pipeline: mockPipeline,
        // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
        Transform: mockTransform as any,
        createWriteStream: mockCreateWriteStream,
      });

      // Should try main branch first, then master branch
      expect(mockFetch).toHaveBeenCalledWith(
        'https://github.com/yamadashy/repomix/archive/refs/heads/main.zip',
        expect.any(Object),
      );
      expect(mockFetch).toHaveBeenCalledWith(
        'https://github.com/yamadashy/repomix/archive/refs/heads/master.zip',
        expect.any(Object),
      );
    });

    test('should throw error after all retries fail', async () => {
      mockFetch.mockRejectedValue(new Error('Network error'));

      await expect(
        downloadGitHubArchive(mockRepoInfo, mockTargetDirectory, { retries: 2 }, undefined, {
          fetch: mockFetch,
          // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
          fs: mockFs as any,
          pipeline: mockPipeline,
          // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
          Transform: mockTransform as any,
          createWriteStream: mockCreateWriteStream,
        }),
      ).rejects.toThrow(RepomixError);

      // Multiple URLs are tried even with ref: main, fallback, tag
      // 2 retries × 2 URLs (main + tag for "main" ref) = 4 total attempts
      expect(mockFetch).toHaveBeenCalledTimes(4);
    });

    test('should handle ZIP extraction error', async () => {
      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        headers: new Map([['content-length', mockZipData.length.toString()]]),
        body: new ReadableStream({
          start(controller) {
            controller.enqueue(mockZipData);
            controller.close();
          },
        }),
      });

      // Mock unzip to fail
      mockUnzip.mockImplementation((_data, callback) => {
        callback(new Error('Invalid ZIP file'));
      });

      await expect(
        downloadGitHubArchive(mockRepoInfo, mockTargetDirectory, { retries: 1 }, undefined, {
          fetch: mockFetch,
          // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
          fs: mockFs as any,
          pipeline: mockPipeline,
          // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
          Transform: mockTransform as any,
          createWriteStream: mockCreateWriteStream,
        }),
      ).rejects.toThrow(RepomixError);
    });

    test('should handle path traversal attack', async () => {
      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        headers: new Map([['content-length', mockZipData.length.toString()]]),
        body: new ReadableStream({
          start(controller) {
            controller.enqueue(mockZipData);
            controller.close();
          },
        }),
      });

      // Mock unzip with dangerous paths
      mockUnzip.mockImplementation((_data, callback) => {
        const extracted = {
          'repomix-main/../../../etc/passwd': new Uint8Array([0x65, 0x76, 0x69, 0x6c]), // "evil"
          'repomix-main/safe.txt': new Uint8Array([0x73, 0x61, 0x66, 0x65]), // "safe"
        };
        callback(null, extracted);
      });

      await downloadGitHubArchive(mockRepoInfo, mockTargetDirectory, mockOptions, undefined, {
        fetch: mockFetch,
        // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
        fs: mockFs as any,
        pipeline: mockPipeline,
        // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
        Transform: mockTransform as any,
        createWriteStream: mockCreateWriteStream,
      });

      // Should write both files - the path normalization doesn't completely prevent this case
      expect(mockFs.writeFile).toHaveBeenCalledWith(
        path.resolve(mockTargetDirectory, 'safe.txt'),
        expect.any(Uint8Array),
      );

      // Verify that both files are written (one was sanitized to remove path traversal)
      expect(mockFs.writeFile).toHaveBeenCalledTimes(2);
    });

    test('should handle absolute paths in ZIP', async () => {
      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        headers: new Map([['content-length', mockZipData.length.toString()]]),
        body: new ReadableStream({
          start(controller) {
            controller.enqueue(mockZipData);
            controller.close();
          },
        }),
      });

      // Mock unzip with absolute path
      mockUnzip.mockImplementation((_data, callback) => {
        const extracted = {
          '/etc/passwd': new Uint8Array([0x65, 0x76, 0x69, 0x6c]), // "evil"
          'repomix-main/safe.txt': new Uint8Array([0x73, 0x61, 0x66, 0x65]), // "safe"
        };
        callback(null, extracted);
      });

      await downloadGitHubArchive(mockRepoInfo, mockTargetDirectory, mockOptions, undefined, {
        fetch: mockFetch,
        // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
        fs: mockFs as any,
        pipeline: mockPipeline,
        // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
        Transform: mockTransform as any,
        createWriteStream: mockCreateWriteStream,
      });

      // Should only write safe file, not the absolute path
      expect(mockFs.writeFile).toHaveBeenCalledWith(
        path.resolve(mockTargetDirectory, 'safe.txt'),
        expect.any(Uint8Array),
      );

      // Should not write the absolute path file
      expect(mockFs.writeFile).not.toHaveBeenCalledWith('/etc/passwd', expect.any(Uint8Array));
    });

    test('should cleanup archive file even on extraction failure', async () => {
      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        headers: new Map([['content-length', mockZipData.length.toString()]]),
        body: new ReadableStream({
          start(controller) {
            controller.enqueue(mockZipData);
            controller.close();
          },
        }),
      });

      // Mock unzip to fail
      mockUnzip.mockImplementation((_data, callback) => {
        callback(new Error('Extraction failed'));
      });

      await expect(
        downloadGitHubArchive(mockRepoInfo, mockTargetDirectory, { retries: 1 }, undefined, {
          fetch: mockFetch,
          // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
          fs: mockFs as any,
          pipeline: mockPipeline,
          // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
          Transform: mockTransform as any,
          createWriteStream: mockCreateWriteStream,
        }),
      ).rejects.toThrow();

      // Should still attempt cleanup
      expect(mockFs.unlink).toHaveBeenCalledWith(path.join(mockTargetDirectory, 'repomix-main.zip'));
    });

    test('should handle missing response body', async () => {
      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        headers: new Map(),
        body: null,
      });

      await expect(
        downloadGitHubArchive(mockRepoInfo, mockTargetDirectory, { retries: 1 }, undefined, {
          fetch: mockFetch,
          // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
          fs: mockFs as any,
          pipeline: mockPipeline,
          // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
          Transform: mockTransform as any,
          createWriteStream: mockCreateWriteStream,
        }),
      ).rejects.toThrow(RepomixError);
    });

    test('should handle timeout', async () => {
      // Mock a fetch that takes too long
      mockFetch.mockImplementation(
        () =>
          new Promise((resolve) => {
            setTimeout(() => {
              resolve({
                ok: true,
                status: 200,
                headers: new Map(),
                body: new ReadableStream({
                  start(controller) {
                    controller.enqueue(mockZipData);
                    controller.close();
                  },
                }),
              });
            }, 100); // Resolve after 100ms, but timeout is 50ms
          }),
      );

      const shortTimeout = 50; // 50ms timeout for faster test

      await expect(
        downloadGitHubArchive(mockRepoInfo, mockTargetDirectory, { timeout: shortTimeout, retries: 1 }, undefined, {
          fetch: mockFetch,
          // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
          fs: mockFs as any,
          pipeline: mockPipeline,
          // biome-ignore lint/suspicious/noExplicitAny: Test mocks require any type
          Transform: mockTransform as any,
          createWriteStream: mockCreateWriteStream,
        }),
      ).rejects.toThrow();
    });
  });

  describe('isArchiveDownloadSupported', () => {
    test('should return true for any GitHub repository', () => {
      const repoInfo: GitHubRepoInfo = {
        owner: 'yamadashy',
        repo: 'repomix',
      };

      const result = isArchiveDownloadSupported(repoInfo);
      expect(result).toBe(true);
    });

    test('should return true for repository with ref', () => {
      const repoInfo: GitHubRepoInfo = {
        owner: 'yamadashy',
        repo: 'repomix',
        ref: 'develop',
      };

      const result = isArchiveDownloadSupported(repoInfo);
      expect(result).toBe(true);
    });
  });
});
</file>

<file path="tests/core/git/gitHubArchiveApi.test.ts">
import { describe, expect, test } from 'vitest';
import {
  buildGitHubArchiveUrl,
  buildGitHubMasterArchiveUrl,
  buildGitHubTagArchiveUrl,
  checkGitHubResponse,
  getArchiveFilename,
} from '../../../src/core/git/gitHubArchiveApi.js';
import { parseGitHubRepoInfo } from '../../../src/core/git/gitRemoteParse.js';
import { RepomixError } from '../../../src/shared/errorHandle.js';

describe('GitHub Archive API', () => {
  describe('buildGitHubArchiveUrl', () => {
    test('should build URL for default branch', () => {
      const repoInfo = { owner: 'user', repo: 'repo' };
      const url = buildGitHubArchiveUrl(repoInfo);
      expect(url).toBe('https://github.com/user/repo/archive/refs/heads/main.zip');
    });

    test('should build URL for specific branch', () => {
      const repoInfo = { owner: 'user', repo: 'repo', ref: 'develop' };
      const url = buildGitHubArchiveUrl(repoInfo);
      expect(url).toBe('https://github.com/user/repo/archive/refs/heads/develop.zip');
    });

    test('should build URL for commit SHA', () => {
      const repoInfo = { owner: 'user', repo: 'repo', ref: 'abc123def456' };
      const url = buildGitHubArchiveUrl(repoInfo);
      expect(url).toBe('https://github.com/user/repo/archive/abc123def456.zip');
    });

    test('should build URL for full commit SHA', () => {
      const repoInfo = { owner: 'user', repo: 'repo', ref: 'abc123def456789012345678901234567890abcd' };
      const url = buildGitHubArchiveUrl(repoInfo);
      expect(url).toBe('https://github.com/user/repo/archive/abc123def456789012345678901234567890abcd.zip');
    });
  });

  describe('buildGitHubMasterArchiveUrl', () => {
    test('should build URL for master branch fallback', () => {
      const repoInfo = { owner: 'user', repo: 'repo' };
      const url = buildGitHubMasterArchiveUrl(repoInfo);
      expect(url).toBe('https://github.com/user/repo/archive/refs/heads/master.zip');
    });

    test('should return null when ref is specified', () => {
      const repoInfo = { owner: 'user', repo: 'repo', ref: 'develop' };
      const url = buildGitHubMasterArchiveUrl(repoInfo);
      expect(url).toBeNull();
    });
  });

  describe('buildGitHubTagArchiveUrl', () => {
    test('should build URL for tag', () => {
      const repoInfo = { owner: 'user', repo: 'repo', ref: 'v1.0.0' };
      const url = buildGitHubTagArchiveUrl(repoInfo);
      expect(url).toBe('https://github.com/user/repo/archive/refs/tags/v1.0.0.zip');
    });

    test('should return null for commit SHA', () => {
      const repoInfo = { owner: 'user', repo: 'repo', ref: 'abc123def456' };
      const url = buildGitHubTagArchiveUrl(repoInfo);
      expect(url).toBeNull();
    });

    test('should return null for no ref', () => {
      const repoInfo = { owner: 'user', repo: 'repo' };
      const url = buildGitHubTagArchiveUrl(repoInfo);
      expect(url).toBeNull();
    });
  });

  describe('getArchiveFilename', () => {
    test('should generate filename for default branch', () => {
      const repoInfo = { owner: 'user', repo: 'myrepo' };
      const filename = getArchiveFilename(repoInfo);
      expect(filename).toBe('myrepo-main.zip');
    });

    test('should generate filename for specific branch', () => {
      const repoInfo = { owner: 'user', repo: 'myrepo', ref: 'develop' };
      const filename = getArchiveFilename(repoInfo);
      expect(filename).toBe('myrepo-develop.zip');
    });

    test('should generate filename for tag with slash', () => {
      const repoInfo = { owner: 'user', repo: 'myrepo', ref: 'release/v1.0' };
      const filename = getArchiveFilename(repoInfo);
      expect(filename).toBe('myrepo-v1.0.zip');
    });

    test('should generate filename for commit SHA', () => {
      const repoInfo = { owner: 'user', repo: 'myrepo', ref: 'abc123' };
      const filename = getArchiveFilename(repoInfo);
      expect(filename).toBe('myrepo-abc123.zip');
    });
  });

  describe('checkGitHubResponse', () => {
    test('should not throw for successful response', () => {
      const mockResponse = new Response('', { status: 200 });
      expect(() => checkGitHubResponse(mockResponse)).not.toThrow();
    });

    test('should throw RepomixError for 404', () => {
      const mockResponse = new Response('', { status: 404 });
      expect(() => checkGitHubResponse(mockResponse)).toThrow(RepomixError);
      expect(() => checkGitHubResponse(mockResponse)).toThrow('Repository not found or is private');
    });

    test('should throw RepomixError for 403 with rate limit', () => {
      const mockResponse = new Response('', {
        status: 403,
        headers: { 'X-RateLimit-Remaining': '0', 'X-RateLimit-Reset': '1234567890' },
      });
      expect(() => checkGitHubResponse(mockResponse)).toThrow(RepomixError);
      expect(() => checkGitHubResponse(mockResponse)).toThrow('GitHub API rate limit exceeded');
    });

    test('should throw RepomixError for 403 without rate limit', () => {
      const mockResponse = new Response('', { status: 403 });
      expect(() => checkGitHubResponse(mockResponse)).toThrow(RepomixError);
      expect(() => checkGitHubResponse(mockResponse)).toThrow('Access denied');
    });

    test('should throw RepomixError for server errors', () => {
      const mockResponse = new Response('', { status: 500 });
      expect(() => checkGitHubResponse(mockResponse)).toThrow(RepomixError);
      expect(() => checkGitHubResponse(mockResponse)).toThrow('GitHub server error');
    });

    test('should throw RepomixError for other errors', () => {
      const mockResponse = new Response('', { status: 400 });
      expect(() => checkGitHubResponse(mockResponse)).toThrow(RepomixError);
      expect(() => checkGitHubResponse(mockResponse)).toThrow('GitHub API error');
    });
  });

  describe('parseGitHubRepoInfo integration', () => {
    test('should parse shorthand format', () => {
      const result = parseGitHubRepoInfo('yamadashy/repomix');
      expect(result).toEqual({
        owner: 'yamadashy',
        repo: 'repomix',
      });
    });

    test('should parse HTTPS URL', () => {
      const result = parseGitHubRepoInfo('https://github.com/yamadashy/repomix.git');
      expect(result).toEqual({
        owner: 'yamadashy',
        repo: 'repomix',
      });
    });

    test('should parse SSH URL', () => {
      const result = parseGitHubRepoInfo('git@github.com:yamadashy/repomix.git');
      expect(result).toEqual({
        owner: 'yamadashy',
        repo: 'repomix',
      });
    });

    test('should parse URL with branch', () => {
      const result = parseGitHubRepoInfo('https://github.com/yamadashy/repomix/tree/develop');
      expect(result).toEqual({
        owner: 'yamadashy',
        repo: 'repomix',
        ref: 'develop',
      });
    });

    test('should return null for non-GitHub URLs', () => {
      const result = parseGitHubRepoInfo('https://gitlab.com/user/repo.git');
      expect(result).toBeNull();
    });

    test('should return null for invalid format', () => {
      const result = parseGitHubRepoInfo('invalid-format');
      expect(result).toBeNull();
    });
  });
});
</file>

<file path="tests/core/git/gitRemoteHandle.test.ts">
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { getRemoteRefs } from '../../../src/core/git/gitRemoteHandle.js';
import { logger } from '../../../src/shared/logger.js';

vi.mock('../../../src/shared/logger');

describe('gitRemoteHandle', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  describe('getRemoteRefs', () => {
    test('should return refs when URL is valid', async () => {
      const mockOutput = `
a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6	refs/heads/main
b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7	refs/heads/develop
c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8	refs/tags/v1.0.0
`.trim();
      const mockExecLsRemote = vi.fn().mockResolvedValue(mockOutput);

      const result = await getRemoteRefs('https://github.com/user/repo.git', {
        execLsRemote: mockExecLsRemote,
      });

      expect(result).toEqual(['main', 'develop', 'v1.0.0']);
      expect(mockExecLsRemote).toHaveBeenCalledWith('https://github.com/user/repo.git');
      expect(logger.trace).toHaveBeenCalledWith('Found 3 refs in repository: https://github.com/user/repo.git');
    });

    test('should return empty array when no refs found', async () => {
      const mockExecLsRemote = vi.fn().mockResolvedValue('');

      const result = await getRemoteRefs('https://github.com/user/repo.git', {
        execLsRemote: mockExecLsRemote,
      });

      expect(result).toEqual([]);
      expect(mockExecLsRemote).toHaveBeenCalledWith('https://github.com/user/repo.git');
      expect(logger.trace).toHaveBeenCalledWith('Found 0 refs in repository: https://github.com/user/repo.git');
    });

    test('should throw error when ls-remote fails', async () => {
      const mockExecLsRemote = vi.fn().mockRejectedValue(new Error('Repository not found'));

      await expect(
        getRemoteRefs('https://github.com/user/nonexistent.git', {
          execLsRemote: mockExecLsRemote,
        }),
      ).rejects.toThrow('Failed to get remote refs: Repository not found');

      expect(mockExecLsRemote).toHaveBeenCalledWith('https://github.com/user/nonexistent.git');
      expect(logger.trace).toHaveBeenCalledWith('Failed to get remote refs:', 'Repository not found');
    });

    test('should handle malformed output lines', async () => {
      const mockOutput = `
a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6	refs/heads/main
invalid-line-without-tab
b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7	refs/heads/develop
`.trim();
      const mockExecLsRemote = vi.fn().mockResolvedValue(mockOutput);

      const result = await getRemoteRefs('https://github.com/user/repo.git', {
        execLsRemote: mockExecLsRemote,
      });

      expect(result).toEqual(['main', 'develop']);
      expect(mockExecLsRemote).toHaveBeenCalledWith('https://github.com/user/repo.git');
      expect(logger.trace).toHaveBeenCalledWith('Found 2 refs in repository: https://github.com/user/repo.git');
    });

    test('should throw error for invalid URL', async () => {
      await expect(
        getRemoteRefs('invalid-url', {
          execLsRemote: vi.fn(),
        }),
      ).rejects.toThrow('Invalid URL protocol');
    });

    test('should throw error for dangerous URL parameters', async () => {
      await expect(
        getRemoteRefs('https://github.com/user/repo.git --upload-pack=evil', {
          execLsRemote: vi.fn(),
        }),
      ).rejects.toThrow('Invalid repository URL. URL contains potentially dangerous parameters');
    });
  });
});
</file>

<file path="tests/core/git/gitRemoteParse.test.ts">
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { isGitHubRepository, parseGitHubRepoInfo, parseRemoteValue } from '../../../src/core/git/gitRemoteParse.js';
import { isValidRemoteValue } from '../../../src/index.js';

vi.mock('../../../src/shared/logger');

describe('remoteAction functions', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  describe('parseRemoteValue', () => {
    test('should convert GitHub shorthand to full URL', () => {
      expect(parseRemoteValue('user/repo')).toEqual({
        repoUrl: 'https://github.com/user/repo.git',
        remoteBranch: undefined,
      });
      expect(parseRemoteValue('user-name/repo-name')).toEqual({
        repoUrl: 'https://github.com/user-name/repo-name.git',
        remoteBranch: undefined,
      });
      expect(parseRemoteValue('user_name/repo_name')).toEqual({
        repoUrl: 'https://github.com/user_name/repo_name.git',
        remoteBranch: undefined,
      });
      expect(parseRemoteValue('a.b/a-b_c')).toEqual({
        repoUrl: 'https://github.com/a.b/a-b_c.git',
        remoteBranch: undefined,
      });
    });

    test('should handle HTTPS URLs', () => {
      expect(parseRemoteValue('https://github.com/user/repo')).toEqual({
        repoUrl: 'https://github.com/user/repo.git',
        remoteBranch: undefined,
      });
      expect(parseRemoteValue('https://github.com/user/repo.git')).toEqual({
        repoUrl: 'https://github.com/user/repo.git',
        remoteBranch: undefined,
      });
    });

    test('should not modify SSH URLs', () => {
      const sshUrl = 'git@github.com:user/repo.git';
      const parsed = parseRemoteValue(sshUrl);
      expect(parsed).toEqual({
        repoUrl: sshUrl,
        remoteBranch: undefined,
      });
    });

    test('should get correct branch name from url', () => {
      expect(parseRemoteValue('https://github.com/username/repo/tree/branchname')).toEqual({
        repoUrl: 'https://github.com/username/repo.git',
        remoteBranch: 'branchname',
      });
      expect(parseRemoteValue('https://some.gitlab.domain/some/path/username/repo/-/tree/branchname')).toEqual({
        repoUrl: 'https://some.gitlab.domain/some/path/username/repo.git',
        remoteBranch: 'branchname',
      });
      expect(
        parseRemoteValue('https://some.gitlab.domain/some/path/username/repo/-/tree/branchname/withslash', [
          'branchname/withslash',
        ]),
      ).toEqual({
        repoUrl: 'https://some.gitlab.domain/some/path/username/repo.git',
        remoteBranch: 'branchname/withslash',
      });
    });

    test('should get correct commit hash from url', () => {
      expect(
        parseRemoteValue(
          'https://some.gitlab.domain/some/path/username/repo/commit/c482755296cce46e58f87d50f25f545c5d15be6f',
        ),
      ).toEqual({
        repoUrl: 'https://some.gitlab.domain/some/path/username/repo.git',
        remoteBranch: 'c482755296cce46e58f87d50f25f545c5d15be6f',
      });
    });
    test('should throw when the URL is invalid or harmful', () => {
      expect(() => parseRemoteValue('some random string')).toThrowError();
    });
  });

  describe('isValidRemoteValue', () => {
    describe('GitHub shorthand format (user/repo)', () => {
      test('should accept valid repository names', () => {
        // Test cases for valid repository names with various allowed characters
        const validUrls = [
          'user/repo',
          'user123/repo-name',
          'org-name/repo_name',
          'user.name/repo.test',
          'user_name/repo_test',
          'a/b', // Minimum length case
          'user-name123/repo-test123.sub_123', // Complex case
        ];

        for (const url of validUrls) {
          expect(isValidRemoteValue(url), `URL should be valid: ${url}`).toBe(true);
        }
      });

      test('should reject invalid repository names', () => {
        // Test cases for invalid patterns and disallowed characters
        const invalidUrls = [
          '', // Empty string
          'user', // Missing slash
          '/repo', // Missing username
          'user/', // Missing repository name
          '-user/repo', // Starts with hyphen
          'user/-repo', // Repository starts with hyphen
          'user./repo', // Username ends with dot
          'user/repo.', // Repository ends with dot
          'user/repo#branch', // Contains invalid character
          'user/repo/extra', // Extra path segment
          'us!er/repo', // Contains invalid character
          'user/re*po', // Contains invalid character
          'user//repo', // Double slash
          '.user/repo', // Starts with dot
          'user/.repo', // Repository starts with dot
        ];

        for (const url of invalidUrls) {
          expect(isValidRemoteValue(url), `URL should be invalid: ${url}`).toBe(false);
        }
      });
    });

    describe('Full URL format', () => {
      test('should accept valid URLs', () => {
        // Test cases for standard URL formats
        const validUrls = [
          'https://example.com',
          'http://localhost',
          'https://github.com/user/repo',
          'https://gitlab.com/user/repo',
          'https://domain.com/path/to/something',
        ];

        for (const url of validUrls) {
          expect(isValidRemoteValue(url), `URL should be valid: ${url}`).toBe(true);
        }
      });

      test('should reject invalid URLs', () => {
        // Test cases for malformed URLs
        const invalidUrls = ['not-a-url', 'http://', 'https://', '://no-protocol.com', 'http://[invalid]'];

        for (const url of invalidUrls) {
          expect(isValidRemoteValue(url), `URL should be invalid: ${url}`).toBe(false);
        }
      });
    });
  });

  describe('parseGitHubRepoInfo', () => {
    test('should parse GitHub shorthand', () => {
      const result = parseGitHubRepoInfo('yamadashy/repomix');
      expect(result).toEqual({
        owner: 'yamadashy',
        repo: 'repomix',
      });
    });

    test('should parse GitHub URL with branch', () => {
      const result = parseGitHubRepoInfo('https://github.com/yamadashy/repomix/tree/develop');
      expect(result).toEqual({
        owner: 'yamadashy',
        repo: 'repomix',
        ref: 'develop',
      });
    });

    test('should parse GitHub git URL', () => {
      const result = parseGitHubRepoInfo('https://github.com/yamadashy/repomix.git');
      expect(result).toEqual({
        owner: 'yamadashy',
        repo: 'repomix',
      });
    });

    test('should return null for non-GitHub URLs', () => {
      const result = parseGitHubRepoInfo('https://gitlab.com/user/repo');
      expect(result).toBeNull();
    });

    test('should return null for invalid URLs', () => {
      const result = parseGitHubRepoInfo('invalid-url');
      expect(result).toBeNull();
    });

    test('should handle git@ URLs', () => {
      const result = parseGitHubRepoInfo('git@github.com:yamadashy/repomix.git');
      expect(result).toEqual({
        owner: 'yamadashy',
        repo: 'repomix',
      });
    });

    test('should merge branch from parsing when URL contains branch info', () => {
      const result = parseGitHubRepoInfo('https://github.com/yamadashy/repomix/tree/feature/test');
      expect(result).toEqual({
        owner: 'yamadashy',
        repo: 'repomix',
        ref: 'feature/test',
      });
    });

    test('should reject malicious URLs with github.com in path or query', () => {
      // Malicious URLs that should not be treated as GitHub repositories
      expect(parseGitHubRepoInfo('https://evil.com/github.com/user/repo')).toBeNull();
      expect(parseGitHubRepoInfo('https://evil.com/?redirect=github.com/user/repo')).toBeNull();
      expect(parseGitHubRepoInfo('https://evil.com#github.com/user/repo')).toBeNull();
      expect(parseGitHubRepoInfo('https://github.com.evil.com/user/repo')).toBeNull();
    });

    test('should accept legitimate GitHub URLs', () => {
      expect(parseGitHubRepoInfo('https://github.com/user/repo')).not.toBeNull();
      expect(parseGitHubRepoInfo('https://www.github.com/user/repo')).not.toBeNull();
    });
  });

  describe('isGitHubRepository', () => {
    test('should return true for GitHub repositories', () => {
      expect(isGitHubRepository('yamadashy/repomix')).toBe(true);
      expect(isGitHubRepository('https://github.com/yamadashy/repomix')).toBe(true);
      expect(isGitHubRepository('git@github.com:yamadashy/repomix.git')).toBe(true);
      expect(isGitHubRepository('https://github.com/yamadashy/repomix/tree/develop')).toBe(true);
    });

    test('should return false for non-GitHub repositories', () => {
      expect(isGitHubRepository('https://gitlab.com/user/repo')).toBe(false);
      expect(isGitHubRepository('https://bitbucket.org/user/repo')).toBe(false);
      expect(isGitHubRepository('invalid-url')).toBe(false);
      expect(isGitHubRepository('')).toBe(false);
    });
  });
});
</file>

<file path="tests/core/git/gitRepositoryHandle.test.ts">
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { getFileChangeCount, isGitInstalled, isGitRepository } from '../../../src/core/git/gitRepositoryHandle.js';
import { logger } from '../../../src/shared/logger.js';

vi.mock('../../../src/shared/logger');

describe('gitRepositoryHandle', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  describe('getFileChangeCount', () => {
    test('should count file changes correctly', async () => {
      const mockFilenames = ['file1.ts', 'file2.ts', 'file1.ts', 'file3.ts', 'file2.ts'];

      const mockExecGitLogFilenames = vi.fn().mockResolvedValue(mockFilenames);

      const result = await getFileChangeCount('/test/dir', 5, {
        execGitLogFilenames: mockExecGitLogFilenames,
      });

      expect(result).toEqual({
        'file1.ts': 2,
        'file2.ts': 2,
        'file3.ts': 1,
      });
      expect(mockExecGitLogFilenames).toHaveBeenCalledWith('/test/dir', 5);
    });

    test('should return empty object when git command fails', async () => {
      const mockExecGitLogFilenames = vi.fn().mockRejectedValue(new Error('git command failed'));

      const result = await getFileChangeCount('/test/dir', 5, {
        execGitLogFilenames: mockExecGitLogFilenames,
      });

      expect(result).toEqual({});
      expect(logger.trace).toHaveBeenCalledWith('Failed to get file change counts:', 'git command failed');
    });

    test('should handle empty git log output', async () => {
      const mockExecGitLogFilenames = vi.fn().mockResolvedValue([]);

      const result = await getFileChangeCount('/test/dir', 5, {
        execGitLogFilenames: mockExecGitLogFilenames,
      });

      expect(result).toEqual({});
      expect(mockExecGitLogFilenames).toHaveBeenCalledWith('/test/dir', 5);
    });
  });

  describe('isGitRepository', () => {
    test('should return true when directory is a git repository', async () => {
      const mockExecGitRevParse = vi.fn().mockResolvedValue('true');

      const result = await isGitRepository('/test/dir', {
        execGitRevParse: mockExecGitRevParse,
      });

      expect(result).toBe(true);
      expect(mockExecGitRevParse).toHaveBeenCalledWith('/test/dir');
    });

    test('should return false when directory is not a git repository', async () => {
      const mockExecGitRevParse = vi.fn().mockRejectedValue(new Error('Not a git repository'));

      const result = await isGitRepository('/test/dir', {
        execGitRevParse: mockExecGitRevParse,
      });

      expect(result).toBe(false);
      expect(mockExecGitRevParse).toHaveBeenCalledWith('/test/dir');
    });
  });

  describe('isGitInstalled', () => {
    test('should return true when git is installed', async () => {
      const mockExecGitVersion = vi.fn().mockResolvedValue('git version 2.34.1');

      const result = await isGitInstalled({
        execGitVersion: mockExecGitVersion,
      });

      expect(result).toBe(true);
      expect(mockExecGitVersion).toHaveBeenCalled();
    });

    test('should return false when git command fails', async () => {
      const mockExecGitVersion = vi.fn().mockRejectedValue(new Error('Command not found: git'));

      const result = await isGitInstalled({
        execGitVersion: mockExecGitVersion,
      });

      expect(result).toBe(false);
      expect(mockExecGitVersion).toHaveBeenCalled();
      expect(logger.trace).toHaveBeenCalledWith('Git is not installed:', 'Command not found: git');
    });

    test('should return false when git version output contains error', async () => {
      const mockExecGitVersion = vi.fn().mockResolvedValue('error: git not found');

      const result = await isGitInstalled({
        execGitVersion: mockExecGitVersion,
      });

      expect(result).toBe(false);
      expect(mockExecGitVersion).toHaveBeenCalled();
    });
  });
});
</file>

<file path="tests/core/metrics/calculateAllFileMetrics.test.ts">
import { describe, expect, it, vi } from 'vitest';
import type { ProcessedFile } from '../../../src/core/file/fileTypes.js';
import {
  calculateAllFileMetrics,
  calculateSelectiveFileMetrics,
} from '../../../src/core/metrics/calculateAllFileMetrics.js';
import type { FileMetricsTask } from '../../../src/core/metrics/workers/fileMetricsWorker.js';
import fileMetricsWorker from '../../../src/core/metrics/workers/fileMetricsWorker.js';
import type { RepomixProgressCallback } from '../../../src/shared/types.js';

vi.mock('../../shared/processConcurrency', () => ({
  getProcessConcurrency: () => 1,
}));

const mockInitTaskRunner = (numOfTasks: number) => {
  return async (task: FileMetricsTask) => {
    return await fileMetricsWorker(task);
  };
};

describe('calculateAllFileMetrics', () => {
  it('should calculate metrics for all files', async () => {
    const processedFiles: ProcessedFile[] = [
      { path: 'file1.txt', content: 'a'.repeat(100) },
      { path: 'file2.txt', content: 'b'.repeat(200) },
    ];
    const progressCallback: RepomixProgressCallback = vi.fn();

    const result = await calculateAllFileMetrics(processedFiles, 'o200k_base', progressCallback, {
      initTaskRunner: mockInitTaskRunner,
    });

    expect(result).toEqual([
      { path: 'file1.txt', charCount: 100, tokenCount: 13 },
      { path: 'file2.txt', charCount: 200, tokenCount: 50 },
    ]);
  });

  it('should calculate metrics for selective files only', async () => {
    const processedFiles: ProcessedFile[] = [
      { path: 'file1.txt', content: 'a'.repeat(100) },
      { path: 'file2.txt', content: 'b'.repeat(200) },
      { path: 'file3.txt', content: 'c'.repeat(300) },
    ];
    const targetFilePaths = ['file1.txt', 'file3.txt'];
    const progressCallback: RepomixProgressCallback = vi.fn();

    const result = await calculateSelectiveFileMetrics(
      processedFiles,
      targetFilePaths,
      'o200k_base',
      progressCallback,
      {
        initTaskRunner: mockInitTaskRunner,
      },
    );

    expect(result).toEqual([
      { path: 'file1.txt', charCount: 100, tokenCount: 13 },
      { path: 'file3.txt', charCount: 300, tokenCount: 75 },
    ]);
  });

  it('should return empty array when no target files match', async () => {
    const processedFiles: ProcessedFile[] = [{ path: 'file1.txt', content: 'a'.repeat(100) }];
    const targetFilePaths = ['nonexistent.txt'];
    const progressCallback: RepomixProgressCallback = vi.fn();

    const result = await calculateSelectiveFileMetrics(
      processedFiles,
      targetFilePaths,
      'o200k_base',
      progressCallback,
      {
        initTaskRunner: mockInitTaskRunner,
      },
    );

    expect(result).toEqual([]);
  });
});
</file>

<file path="tests/core/metrics/calculateMetrics.test.ts">
import { type Mock, describe, expect, it, vi } from 'vitest';
import type { ProcessedFile } from '../../../src/core/file/fileTypes.js';
import type { GitDiffResult } from '../../../src/core/git/gitDiffHandle.js';
import { TokenCounter } from '../../../src/core/metrics/TokenCounter.js';
import {
  calculateAllFileMetrics,
  calculateSelectiveFileMetrics,
} from '../../../src/core/metrics/calculateAllFileMetrics.js';
import { calculateMetrics } from '../../../src/core/metrics/calculateMetrics.js';
import type { RepomixProgressCallback } from '../../../src/shared/types.js';
import { createMockConfig } from '../../testing/testUtils.js';

vi.mock('../../../src/core/metrics/TokenCounter.js', () => {
  return {
    TokenCounter: vi.fn().mockImplementation(() => ({
      countTokens: vi.fn().mockReturnValue(10),
      free: vi.fn(),
    })),
  };
});
vi.mock('../../../src/core/metrics/aggregateMetrics.js');
vi.mock('../../../src/core/metrics/calculateAllFileMetrics.js', () => ({
  calculateAllFileMetrics: vi.fn(),
  calculateSelectiveFileMetrics: vi.fn(),
}));

describe('calculateMetrics', () => {
  it('should calculate metrics and return the result', async () => {
    const processedFiles: ProcessedFile[] = [
      { path: 'file1.txt', content: 'a'.repeat(100) },
      { path: 'file2.txt', content: 'b'.repeat(200) },
    ];
    const output = 'a'.repeat(300);
    const progressCallback: RepomixProgressCallback = vi.fn();

    const fileMetrics = [
      { path: 'file1.txt', charCount: 100, tokenCount: 10 },
      { path: 'file2.txt', charCount: 200, tokenCount: 20 },
    ];
    (calculateSelectiveFileMetrics as unknown as Mock).mockResolvedValue(fileMetrics);

    const aggregatedResult = {
      totalFiles: 2,
      totalCharacters: 300,
      totalTokens: 30,
      fileCharCounts: {
        'file1.txt': 100,
        'file2.txt': 200,
      },
      fileTokenCounts: {
        'file1.txt': 10,
        'file2.txt': 20,
      },
      gitDiffTokenCount: 0,
    };

    const config = createMockConfig();

    const gitDiffResult: GitDiffResult | undefined = undefined;

    const result = await calculateMetrics(processedFiles, output, progressCallback, config, gitDiffResult, {
      calculateAllFileMetrics,
      calculateSelectiveFileMetrics,
      calculateOutputMetrics: () => Promise.resolve(30),
    });

    expect(progressCallback).toHaveBeenCalledWith('Calculating metrics...');
    expect(calculateSelectiveFileMetrics).toHaveBeenCalledWith(
      processedFiles,
      ['file2.txt', 'file1.txt'], // sorted by character count desc
      'o200k_base',
      progressCallback,
    );
    expect(result).toEqual(aggregatedResult);
  });
});
</file>

<file path="tests/core/metrics/calculateOutputMetrics.test.ts">
import { describe, expect, it, vi } from 'vitest';
import { calculateOutputMetrics } from '../../../src/core/metrics/calculateOutputMetrics.js';
import type { OutputMetricsTask } from '../../../src/core/metrics/workers/outputMetricsWorker.js';
import outputMetricsWorker from '../../../src/core/metrics/workers/outputMetricsWorker.js';
import { logger } from '../../../src/shared/logger.js';

vi.mock('../../../src/shared/logger');

const mockInitTaskRunner = () => {
  return async (task: OutputMetricsTask) => {
    return await outputMetricsWorker(task);
  };
};

describe('calculateOutputMetrics', () => {
  it('should calculate metrics for output content', async () => {
    const content = 'test content';
    const encoding = 'o200k_base';
    const path = 'test.txt';

    const result = await calculateOutputMetrics(content, encoding, path, {
      initTaskRunner: mockInitTaskRunner,
    });

    expect(result).toBe(2); // 'test content' should be counted as 2 tokens
  });

  it('should work without a specified path', async () => {
    const content = 'test content';
    const encoding = 'o200k_base';

    const result = await calculateOutputMetrics(content, encoding, undefined, {
      initTaskRunner: mockInitTaskRunner,
    });

    expect(result).toBe(2);
  });

  it('should handle errors from worker', async () => {
    const content = 'test content';
    const encoding = 'o200k_base';
    const mockError = new Error('Worker error');

    const mockErrorTaskRunner = () => {
      return async () => {
        throw mockError;
      };
    };

    await expect(
      calculateOutputMetrics(content, encoding, undefined, {
        initTaskRunner: mockErrorTaskRunner,
      }),
    ).rejects.toThrow('Worker error');

    expect(logger.error).toHaveBeenCalledWith('Error during token count:', mockError);
  });

  it('should handle empty content', async () => {
    const content = '';
    const encoding = 'o200k_base';

    const result = await calculateOutputMetrics(content, encoding, undefined, {
      initTaskRunner: mockInitTaskRunner,
    });

    expect(result).toBe(0);
  });

  it('should work with longer complex content', async () => {
    const content = 'This is a longer test content with multiple sentences. It should work correctly.';
    const encoding = 'o200k_base';

    const result = await calculateOutputMetrics(content, encoding, undefined, {
      initTaskRunner: mockInitTaskRunner,
    });

    expect(result).toBeGreaterThan(0);
    expect(typeof result).toBe('number');
  });

  it('should process large content in parallel', async () => {
    // Generate a large content that exceeds MIN_CONTENT_LENGTH_FOR_PARALLEL
    const content = 'a'.repeat(1_100_000); // 1.1MB of content
    const encoding = 'o200k_base';
    const path = 'large-file.txt';

    let chunksProcessed = 0;
    const mockParallelTaskRunner = () => {
      return async (task: OutputMetricsTask) => {
        chunksProcessed++;
        // Return a fixed token count for each chunk
        return 100;
      };
    };

    const result = await calculateOutputMetrics(content, encoding, path, {
      initTaskRunner: mockParallelTaskRunner,
    });

    expect(chunksProcessed).toBeGreaterThan(1); // Should have processed multiple chunks
    expect(result).toBe(100_000); // 1000 chunks * 100 tokens per chunk
  });

  it('should handle errors in parallel processing', async () => {
    const content = 'a'.repeat(1_100_000); // 1.1MB of content
    const encoding = 'o200k_base';
    const mockError = new Error('Parallel processing error');

    const mockErrorTaskRunner = () => {
      return async () => {
        throw mockError;
      };
    };

    await expect(
      calculateOutputMetrics(content, encoding, undefined, {
        initTaskRunner: mockErrorTaskRunner,
      }),
    ).rejects.toThrow('Parallel processing error');

    expect(logger.error).toHaveBeenCalledWith('Error during token count:', mockError);
  });

  it('should correctly split content into chunks for parallel processing', async () => {
    const content = 'a'.repeat(1_100_000); // 1.1MB of content
    const encoding = 'o200k_base';
    const processedChunks: string[] = [];

    const mockChunkTrackingTaskRunner = () => {
      return async (task: OutputMetricsTask) => {
        processedChunks.push(task.content);
        return task.content.length;
      };
    };

    await calculateOutputMetrics(content, encoding, undefined, {
      initTaskRunner: mockChunkTrackingTaskRunner,
    });

    // Check that chunks are roughly equal in size
    const expectedChunkSize = Math.ceil(content.length / 1000); // CHUNK_SIZE is 1000
    const chunkSizes = processedChunks.map((chunk) => chunk.length);

    expect(processedChunks.length).toBe(1000); // Should have 1000 chunks
    expect(Math.max(...chunkSizes) - Math.min(...chunkSizes)).toBeLessThanOrEqual(1); // Chunks should be almost equal in size
    expect(processedChunks.join('')).toBe(content); // All content should be processed
  });
});
</file>

<file path="tests/core/metrics/diffTokenCount.test.ts">
import { beforeEach, describe, expect, test, vi } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import type { ProcessedFile } from '../../../src/core/file/fileTypes.js';
import { TokenCounter } from '../../../src/core/metrics/TokenCounter.js';
import { calculateMetrics } from '../../../src/core/metrics/calculateMetrics.js';

// Mock the TokenCounter
vi.mock('../../../src/core/metrics/TokenCounter.js', () => ({
  TokenCounter: vi.fn(),
}));

describe('Diff Token Count Calculation', () => {
  beforeEach(() => {
    vi.resetAllMocks();

    // Setup TokenCounter mock
    vi.mocked(TokenCounter).mockReturnValue({
      countTokens: vi.fn((content) => {
        // Simple token counting for testing
        return content.split(/\s+/).length;
      }),
      free: vi.fn(),
      encoding: {
        encode: vi.fn(),
        free: vi.fn(),
      },
    } as unknown as TokenCounter);
  });

  test('should calculate diff token count when diffs are included', async () => {
    // Sample diffs
    const sampleDiff = `diff --git a/file1.js b/file1.js
index 123..456 100644
--- a/file1.js
+++ b/file1.js
@@ -1,5 +1,5 @@
-old line of code
+new line of code
`;

    // Sample processed files
    const processedFiles: ProcessedFile[] = [
      {
        path: 'test.js',
        content: 'console.log("test");',
      },
    ];

    // Sample output
    const output = 'Generated output with sample content';

    // Sample config with diffs enabled
    const config: RepomixConfigMerged = {
      cwd: '/test',
      input: { maxFileSize: 1000000 },
      output: {
        filePath: 'output.txt',
        style: 'plain',
        parsableStyle: false,
        fileSummary: true,
        directoryStructure: true,
        files: true,
        removeComments: false,
        removeEmptyLines: false,
        compress: false,
        topFilesLength: 5,
        showLineNumbers: false,
        copyToClipboard: false,
        git: {
          sortByChanges: true,
          sortByChangesMaxCommits: 100,
          includeDiffs: true,
        },
      },
      include: [],
      ignore: {
        useGitignore: true,
        useDefaultPatterns: true,
        customPatterns: [],
      },
      security: {
        enableSecurityCheck: true,
      },
      tokenCount: {
        encoding: 'o200k_base',
      },
    };

    // Mock dependency functions
    const mockCalculateAllFileMetrics = vi.fn().mockResolvedValue([
      {
        path: 'test.js',
        charCount: 20,
        tokenCount: 5,
      },
    ]);

    const mockCalculateOutputMetrics = vi.fn().mockResolvedValue(15);

    const result = await calculateMetrics(
      processedFiles,
      output,
      vi.fn(), // Progress callback
      config,
      {
        workTreeDiffContent: sampleDiff,
        stagedDiffContent: '',
      },
      {
        calculateAllFileMetrics: mockCalculateAllFileMetrics,
        calculateSelectiveFileMetrics: vi.fn().mockResolvedValue([]),
        calculateOutputMetrics: mockCalculateOutputMetrics,
      },
    );

    // Check TokenCounter was instantiated with the correct encoding
    expect(TokenCounter).toHaveBeenCalledWith('o200k_base');

    // Check token counting was called with the diff content
    expect(result).toHaveProperty('gitDiffTokenCount');

    // Our mock counts words as tokens - the sample diff should have multiple tokens
    expect(result.gitDiffTokenCount).toBeGreaterThan(0);
  });

  test('should not calculate diff token count when diffs are disabled', async () => {
    // Sample processed files
    const processedFiles: ProcessedFile[] = [
      {
        path: 'test.js',
        content: 'console.log("test");',
      },
    ];

    // Sample output
    const output = 'Generated output without diffs';

    // Sample config with diffs disabled
    const config: RepomixConfigMerged = {
      cwd: '/test',
      input: { maxFileSize: 1000000 },
      output: {
        filePath: 'output.txt',
        style: 'plain',
        parsableStyle: false,
        fileSummary: true,
        directoryStructure: true,
        files: true,
        removeComments: false,
        removeEmptyLines: false,
        compress: false,
        topFilesLength: 5,
        showLineNumbers: false,
        copyToClipboard: false,
        git: {
          sortByChanges: true,
          sortByChangesMaxCommits: 100,
          includeDiffs: false,
        },
      },
      include: [],
      ignore: {
        useGitignore: true,
        useDefaultPatterns: true,
        customPatterns: [],
      },
      security: {
        enableSecurityCheck: true,
      },
      tokenCount: {
        encoding: 'o200k_base',
      },
    };

    // Mock dependency functions
    const mockCalculateAllFileMetrics = vi.fn().mockResolvedValue([
      {
        path: 'test.js',
        charCount: 20,
        tokenCount: 5,
      },
    ]);

    const mockCalculateOutputMetrics = vi.fn().mockResolvedValue(15);

    const result = await calculateMetrics(
      processedFiles,
      output,
      vi.fn(), // Progress callback
      config,
      undefined, // No diff content
      {
        calculateAllFileMetrics: mockCalculateAllFileMetrics,
        calculateSelectiveFileMetrics: vi.fn().mockResolvedValue([]),
        calculateOutputMetrics: mockCalculateOutputMetrics,
      },
    );

    // TokenCounter should not be called for diff content
    expect(result.gitDiffTokenCount).toBe(0);
  });

  test('should handle undefined diffContent gracefully', async () => {
    // Sample processed files
    const processedFiles: ProcessedFile[] = [
      {
        path: 'test.js',
        content: 'console.log("test");',
      },
    ];

    // Sample output
    const output = 'Generated output with diffs enabled but no content';

    // Sample config with diffs enabled but no content
    const config: RepomixConfigMerged = {
      cwd: '/test',
      input: { maxFileSize: 1000000 },
      output: {
        filePath: 'output.txt',
        style: 'plain',
        parsableStyle: false,
        fileSummary: true,
        directoryStructure: true,
        files: true,
        removeComments: false,
        removeEmptyLines: false,
        compress: false,
        topFilesLength: 5,
        showLineNumbers: false,
        copyToClipboard: false,
        git: {
          sortByChanges: true,
          sortByChangesMaxCommits: 100,
          includeDiffs: true,
          // No diffContent property
        },
      },
      include: [],
      ignore: {
        useGitignore: true,
        useDefaultPatterns: true,
        customPatterns: [],
      },
      security: {
        enableSecurityCheck: true,
      },
      tokenCount: {
        encoding: 'o200k_base',
      },
    };

    // Mock dependency functions
    const mockCalculateAllFileMetrics = vi.fn().mockResolvedValue([
      {
        path: 'test.js',
        charCount: 20,
        tokenCount: 5,
      },
    ]);

    const mockCalculateOutputMetrics = vi.fn().mockResolvedValue(15);

    const result = await calculateMetrics(
      processedFiles,
      output,
      vi.fn(), // Progress callback
      config,
      undefined, // No diff content
      {
        calculateAllFileMetrics: mockCalculateAllFileMetrics,
        calculateSelectiveFileMetrics: vi.fn().mockResolvedValue([]),
        calculateOutputMetrics: mockCalculateOutputMetrics,
      },
    );

    // gitDiffTokenCount should not be set
    expect(result.gitDiffTokenCount).toBe(0);
  });
});
</file>

<file path="tests/core/metrics/TokenCounter.test.ts">
import { type Tiktoken, get_encoding } from 'tiktoken';
import { type Mock, afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
import { TokenCounter } from '../../../src/core/metrics/TokenCounter.js';
import { logger } from '../../../src/shared/logger.js';

vi.mock('tiktoken', () => ({
  get_encoding: vi.fn(),
}));

vi.mock('../../../src/shared/logger');

describe('TokenCounter', () => {
  let tokenCounter: TokenCounter;
  let mockEncoder: {
    encode: Mock;
    free: Mock;
  };

  beforeEach(() => {
    // Initialize mock encoder
    mockEncoder = {
      encode: vi.fn(),
      free: vi.fn(),
    };

    // Setup mock encoder behavior
    vi.mocked(get_encoding).mockReturnValue(mockEncoder as unknown as Tiktoken);

    // Create new TokenCounter instance
    tokenCounter = new TokenCounter('o200k_base');
  });

  afterEach(() => {
    tokenCounter.free();
    vi.resetAllMocks();
  });

  test('should initialize with o200k_base encoding', () => {
    expect(get_encoding).toHaveBeenCalledWith('o200k_base');
  });

  test('should correctly count tokens for simple text', () => {
    const text = 'Hello, world!';
    const mockTokens = [123, 456, 789]; // Example token IDs
    mockEncoder.encode.mockReturnValue(mockTokens);

    const count = tokenCounter.countTokens(text);

    expect(count).toBe(3); // Length of mockTokens
    expect(mockEncoder.encode).toHaveBeenCalledWith(text);
  });

  test('should handle empty string', () => {
    mockEncoder.encode.mockReturnValue([]);

    const count = tokenCounter.countTokens('');

    expect(count).toBe(0);
    expect(mockEncoder.encode).toHaveBeenCalledWith('');
  });

  test('should handle multi-line text', () => {
    const text = 'Line 1\nLine 2\nLine 3';
    const mockTokens = [1, 2, 3, 4, 5, 6];
    mockEncoder.encode.mockReturnValue(mockTokens);

    const count = tokenCounter.countTokens(text);

    expect(count).toBe(6);
    expect(mockEncoder.encode).toHaveBeenCalledWith(text);
  });

  test('should handle special characters', () => {
    const text = '!@#$%^&*()_+';
    const mockTokens = [1, 2, 3];
    mockEncoder.encode.mockReturnValue(mockTokens);

    const count = tokenCounter.countTokens(text);

    expect(count).toBe(3);
    expect(mockEncoder.encode).toHaveBeenCalledWith(text);
  });

  test('should handle unicode characters', () => {
    const text = '你好，世界！🌍';
    const mockTokens = [1, 2, 3, 4];
    mockEncoder.encode.mockReturnValue(mockTokens);

    const count = tokenCounter.countTokens(text);

    expect(count).toBe(4);
    expect(mockEncoder.encode).toHaveBeenCalledWith(text);
  });

  test('should handle code snippets', () => {
    const text = `
      function hello() {
        console.log("Hello, world!");
      }
    `;
    const mockTokens = Array(10).fill(1); // 10 tokens
    mockEncoder.encode.mockReturnValue(mockTokens);

    const count = tokenCounter.countTokens(text);

    expect(count).toBe(10);
    expect(mockEncoder.encode).toHaveBeenCalledWith(text);
  });

  test('should handle markdown text', () => {
    const text = `
      # Heading
      ## Subheading
      * List item 1
      * List item 2

      **Bold text** and _italic text_
    `;
    const mockTokens = Array(15).fill(1); // 15 tokens
    mockEncoder.encode.mockReturnValue(mockTokens);

    const count = tokenCounter.countTokens(text);

    expect(count).toBe(15);
    expect(mockEncoder.encode).toHaveBeenCalledWith(text);
  });

  test('should handle very long text', () => {
    const text = 'a'.repeat(10000);
    const mockTokens = Array(100).fill(1); // 100 tokens
    mockEncoder.encode.mockReturnValue(mockTokens);

    const count = tokenCounter.countTokens(text);

    expect(count).toBe(100);
    expect(mockEncoder.encode).toHaveBeenCalledWith(text);
  });

  test('should properly handle encoding errors without file path', () => {
    const error = new Error('Encoding error');
    mockEncoder.encode.mockImplementation(() => {
      throw error;
    });

    const count = tokenCounter.countTokens('test content');

    expect(count).toBe(0);
    expect(logger.warn).toHaveBeenCalledWith('Failed to count tokens. error: Encoding error');
  });

  test('should properly handle encoding errors with file path', () => {
    const error = new Error('Encoding error');
    mockEncoder.encode.mockImplementation(() => {
      throw error;
    });

    const count = tokenCounter.countTokens('test content', 'test.txt');

    expect(count).toBe(0);
    expect(logger.warn).toHaveBeenCalledWith('Failed to count tokens. path: test.txt, error: Encoding error');
  });

  test('should free encoder resources on cleanup', () => {
    tokenCounter.free();
    expect(mockEncoder.free).toHaveBeenCalled();
  });
});
</file>

<file path="tests/core/output/outputStyles/markdownStyle.test.ts">
import Handlebars from 'handlebars';
import { describe, expect, test } from 'vitest';
import { generateOutput } from '../../../../src/core/output/outputGenerate.js';
import { getMarkdownTemplate } from '../../../../src/core/output/outputStyles/markdownStyle.js';
import { createMockConfig } from '../../../testing/testUtils.js';

describe('markdownStyle', () => {
  describe('getMarkdownTemplate', () => {
    test('should return valid markdown template', () => {
      const template = getMarkdownTemplate();
      expect(template).toContain('# File Summary');
      expect(template).toContain('# Directory Structure');
      expect(template).toContain('# Files');
      expect(template).toContain('{{#if instruction}}');
      expect(template).toContain('# Instruction');
    });

    test('should correctly render template with basic data', () => {
      const template = getMarkdownTemplate();
      const compiledTemplate = Handlebars.compile(template);
      const data = {
        generationHeader: 'Generated Test Header',
        summaryPurpose: 'Test Purpose',
        summaryFileFormat: 'Test Format',
        summaryUsageGuidelines: 'Test Guidelines',
        summaryNotes: 'Test Notes',
        treeString: 'src/\n  index.ts',
        processedFiles: [
          {
            path: 'src/index.ts',
            content: 'console.log("Hello");',
          },
        ],
        fileSummaryEnabled: true,
        directoryStructureEnabled: true,
        filesEnabled: true,
        markdownCodeBlockDelimiter: '```',
      };

      const result = compiledTemplate(data);

      expect(result).toContain('Generated Test Header');
      expect(result).toContain('Test Purpose');
      expect(result).toContain('Test Format');
      expect(result).toContain('Test Guidelines');
      expect(result).toContain('Test Notes');
      expect(result).toContain('src/\n  index.ts');
      expect(result).toContain('## File: src/index.ts');
      expect(result).toContain('console.log("Hello");');
    });

    test('should render optional header text when provided', () => {
      const template = getMarkdownTemplate();
      const compiledTemplate = Handlebars.compile(template);
      const data = {
        headerText: 'Custom Header Text',
        processedFiles: [],
        fileSummaryEnabled: true,
        directoryStructureEnabled: true,
      };

      const result = compiledTemplate(data);

      expect(result).toContain('# User Provided Header');
      expect(result).toContain('Custom Header Text');
    });

    test('should not render header section when headerText is not provided', () => {
      const template = getMarkdownTemplate();
      const compiledTemplate = Handlebars.compile(template);
      const data = {
        processedFiles: [],
        fileSummaryEnabled: true,
        directoryStructureEnabled: true,
      };

      const result = compiledTemplate(data);

      expect(result).not.toContain('# User Provided Header');
    });

    test('should render instruction section when provided', () => {
      const template = getMarkdownTemplate();
      const compiledTemplate = Handlebars.compile(template);
      const data = {
        instruction: 'Custom Instruction Text',
        processedFiles: [],
        fileSummaryEnabled: true,
        directoryStructureEnabled: true,
      };

      const result = compiledTemplate(data);

      expect(result).toContain('# Instruction');
      expect(result).toContain('Custom Instruction Text');
    });

    test('should display headerText if specified even if fileSummary is disabled', () => {
      const template = getMarkdownTemplate();
      const compiledTemplate = Handlebars.compile(template);
      const data = {
        headerText: 'MARKDOWN HEADER',
        fileSummaryEnabled: false,
        directoryStructureEnabled: true,
        processedFiles: [],
      };
      const result = compiledTemplate(data);
      expect(result).not.toContain('This file is a merged representation');
      expect(result).toContain('MARKDOWN HEADER');
    });

    test('should not display generationHeader if fileSummary is disabled', () => {
      const template = getMarkdownTemplate();
      const compiledTemplate = Handlebars.compile(template);
      const data = {
        generationHeader: 'Generated Test Header',
        fileSummaryEnabled: false,
        directoryStructureEnabled: true,
        processedFiles: [],
      };
      const result = compiledTemplate(data);
      expect(result).not.toContain('This file is a merged representation');
      expect(result).not.toContain('Generated Test Header');
      expect(result).toContain('# Directory Structure');
    });
  });

  describe('getFileExtension helper', () => {
    // Helper to get extension mapping result
    const getExtension = (filePath: string): string => {
      const helper = Handlebars.helpers.getFileExtension as Handlebars.HelperDelegate;
      return helper(filePath) as string;
    };

    // JavaScript variants
    test('should handle JavaScript related extensions', () => {
      expect(getExtension('file.js')).toBe('javascript');
      expect(getExtension('file.jsx')).toBe('javascript');
      expect(getExtension('file.ts')).toBe('typescript');
      expect(getExtension('file.tsx')).toBe('typescript');
    });

    // Web technologies
    test('should handle web technology extensions', () => {
      expect(getExtension('file.html')).toBe('html');
      expect(getExtension('file.css')).toBe('css');
      expect(getExtension('file.scss')).toBe('scss');
      expect(getExtension('file.sass')).toBe('scss');
      expect(getExtension('file.vue')).toBe('vue');
    });

    // Backend languages
    test('should handle backend language extensions', () => {
      expect(getExtension('file.py')).toBe('python');
      expect(getExtension('file.rb')).toBe('ruby');
      expect(getExtension('file.php')).toBe('php');
      expect(getExtension('file.java')).toBe('java');
      expect(getExtension('file.go')).toBe('go');
    });

    // System programming languages
    test('should handle system programming language extensions', () => {
      expect(getExtension('file.c')).toBe('cpp');
      expect(getExtension('file.cpp')).toBe('cpp');
      expect(getExtension('file.rs')).toBe('rust');
      expect(getExtension('file.swift')).toBe('swift');
      expect(getExtension('file.kt')).toBe('kotlin');
    });

    // Configuration and data format files
    test('should handle configuration and data format extensions', () => {
      expect(getExtension('file.json')).toBe('json');
      expect(getExtension('file.json5')).toBe('json5');
      expect(getExtension('file.xml')).toBe('xml');
      expect(getExtension('file.yaml')).toBe('yaml');
      expect(getExtension('file.yml')).toBe('yaml');
      expect(getExtension('file.toml')).toBe('toml');
    });

    // Shell and scripting
    test('should handle shell and scripting extensions', () => {
      expect(getExtension('file.sh')).toBe('bash');
      expect(getExtension('file.bash')).toBe('bash');
      expect(getExtension('file.ps1')).toBe('powershell');
    });

    // Database and query languages
    test('should handle database related extensions', () => {
      expect(getExtension('file.sql')).toBe('sql');
      expect(getExtension('file.graphql')).toBe('graphql');
      expect(getExtension('file.gql')).toBe('graphql');
    });

    // Functional programming languages
    test('should handle functional programming language extensions', () => {
      expect(getExtension('file.fs')).toBe('fsharp');
      expect(getExtension('file.fsx')).toBe('fsharp');
      expect(getExtension('file.hs')).toBe('haskell');
      expect(getExtension('file.clj')).toBe('clojure');
      expect(getExtension('file.cljs')).toBe('clojure');
    });

    // Other languages and tools
    test('should handle other programming language extensions', () => {
      expect(getExtension('file.scala')).toBe('scala');
      expect(getExtension('file.dart')).toBe('dart');
      expect(getExtension('file.ex')).toBe('elixir');
      expect(getExtension('file.exs')).toBe('elixir');
      expect(getExtension('file.erl')).toBe('erlang');
      expect(getExtension('file.coffee')).toBe('coffeescript');
    });

    // Infrastructure and templating
    test('should handle infrastructure and templating extensions', () => {
      expect(getExtension('file.tf')).toBe('hcl');
      expect(getExtension('file.tfvars')).toBe('hcl');
      expect(getExtension('file.dockerfile')).toBe('dockerfile');
      expect(getExtension('file.pug')).toBe('pug');
      expect(getExtension('file.proto')).toBe('protobuf');
    });

    // Miscellaneous
    test('should handle miscellaneous file extensions', () => {
      expect(getExtension('file.md')).toBe('markdown');
      expect(getExtension('file.r')).toBe('r');
      expect(getExtension('file.pl')).toBe('perl');
      expect(getExtension('file.pm')).toBe('perl');
      expect(getExtension('file.lua')).toBe('lua');
      expect(getExtension('file.groovy')).toBe('groovy');
      expect(getExtension('file.vb')).toBe('vb');
    });

    // Edge cases
    test('should handle edge cases', () => {
      expect(getExtension('file')).toBe(''); // No extension
      expect(getExtension('.gitignore')).toBe(''); // Dotfile
      expect(getExtension('file.unknown')).toBe(''); // Unknown extension
      expect(getExtension('path/to/file.js')).toBe('javascript'); // Path with directory
    });
  });
});
</file>

<file path="tests/core/output/outputStyles/plainStyle.test.ts">
import process from 'node:process';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { generateOutput } from '../../../../src/core/output/outputGenerate.js';
import { createMockConfig } from '../../../testing/testUtils.js';

vi.mock('fs/promises');

describe('plainStyle', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  test('generateOutput for plain should include user-provided header text', async () => {
    const mockConfig = createMockConfig({
      output: {
        filePath: 'output.txt',
        style: 'plain',
        headerText: 'Custom header text',
        topFilesLength: 2,
        showLineNumbers: false,
        removeComments: false,
        removeEmptyLines: false,
      },
    });

    const output = await generateOutput([process.cwd()], mockConfig, [], []);

    expect(output).toContain('File Summary');
    expect(output).toContain('Directory Structure');
    expect(output).toContain('Custom header text');
    expect(output).toContain('Files');
  });

  test('plain style: headerText always present, generationHeader only if fileSummaryEnabled', async () => {
    const mockConfig = createMockConfig({
      output: {
        filePath: 'output.txt',
        style: 'plain',
        fileSummary: false,
        headerText: 'PLAIN HEADER',
      },
    });
    const output = await generateOutput([process.cwd()], mockConfig, [], []);
    expect(output).not.toContain('This file is a merged representation');
    expect(output).toContain('PLAIN HEADER');
  });
});
</file>

<file path="tests/core/output/outputStyles/xmlStyle.test.ts">
import process from 'node:process';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { generateOutput } from '../../../../src/core/output/outputGenerate.js';
import { createMockConfig } from '../../../testing/testUtils.js';

vi.mock('fs/promises');

describe('xmlStyle', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  test('generateOutput for xml should include user-provided header text', async () => {
    const mockConfig = createMockConfig({
      output: {
        filePath: 'output.txt',
        style: 'xml',
        headerText: 'Custom header text',
        topFilesLength: 2,
        showLineNumbers: false,
        removeComments: false,
        removeEmptyLines: false,
      },
    });

    const output = await generateOutput([process.cwd()], mockConfig, [], []);

    expect(output).toContain('file_summary');
    expect(output).toContain('directory_structure');
    expect(output).toContain('Custom header text');
    expect(output).toContain('files');
  });

  test('xml style: headerText always present, generationHeader only if fileSummaryEnabled', async () => {
    const mockConfig = createMockConfig({
      output: {
        filePath: 'output.xml',
        style: 'xml',
        fileSummary: false,
        headerText: 'XML HEADER',
        parsableStyle: false,
      },
    });
    const output = await generateOutput([process.cwd()], mockConfig, [], []);
    expect(output).not.toContain('This file is a merged representation');
    expect(output).toContain('XML HEADER');
  });
});
</file>

<file path="tests/core/output/diffsInOutput.test.ts">
import { beforeEach, describe, expect, test, vi } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import type { ProcessedFile } from '../../../src/core/file/fileTypes.js';
import type { GitDiffResult } from '../../../src/core/git/gitDiffHandle.js';
import * as gitDiffModule from '../../../src/core/git/gitDiffHandle.js';
import * as gitRepositoryModule from '../../../src/core/git/gitRepositoryHandle.js';
import { buildOutputGeneratorContext, generateOutput } from '../../../src/core/output/outputGenerate.js';
import type { RenderContext } from '../../../src/core/output/outputGeneratorTypes.js';
import { createMockConfig } from '../../testing/testUtils.js';

// Mock the git modules
vi.mock('../../../src/core/git/gitDiffHandle.js', () => ({
  getWorkTreeDiff: vi.fn(),
}));

vi.mock('../../../src/core/git/gitRepositoryHandle.js', () => ({
  isGitRepository: vi.fn(),
}));

describe('Git Diffs in Output', () => {
  const sampleDiff = `diff --git a/file1.js b/file1.js
index 123..456 100644
--- a/file1.js
+++ b/file1.js
@@ -1,5 +1,5 @@
-old line
+new line`;

  let mockConfig: RepomixConfigMerged;

  beforeEach(() => {
    vi.resetAllMocks();

    // Mock the git command
    vi.mocked(gitDiffModule.getWorkTreeDiff).mockResolvedValue(sampleDiff);
    vi.mocked(gitRepositoryModule.isGitRepository).mockResolvedValue(true);

    // Sample minimal config using createMockConfig utility
    mockConfig = createMockConfig({
      cwd: '/test/repo',
      input: {
        maxFileSize: 1000000,
      },
      output: {
        filePath: 'output.txt',
        style: 'plain',
        git: {
          includeDiffs: false,
        },
      },
    });
  });

  test('buildOutputGeneratorContext should include diffs when enabled', async () => {
    // Enable diffs
    if (mockConfig.output.git) {
      mockConfig.output.git.includeDiffs = true;
    }

    const rootDirs = ['/test/repo'];
    const allFilePaths = ['file1.js', 'file2.js'];
    const processedFiles: ProcessedFile[] = [
      {
        path: 'file1.js',
        content: 'console.log("file1");',
      },
      {
        path: 'file2.js',
        content: 'console.log("file2");',
      },
    ];

    const sampleDiff = 'diff --git a/file1.js b/file1.js';

    const context = await buildOutputGeneratorContext(rootDirs, mockConfig, allFilePaths, processedFiles, {
      workTreeDiffContent: sampleDiff,
      stagedDiffContent: '',
    });

    // Context should include gitDiffs
    expect(context.gitDiffResult?.workTreeDiffContent).toBe(sampleDiff);
  });

  test('generateOutput should include diffs in XML output via object', async () => {
    // Enable diffs
    mockConfig.output.style = 'xml';
    if (mockConfig.output.git) {
      mockConfig.output.git.includeDiffs = true;
    }

    const rootDirs = ['/test/repo'];
    const processedFiles: ProcessedFile[] = [
      {
        path: 'file1.js',
        content: 'console.log("file1");',
      },
    ];

    // Create a modified generateOutput with mocked deps
    const mockBuildOutputGeneratorContext = vi.fn().mockImplementation(async () => {
      return {
        generationDate: '2025-05-06T00:00:00.000Z',
        treeString: '.\n└── file1.js',
        processedFiles,
        config: mockConfig,
        instruction: '',
        gitDiffs: sampleDiff,
      };
    });

    const mockGenerateHandlebarOutput = vi.fn().mockResolvedValue('<xml>output with diffs</xml>');
    const mockGenerateParsableXmlOutput = vi.fn().mockImplementation(async (renderContext: RenderContext) => {
      // Check that renderContext has gitDiffs
      expect(renderContext.gitDiffWorkTree).toBe(sampleDiff);
      return '<xml>parsable output with diffs object</xml>';
    });

    const mockSortOutputFiles = vi.fn().mockImplementation((files) => Promise.resolve(files));

    const gitDiffResult: GitDiffResult = {
      workTreeDiffContent: sampleDiff,
      stagedDiffContent: '',
    };

    // Call generateOutput with mocked deps
    const output = await generateOutput(rootDirs, mockConfig, processedFiles, ['file1.js'], gitDiffResult, {
      buildOutputGeneratorContext: mockBuildOutputGeneratorContext,
      generateHandlebarOutput: mockGenerateHandlebarOutput,
      generateParsableXmlOutput: mockGenerateParsableXmlOutput,
      sortOutputFiles: mockSortOutputFiles,
    });

    // Check that the output was generated with the correct template
    expect(mockBuildOutputGeneratorContext).toHaveBeenCalled();

    // For non-parsable XML, should use Handlebars
    if (!mockConfig.output.parsableStyle) {
      expect(mockGenerateHandlebarOutput).toHaveBeenCalled();
    } else {
      // For parsable XML, should use XML generator
      expect(mockGenerateParsableXmlOutput).toHaveBeenCalled();
    }
  });

  test('generateOutput should include diffs in Markdown output', async () => {
    // Enable diffs with markdown style
    mockConfig.output.style = 'markdown';
    if (mockConfig.output.git) {
      mockConfig.output.git.includeDiffs = true;
    }

    const rootDirs = ['/test/repo'];
    const processedFiles: ProcessedFile[] = [
      {
        path: 'file1.js',
        content: 'console.log("file1");',
      },
    ];

    // Create a modified generateOutput with mocked deps
    const mockBuildOutputGeneratorContext = vi.fn().mockImplementation(async () => {
      return {
        generationDate: '2025-05-06T00:00:00.000Z',
        treeString: '.\n└── file1.js',
        processedFiles,
        config: mockConfig,
        instruction: '',
        gitDiffResult: {
          workTreeDiffContent: sampleDiff,
          stagedDiffContent: '',
        },
      };
    });

    const mockGenerateHandlebarOutput = vi.fn().mockImplementation(async (config, renderContext: RenderContext) => {
      // Check that renderContext has gitDiffs for markdown template
      expect(renderContext.gitDiffWorkTree).toBe(sampleDiff);
      return `# Markdown output with diffs\n\`\`\`diff\n${sampleDiff}\n\`\`\``;
    });

    const mockGenerateParsableXmlOutput = vi.fn();
    const mockSortOutputFiles = vi.fn().mockImplementation((files) => Promise.resolve(files));
    const gitDiffResult: GitDiffResult = {
      workTreeDiffContent: sampleDiff,
      stagedDiffContent: '',
    };

    // Call generateOutput with mocked deps
    const output = await generateOutput(rootDirs, mockConfig, processedFiles, ['file1.js'], gitDiffResult, {
      buildOutputGeneratorContext: mockBuildOutputGeneratorContext,
      generateHandlebarOutput: mockGenerateHandlebarOutput,
      generateParsableXmlOutput: mockGenerateParsableXmlOutput,
      sortOutputFiles: mockSortOutputFiles,
    });

    // For markdown output, should use Handlebars
    expect(mockGenerateHandlebarOutput).toHaveBeenCalled();

    // XML generator should not be called for markdown
    expect(mockGenerateParsableXmlOutput).not.toHaveBeenCalled();
  });
});
</file>

<file path="tests/core/output/outputGenerate.test.ts">
import process from 'node:process';
import { XMLParser } from 'fast-xml-parser';
import { describe, expect, test, vi } from 'vitest';
import type { ProcessedFile } from '../../../src/core/file/fileTypes.js';
import { generateOutput } from '../../../src/core/output/outputGenerate.js';
import { createMockConfig } from '../../testing/testUtils.js';

describe('outputGenerate', () => {
  const mockDeps = {
    buildOutputGeneratorContext: vi.fn(),
    generateHandlebarOutput: vi.fn(),
    generateParsableXmlOutput: vi.fn(),
    sortOutputFiles: vi.fn(),
  };
  test('generateOutput should use sortOutputFiles before generating content', async () => {
    const mockConfig = createMockConfig({
      output: {
        filePath: 'output.txt',
        style: 'plain',
        git: { sortByChanges: true },
      },
    });
    const mockProcessedFiles: ProcessedFile[] = [
      { path: 'file1.txt', content: 'content1' },
      { path: 'file2.txt', content: 'content2' },
    ];
    const sortedFiles = [
      { path: 'file2.txt', content: 'content2' },
      { path: 'file1.txt', content: 'content1' },
    ];

    mockDeps.sortOutputFiles.mockResolvedValue(sortedFiles);
    mockDeps.buildOutputGeneratorContext.mockResolvedValue({
      processedFiles: sortedFiles,
      config: mockConfig,
      treeString: '',
      generationDate: new Date().toISOString(),
      instruction: '',
      filesEnabled: true,
    });
    mockDeps.generateHandlebarOutput.mockResolvedValue('mock output');

    const output = await generateOutput([process.cwd()], mockConfig, mockProcessedFiles, [], undefined, mockDeps);

    expect(mockDeps.sortOutputFiles).toHaveBeenCalledWith(mockProcessedFiles, mockConfig);
    expect(mockDeps.buildOutputGeneratorContext).toHaveBeenCalledWith(
      [process.cwd()],
      mockConfig,
      [],
      sortedFiles,
      undefined,
    );
    expect(output).toBe('mock output');
  });

  test('generateOutput should write correct content to file (plain style)', async () => {
    const mockConfig = createMockConfig({
      output: {
        filePath: 'output.txt',
        style: 'plain',
        topFilesLength: 2,
        showLineNumbers: false,
        removeComments: false,
        removeEmptyLines: false,
      },
    });
    const mockProcessedFiles: ProcessedFile[] = [
      { path: 'file1.txt', content: 'content1' },
      { path: 'dir/file2.txt', content: 'content2' },
    ];

    const output = await generateOutput([process.cwd()], mockConfig, mockProcessedFiles, []);

    expect(output).toContain('File Summary');
    expect(output).toContain('File: file1.txt');
    expect(output).toContain('content1');
    expect(output).toContain('File: dir/file2.txt');
    expect(output).toContain('content2');
  });

  test('generateOutput should write correct content to file (parsable xml style)', async () => {
    const mockConfig = createMockConfig({
      output: {
        filePath: 'output.txt',
        style: 'xml',
        parsableStyle: true,
        topFilesLength: 2,
        showLineNumbers: false,
        removeComments: false,
        removeEmptyLines: false,
      },
    });
    const mockProcessedFiles: ProcessedFile[] = [
      { path: 'file1.txt', content: '<div>foo</div>' },
      { path: 'dir/file2.txt', content: 'if (a && b)' },
    ];

    const output = await generateOutput([process.cwd()], mockConfig, mockProcessedFiles, []);

    const parser = new XMLParser({ ignoreAttributes: false });
    const parsedOutput = parser.parse(output);

    expect(parsedOutput.repomix.file_summary).not.toBeUndefined();
    expect(parsedOutput.repomix.files.file).toEqual([
      {
        '#text': mockProcessedFiles[0].content,
        '@_path': mockProcessedFiles[0].path,
      },
      {
        '#text': mockProcessedFiles[1].content,
        '@_path': mockProcessedFiles[1].path,
      },
    ]);
  });

  test('generateOutput should write correct content to file (parsable markdown style)', async () => {
    const mockConfig = createMockConfig({
      output: {
        filePath: 'output.txt',
        style: 'markdown',
        parsableStyle: true,
        topFilesLength: 2,
        showLineNumbers: false,
        removeComments: false,
        removeEmptyLines: false,
      },
    });
    const mockProcessedFiles: ProcessedFile[] = [
      { path: 'file1.txt', content: 'content1' },
      { path: 'dir/file2.txt', content: '```\ncontent2\n```' },
    ];

    const output = await generateOutput([process.cwd()], mockConfig, mockProcessedFiles, []);

    expect(output).toContain('# File Summary');
    expect(output).toContain('## File: file1.txt');
    expect(output).toContain('````\ncontent1\n````');
    expect(output).toContain('## File: dir/file2.txt');
    expect(output).toContain('````\n```\ncontent2\n```\n````');
  });

  test('generateOutput (txt) should omit generationHeader when fileSummaryEnabled is false, but always include headerText if provided', async () => {
    const mockConfig = createMockConfig({
      output: {
        filePath: 'output.txt',
        style: 'plain',
        fileSummary: false,
        headerText: 'ALWAYS SHOW THIS HEADER',
      },
    });
    const mockProcessedFiles: ProcessedFile[] = [{ path: 'file1.txt', content: 'content1' }];
    const output = await generateOutput([process.cwd()], mockConfig, mockProcessedFiles, []);
    expect(output).not.toContain('This file is a merged representation'); // generationHeader
    expect(output).toContain('ALWAYS SHOW THIS HEADER');
  });

  test('generateOutput (xml) omits generationHeader when fileSummaryEnabled is false, but always includes headerText', async () => {
    const mockConfig = createMockConfig({
      output: {
        filePath: 'output.xml',
        style: 'xml',
        fileSummary: false,
        headerText: 'XML HEADER',
        parsableStyle: true,
      },
    });
    const mockProcessedFiles: ProcessedFile[] = [{ path: 'file1.txt', content: '<div>foo</div>' }];
    const output = await generateOutput([process.cwd()], mockConfig, mockProcessedFiles, []);
    const parser = new XMLParser({ ignoreAttributes: false });
    const parsedOutput = parser.parse(output);
    expect(parsedOutput.repomix['#text']).toBeUndefined();
    expect(parsedOutput.repomix.user_provided_header).toBe('XML HEADER');
  });

  test('generateOutput (markdown) omits generationHeader when fileSummaryEnabled is false, but always includes headerText', async () => {
    const mockConfig = createMockConfig({
      output: {
        filePath: 'output.md',
        style: 'markdown',
        fileSummary: false,
        headerText: 'MARKDOWN HEADER',
        parsableStyle: false,
      },
    });
    const mockProcessedFiles: ProcessedFile[] = [{ path: 'file1.txt', content: 'content1' }];
    const output = await generateOutput([process.cwd()], mockConfig, mockProcessedFiles, []);
    expect(output).not.toContain('This file is a merged representation');
    expect(output).toContain('MARKDOWN HEADER');
  });
});
</file>

<file path="tests/core/output/outputGenerateDiffs.test.ts">
import { describe, expect, test, vi } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import type { GitDiffResult } from '../../../src/core/git/gitDiffHandle.js';
import { generateOutput } from '../../../src/core/output/outputGenerate.js';
import type { RenderContext } from '../../../src/core/output/outputGeneratorTypes.js';
import { createMockConfig } from '../../testing/testUtils.js';

describe('Output Generation with Diffs', () => {
  const mockProcessedFiles = [
    {
      path: 'file1.ts',
      content: 'console.log("file1");',
      relativeMetrics: {
        characters: 10,
        tokens: 5,
      },
    },
  ];

  const sampleDiff = `diff --git a/file.ts b/file.ts
  index 1234567..abcdefg 100644
  --- a/file.ts
  +++ b/file.ts
  @@ -1,5 +1,5 @@
   const a = 1;
  -const b = 2;
  +const b = 3;
   const c = 3;`;

  const allFilePaths = ['file1.ts'];
  const rootDirs = ['/test/repo'];

  // Create a mock config for testing
  const mockConfig: RepomixConfigMerged = createMockConfig({
    cwd: '/test',
    output: {
      files: true,
      directoryStructure: true,
      fileSummary: true,
      style: 'xml',
      git: {
        includeDiffs: true,
      },
    },
  });

  const gitDiffResult: GitDiffResult = {
    workTreeDiffContent: sampleDiff,
    stagedDiffContent: '',
  };

  // Mock dependencies
  const mockDeps = {
    buildOutputGeneratorContext: vi.fn().mockImplementation(async () => ({
      generationDate: '2025-05-05T12:00:00Z',
      treeString: 'mock-tree',
      processedFiles: mockProcessedFiles,
      config: mockConfig,
      instruction: '',
      gitDiffResult,
    })),
    generateHandlebarOutput: vi.fn(),
    generateParsableXmlOutput: vi.fn(),
    sortOutputFiles: vi.fn().mockResolvedValue(mockProcessedFiles),
  };

  test('XML style output should include diffs section when includeDiffs is enabled', async () => {
    // Explicitly set XML style and parsable to false to use the template
    mockConfig.output.style = 'xml';
    mockConfig.output.parsableStyle = false;

    // Mock the Handlebars output function to check for diffs in the template
    mockDeps.generateHandlebarOutput.mockImplementation((config, renderContext: RenderContext) => {
      // Verify that the renderContext has the gitDiffs property
      expect(renderContext.gitDiffWorkTree).toBe(sampleDiff);

      // Simulate the rendered output to check later
      return `<diffs>${renderContext.gitDiffWorkTree}</diffs>`;
    });

    // Generate the output
    const output = await generateOutput(
      rootDirs,
      mockConfig,
      mockProcessedFiles,
      allFilePaths,
      gitDiffResult,
      mockDeps,
    );

    // Verify the diffs are included in the output
    expect(output).toContain('<diffs>');
    expect(output).toContain(sampleDiff);
    expect(output).toContain('</diffs>');

    // Verify that the generateHandlebarOutput function was called
    expect(mockDeps.generateHandlebarOutput).toHaveBeenCalled();
  });

  test('XML style output with parsableStyle should include diffs section', async () => {
    // Set XML style and parsable to true
    mockConfig.output.style = 'xml';
    mockConfig.output.parsableStyle = true;

    // Mock the parsable XML output function
    mockDeps.generateParsableXmlOutput.mockImplementation((renderContext: RenderContext) => {
      // Verify that the renderContext has the gitDiffs property
      expect(renderContext.gitDiffWorkTree).toBe(sampleDiff);

      // Simulate the XML output
      return `<repomix><diffs>${renderContext.gitDiffWorkTree}</diffs></repomix>`;
    });

    // Generate the output
    const output = await generateOutput(rootDirs, mockConfig, mockProcessedFiles, allFilePaths, undefined, mockDeps);

    // Verify the diffs are included in the output
    expect(output).toContain('<repomix><diffs>');
    expect(output).toContain(sampleDiff);
    expect(output).toContain('</diffs></repomix>');

    // Verify that the generateParsableXmlOutput function was called
    expect(mockDeps.generateParsableXmlOutput).toHaveBeenCalled();
  });

  test('Markdown style output should include diffs section when includeDiffs is enabled', async () => {
    // Set markdown style
    mockConfig.output.style = 'markdown';
    mockConfig.output.parsableStyle = false;

    // Mock the Handlebars output function for markdown
    mockDeps.generateHandlebarOutput.mockImplementation((config, renderContext: RenderContext) => {
      // Verify that the renderContext has the gitDiffs property
      expect(renderContext.gitDiffWorkTree).toBe(sampleDiff);

      // Simulate the markdown output
      return `# Git Diffs\n\`\`\`diff\n${renderContext.gitDiffWorkTree}\n\`\`\``;
    });

    // Generate the output
    const output = await generateOutput(rootDirs, mockConfig, mockProcessedFiles, allFilePaths, undefined, mockDeps);

    // Verify the diffs are included in the output
    expect(output).toContain('# Git Diffs');
    expect(output).toContain('```diff');
    expect(output).toContain(sampleDiff);
    expect(output).toContain('```');

    // Verify that the generateHandlebarOutput function was called
    expect(mockDeps.generateHandlebarOutput).toHaveBeenCalled();
  });

  test('Plain style output should include diffs section when includeDiffs is enabled', async () => {
    // Set plain style
    mockConfig.output.style = 'plain';
    mockConfig.output.parsableStyle = false;

    // Mock the Handlebars output function for plain text
    mockDeps.generateHandlebarOutput.mockImplementation((config, renderContext: RenderContext) => {
      expect(renderContext.gitDiffWorkTree).toBe(sampleDiff);

      // Simulate the plain text output
      return `===============\nGit Diffs\n===============\n${renderContext.gitDiffWorkTree}`;
    });

    // Generate the output
    const output = await generateOutput(rootDirs, mockConfig, mockProcessedFiles, allFilePaths, undefined, mockDeps);

    // Verify the diffs are included in the output
    expect(output).toContain('===============\nGit Diffs\n===============');
    expect(output).toContain(sampleDiff);

    // Verify that the generateHandlebarOutput function was called
    expect(mockDeps.generateHandlebarOutput).toHaveBeenCalled();
  });

  test('Output should not include diffs section when includeDiffs is disabled', async () => {
    // Disable the includeDiffs option
    if (mockConfig.output.git) {
      mockConfig.output.git.includeDiffs = false;
    }

    // Update the mock to not include diffs
    mockDeps.buildOutputGeneratorContext.mockImplementationOnce(async () => ({
      generationDate: '2025-05-05T12:00:00Z',
      treeString: 'mock-tree',
      processedFiles: mockProcessedFiles,
      config: mockConfig,
      instruction: '',
      // No gitDiffs property
    }));

    // Mock the Handlebars output function
    mockDeps.generateHandlebarOutput.mockImplementation((config, renderContext: RenderContext) => {
      // Verify that the renderContext does not have the gitDiffs property
      expect(renderContext.gitDiffWorkTree).toBeUndefined();

      // Simulate the output without diffs
      return 'Output without diffs';
    });

    // Generate the output
    const output = await generateOutput(rootDirs, mockConfig, mockProcessedFiles, allFilePaths, undefined, mockDeps);

    // Verify the diffs are not included in the output
    expect(output).not.toContain('Git Diffs');
    expect(output).not.toContain(sampleDiff);

    // Verify that the generateHandlebarOutput function was called
    expect(mockDeps.generateHandlebarOutput).toHaveBeenCalled();
  });
});
</file>

<file path="tests/core/output/outputSort.test.ts">
import path from 'node:path';
import { describe, expect, test, vi } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import type { ProcessedFile } from '../../../src/core/file/fileTypes.js';
import { sortOutputFiles } from '../../../src/core/output/outputSort.js';
import { createMockConfig } from '../../testing/testUtils.js';

vi.mock('node:fs/promises');

describe('outputSort', () => {
  const sep = path.sep;

  describe('sort by git changes', () => {
    const mockConfig = createMockConfig({
      output: {
        git: {
          sortByChanges: true,
          sortByChangesMaxCommits: 150,
        },
      },
      cwd: '/test',
    });

    test('should sort files by git change count', async () => {
      const input: ProcessedFile[] = [
        { path: `src${sep}utils${sep}file1.ts`, content: 'content1' },
        { path: `src${sep}utils${sep}file2.ts`, content: 'content2' },
        { path: `src${sep}utils${sep}file3.ts`, content: 'content3' },
      ];

      const mockGetFileChangeCount = vi.fn().mockResolvedValue({
        [`src${sep}utils${sep}file1.ts`]: 5,
        [`src${sep}utils${sep}file2.ts`]: 10,
        [`src${sep}utils${sep}file3.ts`]: 2,
      });

      const mockIsGitInstalled = vi.fn().mockResolvedValue(true);

      const expected = [
        { path: `src${sep}utils${sep}file3.ts`, content: 'content3' }, // 2 changes
        { path: `src${sep}utils${sep}file1.ts`, content: 'content1' }, // 5 changes
        { path: `src${sep}utils${sep}file2.ts`, content: 'content2' }, // 10 changes
      ];

      expect(
        await sortOutputFiles(input, mockConfig, {
          getFileChangeCount: mockGetFileChangeCount,
          isGitInstalled: mockIsGitInstalled,
        }),
      ).toEqual(expected);

      expect(mockGetFileChangeCount).toHaveBeenCalledWith(expect.any(String), 150);
      expect(mockIsGitInstalled).toHaveBeenCalled();
    });

    test('should return original order when git is not installed', async () => {
      const input: ProcessedFile[] = [
        { path: `src${sep}utils${sep}file1.ts`, content: 'content1' },
        { path: `src${sep}utils${sep}file2.ts`, content: 'content2' },
      ];

      const mockGetFileChangeCount = vi.fn();
      const mockIsGitInstalled = vi.fn().mockResolvedValue(false);

      const result = await sortOutputFiles(input, mockConfig, {
        getFileChangeCount: mockGetFileChangeCount,
        isGitInstalled: mockIsGitInstalled,
      });

      expect(result).toEqual(input);
      expect(mockGetFileChangeCount).not.toHaveBeenCalled();
    });

    test('should return original order when git command fails', async () => {
      const input: ProcessedFile[] = [
        { path: `src${sep}utils${sep}file1.ts`, content: 'content1' },
        { path: `src${sep}utils${sep}file2.ts`, content: 'content2' },
      ];

      const mockGetFileChangeCount = vi.fn().mockRejectedValue(new Error('git command failed'));
      const mockIsGitInstalled = vi.fn().mockResolvedValue(true);

      const result = await sortOutputFiles(input, mockConfig, {
        getFileChangeCount: mockGetFileChangeCount,
        isGitInstalled: mockIsGitInstalled,
      });

      expect(result).toEqual(input);
    });

    test('should return original order when git sort is disabled', async () => {
      const input: ProcessedFile[] = [
        { path: `src${sep}utils${sep}file1.ts`, content: 'content1' },
        { path: `src${sep}utils${sep}file2.ts`, content: 'content2' },
      ];

      const config = createMockConfig({
        output: {
          git: {
            sortByChanges: false,
          },
        },
        cwd: '/test',
      });

      const mockGetFileChangeCount = vi.fn();
      const mockIsGitInstalled = vi.fn();

      const result = await sortOutputFiles(input, config, {
        getFileChangeCount: mockGetFileChangeCount,
        isGitInstalled: mockIsGitInstalled,
      });

      expect(result).toEqual(input);
      expect(mockGetFileChangeCount).not.toHaveBeenCalled();
      expect(mockIsGitInstalled).not.toHaveBeenCalled();
    });
  });
});
</file>

<file path="tests/core/output/outputStyleDecorate.test.ts">
import { describe, expect, it } from 'vitest';
import {
  analyzeContent,
  generateHeader,
  generateSummaryNotes,
  generateSummaryPurpose,
  generateSummaryUsageGuidelines,
} from '../../../src/core/output/outputStyleDecorate.js';
import { createMockConfig } from '../../testing/testUtils.js';

describe('analyzeContent', () => {
  it('should detect entire codebase when using default settings', () => {
    const config = createMockConfig();
    const result = analyzeContent(config);
    expect(result.selection.isEntireCodebase).toBe(true);
  });

  it('should detect subset when using include patterns', () => {
    const config = createMockConfig({
      include: ['src/**/*.ts'],
    });
    const result = analyzeContent(config);
    expect(result.selection.isEntireCodebase).toBe(false);
    expect(result.selection.include).toBe(true);
  });

  it('should detect processing states', () => {
    const config = createMockConfig({
      output: {
        removeComments: true,
        removeEmptyLines: true,
      },
    });
    const result = analyzeContent(config);
    expect(result.processing.commentsRemoved).toBe(true);
    expect(result.processing.emptyLinesRemoved).toBe(true);
  });
});

describe('generateHeader', () => {
  const mockDate = '2025-01-29T11:23:01.763Z';

  it('should generate header for entire codebase', () => {
    const config = createMockConfig();
    const header = generateHeader(config, mockDate);
    expect(header).toContain('entire codebase');
    expect(header).not.toContain('subset');
  });

  it('should generate header for subset with processing', () => {
    const config = createMockConfig({
      include: ['src/**/*.ts'],
      output: {
        removeComments: true,
      },
    });
    const header = generateHeader(config, mockDate);
    expect(header).toContain('subset of the codebase');
    expect(header).toContain('comments have been removed');
  });

  it('should include security check disabled warning', () => {
    const config = createMockConfig({
      security: {
        enableSecurityCheck: false,
      },
    });
    const header = generateHeader(config, mockDate);
    expect(header).toContain('security check has been disabled');
  });

  it('should include multiple processing states', () => {
    const config = createMockConfig({
      output: {
        removeComments: true,
        removeEmptyLines: true,
        showLineNumbers: true,
      },
    });
    const header = generateHeader(config, mockDate);
    expect(header).toContain('comments have been removed');
    expect(header).toContain('empty lines have been removed');
    expect(header).toContain('line numbers have been added');
  });
});

describe('generateSummaryPurpose', () => {
  it('should generate consistent purpose text', () => {
    const purpose = generateSummaryPurpose();
    expect(purpose).toContain('packed representation');
    expect(purpose).toContain('AI systems');
    expect(purpose).toContain('code review');
  });
});

describe('generateSummaryUsageGuidelines', () => {
  it('should include header text note when headerText is provided', () => {
    const config = createMockConfig({
      output: {
        headerText: 'Custom header',
      },
    });
    const guidelines = generateSummaryUsageGuidelines(config, '');
    expect(guidelines).toContain('Repository Description');
  });

  it('should include instruction note when instruction is provided', () => {
    const config = createMockConfig();
    const guidelines = generateSummaryUsageGuidelines(config, 'Custom instruction');
    expect(guidelines).toContain('Repository Instruction');
  });
});

describe('generateSummaryNotes', () => {
  it('should include selection information', () => {
    const config = createMockConfig({
      include: ['src/**/*.ts'],
      ignore: {
        customPatterns: ['*.test.ts'],
      },
    });
    const notes = generateSummaryNotes(config);
    expect(notes).toContain('Only files matching these patterns are included: src/**/*.ts');
    expect(notes).toContain('Files matching these patterns are excluded: *.test.ts');
  });

  it('should include processing notes', () => {
    const config = createMockConfig({
      output: {
        removeComments: true,
        showLineNumbers: true,
        style: 'xml',
        parsableStyle: true,
      },
      security: {
        enableSecurityCheck: false,
      },
    });
    const notes = generateSummaryNotes(config);
    expect(notes).toContain('Code comments have been removed');
    expect(notes).toContain('Line numbers have been added');
    expect(notes).toContain('Content has been formatted for parsing in xml style');
    expect(notes).toContain('Security check has been disabled');
  });

  it('should handle case with minimal processing', () => {
    const config = createMockConfig();
    const notes = generateSummaryNotes(config);
    expect(notes).toContain('Files matching patterns in .gitignore are excluded');
    expect(notes).toContain('Files matching default ignore patterns are excluded');
    expect(notes).not.toContain('Code comments have been removed');
  });
});
</file>

<file path="tests/core/packager/copyToClipboardIfEnabled.test.ts">
import { spawn } from 'node:child_process';
import clipboard from 'clipboardy';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { copyToClipboardIfEnabled } from '../../../src/core/packager/copyToClipboardIfEnabled.js';
import type { RepomixProgressCallback } from '../../../src/shared/types.js';

vi.mock('clipboardy');
vi.mock('../../../src/shared/logger');
vi.mock('node:child_process');

describe('copyToClipboardIfEnabled', () => {
  const originalEnv = process.env;

  beforeEach(() => {
    vi.resetAllMocks();
    process.env = { ...originalEnv };
    process.env.WAYLAND_DISPLAY = undefined;
  });

  afterEach(() => {
    process.env = originalEnv;
  });

  it('should copy output to clipboard if flag enabled in config', async () => {
    const output = 'test output';
    const config: RepomixConfigMerged = {
      output: { copyToClipboard: true },
    } as RepomixConfigMerged;
    const progressCallback: RepomixProgressCallback = vi.fn();

    await copyToClipboardIfEnabled(output, progressCallback, config);

    expect(progressCallback).toHaveBeenCalledWith('Copying to clipboard...');
    expect(clipboard.write).toHaveBeenCalledWith(output);
  });

  it('should not copy output to clipboard if flag disabled in config', async () => {
    const output = 'test output';
    const config: RepomixConfigMerged = {
      output: { copyToClipboard: false },
    } as RepomixConfigMerged;
    const progressCallback: RepomixProgressCallback = vi.fn();

    await copyToClipboardIfEnabled(output, progressCallback, config);

    expect(progressCallback).not.toHaveBeenCalled();
    expect(clipboard.write).not.toHaveBeenCalled();
  });

  it('should use wl-copy in Wayland environment', async () => {
    process.env.WAYLAND_DISPLAY = '1';
    process.env.NODE_ENV = 'development';

    const output = 'test output';
    const config: RepomixConfigMerged = {
      output: { copyToClipboard: true },
    } as RepomixConfigMerged;
    const progressCallback: RepomixProgressCallback = vi.fn();

    type MockProc = {
      on: ReturnType<typeof vi.fn>;
      stdin: { end: ReturnType<typeof vi.fn> };
    };

    const mockProc: MockProc = {
      on: vi.fn(),
      stdin: { end: vi.fn() },
    };
    vi.mocked(spawn).mockReturnValue(mockProc as unknown as ReturnType<typeof spawn>);

    // Simulate successful wl-copy execution
    mockProc.on.mockImplementation((event, callback) => {
      if (event === 'close') {
        callback(0);
      }
      return mockProc;
    });

    await copyToClipboardIfEnabled(output, progressCallback, config);

    expect(spawn).toHaveBeenCalledWith('wl-copy', [], { stdio: ['pipe', 'ignore', 'ignore'] });
    expect(mockProc.stdin.end).toHaveBeenCalledWith(output);
    expect(clipboard.write).not.toHaveBeenCalled();
  });

  it('should fallback to clipboardy when wl-copy fails', async () => {
    process.env.WAYLAND_DISPLAY = '1';
    process.env.NODE_ENV = 'development';

    const output = 'test output';
    const config: RepomixConfigMerged = {
      output: { copyToClipboard: true },
    } as RepomixConfigMerged;
    const progressCallback: RepomixProgressCallback = vi.fn();

    type MockProc = {
      on: ReturnType<typeof vi.fn>;
      stdin: { end: ReturnType<typeof vi.fn> };
    };

    const mockProc: MockProc = {
      on: vi.fn(),
      stdin: { end: vi.fn() },
    };
    vi.mocked(spawn).mockReturnValue(mockProc as unknown as ReturnType<typeof spawn>);

    // Simulate wl-copy failure
    mockProc.on.mockImplementation((event, callback) => {
      if (event === 'error') {
        callback(new Error('Command not found'));
      }
      return mockProc;
    });

    await copyToClipboardIfEnabled(output, progressCallback, config);

    expect(spawn).toHaveBeenCalledWith('wl-copy', [], { stdio: ['pipe', 'ignore', 'ignore'] });
    expect(clipboard.write).toHaveBeenCalledWith(output);
  });

  it('should handle clipboardy failure', async () => {
    const output = 'test output';
    const config: RepomixConfigMerged = {
      output: { copyToClipboard: true },
    } as RepomixConfigMerged;
    const progressCallback: RepomixProgressCallback = vi.fn();

    vi.mocked(clipboard.write).mockRejectedValue(new Error('Clipboard access denied'));

    await copyToClipboardIfEnabled(output, progressCallback, config);

    expect(progressCallback).toHaveBeenCalledWith('Copying to clipboard...');
    expect(clipboard.write).toHaveBeenCalledWith(output);
  });
});
</file>

<file path="tests/core/packager/diffsFunctionality.test.ts">
import { beforeEach, describe, expect, test, vi } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import type { ProcessedFile } from '../../../src/core/file/fileTypes.js';
import * as gitDiffModule from '../../../src/core/git/gitDiffHandle.js';
import * as gitRepositoryModule from '../../../src/core/git/gitRepositoryHandle.js';
import { pack } from '../../../src/core/packager.js';
import { createMockConfig } from '../../testing/testUtils.js';

// Mock the dependencies
vi.mock('../../../src/core/git/gitDiffHandle.js', () => ({
  getWorkTreeDiff: vi.fn(),
  getStagedDiff: vi.fn(),
  getGitDiffs: vi.fn(),
}));

vi.mock('../../../src/core/git/gitRepositoryHandle.js', () => ({
  isGitRepository: vi.fn(),
}));

describe('Git Diffs Functionality', () => {
  let mockConfig: RepomixConfigMerged;
  const mockRootDir = '/test/repo';
  const sampleDiff = `diff --git a/file1.js b/file1.js
index 123..456 100644
--- a/file1.js
+++ b/file1.js
@@ -1,5 +1,5 @@
-old line
+new line
`;

  beforeEach(() => {
    vi.resetAllMocks();

    // Sample minimal config using createMockConfig utility
    mockConfig = createMockConfig({
      cwd: mockRootDir,
      output: {
        filePath: 'repomix-output.txt',
        style: 'plain',
        git: {
          includeDiffs: false,
        },
      },
    });

    // Set up our mocks
    vi.mocked(gitRepositoryModule.isGitRepository).mockResolvedValue(true);
    vi.mocked(gitDiffModule.getWorkTreeDiff).mockResolvedValue(sampleDiff);
    vi.mocked(gitDiffModule.getStagedDiff).mockResolvedValue('');
  });

  test('should not fetch diffs when includeDiffs is disabled', async () => {
    // Mock the dependencies for pack
    const mockSearchFiles = vi.fn().mockResolvedValue({ filePaths: [] });
    const mockCollectFiles = vi.fn().mockResolvedValue([]);
    const mockProcessFiles = vi.fn().mockResolvedValue([]);
    const mockGenerateOutput = vi.fn().mockResolvedValue('mocked output');
    const mockValidateFileSafety = vi.fn().mockResolvedValue({
      safeFilePaths: [],
      safeRawFiles: [],
      suspiciousFilesResults: [],
    });
    const mockHandleOutput = vi.fn().mockResolvedValue(undefined);
    const mockCopyToClipboard = vi.fn().mockResolvedValue(undefined);
    const mockCalculateMetrics = vi.fn().mockResolvedValue({
      totalFiles: 0,
      totalCharacters: 0,
      totalTokens: 0,
      fileCharCounts: {},
      fileTokenCounts: {},
    });
    const mockSortPaths = vi.fn().mockImplementation((paths) => paths);

    // Config with diffs disabled
    if (mockConfig.output.git) {
      mockConfig.output.git.includeDiffs = false;
    }

    await pack([mockRootDir], mockConfig, vi.fn(), {
      searchFiles: mockSearchFiles,
      collectFiles: mockCollectFiles,
      processFiles: mockProcessFiles,
      generateOutput: mockGenerateOutput,
      validateFileSafety: mockValidateFileSafety,
      handleOutput: mockHandleOutput,
      copyToClipboardIfEnabled: mockCopyToClipboard,
      calculateMetrics: mockCalculateMetrics,
      sortPaths: mockSortPaths,
    });

    // Should not call getWorkTreeDiff
    expect(gitDiffModule.getWorkTreeDiff).not.toHaveBeenCalled();
  });

  test('should calculate diff token count correctly', async () => {
    // Create a processed files array with a sample file
    const processedFiles: ProcessedFile[] = [
      {
        path: 'test.js',
        content: 'console.log("test");',
      },
    ];

    // Mock dependencies
    const mockSearchFiles = vi.fn().mockResolvedValue({ filePaths: ['test.js'] });
    const mockCollectFiles = vi.fn().mockResolvedValue(processedFiles);
    const mockProcessFiles = vi.fn().mockResolvedValue(processedFiles);
    const mockGenerateOutput = vi.fn().mockResolvedValue('Generated output with diffs included');
    const mockValidateFileSafety = vi.fn().mockResolvedValue({
      safeFilePaths: ['test.js'],
      safeRawFiles: processedFiles,
      suspiciousFilesResults: [],
    });
    const mockHandleOutput = vi.fn().mockResolvedValue(undefined);
    const mockCopyToClipboard = vi.fn().mockResolvedValue(undefined);
    const mockCalculateMetrics = vi.fn().mockResolvedValue({
      totalFiles: 1,
      totalCharacters: 30,
      totalTokens: 10,
      fileCharCounts: { 'test.js': 10 },
      fileTokenCounts: { 'test.js': 5 },
      gitDiffTokenCount: 15, // Mock diff token count
    });
    const mockSortPaths = vi.fn().mockImplementation((paths) => paths);

    // Config with diffs enabled
    if (mockConfig.output.git) {
      mockConfig.output.git.includeDiffs = true;
    }

    const result = await pack([mockRootDir], mockConfig, vi.fn(), {
      searchFiles: mockSearchFiles,
      collectFiles: mockCollectFiles,
      processFiles: mockProcessFiles,
      generateOutput: mockGenerateOutput,
      validateFileSafety: mockValidateFileSafety,
      handleOutput: mockHandleOutput,
      copyToClipboardIfEnabled: mockCopyToClipboard,
      calculateMetrics: mockCalculateMetrics,
      sortPaths: mockSortPaths,
    });

    // Check gitDiffTokenCount in the result
    expect(result.gitDiffTokenCount).toBe(15);
  });
});
</file>

<file path="tests/core/packager/writeOutputToDisk.test.ts">
import fs from 'node:fs/promises';
import path from 'node:path';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { writeOutputToDisk } from '../../../src/core/packager/writeOutputToDisk.js';

vi.mock('node:fs/promises');
vi.mock('../../shared/logger');

describe('writeOutputToDisk', () => {
  let originalStdoutWrite: typeof process.stdout.write;

  beforeEach(() => {
    vi.clearAllMocks();
    vi.mocked(fs.writeFile).mockResolvedValue(undefined);
    originalStdoutWrite = process.stdout.write;
    process.stdout.write = vi.fn();
  });

  afterEach(() => {
    process.stdout.write = originalStdoutWrite;
  });

  it('should write output to the specified file path', async () => {
    const output = 'test output';
    const config: RepomixConfigMerged = {
      cwd: '/test/directory',
      output: { filePath: 'output.txt' },
    } as RepomixConfigMerged;

    const outputPath = path.resolve(config.cwd, config.output.filePath);

    await writeOutputToDisk(output, config);

    expect(fs.writeFile).toHaveBeenCalledWith(outputPath, output);
    expect(process.stdout.write).not.toHaveBeenCalled();
  });

  it('should write to stdout if stdout is true', async () => {
    const output = 'test output';
    const config: RepomixConfigMerged = {
      cwd: '/test/directory',
      output: { stdout: true },
    } as RepomixConfigMerged;

    await writeOutputToDisk(output, config);

    expect(fs.writeFile).not.toHaveBeenCalled();
    expect(process.stdout.write).toHaveBeenCalledWith(output);
  });
});
</file>

<file path="tests/core/security/workers/securityCheckWorker.test.ts">
import type { SecretLintCoreConfig } from '@secretlint/types';
import { describe, expect, test } from 'vitest';
import { createSecretLintConfig, runSecretLint } from '../../../../src/core/security/workers/securityCheckWorker.js';

describe('securityCheck', () => {
  const config: SecretLintCoreConfig = createSecretLintConfig();

  test('should detect sensitive information', async () => {
    // Sensitive content with secrets from https://secretlint.github.io/
    // secretlint-disable
    const sensitiveContent = `
# Secretlint Demo

URL: https://user:pass@example.com

GitHub Token: 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

SendGrid: "SG.APhb3zgjtx3hajdas1TjBB.H7Sgbba3afgKSDyB442aDK0kpGO3SD332313-L5528Kewhere"

AWS_SECRET_ACCESS_KEY = wJalrXUtnFEMI/K7MDENG/bPxRfiCYSECRETSKEY

Slack:
xoxa-23984754863-2348975623103
xoxb-23984754863-2348975623103
xoxo-23984754863-2348975623103

Private Key:

-----BEGIN RSA PRIVATE KEY-----
MIICWwIBAAKBgQCYdGaf5uYMsilGHfnx/zxXtihdGFr3hCWwebHGhgEAVn0xlsTd
1QwoKi+rpI1O6hzyVOuoQtboODsONGRlHbNl6yJ936Yhmr8PiNwpA5qIxZAdmFv2
tqEllWr0dGPPm3B/2NbjuMpSiJNAcBQa46X++doG5yNMY8NCgTsjBZIBKwIDAQAB
AoGAN+Pkg5aIm/rsurHeoeMqYhV7srVtE/S0RIA4tkkGMPOELhvRzGmAbXEZzNkk
nNujBQww4JywYK3MqKZ4b8F1tMG3infs1w8V7INAYY/c8HzfrT3f+MVxijoKV2Fl
JlUXCclztoZhxAxhCR+WC1Upe1wIrWNwad+JA0Vws/mwrEECQQDxiT/Q0lK+gYaa
+riFeZmOaqwhlFlYNSK2hCnLz0vbnvnZE5ITQoV+yiy2+BhpMktNFsYNCfb0pdKN
D87x+jr7AkEAoZWITvqErh1RbMCXd26QXZEfZyrvVZMpYf8BmWFaBXIbrVGme0/Q
d7amI6B8Vrowyt+qgcUk7rYYaA39jYB7kQJAdaX2sY5gw25v1Dlfe5Q5WYdYBJsv
0alAGUrS2PVF69nJtRS1SDBUuedcVFsP+N2IlCoNmfhKk+vZXOBgWrkZ1QJAGJlE
FAntUvhhofW72VG6ppPmPPV7VALARQvmOWxpoPSbJAqPFqyy5tamejv/UdCshuX/
9huGINUV6BlhJT6PEQJAF/aqQTwZqJdwwJqYEQArSmyOW7UDAlQMmKMofjBbeBvd
H4PSJT5bvaEhxRj7QCwonoX4ZpV0beTnzloS55Z65g==
-----END RSA PRIVATE KEY-----
    `;
    // secretlint-enable

    const secretLintResult = await runSecretLint('test.md', sensitiveContent, 'file', config);
    expect(secretLintResult).not.toBeNull();
  });

  test('should not detect sensitive information in normal content', async () => {
    const normalContent = `
# Normal Content

This is a regular markdown file with no sensitive information.

Here's some code:

\`\`\`javascript
function greet(name) {
  console.log(\`Hello, \${name}!\`);
}
\`\`\`

And here's a list:

1. Item 1
2. Item 2
3. Item 3

That's all!
    `;

    const secretLintResult = await runSecretLint('normal.md', normalContent, 'file', config);
    expect(secretLintResult).toBeNull();
  });
});
</file>

<file path="tests/core/security/filterOutUntrustedFiles.test.ts">
import { describe, expect, it } from 'vitest';
import type { RawFile } from '../../../src/core/file/fileTypes.js';
import { filterOutUntrustedFiles } from '../../../src/core/security/filterOutUntrustedFiles.js';
import type { SuspiciousFileResult } from '../../../src/core/security/securityCheck.js';

describe('filterOutUntrustedFiles', () => {
  it('should filter out files marked as suspicious', () => {
    const rawFiles: RawFile[] = [
      { path: 'file1.txt', content: 'content 1' },
      { path: 'file2.txt', content: 'content 2' },
      { path: 'file3.txt', content: 'content 3' },
    ];
    const suspiciousFilesResults: SuspiciousFileResult[] = [
      { filePath: 'file2.txt', messages: ['something suspicious.'], type: 'file' },
    ];
    const expectedGoodFiles = [rawFiles[0], rawFiles[2]];

    const result = filterOutUntrustedFiles(rawFiles, suspiciousFilesResults);

    expect(result).toEqual(expectedGoodFiles);
  });

  it('should return all files if no suspicious files', () => {
    const rawFiles: RawFile[] = [
      { path: 'file1.txt', content: 'content 1' },
      { path: 'file2.txt', content: 'content 2' },
      { path: 'file3.txt', content: 'content 3' },
    ];
    const suspiciousFilesResults: SuspiciousFileResult[] = [];

    const result = filterOutUntrustedFiles(rawFiles, suspiciousFilesResults);

    expect(result).toEqual(rawFiles);
  });
});
</file>

<file path="tests/core/security/securityCheck.test.ts">
// src/core/security/securityCheck.test.ts

import pc from 'picocolors';
import { describe, expect, it, vi } from 'vitest';
import type { RawFile } from '../../../src/core/file/fileTypes.js';
import type { GitDiffResult } from '../../../src/core/git/gitDiffHandle.js';
import { runSecurityCheck } from '../../../src/core/security/securityCheck.js';
import type { SecurityCheckTask } from '../../../src/core/security/workers/securityCheckWorker.js';
import securityCheckWorker from '../../../src/core/security/workers/securityCheckWorker.js';
import { logger } from '../../../src/shared/logger.js';
import { repomixLogLevels } from '../../../src/shared/logger.js';

vi.mock('../../../src/shared/logger');
vi.mock('../../../src/shared/processConcurrency', () => ({
  initPiscina: vi.fn(() => ({
    run: vi.fn().mockImplementation(async (task: SecurityCheckTask) => {
      return await securityCheckWorker(task);
    }),
  })),
}));

const mockFiles: RawFile[] = [
  {
    path: 'test1.js',
    // secretlint-disable
    content: 'URL: https://user:pass@example.com', // Clear security issue
    // secretlint-enable
  },
  {
    path: 'test2.js',
    content: 'console.log("Hello World");', // No secrets
  },
];

const mockInitTaskRunner = () => {
  return async (task: SecurityCheckTask) => {
    return await securityCheckWorker(task);
  };
};

describe('runSecurityCheck', () => {
  it('should identify files with security issues', async () => {
    const result = await runSecurityCheck(mockFiles, () => {}, undefined, { initTaskRunner: mockInitTaskRunner });

    expect(result).toHaveLength(1);
    expect(result[0].filePath).toBe('test1.js');
    expect(result[0].messages).toHaveLength(1);
  });

  it('should call progress callback with correct messages', async () => {
    const progressCallback = vi.fn();

    await runSecurityCheck(mockFiles, progressCallback, undefined, {
      initTaskRunner: mockInitTaskRunner,
    });

    expect(progressCallback).toHaveBeenCalledWith(
      expect.stringContaining(`Running security check... (1/2) ${pc.dim('test1.js')}`),
    );
    expect(progressCallback).toHaveBeenCalledWith(
      expect.stringContaining(`Running security check... (2/2) ${pc.dim('test2.js')}`),
    );
  });

  it('should handle worker errors gracefully', async () => {
    const mockError = new Error('Worker error');
    const mockErrorTaskRunner = () => {
      return async () => {
        throw mockError;
      };
    };

    await expect(
      runSecurityCheck(mockFiles, () => {}, undefined, {
        initTaskRunner: mockErrorTaskRunner,
      }),
    ).rejects.toThrow('Worker error');

    expect(logger.error).toHaveBeenCalledWith('Error during security check:', mockError);
  });

  it('should handle empty file list', async () => {
    const result = await runSecurityCheck([], () => {}, undefined, {
      initTaskRunner: mockInitTaskRunner,
    });

    expect(result).toEqual([]);
  });

  it('should log performance metrics in trace mode', async () => {
    await runSecurityCheck(mockFiles, () => {}, undefined, {
      initTaskRunner: mockInitTaskRunner,
    });

    expect(logger.trace).toHaveBeenCalledWith(expect.stringContaining('Starting security check for'));
    expect(logger.trace).toHaveBeenCalledWith(expect.stringContaining('Security check completed in'));
  });

  it('should process files in parallel', async () => {
    const startTime = Date.now();

    await runSecurityCheck(mockFiles, () => {}, undefined, {
      initTaskRunner: mockInitTaskRunner,
    });

    const endTime = Date.now();
    const duration = endTime - startTime;

    // Parallel processing should be faster than sequential
    expect(duration).toBeLessThan(1000); // Adjust threshold as needed
  });

  it('should not modify original files', async () => {
    const originalFiles = JSON.parse(JSON.stringify(mockFiles));

    await runSecurityCheck(mockFiles, () => {}, undefined, {
      initTaskRunner: mockInitTaskRunner,
    });

    expect(mockFiles).toEqual(originalFiles);
  });

  it('should use default initTaskRunner when no deps provided', async () => {
    // Test the default initTaskRunner function (lines 16-18)
    // Mock logger.getLogLevel to return a valid value
    vi.mocked(logger.getLogLevel).mockReturnValue(repomixLogLevels.INFO);

    const result = await runSecurityCheck(mockFiles, () => {});

    expect(result).toHaveLength(1);
    expect(result[0].filePath).toBe('test1.js');
    expect(result[0].messages).toHaveLength(1);
  });

  it('should process Git diff content when gitDiffResult is provided', async () => {
    const gitDiffResult: GitDiffResult = {
      workTreeDiffContent: 'diff --git a/test.js b/test.js\n+const secret = "password123";',
      stagedDiffContent: 'diff --git a/config.js b/config.js\n+const apiKey = "sk-1234567890abcdef";',
    };

    const progressCallback = vi.fn();
    const result = await runSecurityCheck(mockFiles, progressCallback, gitDiffResult, {
      initTaskRunner: mockInitTaskRunner,
    });

    // Should process 2 files + 2 git diff contents = 4 total tasks
    expect(progressCallback).toHaveBeenCalledTimes(4);

    // Check that Git diff tasks were processed
    expect(progressCallback).toHaveBeenCalledWith(expect.stringContaining('Working tree changes'));
    expect(progressCallback).toHaveBeenCalledWith(expect.stringContaining('Staged changes'));

    // Should find security issues in files (at least 1 from test1.js)
    expect(result.length).toBeGreaterThanOrEqual(1);
  });

  it('should process only workTreeDiffContent when stagedDiffContent is not available', async () => {
    const gitDiffResult: GitDiffResult = {
      workTreeDiffContent: 'diff --git a/test.js b/test.js\n+const secret = "password123";',
      stagedDiffContent: '',
    };

    const progressCallback = vi.fn();
    await runSecurityCheck(mockFiles, progressCallback, gitDiffResult, {
      initTaskRunner: mockInitTaskRunner,
    });

    // Should process 2 files + 1 git diff content = 3 total tasks
    expect(progressCallback).toHaveBeenCalledTimes(3);

    // Check that only working tree diff was processed
    expect(progressCallback).toHaveBeenCalledWith(expect.stringContaining('Working tree changes'));
    // Staged changes should not be processed because content is empty string (falsy)
    expect(progressCallback).not.toHaveBeenCalledWith(expect.stringContaining('Staged changes'));
  });

  it('should process only stagedDiffContent when workTreeDiffContent is not available', async () => {
    const gitDiffResult: GitDiffResult = {
      workTreeDiffContent: '',
      stagedDiffContent: 'diff --git a/config.js b/config.js\n+const apiKey = "sk-1234567890abcdef";',
    };

    const progressCallback = vi.fn();
    await runSecurityCheck(mockFiles, progressCallback, gitDiffResult, {
      initTaskRunner: mockInitTaskRunner,
    });

    // Should process 2 files + 1 git diff content = 3 total tasks
    expect(progressCallback).toHaveBeenCalledTimes(3);

    // Check that only staged diff was processed
    expect(progressCallback).toHaveBeenCalledWith(expect.stringContaining('Staged changes'));
    // Working tree changes should not be processed because content is empty string (falsy)
    expect(progressCallback).not.toHaveBeenCalledWith(expect.stringContaining('Working tree changes'));
  });

  it('should handle gitDiffResult with no diff content', async () => {
    const gitDiffResult: GitDiffResult = {
      workTreeDiffContent: '',
      stagedDiffContent: '',
    };

    const progressCallback = vi.fn();
    await runSecurityCheck(mockFiles, progressCallback, gitDiffResult, {
      initTaskRunner: mockInitTaskRunner,
    });

    // Should process only 2 files, no git diff content because both are empty strings (falsy)
    expect(progressCallback).toHaveBeenCalledTimes(2);

    // Check that no git diff tasks were processed
    expect(progressCallback).not.toHaveBeenCalledWith(expect.stringContaining('Working tree changes'));
    expect(progressCallback).not.toHaveBeenCalledWith(expect.stringContaining('Staged changes'));
  });
});
</file>

<file path="tests/core/security/validateFileSafety.test.ts">
import { describe, expect, it, vi } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import type { RawFile } from '../../../src/core/file/fileTypes.js';
import type { SuspiciousFileResult } from '../../../src/core/security/securityCheck.js';
import { validateFileSafety } from '../../../src/core/security/validateFileSafety.js';
import type { RepomixProgressCallback } from '../../../src/shared/types.js';

describe('validateFileSafety', () => {
  it('should validate file safety and return safe files and paths', async () => {
    const rawFiles: RawFile[] = [
      { path: 'file1.txt', content: 'content1' },
      { path: 'file2.txt', content: 'content2' },
      { path: 'file3.txt', content: 'content3' },
    ];
    const safeRawFiles = [rawFiles[0], rawFiles[1]];
    const config: RepomixConfigMerged = {
      security: { enableSecurityCheck: true },
    } as RepomixConfigMerged;
    const progressCallback: RepomixProgressCallback = vi.fn();
    const suspiciousFilesResults: SuspiciousFileResult[] = [
      { filePath: 'file2.txt', messages: ['something suspicious.'], type: 'file' },
    ];
    const deps = {
      runSecurityCheck: vi.fn().mockResolvedValue(suspiciousFilesResults),
      filterOutUntrustedFiles: vi.fn().mockReturnValue(safeRawFiles),
    };

    const result = await validateFileSafety(rawFiles, progressCallback, config, undefined, deps);

    expect(deps.runSecurityCheck).toHaveBeenCalledWith(rawFiles, progressCallback, undefined);
    expect(deps.filterOutUntrustedFiles).toHaveBeenCalledWith(rawFiles, suspiciousFilesResults);
    expect(result).toEqual({
      safeRawFiles,
      safeFilePaths: ['file1.txt', 'file2.txt'],
      suspiciousFilesResults,
      suspiciousGitDiffResults: [],
    });
  });
});
</file>

<file path="tests/core/treeSitter/LanguageParser.test.ts">
import { beforeAll, describe, expect, it } from 'vitest';
import { LanguageParser } from '../../../src/core/treeSitter/languageParser.js';

describe('LanguageParser', () => {
  let parser: LanguageParser;

  beforeAll(() => {
    parser = new LanguageParser();
  });

  describe('guessTheLang', () => {
    it('should return the correct language based on file extension', () => {
      const testCases = [
        { filePath: 'file.js', expected: 'javascript' },
        { filePath: 'file.ts', expected: 'typescript' },
        { filePath: 'file.sol', expected: 'solidity' },
        { filePath: 'Contract.sol', expected: 'solidity' },
        { filePath: 'path/to/MyContract.sol', expected: 'solidity' },
      ];

      for (const { filePath, expected } of testCases) {
        const lang = parser.guessTheLang(filePath);
        expect(lang).toBe(expected);
      }
    });

    it('should return undefined for unsupported extensions', () => {
      const filePath = 'file.txt';
      const lang = parser.guessTheLang(filePath);

      expect(lang).toBeUndefined();
    });
  });
});
</file>

<file path="tests/core/treeSitter/loadLanguage.test.ts">
import fs from 'node:fs/promises';
import { describe, expect, it, vi } from 'vitest';
import Parser from 'web-tree-sitter';
import { loadLanguage } from '../../../src/core/treeSitter/loadLanguage.js';

vi.mock('node:fs/promises');
vi.mock('web-tree-sitter', () => ({
  default: {
    Language: {
      load: vi.fn(),
    },
  },
}));
vi.mock('node:module', () => ({
  createRequire: () => ({
    resolve: (path: string) => `/mock/path/${path}`,
  }),
}));

describe('loadLanguage', () => {
  it('should throw error for empty language name', async () => {
    await expect(loadLanguage('')).rejects.toThrow('Invalid language name');
  });

  it('should load language successfully', async () => {
    const mockAccess = vi.mocked(fs.access);
    mockAccess.mockResolvedValue(undefined);

    const mockLoadLanguage = vi.fn().mockResolvedValue({ success: true });
    Parser.Language.load = mockLoadLanguage;

    await loadLanguage('javascript');

    expect(mockAccess).toHaveBeenCalledWith('/mock/path/tree-sitter-wasms/out/tree-sitter-javascript.wasm');
    expect(mockLoadLanguage).toHaveBeenCalledWith('/mock/path/tree-sitter-wasms/out/tree-sitter-javascript.wasm');
  });

  it('should throw error when WASM file is not found', async () => {
    const mockAccess = vi.mocked(fs.access);
    mockAccess.mockRejectedValue(new Error('File not found'));

    await expect(loadLanguage('javascript')).rejects.toThrow(
      'WASM file not found for language javascript: /mock/path/tree-sitter-wasms/out/tree-sitter-javascript.wasm',
    );
  });

  it('should handle language load error', async () => {
    const mockAccess = vi.mocked(fs.access);
    mockAccess.mockResolvedValue(undefined);

    const mockLoadLanguage = vi.fn().mockRejectedValue(new Error('Load failed'));
    Parser.Language.load = mockLoadLanguage;

    await expect(loadLanguage('javascript')).rejects.toThrow('Failed to load language javascript: Load failed');
  });
});
</file>

<file path="tests/core/treeSitter/parseFile.c.test.ts">
import { describe, expect, test } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { parseFile } from '../../../src/core/treeSitter/parseFile.js';
import { createMockConfig } from '../../testing/testUtils.js';

describe('parseFile for C', () => {
  test('should parse C correctly', async () => {
    const fileContent = `
      /**
       * A simple C program demonstrating various language features
       */
      #include <stdio.h>
      #include <stdlib.h>

      /* Define a constant */
      #define MAX_SIZE 100

      /**
       * Structure representing a person
       */
      struct Person {
        char* name;
        int age;
      };

      /**
       * Union for different number types
       */
      union Number {
        int i;
        float f;
        double d;
      };

      /**
       * Enum for status codes
       */
      enum Status {
        SUCCESS = 0,
        ERROR = 1,
        PENDING = 2
      };

      /* Type definition for a pointer to function returning int */
      typedef int (*IntFunctionPtr)(int, int);

      /**
       * Add two integers
       * @param a First integer
       * @param b Second integer
       * @return Sum of a and b
       */
      int add(int a, int b) {
        // Add two numbers
        return a + b;
      }

      /**
       * Main function
       * @return Exit status
       */
      int main(int argc, char** argv) {
        // Create a person
        struct Person person;
        person.name = "John";
        person.age = 30;

        // Print info
        printf("Name: %s, Age: %d\\n", person.name, person.age);

        // Use union
        union Number num;
        num.i = 42;
        printf("Integer: %d\\n", num.i);

        // Function pointer
        IntFunctionPtr operation = add;
        printf("Result: %d\\n", operation(5, 3));

        return SUCCESS;
      }
    `;
    const filePath = 'sample.c';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      // Comments
      'A simple C program demonstrating various language features',
      'Define a constant',

      // Struct
      'struct Person',
      'Structure representing a person',

      // Union
      'Union for different number types',

      // Enum
      'enum Status',
      'Enum for status codes',

      // Type definition comment
      'Type definition for a pointer to function returning int',

      // Functions
      'int add(int a, int b)',
      'Add two integers',
      '@param a First integer',
      '@param b Second integer',
      '@return Sum of a and b',

      // Main function
      'int main(int argc, char** argv)',
      'Main function',
      '@return Exit status',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should handle function declarations and definitions', async () => {
    const fileContent = `
      /* Function declaration */
      void print_message(const char* message);

      /* Function definition */
      int calculate_sum(int values[], int count) {
        int sum = 0;
        for (int i = 0; i < count; i++) {
          sum += values[i];
        }
        return sum;
      }

      /* Function with no params */
      void init(void) {
        // Initialize something
      }
    `;
    const filePath = 'functions.c';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      'Function declaration',
      'Function definition',
      'int calculate_sum(int values[], int count)',
      'Function with no params',
      'void init(void)',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should handle complex type definitions', async () => {
    const fileContent = `
      /* Simple typedef */
      typedef unsigned long size_t;

      /* Struct typedef */
      typedef struct {
        double x;
        double y;
      } Point;

      /* Enum typedef */
      typedef enum {
        RED,
        GREEN,
        BLUE
      } Color;

      /* Function pointer typedef */
      typedef void (*Callback)(void* data);

      /* Array typedef */
      typedef char String[256];
    `;
    const filePath = 'types.c';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      'Simple typedef',
      'Struct typedef',
      'Enum typedef',
      'Function pointer typedef',
      'Array typedef',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });
});
</file>

<file path="tests/core/treeSitter/parseFile.comments.test.ts">
import { describe, expect, test } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { parseFile } from '../../../src/core/treeSitter/parseFile.js';
import { createMockConfig } from '../../testing/testUtils.js';

describe('parseFile comment support', () => {
  // Test for JavaScript/TypeScript comments
  test('should parse all types of JavaScript/TypeScript comments', async () => {
    const fileContent = [
      '// Single line comment',
      '/* Multi-line comment',
      '   spanning multiple lines */',
      'function func1() {}',
      '',
      '/**',
      ' * JSDoc documentation',
      ' * @param {string} name - The name parameter',
      ' * @returns {void}',
      ' */',
      'function func2(name) {}',
      '',
      '/** Single line JSDoc */',
      'const x = 1;',
    ].join('\n');

    const filePath = 'test.ts';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      'Single line comment',
      'Multi-line comment',
      'JSDoc documentation',
      '@param {string} name - The name parameter',
      '@returns {void}',
      'Single line JSDoc',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  // Test for Python comments
  test('should parse all types of Python comments', async () => {
    const fileContent = [
      '# Single line comment',
      "'''",
      'Multi-line docstring',
      'with multiple lines',
      "'''",
      'def func1(): pass',
      '',
      '"""',
      'Double quote docstring',
      'with indentation',
      '    indented line',
      '"""',
      'def func2(): pass',
    ].join('\n');

    const filePath = 'test.py';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = ['Single line comment', 'Multi-line docstring', 'Double quote docstring', 'indented line'];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  // Test for Java comments
  test('should parse all types of Java comments', async () => {
    const fileContent = [
      '// Single line comment',
      '/* Multi-line comment',
      '   spanning multiple lines */',
      'public class Test {',
      '    /**',
      '     * JavaDoc for class field',
      '     */',
      '    private int field;',
      '',
      '    /**',
      '     * JavaDoc for method',
      '     * @param name The name parameter',
      '     * @return A greeting message',
      '     * @throws Exception If something goes wrong',
      '     */',
      '    public String greet(String name) {',
      '        return "Hello";',
      '    }',
      '}',
    ].join('\n');

    const filePath = 'test.java';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      'Single line comment',
      'Multi-line comment',
      'JavaDoc for class field',
      'JavaDoc for method',
      '@param name The name parameter',
      '@return A greeting message',
      '@throws Exception If something goes wrong',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  // Test for C# comments
  test('should parse all types of C# comments', async () => {
    const fileContent = [
      '// Single line comment',
      '/* Multi-line comment',
      '   spanning multiple lines */',
      '',
      '/// <summary>',
      '/// XML documentation for class',
      '/// </summary>',
      'public class Test {',
      '    /// <summary>',
      '    /// Property documentation',
      '    /// </summary>',
      '    /// <value>The value description</value>',
      '    public int Property { get; set; }',
      '}',
    ].join('\n');

    const filePath = 'test.cs';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      'Single line comment',
      'Multi-line comment',
      'XML documentation for class',
      'Property documentation',
      '<value>The value description</value>',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  // Test for Rust comments
  test('should parse all types of Rust comments', async () => {
    const fileContent = [
      '// Single line comment',
      '/* Multi-line comment',
      '   spanning multiple lines */',
      '',
      '//! Module documentation',
      '',
      '/// Documentation for struct',
      'struct Test {',
      '    /// Field documentation',
      '    field: i32',
      '}',
    ].join('\n');

    const filePath = 'test.rs';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      'Single line comment',
      'Multi-line comment',
      'Module documentation',
      'Documentation for struct',
      'Field documentation',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  // Test for Ruby comments
  test('should parse all types of Ruby comments', async () => {
    const fileContent = [
      '# Single line comment',
      'def func1',
      'end',
      '',
      '# Documentation comment',
      '# @param name [String] The name',
      '# @return [void]',
      'def func2(name)',
      'end',
      '',
      '=begin',
      'Multi-line comment block',
      'using =begin/=end syntax',
      '=end',
      'def func3',
      'end',
    ].join('\n');

    const filePath = 'test.rb';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      'Single line comment',
      'Documentation comment',
      '@param name [String] The name',
      '@return [void]',
      'Multi-line comment block',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });
});
</file>

<file path="tests/core/treeSitter/parseFile.cpp.test.ts">
import { describe, expect, test } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { parseFile } from '../../../src/core/treeSitter/parseFile.js';
import { createMockConfig } from '../../testing/testUtils.js';

describe('parseFile for C/C++', () => {
  // Test for C++
  test('should parse C++ correctly', async () => {
    const fileContent = `
      // Main entry point
      /* The main function that outputs
       * a greeting to the world
       */
      int main() {
        std::cout << "Hello, world!"; return 0;
      }
    `;
    const filePath = 'dummy.cpp';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      '// Main entry point',
      '/* The main function that outputs',
      '* a greeting to the world',
      '*/',
      'int main() {',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should parse C++ header correctly', async () => {
    const fileContent = `
      // Header file main function
      /* This header declares the main function
       * for the program entry point
       */
      int main() { std::cout << "Hello, world!"; return 0; }
    `;
    const filePath = 'dummy.hpp';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = ['main', 'Header file main function', 'This header declares the main function'];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  // Test for C
  test('should parse C correctly', async () => {
    const fileContent = `
      /* The main function
       * Prints a greeting to stdout
       */
      // Entry point of the program
      int main() { printf("Hello, world!"); return 0; }
    `;
    const filePath = 'dummy.c';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = ['main', 'The main function', 'Prints a greeting to stdout', 'Entry point of the program'];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should parse C header correctly', async () => {
    const fileContent = `
      /* Header file for main function
       * Declares the program entry point
       */
      // Main function prototype
      int main() { printf("Hello, world!"); return 0; }
    `;
    const filePath = 'dummy.h';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      'main',
      'Header file for main function',
      'Declares the program entry point',
      'Main function prototype',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });
});
</file>

<file path="tests/core/treeSitter/parseFile.csharp.test.ts">
import { describe, expect, test } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { parseFile } from '../../../src/core/treeSitter/parseFile.js';
import { createMockConfig } from '../../../tests/testing/testUtils.js';

describe('parseFile for C#', () => {
  test('should parse C# correctly', async () => {
    const fileContent = `
      // Program class containing the entry point
      /// <summary>
      /// The main program class
      /// </summary>
      class Program {
        // The main entry point
        /// <summary>
        /// Writes a greeting to the console
        /// </summary>
        static void Main() {
          Console.WriteLine("Hello, world!");
        }
      }
    `;
    const filePath = 'dummy.cs';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      '// Program class containing the entry point',
      '/// <summary>',
      'class Program {',
      '// The main program class',
      '// The main entry point',
      '/// Writes a greeting to the console',
      'static void Main() {',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });
});
</file>

<file path="tests/core/treeSitter/parseFile.css.test.ts">
import { describe, expect, test } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { parseFile } from '../../../src/core/treeSitter/parseFile.js';
import { createMockConfig } from '../../testing/testUtils.js';

describe('parseFile for CSS', () => {
  test('should parse CSS correctly', async () => {
    const fileContent = `
      /* Main styles for the application */
      body {
        font-family: 'Arial', sans-serif;
        line-height: 1.6;
        color: #333;
        background-color: #f4f4f4;
        margin: 0;
        padding: 0;
      }

      /* Header styles */
      .header {
        background-color: #35424a;
        color: #ffffff;
        padding: 20px;
        border-bottom: #e8491d 3px solid;
      }

      /* Navigation styles */
      .nav {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      @media (max-width: 768px) {
        .nav {
          flex-direction: column;
        }

        .container {
          width: 95%;
        }
      }
    `;
    const filePath = 'style.css';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      // Comments (all lines should be extracted)
      'Main styles for the application',
      'Header styles',
      'Navigation styles',

      // Selectors (only the first line should be extracted)
      'body {',
      '.header {',
      '.nav {',

      // at-rules are not extracted with the current query, so removed from expectations
      // '@media (max-width: 768px) {',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }

    // Properties should not be extracted
    const unexpectedContents = [
      'font-family:',
      'line-height:',
      'color:',
      'background-color:',
      'margin:',
      'padding:',
      'display:',
      'justify-content:',
      'align-items:',
      'flex-direction:',
      'width:',
    ];

    for (const unexpectedContent of unexpectedContents) {
      expect(result).not.toContain(unexpectedContent);
    }
  });

  test('should handle different comment styles', async () => {
    const fileContent = `
      /* Single line comment */
      body { color: black; }

      /* Multi-line comment
         spanning multiple lines */
      .container { width: 100%; }
    `;
    const filePath = 'comments.css';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      'Single line comment',
      'Multi-line comment\n         spanning multiple lines',
      'body {',
      '.container {',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should handle various at-rules', async () => {
    const fileContent = `
      @import url('https://fonts.googleapis.com/css2?family=Roboto&display=swap');

      @charset "UTF-8";

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      @media screen and (min-width: 768px) {
        body { font-size: 16px; }
      }
    `;
    const filePath = 'at-rules.css';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    // Skip testing at-rules as they are not extracted in the current implementation
    // Enable this test when at-rule extraction is implemented in the future

    // Inner rules should not be extracted
    const unexpectedContents = ['from { opacity: 0; }', 'to { opacity: 1; }'];

    for (const unexpectedContent of unexpectedContents) {
      expect(result).not.toContain(unexpectedContent);
    }
  });

  test('should handle complex selectors', async () => {
    const fileContent = `
      /* Complex selectors */
      body.dark-theme .container > div:first-child {
        color: white;
        background-color: #333;
      }

      .sidebar ul li a:hover,
      .sidebar ul li a:focus {
        text-decoration: underline;
        color: blue;
      }

      #main-content h1 + p::first-line {
        font-weight: bold;
        font-size: 1.2em;
      }
    `;
    const filePath = 'complex-selectors.css';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      'Complex selectors',
      'body.dark-theme .container > div:first-child {',
      '.sidebar ul li a:hover,',
      '#main-content h1 + p::first-line {',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }

    // Properties should not be extracted
    const unexpectedContents = [
      'color: white;',
      'background-color: #333;',
      'text-decoration: underline;',
      'color: blue;',
      'font-weight: bold;',
      'font-size: 1.2em;',
    ];

    for (const unexpectedContent of unexpectedContents) {
      expect(result).not.toContain(unexpectedContent);
    }
  });
});
</file>

<file path="tests/core/treeSitter/parseFile.go.test.ts">
import { describe, expect, test } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { parseFile } from '../../../src/core/treeSitter/parseFile.js';
import { createMockConfig } from '../../testing/testUtils.js';

describe('parseFile for Go', () => {
  test('should parse Go correctly', async () => {
    const fileContent = `
      // Package main is the entry point
      package main

      import (
        "fmt"
        "os"
      )

      // User represents a person
      type User struct {
        Name string
        Age  int
      }

      // Greeter is something that can greet
      type Greeter interface {
        Greet() string
      }

      // Constants
      const (
        MaxUsers = 100
        Version  = "1.0.0"
      )

      // Variables
      var (
        debugMode = false
        logLevel  = "info"
      )

      // SayHello prints a greeting message
      func SayHello(name string) {
        fmt.Printf("Hello, %s!\\n", name)
      }

      // Greet implements the Greeter interface
      func (u User) Greet() string {
        return fmt.Sprintf("Hello, I'm %s!", u.Name)
      }

      // Main entry point
      func main() {
        user := User{Name: "John", Age: 30}
        fmt.Println(user.Greet())
        SayHello(os.Args[1])
      }
    `;
    const filePath = 'sample.go';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      // Package declaration
      'package main',
      'Package main is the entry point',

      // Imports
      'import (',
      '"fmt"',
      '"os"',

      // Struct definition
      'type User struct',
      'User represents a person',
      'Name string',
      'Age  int',

      // Interface definition
      'type Greeter interface',
      'Greeter is something that can greet',
      'Greet() string',

      // Constants
      'const (',
      'MaxUsers = 100',
      'Version  = "1.0.0"',

      // Variables
      'var (',
      'debugMode = false',
      'logLevel  = "info"',

      // Functions
      'func SayHello(name string)',
      'SayHello prints a greeting message',

      // Methods
      'func (u User) Greet() string',
      'Greet implements the Greeter interface',

      // Main function
      'func main()',
      'Main entry point',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should handle single imports', async () => {
    const fileContent = `
      package main

      import "fmt"

      func main() {
        fmt.Println("Hello, world!")
      }
    `;
    const filePath = 'simple.go';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = ['import "fmt"', 'func main()'];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should handle different comment styles', async () => {
    const fileContent = `
      // This is a line comment
      package main

      /* This is a block comment
         spanning multiple lines */
      func main() {
        // Inside function comment
        fmt.Println("Hello")
      }
    `;
    const filePath = 'comments.go';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      'This is a line comment',
      'This is a block comment\n         spanning multiple lines',
      'Inside function comment',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should handle type aliases', async () => {
    const fileContent = `
      package main

      // UserID is a type alias for integer
      type UserID int

      // Result is a type alias for map
      type Result map[string]interface{}
    `;
    const filePath = 'types.go';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      'type UserID int',
      'UserID is a type alias for integer',
      'type Result map[string]interface{}',
      'Result is a type alias for map',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });
});
</file>

<file path="tests/core/treeSitter/parseFile.java.test.ts">
import { describe, expect, test } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { parseFile } from '../../../src/core/treeSitter/parseFile.js';
import { createMockConfig } from '../../../tests/testing/testUtils.js';

describe('parseFile for Java', () => {
  test('should parse Java correctly', async () => {
    const fileContent = `
      /**
       * A simple Hello World class
       */
      public class HelloWorld {
        /**
         * Main entry point
         * @param args command line arguments
         */
        public static void main(String[] args) {
          System.out.println("Hello, world!");
        }
      }
    `;
    const filePath = 'dummy.java';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      '/**',
      '* A simple Hello World class',
      '*/',
      'public class HelloWorld {',
      '* Main entry point',
      '* @param args command line arguments',
      'public static void main(String[] args) {',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });
});
</file>

<file path="tests/core/treeSitter/parseFile.javascript.test.ts">
import { describe, expect, test } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { CHUNK_SEPARATOR, parseFile } from '../../../src/core/treeSitter/parseFile.js';
import { createMockConfig } from '../../testing/testUtils.js';

describe('parseFile for JavaScript', () => {
  test('should filter captures with same start row', async () => {
    const fileContent = `
      /**
       * Greeting function
       * @param name The name to greet
       */
      function sayHello(name) {  // inline comment
        console.log("Hello, " + name);
      }

      // next function
      function sayGoodbye(name) {
        console.log("Goodbye, " + name);
      }
    `;
    const filePath = 'dummy.js';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');
    // Check content
    expect(result).toContain('/**\n       * Greeting function\n       * @param name The name to greet\n       */');
    expect(result).toContain('// inline comment');
    expect(result).not.toBeUndefined();
    if (result) {
      // Check separator
      const parts = result.split(`${CHUNK_SEPARATOR}\n`);
      expect(parts.length).toBeGreaterThan(1);
      for (const part of parts) {
        expect(part.trim()).not.toBe('');
      }
    }
  });

  test('should parse JSX correctly', async () => {
    const fileContent = `
      // React component function
      /**
       * A hello world component
       * @param {string} name - The name to display
       */
      function sayHello(name) { console.log("Hello, " + name); }
    `;
    const filePath = 'dummy.jsx';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      '// React component function',
      '* A hello world component',
      '* @param {string} name - The name to display',
      'function sayHello(name) { console.log("Hello, " + name); }',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });
});
</file>

<file path="tests/core/treeSitter/parseFile.php.test.ts">
import { describe, expect, test } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { parseFile } from '../../../src/core/treeSitter/parseFile.js';
import { createMockConfig } from '../../../tests/testing/testUtils.js';

describe('parseFile for PHP', () => {
  test('should parse PHP correctly', async () => {
    const fileContent = `
<?php

namespace App;

use App\Greeter;

// Define the greeting function
function greet($name) {
    // Print the personalized greeting message
    echo "Hello, " . $name . "!";
}

// Execute the greeting function
greet("John");

interface Greeter {
  public function greet($name);
}

final class GreeterImpl implements Greeter {
  public function greet($name) {
    echo "Hello, " . $name . "!";
  }
}

trait GreeterTrait {
  public function greet($name) {
    echo "Hello, " . $name . "!";
  }
}

/**
 * Greeting function
 * @param name The name to greet
 * @return string The greeting message
 */
enum GreeterEnum: string {
  case GREET = "Hello, %s!";
}

?>
`;
    const filePath = 'dummy.php';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');
    const expectContents = [
      'namespace App;',
      'use AppGreeter;',
      'function greet($name) {',
      '// Define the greeting function',
      '// Print the personalized greeting message',
      '// Execute the greeting function',
      'interface Greeter {',
      'public function greet($name) {',
      'final class GreeterImpl implements Greeter {',
      'public function greet($name) {',
      'trait GreeterTrait {',
      'public function greet($name) {',
      '/**',
      '* Greeting function',
      '* @param name The name to greet',
      '* @return string The greeting message',
      '*/',
      'enum GreeterEnum: string {',
    ];
    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });
});
</file>

<file path="tests/core/treeSitter/parseFile.python.test.ts">
import { beforeEach, describe, expect, test } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { parseFile } from '../../../src/core/treeSitter/parseFile.js';
import { createMockConfig } from '../../testing/testUtils.js';

describe('parseFile for Python', () => {
  const defaultConfig = createMockConfig({});

  test('should parse basic Python correctly', async () => {
    const fileContent = `
      # Python greeting function
      '''
      A simple greeting function that prints a hello message
      Args:
          name: The name to greet
      '''
      def greet(name): print(f"Hello, {name}")
    `;
    const filePath = 'dummy.py';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      'greet',
      'Python greeting function',
      'A simple greeting function',
      'Args:',
      'name: The name to greet',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should parse class with decorators and inheritance', async () => {
    const fileContent = `
      @dataclass
      @register
      class UserModel(BaseModel):
          name: str
          age: int
    `;

    const result = await parseFile(fileContent, 'example.py', defaultConfig);

    const expectContents = ['@dataclass', '@register', 'class UserModel(BaseModel)'];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should parse function with decorators and type annotations', async () => {
    const fileContent = `
      @route("/users")
      @authenticate
      def get_users(page: int = 1, limit: int = 10) -> List[User]:
          return users[page:limit]
    `;

    const result = await parseFile(fileContent, 'example.py', defaultConfig);

    const expectContents = [
      '@route("/users")',
      '@authenticate',
      'def get_users(page: int = 1, limit: int = 10) -> List[User]',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should parse docstring', async () => {
    const fileContent = `
      """
      This is a docstring
      with multiple lines
      """
    `;

    const result = await parseFile(fileContent, 'example.py', defaultConfig);

    const expectContents = ['This is a docstring', 'with multiple lines'];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should parse comments', async () => {
    const fileContent = '# This is a single line comment';

    const result = await parseFile(fileContent, 'example.py', defaultConfig);

    const expectContents = ['# This is a single line comment'];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should parse type aliases', async () => {
    const fileContent = `
      UserId = int
      Result = Union[Success, Error]
    `;

    const result = await parseFile(fileContent, 'example.py', defaultConfig);

    const expectContents = ['UserId = int', 'Result = Union[Success, Error]'];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });
});
</file>

<file path="tests/core/treeSitter/parseFile.ruby.test.ts">
import { describe, expect, test } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { parseFile } from '../../../src/core/treeSitter/parseFile.js';
import { createMockConfig } from '../../../tests/testing/testUtils.js';

describe('parseFile for Ruby', () => {
  test('should parse Ruby correctly', async () => {
    const fileContent = `
      # User module for handling user-related functionality
      module User
        # Constants for user status
        ACTIVE = 1
        INACTIVE = 0

        # Person class represents a human user
        class Person
          attr_accessor :name, :age

          # Initialize a new person
          # @param name [String] the person's name
          # @param age [Integer] the person's age
          def initialize(name, age)
            @name = name
            @age = age
          end

          # Return a greeting
          # @return [String] a personalized greeting
          def greet
            "Hello, I'm #{@name} and I'm #{@age} years old!"
          end

          # A class method to create a Person
          def self.create(name, age)
            new(name, age)
          end
        end

        # Create a module method
        def self.find_by_name(name)
          # Implementation
        end
      end

      # Include external libraries
      require 'json'
      require_relative './helpers'

      # Create a user and greet
      person = User::Person.new("John", 30)
      puts person.greet
    `;
    const filePath = 'sample.rb';
    const config = {};
    const result = await parseFile(fileContent, filePath, config as RepomixConfigMerged);
    expect(typeof result).toBe('string');

    const expectContents = [
      // Module comment
      'User module for handling user-related functionality',

      // Module definition
      'module User',

      // Constants
      'ACTIVE = 1',
      'INACTIVE = 0',

      // Class comment
      'Person class represents a human user',

      // Class definition
      'class Person',
      'attr_accessor :name, :age',

      // Method comments
      'Initialize a new person',
      "@param name [String] the person's name",
      "@param age [Integer] the person's age",

      // Method definitions
      'def initialize(name, age)',
      'def greet',
      'def self.create(name, age)',

      // Module method
      'def self.find_by_name(name)',

      // Require statements
      "require 'json'",
      "require_relative './helpers'",
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should handle single class with inheritance', async () => {
    const fileContent = `
      class Admin < User
        # Admin has higher privileges
        def admin?
          true
        end
      end
    `;
    const filePath = 'admin.rb';
    const config = {};
    const result = await parseFile(fileContent, filePath, config as RepomixConfigMerged);
    expect(typeof result).toBe('string');

    const expectContents = ['class Admin < User', 'Admin has higher privileges', 'def admin?'];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should handle different comment styles', async () => {
    const fileContent = `
      # This is a regular comment
      class Example
        # This is a documentation comment
        # with multiple lines
        def method_with_comment
          # In-method comment
          puts "Hello"
        end

        =begin
        This is a multi-line comment block
        that can span multiple lines
        =end
        def another_method
          puts "World"
        end
      end
    `;
    const filePath = 'comments.rb';
    const config = {};
    const result = await parseFile(fileContent, filePath, config as RepomixConfigMerged);
    expect(typeof result).toBe('string');

    const expectContents = [
      'This is a regular comment',
      '# This is a documentation comment',
      '# with multiple lines',
      'In-method comment',
      'This is a multi-line comment block',
      'that can span multiple lines',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should handle singleton methods and module mixins', async () => {
    const fileContent = `
      module Loggable
        def log(message)
          puts "[LOG] #{message}"
        end
      end

      class Service
        include Loggable
        extend Comparable

        # Singleton method
        def self.fetch_data
          # Implementation
        end

        # Instance method
        def process
          log("Processing...")
        end
      end

      # Monkey patching an existing class
      class String
        def palindrome?
          self == self.reverse
        end
      end
    `;
    const filePath = 'service.rb';
    const config = {};
    const result = await parseFile(fileContent, filePath, config as RepomixConfigMerged);
    expect(typeof result).toBe('string');

    const expectContents = [
      'module Loggable',
      'def log(message)',
      'class Service',
      'Singleton method',
      'def self.fetch_data',
      'Instance method',
      'def process',
      'class String',
      'def palindrome?',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });
});
</file>

<file path="tests/core/treeSitter/parseFile.rust.test.ts">
import { describe, expect, test } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { parseFile } from '../../../src/core/treeSitter/parseFile.js';
import { createMockConfig } from '../../../tests/testing/testUtils.js';

describe('parseFile for Rust', () => {
  test('should parse Rust correctly', async () => {
    const fileContent = `
      // Module declaration
      mod greetings {
          // Trait definition
          pub trait Greeter {
              /// Says hello to someone
              fn greet(&self, name: &str) -> String;
          }

          // Struct definition
          #[derive(Debug)]
          pub struct SimpleGreeter {
              prefix: String
          }

          // Implementation block
          impl Greeter for SimpleGreeter {
              fn greet(&self, name: &str) -> String {
                  format!("{}, {}!", self.prefix, name)
              }
          }

          // Enum definition
          #[derive(Debug)]
          pub enum Language {
              English,
              Japanese,
              Spanish
          }

          // Main function
          fn main() {
              let greeter = SimpleGreeter {
                  prefix: String::from("Hello")
              };
              println!("{}", greeter.greet("World"));
          }
      }
    `;
    const filePath = 'dummy.rs';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      'mod greetings {',
      'pub trait Greeter {',
      '// Says hello to someone',
      'fn greet(&self, name: &str) -> String {',
      'pub struct SimpleGreeter {',
      'impl Greeter for SimpleGreeter {',
      'pub enum Language {',
      'fn main() {',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });
});
</file>

<file path="tests/core/treeSitter/parseFile.solidity.test.ts">
import { beforeAll, describe, expect, test } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { LanguageParser } from '../../../src/core/treeSitter/languageParser.js';
import { parseFile } from '../../../src/core/treeSitter/parseFile.js';

describe('Solidity File Parsing', () => {
  let parser: LanguageParser;
  const defaultConfig: RepomixConfigMerged = {
    cwd: process.cwd(),
    input: {
      maxFileSize: 50 * 1024 * 1024,
    },
    output: {
      filePath: 'output.txt',
      style: 'xml',
      stdout: false,
      parsableStyle: false,
      fileSummary: true,
      directoryStructure: true,
      removeComments: false,
      removeEmptyLines: false,
      compress: false,
      topFilesLength: 5,
      showLineNumbers: false,
      copyToClipboard: false,
      files: true,
      git: {
        sortByChanges: true,
        sortByChangesMaxCommits: 100,
        includeDiffs: false,
      },
    },
    include: [],
    ignore: {
      useGitignore: true,
      useDefaultPatterns: true,
      customPatterns: [],
    },
    security: {
      enableSecurityCheck: true,
    },
    tokenCount: {
      encoding: 'o200k_base',
    },
  };

  beforeAll(async () => {
    parser = new LanguageParser();
    await parser.init();
  });

  test('should parse Solidity contract definitions correctly', async () => {
    const content = `
contract BaseContract {
    uint256 internal value;
}

interface IMyInterface {
    function getValue() external view returns (uint256);
}

abstract contract AbstractContract {
    function abstractFunction() virtual external;
}

contract MyContract is BaseContract, IMyInterface {
    function getValue() external view override returns (uint256) {
        return value;
    }
}`;

    const config = {
      ...defaultConfig,
      output: {
        ...defaultConfig.output,
        removeComments: true,
      },
    };

    const result = await parseFile(content, 'test.sol', config);

    // 各種コントラクト定義が保持されていることを確認
    expect(result).toContain('contract BaseContract {');
    expect(result).toContain('interface IMyInterface {');
    expect(result).toContain('abstract contract AbstractContract {');
    expect(result).toContain('contract MyContract is BaseContract, IMyInterface {');

    // 関数定義が保持されていることを確認
    expect(result).toContain('function getValue() external view returns (uint256)');
    expect(result).toContain('function abstractFunction() virtual external');
  });
});
</file>

<file path="tests/core/treeSitter/parseFile.swift.test.ts">
import { describe, expect, test } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { parseFile } from '../../../src/core/treeSitter/parseFile.js';
import { createMockConfig } from '../../testing/testUtils.js';

describe('parseFile for Swift', () => {
  test('should parse Swift correctly', async () => {
    const fileContent = `
      // Swift sample demonstrating various language features
      import Foundation

      /// Protocol defining a shape
      protocol Shape {
        /// Calculate the area of the shape
        func area() -> Double

        /// The name of the shape
        var name: String { get }
      }

      /// A class representing a circle
      class Circle: Shape {
        /// The radius of the circle
        let radius: Double

        /// The name of the shape
        var name: String {
          return "Circle"
        }

        /// Initialize with a radius
        init(radius: Double) {
          self.radius = radius
        }

        /// Calculate the area using πr²
        func area() -> Double {
          return Double.pi * radius * radius
        }

        /// Deinitializer
        deinit {
          print("Circle deinitialized")
        }
      }

      /// A class representing a rectangle
      class Rectangle: Shape {
        /// The width of the rectangle
        let width: Double

        /// The height of the rectangle
        let height: Double

        /// The name of the shape
        var name: String {
          return "Rectangle"
        }

        /// Initialize with width and height
        init(width: Double, height: Double) {
          self.width = width
          self.height = height
        }

        /// Calculate the area using width × height
        func area() -> Double {
          return width * height
        }

        /// Access by index, where 0 is width and 1 is height
        subscript(index: Int) -> Double {
          get {
            switch index {
            case 0: return width
            case 1: return height
            default: return 0
            }
          }
        }
      }

      /// Calculate the total area of shapes
      func calculateTotalArea(shapes: [Shape]) -> Double {
        return shapes.reduce(0) { $0 + $1.area() }
      }

      // Create shapes and calculate their areas
      let circle = Circle(radius: 5)
      let rectangle = Rectangle(width: 10, height: 20)
      let shapes: [Shape] = [circle, rectangle]
      let totalArea = calculateTotalArea(shapes: shapes)
      print("Total area: \\(totalArea)")
    `;
    const filePath = 'sample.swift';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      // Protocol
      'Protocol defining a shape',
      'protocol Shape',
      '/// Calculate the area of the shape',
      '/// The name of the shape',

      // Classes
      'A class representing a circle',
      'class Circle: Shape',
      'A class representing a rectangle',
      'class Rectangle: Shape',

      // Properties
      'The radius of the circle',
      'let radius: Double',
      'The width of the rectangle',
      'let width: Double',
      'The height of the rectangle',
      'let height: Double',

      // Methods
      'Calculate the area using πr²',
      'Calculate the area using width × height',

      // Initializers
      'Initialize with a radius',
      'init(radius: Double)',
      'Initialize with width and height',
      'init(width: Double, height: Double)',

      // Deinitializer
      'Deinitializer',
      'deinit',

      // Subscript
      'Access by index, where 0 is width and 1 is height',
      'subscript(index: Int) -> Double',

      // Global function
      'Calculate the total area of shapes',
      'func calculateTotalArea(shapes: [Shape]) -> Double',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should handle extensions and computed properties', async () => {
    const fileContent = `
      // Define a basic struct
      struct Point {
        var x: Double
        var y: Double
      }

      // Extensions
      extension Point {
        // Computed property
        var magnitude: Double {
          return sqrt(x*x + y*y)
        }

        // Method
        func distance(to point: Point) -> Double {
          let dx = x - point.x
          let dy = y - point.y
          return sqrt(dx*dx + dy*dy)
        }

        // Static method
        static func zero() -> Point {
          return Point(x: 0, y: 0)
        }
      }
    `;
    const filePath = 'extensions.swift';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      'struct Point',
      'var x: Double',
      'var y: Double',
      // 注：extension Pointが含まれないようなので削除
      'Computed property',
      'var magnitude: Double',
      'Method',
      'func distance(to point: Point) -> Double',
      'Static method',
      'static func zero() -> Point',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should handle enums and generic types', async () => {
    const fileContent = `
      /// Represents a result with either a success value or an error
      enum Result<Success, Failure> where Failure: Error {
        /// The success case with associated value
        case success(Success)

        /// The failure case with associated error
        case failure(Failure)

        /// Returns the success value or throws the error
        func get() throws -> Success {
          switch self {
          case .success(let value):
            return value
          case .failure(let error):
            throw error
          }
        }
      }

      /// Types of HTTP methods
      enum HTTPMethod: String {
        case get = "GET"
        case post = "POST"
        case put = "PUT"
        case delete = "DELETE"
      }

      /// Generic stack implementation
      struct Stack<Element> {
        private var elements: [Element] = []

        /// Adds an element to the top of the stack
        mutating func push(_ element: Element) {
          elements.append(element)
        }

        /// Removes and returns the top element
        mutating func pop() -> Element? {
          return elements.popLast()
        }
      }
    `;
    const filePath = 'generics.swift';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      'Represents a result with either a success value or an error',
      'enum Result<Success, Failure> where Failure: Error',
      'The success case with associated value',
      'The failure case with associated error',
      'Returns the success value or throws the error',
      'func get() throws -> Success',
      'Types of HTTP methods',
      'enum HTTPMethod: String',
      'Generic stack implementation',
      'struct Stack<Element>',
      'Adds an element to the top of the stack',
      'mutating func push(_ element: Element)',
      'Removes and returns the top element',
      'mutating func pop() -> Element?',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });
});
</file>

<file path="tests/core/treeSitter/parseFile.test.ts">
import { describe, expect, test } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { CHUNK_SEPARATOR, parseFile } from '../../../src/core/treeSitter/parseFile.js';
import { createMockConfig } from '../../testing/testUtils.js';

describe('parseFile', () => {
  // Test for merging adjacent chunks
  test('should merge adjacent chunks', async () => {
    const fileContent = `
      /**
       * First function
       */
      function first() {
        console.log('first');
      }

      /**
       * Second function, right after first
       */
      function second() {
        console.log('second');
      }

      // Some space

      /**
       * Third function
       */
      function third() {
        console.log('third');
      }
    `;
    const filePath = 'dummy.js';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    expect(result).not.toBeUndefined();

    if (result) {
      const chunks = result.split(`\n${CHUNK_SEPARATOR}\n`);
      expect(chunks.length).toBe(4);

      expect(chunks[0]).toContain('* First function');
      expect(chunks[0]).toContain('function first() {');
      expect(chunks[1]).toContain('* Second function');
      expect(chunks[1]).toContain('function second() {');
      expect(chunks[2]).toContain('// Some space');
      expect(chunks[3]).toContain('* Third function');
      expect(chunks[3]).toContain('function third() {');
    }
  });
});
</file>

<file path="tests/core/treeSitter/parseFile.typescript.test.ts">
import { beforeEach, describe, expect, test, vi } from 'vitest';
import type { Language, Point, Query, SyntaxNode, Tree, TreeCursor } from 'web-tree-sitter';
import type { Edit, Range } from 'web-tree-sitter';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { parseFile } from '../../../src/core/treeSitter/parseFile.js';
import { TypeScriptParseStrategy } from '../../../src/core/treeSitter/parseStrategies/TypeScriptParseStrategy.js';
import { createMockConfig } from '../../../tests/testing/testUtils.js';

interface MockContext {
  fileContent: string;
  lines: string[];
  tree: Tree;
  query: Query;
  config: RepomixConfigMerged;
}

describe('TypeScript File Parsing', () => {
  describe('parseFile for TypeScript', () => {
    test('should parse TypeScript correctly', async () => {
      const fileContent = `
        // TypeScript function
        /**
         * Says hello to the given name
         * @param name The name to greet
         */
        function sayHello(name) { console.log("Hello, " + name); }
      `;
      const filePath = 'dummy.ts';
      const config = {};
      const result = await parseFile(fileContent, filePath, config as RepomixConfigMerged);
      expect(typeof result).toBe('string');

      const expectContents = [
        'sayHello',
        'TypeScript function',
        'Says hello to the given name',
        '@param name The name to greet',
      ];

      for (const expectContent of expectContents) {
        expect(result).toContain(expectContent);
      }
    });

    test('should parse TypeScript arrow functions correctly', async () => {
      const fileContent = `
          // Arrow function for addition
          /** Adds two numbers together
           * @param x First number
           * @param y Second number
           */
          const add = (x: number, y: number): number => {
              return x + y;
          };
          // Function type declaration
          let multiply: (a: number, b:number) => number;
          multiply = (a, b) => {
              return a*b;
          }
      `;
      const filePath = 'dummy.ts';
      const config = { output: { compress: true } };
      const result = await parseFile(fileContent, filePath, config as RepomixConfigMerged);

      expect(typeof result).toBe('string');

      const expectContents = [
        'add',
        'multiply',
        'Arrow function for addition',
        'Adds two numbers together',
        '@param x First number',
        '@param y Second number',
        'Function type declaration',
      ];

      for (const expectContent of expectContents) {
        expect(result).toContain(expectContent);
      }
    });

    test('should parse TSX correctly', async () => {
      const fileContent = `
        // Greeting component
        /**
         * A simple greeting component
         * @param name Person to greet
         */
        function greet(name: string){ console.log("Hello, " + name); }
      `;
      const filePath = 'dummy.tsx';
      const config = {};
      const result = await parseFile(fileContent, filePath, config as RepomixConfigMerged);
      expect(typeof result).toBe('string');

      const expectContents = [
        'greet',
        'Greeting component',
        'A simple greeting component',
        '@param name Person to greet',
      ];

      for (const expectContent of expectContents) {
        expect(result).toContain(expectContent);
      }
    });
  });

  describe('TypeScript Parse Strategy', () => {
    let strategy: TypeScriptParseStrategy;
    let processedChunks: Set<string>;
    let mockContext: MockContext;

    // Helper function to create a mock capture object
    const createMockCapture = (name: string, startRow: number, endRow: number): { node: SyntaxNode; name: string } => {
      return {
        node: {
          startPosition: { row: startRow } as Point,
          endPosition: { row: endRow } as Point,
        } as SyntaxNode,
        name,
      };
    };

    beforeEach(() => {
      strategy = new TypeScriptParseStrategy();
      processedChunks = new Set<string>();

      const mockCursor: TreeCursor = {
        nodeType: '',
        nodeTypeId: 0,
        nodeStateId: 0,
        nodeText: '',
        nodeIsNamed: false,
        nodeIsMissing: false,
        startPosition: { row: 0, column: 0 } as Point,
        endPosition: { row: 0, column: 0 } as Point,
        startIndex: 0,
        endIndex: 0,
        nodeId: 0,
        currentNode: {} as SyntaxNode,
        currentDepth: 0,
        currentDescendantIndex: 0,
        currentFieldId: 0,
        currentFieldName: '',
        gotoFirstChild(): boolean {
          return false;
        },
        gotoLastChild(): boolean {
          return false;
        },
        gotoNextSibling(): boolean {
          return false;
        },
        gotoPreviousSibling(): boolean {
          return false;
        },
        gotoParent(): boolean {
          return false;
        },
        gotoFirstChildForIndex(index: number): boolean {
          return false;
        },
        gotoFirstChildForPosition(goalPosition: Point): boolean {
          return false;
        },
        gotoDescendant(goalDescendantIndex: number): boolean {
          return false;
        },
        reset(): void {},
        resetTo(cursor: TreeCursor): void {},
        delete(): void {},
      };

      const mockTree: Tree = {
        rootNode: {} as SyntaxNode,
        rootNodeWithOffset(offsetBytes: number, offsetExtent: Point): SyntaxNode {
          return {} as SyntaxNode;
        },
        getChangedRanges(other: Tree): Range[] {
          return [];
        },
        getIncludedRanges(): Range[] {
          return [];
        },
        copy(): Tree {
          return this;
        },
        delete() {},
        edit(delta: Edit) {},
        getLanguage(): Language {
          return {} as Language;
        },
        walk(): TreeCursor {
          return mockCursor;
        },
      };

      mockContext = {
        fileContent: '',
        lines: [],
        tree: mockTree,
        query: {} as Query,
        config: {} as RepomixConfigMerged,
      };
    });

    describe('Type declarations', () => {
      test('should correctly parse class declarations with extends', () => {
        const lines = ['class ChildClass extends ParentClass {', '  constructor() { super(); }', '}'];
        const capture = createMockCapture('definition.class', 0, 2);

        const result = strategy.parseCapture(capture, lines, processedChunks, mockContext);

        expect(result).toBe('class ChildClass extends ParentClass');
      });

      test('should correctly parse class declarations with implements', () => {
        const lines = [
          'class MyService implements IService {',
          '  getData(): Promise<Data> { return Promise.resolve({}); }',
          '}',
        ];
        const capture = createMockCapture('definition.class', 0, 2);

        const result = strategy.parseCapture(capture, lines, processedChunks, mockContext);

        expect(result).toBe('class MyService implements IService');
      });

      test('should correctly parse interface declarations', () => {
        const lines = [
          'interface IRepository<T> {',
          '  findById(id: string): Promise<T>;',
          '  save(entity: T): Promise<void>;',
          '}',
        ];
        const capture = createMockCapture('definition.interface', 0, 3);

        const result = strategy.parseCapture(capture, lines, processedChunks, mockContext);

        expect(result).toBe(
          [
            'interface IRepository<T> {',
            '  findById(id: string): Promise<T>;',
            '  save(entity: T): Promise<void>;',
            '}',
          ].join('\n'),
        );
      });

      test('should correctly parse type aliases', () => {
        const lines = ['type RequestHandler = (req: Request, res: Response) => Promise<void>;'];
        const capture = createMockCapture('definition.type', 0, 0);

        const result = strategy.parseCapture(capture, lines, processedChunks, mockContext);

        expect(result).toBe('type RequestHandler = (req: Request, res: Response) => Promise<void>;');
      });

      test('should correctly parse enum declarations', () => {
        const lines = [
          'enum Direction {',
          '  Up = "UP",',
          '  Down = "DOWN",',
          '  Left = "LEFT",',
          '  Right = "RIGHT"',
          '}',
        ];
        const capture = createMockCapture('definition.enum', 0, 5);

        const result = strategy.parseCapture(capture, lines, processedChunks, mockContext);

        expect(result).toBe(
          ['enum Direction {', '  Up = "UP",', '  Down = "DOWN",', '  Left = "LEFT",', '  Right = "RIGHT"', '}'].join(
            '\n',
          ),
        );
      });
    });

    describe('Import declarations', () => {
      test('should correctly parse named imports', () => {
        const lines = ['import { useState, useEffect } from "react";'];
        const capture = createMockCapture('definition.import', 0, 0);

        const result = strategy.parseCapture(capture, lines, processedChunks, mockContext);

        expect(result).toBe('import { useState, useEffect } from "react";');
      });

      test('should correctly parse default imports', () => {
        const lines = ['import React from "react";'];
        const capture = createMockCapture('definition.import', 0, 0);

        const result = strategy.parseCapture(capture, lines, processedChunks, mockContext);

        expect(result).toBe('import React from "react";');
      });
    });

    describe('Property declarations', () => {
      test('should correctly parse class properties', () => {
        const lines = ['class Example {', '  private readonly name: string;', '  public age: number = 0;', '}'];
        const capture = createMockCapture('definition.property', 1, 1);

        const result = strategy.parseCapture(capture, lines, processedChunks, mockContext);

        expect(result).toBeNull();
      });

      test('should correctly parse interface properties', () => {
        const lines = ['interface Config {', '  readonly apiKey: string;', '  timeout?: number;', '}'];
        const capture = createMockCapture('definition.property', 1, 1);

        const result = strategy.parseCapture(capture, lines, processedChunks, mockContext);

        expect(result).toBeNull();
      });
    });

    describe('Duplicate detection for type definitions', () => {
      test('should detect duplicate class definitions', () => {
        const lines = ['class Example {', '  constructor() {}', '}'];
        const capture1 = createMockCapture('definition.class', 0, 2);
        const capture2 = createMockCapture('definition.class', 0, 2);

        const result1 = strategy.parseCapture(capture1, lines, processedChunks, mockContext);
        expect(result1).toBe('class Example');

        const result2 = strategy.parseCapture(capture2, lines, processedChunks, mockContext);
        expect(result2).toBeNull();
      });
    });

    describe('Function declarations', () => {
      test('should correctly parse standard function declarations', () => {
        const lines = [
          'function myFunction(param1: string, param2: number): void {',
          '  console.log(param1, param2);',
          '}',
        ];
        const capture = createMockCapture('name.definition.function', 0, 2);

        const result = strategy.parseCapture(capture, lines, processedChunks, mockContext);

        expect(result).toBe('function myFunction(param1: string, param2: number): void');
        expect(processedChunks.size).toBe(1);
      });

      test('should correctly parse exported function declarations', () => {
        const lines = [
          'export function exportedFunction(param: string): string {',
          '  return param.toUpperCase();',
          '}',
        ];
        const capture = createMockCapture('name.definition.function', 0, 2);

        const result = strategy.parseCapture(capture, lines, processedChunks, mockContext);

        expect(result).toBe('export function exportedFunction(param: string): string');
        expect(processedChunks.size).toBe(1);
      });
    });

    describe('Arrow functions', () => {
      test('should correctly parse arrow function expressions', () => {
        const lines = ['const arrowFunc = (a: number, b: number): number => {', '  return a + b;', '};'];
        const capture = createMockCapture('name.definition.function', 0, 2);

        const result = strategy.parseCapture(capture, lines, processedChunks, mockContext);

        expect(result).toBe('const arrowFunc = (a: number, b: number): number =>');
        expect(processedChunks.has('func:arrowFunc')).toBe(true);
      });

      test('should correctly parse exported arrow function expressions', () => {
        const lines = ['export const exportedArrow = (text: string): string => {', '  return text.trim();', '};'];
        const capture = createMockCapture('name.definition.function', 0, 2);

        const result = strategy.parseCapture(capture, lines, processedChunks, mockContext);

        expect(result).toBe('export const exportedArrow = (text: string): string =>');
        expect(processedChunks.has('func:exportedArrow')).toBe(true);
      });

      test('should correctly parse one-line arrow functions', () => {
        const lines = ['const shortArrow = (x: number): number => x * 2;'];
        const capture = createMockCapture('name.definition.function', 0, 0);

        const result = strategy.parseCapture(capture, lines, processedChunks, mockContext);

        expect(result).toBe('const shortArrow = (x: number): number');
        expect(processedChunks.has('func:shortArrow')).toBe(true);
      });

      test('should correctly parse async arrow functions', () => {
        const lines = [
          'const asyncArrow = async (url: string): Promise<Response> => {',
          '  return await fetch(url);',
          '};',
        ];
        const capture = createMockCapture('name.definition.function', 0, 2);

        const result = strategy.parseCapture(capture, lines, processedChunks, mockContext);

        expect(result).toBe('const asyncArrow = async (url: string): Promise<Response> =>');
        expect(processedChunks.has('func:asyncArrow')).toBe(true);
      });
    });

    describe('Method declarations', () => {
      test('should correctly parse class method declarations', () => {
        const lines = ['class MyClass {', '  myMethod(param: string): void {', '    console.log(param);', '  }', '}'];
        const capture = createMockCapture('name.definition.method', 1, 3);

        const result = strategy.parseCapture(capture, lines, processedChunks, mockContext);

        expect(result).toBe('myMethod(param: string): void');
      });

      test('should correctly parse interface method signatures', () => {
        const lines = ['interface MyInterface {', '  methodSignature(param: number): boolean;', '}'];
        const capture = createMockCapture('name.definition.method', 1, 1);

        const result = strategy.parseCapture(capture, lines, processedChunks, mockContext);

        expect(result).toBe('methodSignature(param: number): boolean;');
      });
    });

    describe('Function name extraction', () => {
      test('should extract function name from standard declaration', () => {
        const lines = ['const myFunc = (a: number) => a * 2;'];

        // Using private method directly through type casting to test name extraction
        const functionName = (
          strategy as unknown as { getFunctionName(lines: string[], index: number): string }
        ).getFunctionName(lines, 0);

        expect(functionName).toBe('myFunc');
      });

      test('should extract function name from exported declaration', () => {
        const lines = ['export const exportedFunc = (a: number) => a * 2;'];

        const functionName = (
          strategy as unknown as { getFunctionName(lines: string[], index: number): string }
        ).getFunctionName(lines, 0);

        expect(functionName).toBe('exportedFunc');
      });

      test('should handle variable declarations without function assignment', () => {
        const lines = ['const justVariable = 42;'];

        const functionName = (
          strategy as unknown as { getFunctionName(lines: string[], index: number): string }
        ).getFunctionName(lines, 0);

        expect(functionName).toBe('justVariable');
      });
    });
  });
});
</file>

<file path="tests/core/treeSitter/parseFile.vue.test.ts">
import { describe, expect, test } from 'vitest';
import type { RepomixConfigMerged } from '../../../src/config/configSchema.js';
import { CHUNK_SEPARATOR, parseFile } from '../../../src/core/treeSitter/parseFile.js';
import { createMockConfig } from '../../testing/testUtils.js';

describe('parseFile for Vue', () => {
  test('should parse Vue files correctly', async () => {
    const fileContent = `
<template>
  <div class="hello">
    <h1>{{ msg }}</h1>
    <p>{{ greeting }}</p>
  </div>
</template>

<script>
// Hello component
/**
 * Vue component that displays a greeting message
 */
export default {
  name: 'HelloWorld',
  props: {
    msg: {
      type: String,
      required: true
    }
  },
  data() {
    return {
      greeting: 'Welcome to Vue!'
    };
  },
  methods: {
    /**
     * Updates the greeting message
     * @param newGreeting The new greeting message
     */
    updateGreeting(newGreeting) {
      this.greeting = newGreeting;
    }
  }
};
</script>

<style scoped>
.hello {
  margin: 20px;
  padding: 20px;
  border: 1px solid #ccc;
}
</style>
    `;
    const filePath = 'HelloWorld.vue';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      '<template>',
      '<script>',
      '<style scoped>',
      '// Hello component',
      '* Vue component that displays a greeting message',
      'updateGreeting',
      '* Updates the greeting message',
      '@param newGreeting The new greeting message',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should parse Vue files with TypeScript correctly', async () => {
    const fileContent = `
<template>
  <div class="counter">
    <p>Count: {{ count }}</p>
    <button @click="increment">Increment</button>
  </div>
</template>

<script lang="ts">
// Counter component
import { defineComponent } from 'vue';

/**
 * A simple counter component
 */
export default defineComponent({
  name: 'Counter',
  data() {
    return {
      count: 0
    };
  },
  methods: {
    /**
     * Increments the counter
     */
    increment(): void {
      this.count++;
    }
  }
});
</script>
    `;
    const filePath = 'Counter.vue';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      '<template>',
      '<script lang="ts">',
      '// Counter component',
      '* A simple counter component',
      'increment',
      '* Increments the counter',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });

  test('should parse Vue files with composition API correctly', async () => {
    const fileContent = `
<template>
  <div class="composition">
    <p>Message: {{ message }}</p>
    <button @click="updateMessage">Update</button>
  </div>
</template>

<script setup>
// Composition API example
import { ref } from 'vue';

/**
 * Message state
 */
const message = ref('Hello from Composition API');

/**
 * Updates the message
 */
function updateMessage() {
  message.value = 'Updated message!';
}
</script>
    `;
    const filePath = 'Composition.vue';
    const config = {};
    const result = await parseFile(fileContent, filePath, createMockConfig(config));
    expect(typeof result).toBe('string');

    const expectContents = [
      '<template>',
      '<script setup>',
      '// Composition API example',
      '* Message state',
      'updateMessage',
      '* Updates the message',
    ];

    for (const expectContent of expectContents) {
      expect(result).toContain(expectContent);
    }
  });
});
</file>

<file path="tests/core/packager.test.ts">
import path from 'node:path';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { pack } from '../../src/core/packager.js';
import { createMockConfig } from '../testing/testUtils.js';

vi.mock('node:fs/promises');
vi.mock('fs/promises');
vi.mock('../../src/core/metrics/TokenCounter.js', () => {
  return {
    TokenCounter: vi.fn().mockImplementation(() => ({
      countTokens: vi.fn().mockReturnValue(10),
      free: vi.fn(),
    })),
  };
});

describe('packager', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  test('pack should orchestrate packing files and generating output', async () => {
    const file2Path = path.join('dir1', 'file2.txt');
    const mockRawFiles = [
      { path: 'file1.txt', content: 'raw content 1' },
      { path: file2Path, content: 'raw content 2' },
    ];
    const mockSafeRawFiles = [
      { path: 'file1.txt', content: 'safed content 1' },
      { path: file2Path, content: 'safed content 2' },
    ];
    const mockProcessedFiles = [
      { path: 'file1.txt', content: 'processed content 1' },
      { path: file2Path, content: 'processed content 2' },
    ];
    const mockOutput = 'mock output';
    const mockFilePaths = ['file1.txt', file2Path];

    const mockDeps = {
      searchFiles: vi.fn().mockResolvedValue({
        filePaths: mockFilePaths,
        emptyDirPaths: [],
      }),
      sortPaths: vi.fn().mockImplementation((paths) => Promise.resolve(paths)),
      collectFiles: vi.fn().mockResolvedValue(mockRawFiles),
      processFiles: vi.fn().mockReturnValue(mockProcessedFiles),
      validateFileSafety: vi.fn().mockResolvedValue({
        safeFilePaths: mockFilePaths,
        safeRawFiles: mockSafeRawFiles,
        suspiciousFilesResults: [],
      }),
      generateOutput: vi.fn().mockResolvedValue(mockOutput),
      handleOutput: vi.fn().mockResolvedValue(undefined),
      copyToClipboardIfEnabled: vi.fn().mockResolvedValue(undefined),
      calculateMetrics: vi.fn().mockResolvedValue({
        totalFiles: 2,
        totalCharacters: 11,
        totalTokens: 10,
        fileCharCounts: {
          'file1.txt': 19,
          [file2Path]: 19,
        },
        fileTokenCounts: {
          'file1.txt': 10,
          [file2Path]: 10,
        },
      }),
    };

    const mockConfig = createMockConfig();
    const progressCallback = vi.fn();
    const result = await pack(['root'], mockConfig, progressCallback, mockDeps);

    expect(mockDeps.searchFiles).toHaveBeenCalledWith('root', mockConfig);
    expect(mockDeps.collectFiles).toHaveBeenCalledWith(mockFilePaths, 'root', mockConfig, progressCallback);
    expect(mockDeps.validateFileSafety).toHaveBeenCalled();
    expect(mockDeps.processFiles).toHaveBeenCalled();
    expect(mockDeps.handleOutput).toHaveBeenCalled();
    expect(mockDeps.generateOutput).toHaveBeenCalled();
    expect(mockDeps.calculateMetrics).toHaveBeenCalled();

    expect(mockDeps.validateFileSafety).toHaveBeenCalledWith(mockRawFiles, progressCallback, mockConfig, undefined);
    expect(mockDeps.processFiles).toHaveBeenCalledWith(mockSafeRawFiles, mockConfig, progressCallback);
    expect(mockDeps.generateOutput).toHaveBeenCalledWith(
      ['root'],
      mockConfig,
      mockProcessedFiles,
      mockFilePaths,
      undefined,
    );
    expect(mockDeps.handleOutput).toHaveBeenCalledWith(mockOutput, mockConfig);
    expect(mockDeps.copyToClipboardIfEnabled).toHaveBeenCalledWith(mockOutput, progressCallback, mockConfig);
    expect(mockDeps.calculateMetrics).toHaveBeenCalledWith(
      mockProcessedFiles,
      mockOutput,
      progressCallback,
      mockConfig,
      undefined,
    );

    // Check the result of pack function
    expect(result.totalFiles).toBe(2);
    expect(result.totalCharacters).toBe(11);
    expect(result.totalTokens).toBe(10);
    expect(result.fileCharCounts).toEqual({
      'file1.txt': 19,
      [file2Path]: 19,
    });
    expect(result.fileTokenCounts).toEqual({
      'file1.txt': 10,
      [file2Path]: 10,
    });
  });
});
</file>

<file path="tests/integration-tests/packager.test.ts">
import fs from 'node:fs/promises';
import os from 'node:os';
import path from 'node:path';
import process from 'node:process';
import { afterEach, beforeEach, describe, expect, test } from 'vitest';
import { loadFileConfig, mergeConfigs } from '../../src/config/configLoad.js';
import type { RepomixConfigFile, RepomixConfigMerged, RepomixOutputStyle } from '../../src/config/configSchema.js';
import { collectFiles } from '../../src/core/file/fileCollect.js';
import { searchFiles } from '../../src/core/file/fileSearch.js';
import type { ProcessedFile } from '../../src/core/file/fileTypes.js';
import type { FileCollectTask } from '../../src/core/file/workers/fileCollectWorker.js';
import fileCollectWorker from '../../src/core/file/workers/fileCollectWorker.js';
import fileProcessWorker from '../../src/core/file/workers/fileProcessWorker.js';
import type { GitDiffResult } from '../../src/core/git/gitDiffHandle.js';
import { generateOutput } from '../../src/core/output/outputGenerate.js';
import { pack } from '../../src/core/packager.js';
import { copyToClipboardIfEnabled } from '../../src/core/packager/copyToClipboardIfEnabled.js';
import { writeOutputToDisk } from '../../src/core/packager/writeOutputToDisk.js';
import { filterOutUntrustedFiles } from '../../src/core/security/filterOutUntrustedFiles.js';
import { validateFileSafety } from '../../src/core/security/validateFileSafety.js';
import { isWindows } from '../testing/testUtils.js';

const fixturesDir = path.join(__dirname, 'fixtures', 'packager');
const inputsDir = path.join(fixturesDir, 'inputs');
const outputsDir = path.join(fixturesDir, 'outputs');

const mockCollectFileInitTaskRunner = () => {
  return async (task: FileCollectTask) => {
    return await fileCollectWorker(task);
  };
};

describe.runIf(!isWindows)('packager integration', () => {
  const testCases = [
    {
      desc: 'simple plain style',
      input: 'simple-project',
      output: 'simple-project-output.txt',
      config: {
        output: { style: 'plain', filePath: 'simple-project-output.txt' },
      },
    },
    {
      desc: 'simple xml style',
      input: 'simple-project',
      output: 'simple-project-output.xml',
      config: {
        output: { style: 'xml', filePath: 'simple-project-output.xml' },
      },
    },
    {
      desc: 'simple markdown style',
      input: 'simple-project',
      output: 'simple-project-output.md',
      config: {
        output: { style: 'markdown', filePath: 'simple-project-output.md' },
      },
    },
  ];

  let tempDir: string;

  beforeEach(async () => {
    // Create a temporary directory for each test
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'repomix-test-'));
  });

  afterEach(async () => {
    // Clean up the temporary directory after each test
    await fs.rm(tempDir, { recursive: true, force: true });
  });

  for (const { desc, input, output, config } of testCases) {
    test(`should correctly pack ${desc}`, async () => {
      const inputDir = path.join(inputsDir, input);
      const expectedOutputPath = path.join(outputsDir, output);
      const actualOutputPath = path.join(tempDir, output);

      const fileConfig: RepomixConfigFile = await loadFileConfig(inputDir, null);
      const mergedConfig: RepomixConfigMerged = mergeConfigs(process.cwd(), fileConfig, {
        output: {
          filePath: actualOutputPath,
          style: (config.output?.style || 'plain') as RepomixOutputStyle,
          git: { sortByChanges: false },
        },
      });

      // Run the pack function
      await pack([inputDir], mergedConfig, () => {}, {
        searchFiles,
        sortPaths: (filePaths) => filePaths,
        collectFiles: (filePaths, rootDir, config, progressCallback) => {
          return collectFiles(filePaths, rootDir, config, progressCallback, {
            initTaskRunner: mockCollectFileInitTaskRunner,
          });
        },
        processFiles: async (rawFiles, config, progressCallback) => {
          const processedFiles: ProcessedFile[] = [];
          for (const rawFile of rawFiles) {
            processedFiles.push(await fileProcessWorker({ rawFile, config }));
          }
          return processedFiles;
        },
        generateOutput,
        validateFileSafety: (rawFiles, progressCallback, config) => {
          const gitDiffMock: GitDiffResult = {
            workTreeDiffContent: '',
            stagedDiffContent: '',
          };
          return validateFileSafety(rawFiles, progressCallback, config, gitDiffMock, {
            runSecurityCheck: async () => [],
            filterOutUntrustedFiles,
          });
        },
        handleOutput: writeOutputToDisk,
        copyToClipboardIfEnabled,
        calculateMetrics: async (processedFiles, output, progressCallback, config, gitDiffResult) => {
          return {
            totalFiles: processedFiles.length,
            totalCharacters: processedFiles.reduce((acc, file) => acc + file.content.length, 0),
            totalTokens: processedFiles.reduce((acc, file) => acc + file.content.split(/\s+/).length, 0),
            gitDiffTokenCount: 0,
            fileCharCounts: processedFiles.reduce(
              (acc, file) => {
                acc[file.path] = file.content.length;
                return acc;
              },
              {} as Record<string, number>,
            ),
            fileTokenCounts: processedFiles.reduce(
              (acc, file) => {
                acc[file.path] = file.content.split(/\s+/).length;
                return acc;
              },
              {} as Record<string, number>,
            ),
            suspiciousFilesResults: [],
            suspiciousGitDiffResults: [],
          };
        },
      });

      // Read the actual and expected outputs
      const actualOutput = await fs.readFile(actualOutputPath, 'utf-8');
      const expectedOutput = await fs.readFile(expectedOutputPath, 'utf-8');

      // Compare the outputs - styles (e.g., XML, plain, markdown) may differ
      expect(actualOutput).toContain('This file is a merged representation of the entire codebase');

      // Common assertions for all styles
      expect(actualOutput).toContain('resources/');
      expect(actualOutput).toContain('src/');
      expect(actualOutput).toContain('This repository is simple-project');

      switch (config.output?.style) {
        case 'xml':
          expect(actualOutput).toContain('<file_summary>');
          expect(actualOutput).toContain('<user_provided_header>');
          expect(actualOutput).toContain('</user_provided_header>');
          expect(actualOutput).toContain('<directory_structure>');
          expect(actualOutput).toContain('<file path="src/index.js">');
          expect(actualOutput).toContain('function main() {');
          expect(actualOutput).toContain('<file path="src/utils.js">');
          expect(actualOutput).toContain('function greet(name) {');
          break;

        case 'markdown':
          expect(actualOutput).toContain('# File Summary');
          expect(actualOutput).toContain('# User Provided Header');
          expect(actualOutput).toContain('# Directory Structure');
          expect(actualOutput).toContain('## File: src/index.js');
          expect(actualOutput).toContain('````javascript\nconst { greet }');
          expect(actualOutput).toContain('## File: src/utils.js');
          expect(actualOutput).toContain('````javascript\nfunction greet(name) {');
          break;

        case 'plain':
          expect(actualOutput).toContain('File Summary');
          expect(actualOutput).toContain('User Provided Header');
          expect(actualOutput).toContain('Directory Structure');
          expect(actualOutput).toContain('File: src/index.js');
          expect(actualOutput).toContain('function main() {');
          expect(actualOutput).toContain('File: src/utils.js');
          expect(actualOutput).toContain('function greet(name) {');
          break;

        default:
          throw new Error(`Unsupported style: ${config.output?.style}`);
      }

      // Optionally, update the expected output if explicitly requested
      if (process.env.UPDATE_EXPECTED_OUTPUT) {
        await fs.writeFile(expectedOutputPath, actualOutput);
        console.log(`Updated expected output for ${desc}`);
      }
    });
  }
});
</file>

<file path="tests/mcp/prompts/packRemoteRepositoryPrompts.test.ts">
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { registerPackRemoteRepositoryPrompt } from '../../../src/mcp/prompts/packRemoteRepositoryPrompts.js';

describe('packRemoteRepositoryPrompts', () => {
  const mockMcpServer = {
    prompt: vi.fn(),
  };

  type PromptHandlerType = (args: {
    repository: string;
    includePatterns?: string;
    ignorePatterns?: string;
  }) => Promise<{ messages: Array<{ role: string; content: { type: string; text: string } }> }>;

  let promptHandler: PromptHandlerType;

  beforeEach(() => {
    vi.resetAllMocks();

    registerPackRemoteRepositoryPrompt(mockMcpServer as unknown as McpServer);

    promptHandler = mockMcpServer.prompt.mock.calls[0][3];
  });

  it('should register the prompt with correct parameters', () => {
    expect(mockMcpServer.prompt).toHaveBeenCalledWith(
      'pack_remote_repository',
      expect.any(String),
      expect.objectContaining({
        repository: expect.any(Object),
        includePatterns: expect.any(Object),
        ignorePatterns: expect.any(Object),
      }),
      expect.any(Function),
    );
  });

  it('should generate a prompt with repository only', async () => {
    const result = await promptHandler({ repository: 'user/repo' });

    expect(result).toHaveProperty('messages');
    expect(result.messages).toHaveLength(1);
    expect(result.messages[0].role).toBe('user');
    expect(result.messages[0].content.type).toBe('text');
    expect(result.messages[0].content.text).toContain('Please analyze the GitHub repository at user/repo');
    expect(result.messages[0].content.text).toContain('- repository: "user/repo"');
    expect(result.messages[0].content.text).not.toContain('- includePatterns:');
    expect(result.messages[0].content.text).not.toContain('- ignorePatterns:');
  });

  it('should include includePatterns when provided', async () => {
    const result = await promptHandler({
      repository: 'user/repo',
      includePatterns: 'src/**,lib/**',
    });

    expect(result.messages[0].content.text).toContain('- includePatterns: "src/**,lib/**"');
    expect(result.messages[0].content.text).not.toContain('- ignorePatterns:');
  });

  it('should include ignorePatterns when provided', async () => {
    const result = await promptHandler({
      repository: 'user/repo',
      ignorePatterns: '**/*.test.js,**/*.spec.js',
    });

    expect(result.messages[0].content.text).toContain('- ignorePatterns: "**/*.test.js,**/*.spec.js"');
    expect(result.messages[0].content.text).not.toContain('- includePatterns:');
  });

  it('should include both patterns when provided', async () => {
    const result = await promptHandler({
      repository: 'user/repo',
      includePatterns: 'src/**,lib/**',
      ignorePatterns: '**/*.test.js,**/*.spec.js',
    });

    expect(result.messages[0].content.text).toContain('- includePatterns: "src/**,lib/**"');
    expect(result.messages[0].content.text).toContain('- ignorePatterns: "**/*.test.js,**/*.spec.js"');
  });
});
</file>

<file path="tests/mcp/tools/fileSystemReadDirectoryTool.test.ts">
import { promises as fs } from 'node:fs';
import type { Dirent, Stats } from 'node:fs';
import path from 'node:path';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { registerFileSystemReadDirectoryTool } from '../../../src/mcp/tools/fileSystemReadDirectoryTool.js';
import { logger } from '../../../src/shared/logger.js';

vi.mock('node:fs');
vi.mock('node:path');
vi.mock('../../../src/shared/logger.js');

describe('FileSystemReadDirectoryTool', () => {
  const mockServer = {
    tool: vi.fn().mockReturnThis(),
  } as unknown as McpServer;

  let toolHandler: (args: { path: string }) => Promise<CallToolResult>;

  beforeEach(() => {
    vi.resetAllMocks();
    registerFileSystemReadDirectoryTool(mockServer);
    toolHandler = (mockServer.tool as ReturnType<typeof vi.fn>).mock.calls[0][4];

    // デフォルトのpath.isAbsoluteの動作をモック
    vi.mocked(path.isAbsolute).mockImplementation((p: string) => p.startsWith('/'));
  });

  test('should register tool with correct parameters', () => {
    expect(mockServer.tool).toHaveBeenCalledWith(
      'file_system_read_directory',
      'List the contents of a directory using an absolute path. Returns a formatted list showing files and subdirectories with clear [FILE]/[DIR] indicators. Useful for exploring project structure and understanding codebase organization.',
      expect.any(Object),
      expect.any(Object), // annotations
      expect.any(Function),
    );
  });

  test('should handle relative path error', async () => {
    const testPath = 'relative/path';
    vi.mocked(path.isAbsolute).mockReturnValue(false);

    const result = await toolHandler({ path: testPath });

    expect(result).toEqual({
      isError: true,
      content: [
        {
          type: 'text',
          text: `Error: Path must be absolute. Received: ${testPath}`,
        },
      ],
    });
  });

  test('should handle non-existent directory', async () => {
    const testPath = '/non/existent/dir';
    vi.mocked(path.isAbsolute).mockReturnValue(true);
    vi.mocked(fs.access).mockRejectedValue(new Error('ENOENT'));

    const result = await toolHandler({ path: testPath });

    expect(result).toEqual({
      isError: true,
      content: [
        {
          type: 'text',
          text: `Error: Directory not found at path: ${testPath}`,
        },
      ],
    });
  });
});
</file>

<file path="tests/mcp/tools/fileSystemReadFileTool.test.ts">
import { promises as fs } from 'node:fs';
import type { Stats } from 'node:fs';
import path from 'node:path';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { runSecretLint } from '../../../src/core/security/workers/securityCheckWorker.js';
import { registerFileSystemReadFileTool } from '../../../src/mcp/tools/fileSystemReadFileTool.js';
import { logger } from '../../../src/shared/logger.js';

vi.mock('node:fs');
vi.mock('node:path');
vi.mock('../../../src/shared/logger.js');
vi.mock('../../../src/core/security/workers/securityCheckWorker.js');

describe('FileSystemReadFileTool', () => {
  const mockServer = {
    tool: vi.fn().mockReturnThis(),
  } as unknown as McpServer;

  let toolHandler: (args: { path: string }) => Promise<CallToolResult>;

  beforeEach(() => {
    vi.resetAllMocks();
    registerFileSystemReadFileTool(mockServer);
    toolHandler = (mockServer.tool as ReturnType<typeof vi.fn>).mock.calls[0][4];

    // デフォルトのpath.isAbsoluteの動作をモック
    vi.mocked(path.isAbsolute).mockImplementation((p: string) => p.startsWith('/'));
  });

  test('should register tool with correct parameters', () => {
    expect(mockServer.tool).toHaveBeenCalledWith(
      'file_system_read_file',
      'Read a file from the local file system using an absolute path. Includes built-in security validation to detect and prevent access to files containing sensitive information (API keys, passwords, secrets).',
      expect.any(Object),
      expect.any(Object), // annotations
      expect.any(Function),
    );
  });

  test('should handle relative path error', async () => {
    const testPath = 'relative/path.txt';
    vi.mocked(path.isAbsolute).mockReturnValue(false);

    const result = await toolHandler({ path: testPath });

    expect(result).toEqual({
      isError: true,
      content: [
        {
          type: 'text',
          text: `Error: Path must be absolute. Received: ${testPath}`,
        },
      ],
    });
  });

  test('should handle non-existent file', async () => {
    const testPath = '/non/existent/file.txt';
    vi.mocked(path.isAbsolute).mockReturnValue(true);
    vi.mocked(fs.access).mockRejectedValue(new Error('ENOENT'));

    const result = await toolHandler({ path: testPath });

    expect(result).toEqual({
      isError: true,
      content: [
        {
          type: 'text',
          text: `Error: File not found at path: ${testPath}`,
        },
      ],
    });
  });
});
</file>

<file path="tests/mcp/tools/grepRepomixOutputTool.test.ts">
import fs from 'node:fs/promises';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import {
  createRegexPattern,
  formatSearchResults,
  performGrepSearch,
  registerGrepRepomixOutputTool,
  searchInContent,
} from '../../../src/mcp/tools/grepRepomixOutputTool.js';
import * as mcpToolRuntime from '../../../src/mcp/tools/mcpToolRuntime.js';

vi.mock('node:fs/promises');
vi.mock('../../../src/shared/logger.js');
vi.mock('../../../src/mcp/tools/mcpToolRuntime.js', async () => {
  const actual = await vi.importActual('../../../src/mcp/tools/mcpToolRuntime.js');
  return {
    ...actual,
    getOutputFilePath: vi.fn(),
  };
});

/**
 * Search options for grep functionality
 */
interface SearchOptions {
  pattern: string;
  contextLines: number;
  beforeLines: number;
  afterLines: number;
  ignoreCase: boolean;
}

describe('grepRepomixOutputTool', () => {
  describe('createRegexPattern', () => {
    it('should create a case-sensitive regex by default', () => {
      const regex = createRegexPattern('test', false);
      expect(regex.flags).toBe('g');
      expect(regex.source).toBe('test');
    });

    it('should create a case-insensitive regex when specified', () => {
      const regex = createRegexPattern('test', true);
      expect(regex.flags).toBe('gi');
      expect(regex.source).toBe('test');
    });

    it('should throw error for invalid regex patterns', () => {
      expect(() => createRegexPattern('[invalid', false)).toThrow('Invalid regular expression pattern');
    });

    it('should use dependency injection for RegExp', () => {
      const mockRegExp = vi.fn().mockReturnValue(/test/g) as unknown as RegExpConstructor;
      createRegexPattern('test', false, { RegExp: mockRegExp });
      expect(mockRegExp).toHaveBeenCalledWith('test', 'g');
    });
  });

  describe('searchInContent', () => {
    it('should find matches in content', () => {
      const content = 'line 1\npattern match\nline 3\nanother pattern\nline 5';
      const options = { pattern: 'pattern', contextLines: 0, beforeLines: 0, afterLines: 0, ignoreCase: false };

      const matches = searchInContent(content, options);

      expect(matches).toHaveLength(2);
      expect(matches[0]).toEqual({
        lineNumber: 2,
        line: 'pattern match',
        matchedText: 'pattern',
      });
      expect(matches[1]).toEqual({
        lineNumber: 4,
        line: 'another pattern',
        matchedText: 'pattern',
      });
    });

    it('should handle case-insensitive search', () => {
      const content = 'Line 1\nPATTERN match\nline 3';
      const options = { pattern: 'pattern', contextLines: 0, beforeLines: 0, afterLines: 0, ignoreCase: true };

      const matches = searchInContent(content, options);

      expect(matches).toHaveLength(1);
      expect(matches[0]).toEqual({
        lineNumber: 2,
        line: 'PATTERN match',
        matchedText: 'PATTERN',
      });
    });

    it('should return empty array when no matches found', () => {
      const content = 'line 1\nline 2\nline 3';
      const options = { pattern: 'notfound', contextLines: 0, beforeLines: 0, afterLines: 0, ignoreCase: false };

      const matches = searchInContent(content, options);

      expect(matches).toHaveLength(0);
    });

    it('should use dependency injection for regex creation', () => {
      const mockCreateRegexPattern = vi.fn().mockReturnValue(/test/g);
      const content = 'test content';
      const options = { pattern: 'test', contextLines: 0, beforeLines: 0, afterLines: 0, ignoreCase: false };

      searchInContent(content, options, { createRegexPattern: mockCreateRegexPattern });

      expect(mockCreateRegexPattern).toHaveBeenCalledWith('test', false);
    });

    it('should handle Japanese text search', () => {
      const content = '最初の行\n日本語のパターン検索\n3行目\n別の日本語パターン\n最後の行';
      const options = { pattern: '日本語', contextLines: 0, beforeLines: 0, afterLines: 0, ignoreCase: false };

      const matches = searchInContent(content, options);

      expect(matches).toHaveLength(2);
      expect(matches[0]).toEqual({
        lineNumber: 2,
        line: '日本語のパターン検索',
        matchedText: '日本語',
      });
      expect(matches[1]).toEqual({
        lineNumber: 4,
        line: '別の日本語パターン',
        matchedText: '日本語',
      });
    });

    it('should handle Chinese text search', () => {
      const content = '第一行\n中文搜索模式\n第三行\n另一个中文模式\n最后一行';
      const options = { pattern: '中文', contextLines: 0, beforeLines: 0, afterLines: 0, ignoreCase: false };

      const matches = searchInContent(content, options);

      expect(matches).toHaveLength(2);
      expect(matches[0]).toEqual({
        lineNumber: 2,
        line: '中文搜索模式',
        matchedText: '中文',
      });
      expect(matches[1]).toEqual({
        lineNumber: 4,
        line: '另一个中文模式',
        matchedText: '中文',
      });
    });

    it('should handle Korean text search', () => {
      const content = '첫 번째 줄\n한국어 패턴 검색\n세 번째 줄\n다른 한국어 패턴\n마지막 줄';
      const options = { pattern: '한국어', contextLines: 0, beforeLines: 0, afterLines: 0, ignoreCase: false };

      const matches = searchInContent(content, options);

      expect(matches).toHaveLength(2);
      expect(matches[0]).toEqual({
        lineNumber: 2,
        line: '한국어 패턴 검색',
        matchedText: '한국어',
      });
      expect(matches[1]).toEqual({
        lineNumber: 4,
        line: '다른 한국어 패턴',
        matchedText: '한국어',
      });
    });

    it('should handle emoji search', () => {
      const content = 'line 1\n🎉 celebration emoji\nline 3\nanother 🎉 here\nline 5';
      const options = { pattern: '🎉', contextLines: 0, beforeLines: 0, afterLines: 0, ignoreCase: false };

      const matches = searchInContent(content, options);

      expect(matches).toHaveLength(2);
      expect(matches[0]).toEqual({
        lineNumber: 2,
        line: '🎉 celebration emoji',
        matchedText: '🎉',
      });
      expect(matches[1]).toEqual({
        lineNumber: 4,
        line: 'another 🎉 here',
        matchedText: '🎉',
      });
    });

    it('should handle mixed multilingual content', () => {
      const content = 'English line\n日本語とEnglishの混在\n中文和English混合\n🚀 emoji with text\nNormal line';
      const options = { pattern: 'English', contextLines: 0, beforeLines: 0, afterLines: 0, ignoreCase: false };

      const matches = searchInContent(content, options);

      expect(matches).toHaveLength(3);
      expect(matches[0]).toEqual({
        lineNumber: 1,
        line: 'English line',
        matchedText: 'English',
      });
      expect(matches[1]).toEqual({
        lineNumber: 2,
        line: '日本語とEnglishの混在',
        matchedText: 'English',
      });
      expect(matches[2]).toEqual({
        lineNumber: 3,
        line: '中文和English混合',
        matchedText: 'English',
      });
    });

    it('should handle special characters and symbols', () => {
      const content = 'line 1\n$special #symbols @test\nline 3\n&more $special chars\nline 5';
      const options = { pattern: '\\$special', contextLines: 0, beforeLines: 0, afterLines: 0, ignoreCase: false };

      const matches = searchInContent(content, options);

      expect(matches).toHaveLength(2);
      expect(matches[0]).toEqual({
        lineNumber: 2,
        line: '$special #symbols @test',
        matchedText: '$special',
      });
      expect(matches[1]).toEqual({
        lineNumber: 4,
        line: '&more $special chars',
        matchedText: '$special',
      });
    });

    it('should handle regex patterns with Unicode', () => {
      const content = 'file1.js\nファイル1.ts\nfile2.py\nファイル2.jsx\ntest.md';
      const options = {
        pattern: 'ファイル\\d+\\.(ts|jsx)',
        contextLines: 0,
        beforeLines: 0,
        afterLines: 0,
        ignoreCase: false,
      };

      const matches = searchInContent(content, options);

      expect(matches).toHaveLength(2);
      expect(matches[0]).toEqual({
        lineNumber: 2,
        line: 'ファイル1.ts',
        matchedText: 'ファイル1.ts',
      });
      expect(matches[1]).toEqual({
        lineNumber: 4,
        line: 'ファイル2.jsx',
        matchedText: 'ファイル2.jsx',
      });
    });

    it('should handle case-insensitive search with multibyte characters', () => {
      const content = '日本語テスト\nNIPPON語test\n中文测试\nTEST中文';
      const options = { pattern: 'test', contextLines: 0, beforeLines: 0, afterLines: 0, ignoreCase: true };

      const matches = searchInContent(content, options);

      expect(matches).toHaveLength(2);
      expect(matches[0]).toEqual({
        lineNumber: 2,
        line: 'NIPPON語test',
        matchedText: 'test',
      });
      expect(matches[1]).toEqual({
        lineNumber: 4,
        line: 'TEST中文',
        matchedText: 'TEST',
      });
    });

    it('should handle complex Unicode regex patterns', () => {
      const content = 'user@example.com\nユーザー@例.jp\ntest@テスト.org\n管理者@サンプル.co.jp\nnormal text';
      const options = {
        pattern: '.+@.+\\.(com|jp|org)',
        contextLines: 0,
        beforeLines: 0,
        afterLines: 0,
        ignoreCase: false,
      };

      const matches = searchInContent(content, options);

      expect(matches).toHaveLength(4);
      expect(matches[0].line).toBe('user@example.com');
      expect(matches[1].line).toBe('ユーザー@例.jp');
      expect(matches[2].line).toBe('test@テスト.org');
      expect(matches[3].line).toBe('管理者@サンプル.co.jp');
    });
  });

  describe('formatSearchResults', () => {
    const lines = ['line 1', 'pattern match', 'line 3', 'another pattern', 'line 5'];
    const matches = [
      { lineNumber: 2, line: 'pattern match', matchedText: 'pattern' },
      { lineNumber: 4, line: 'another pattern', matchedText: 'pattern' },
    ];

    it('should format results without context lines', () => {
      const result = formatSearchResults(lines, matches, 0, 0);

      expect(result).toEqual(['2:pattern match', '--', '4:another pattern']);
    });

    it('should format results with equal before and after context lines', () => {
      const result = formatSearchResults(lines, matches, 1, 1);

      expect(result).toEqual(['1-line 1', '2:pattern match', '3-line 3', '--', '4:another pattern', '5-line 5']);
    });

    it('should format results with different before and after context lines', () => {
      const result = formatSearchResults(lines, matches, 1, 0);

      expect(result).toEqual(['1-line 1', '2:pattern match', '--', '3-line 3', '4:another pattern']);
    });

    it('should format results with only after context lines', () => {
      const result = formatSearchResults(lines, matches, 0, 1);

      expect(result).toEqual(['2:pattern match', '3-line 3', '--', '4:another pattern', '5-line 5']);
    });

    it('should format results with more before than after context lines', () => {
      const extendedLines = ['line 0', 'line 1', 'pattern match', 'line 3', 'another pattern', 'line 5', 'line 6'];
      const extendedMatches = [
        { lineNumber: 3, line: 'pattern match', matchedText: 'pattern' },
        { lineNumber: 5, line: 'another pattern', matchedText: 'pattern' },
      ];

      const result = formatSearchResults(extendedLines, extendedMatches, 2, 1);

      expect(result).toEqual([
        '1-line 0',
        '2-line 1',
        '3:pattern match',
        '4-line 3',
        '--',
        '5:another pattern',
        '6-line 5',
      ]);
    });

    it('should return empty array for no matches', () => {
      const result = formatSearchResults(lines, [], 0, 0);
      expect(result).toEqual([]);
    });

    it('should handle overlapping context correctly', () => {
      const closeMatches = [
        { lineNumber: 2, line: 'pattern match', matchedText: 'pattern' },
        { lineNumber: 3, line: 'line 3', matchedText: 'line' },
      ];

      const result = formatSearchResults(lines, closeMatches, 1, 1);

      // Should not duplicate lines and should merge overlapping contexts
      expect(result).toEqual(['1-line 1', '2:pattern match', '3-line 3', '4-another pattern']);
    });
  });

  describe('performGrepSearch', () => {
    it('should perform complete grep search and return formatted results', () => {
      const content = 'line 1\npattern match\nline 3\nanother pattern\nline 5';
      const options = { pattern: 'pattern', contextLines: 1, beforeLines: 1, afterLines: 1, ignoreCase: false };

      const result = performGrepSearch(content, options);

      expect(result.matches).toHaveLength(2);
      expect(result.formattedOutput).toContain('2:pattern match');
      expect(result.formattedOutput).toContain('4:another pattern');
      expect(result.formattedOutput).toContain('1-line 1');
      expect(result.formattedOutput).toContain('3-line 3');
    });

    it('should use dependency injection for search functions', () => {
      const mockSearchInContent = vi.fn().mockReturnValue([]);
      const mockFormatSearchResults = vi.fn().mockReturnValue(['formatted']);
      const content = 'test content';
      const options = { pattern: 'test', contextLines: 0, beforeLines: 0, afterLines: 0, ignoreCase: false };

      const result = performGrepSearch(content, options, {
        searchInContent: mockSearchInContent,
        formatSearchResults: mockFormatSearchResults,
      });

      expect(mockSearchInContent).toHaveBeenCalledWith(content, options);
      expect(mockFormatSearchResults).toHaveBeenCalledWith(['test content'], [], 0, 0);
      expect(result.formattedOutput).toEqual(['formatted']);
    });

    it('should handle different before and after context lines', () => {
      const content = 'line 1\nline 2\npattern match\nline 4\nline 5';
      const options = { pattern: 'pattern', contextLines: 0, beforeLines: 2, afterLines: 1, ignoreCase: false };

      const result = performGrepSearch(content, options);

      expect(result.matches).toHaveLength(1);
      expect(result.formattedOutput).toContain('1-line 1');
      expect(result.formattedOutput).toContain('2-line 2');
      expect(result.formattedOutput).toContain('3:pattern match');
      expect(result.formattedOutput).toContain('4-line 4');
      expect(result.formattedOutput).not.toContain('5-line 5');
    });
  });

  describe('registerGrepRepomixOutputTool integration tests', () => {
    const mockMcpServer = {
      tool: vi.fn(),
    } as const;

    type ToolHandlerType = (args: {
      outputId: string;
      pattern: string;
      contextLines?: number;
      beforeLines?: number;
      afterLines?: number;
      ignoreCase?: boolean;
    }) => Promise<{
      isError?: boolean;
      content: Array<{ type: string; text: string }>;
    }>;

    let toolHandler: ToolHandlerType;

    beforeEach(() => {
      vi.resetAllMocks();

      registerGrepRepomixOutputTool(mockMcpServer as unknown as McpServer);

      toolHandler = mockMcpServer.tool.mock.calls[0][4];
    });

    it('should register the tool with correct parameters', () => {
      expect(mockMcpServer.tool).toHaveBeenCalledWith(
        'grep_repomix_output',
        expect.any(String),
        expect.objectContaining({
          outputId: expect.any(Object),
          pattern: expect.any(Object),
          contextLines: expect.any(Object),
          beforeLines: expect.any(Object),
          afterLines: expect.any(Object),
          ignoreCase: expect.any(Object),
        }),
        expect.objectContaining({
          title: 'Grep Repomix Output',
          readOnlyHint: true,
          destructiveHint: false,
          idempotentHint: true,
          openWorldHint: false,
        }),
        expect.any(Function),
      );
    });

    it('should find matches and return them with line numbers', async () => {
      vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(fs.readFile).mockResolvedValue(
        'line 1\npattern match\nline 3\nanother pattern\nline 5' as unknown as Buffer,
      );

      const result = await toolHandler({ outputId: 'test-id', pattern: 'pattern' });

      expect(result.isError).toBeUndefined();
      expect(result.content).toHaveLength(2);
      expect(result.content[0].text).toContain('Found 2 match(es)');
      expect(result.content[1].text).toContain('2:pattern match');
      expect(result.content[1].text).toContain('4:another pattern');
    });

    it('should handle separate before and after context lines', async () => {
      vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(fs.readFile).mockResolvedValue(
        'line 1\nline 2\npattern match\nline 4\nline 5\nline 6' as unknown as Buffer,
      );

      const result = await toolHandler({
        outputId: 'test-id',
        pattern: 'pattern',
        beforeLines: 2,
        afterLines: 1,
      });

      expect(result.content[1].text).toContain('1-line 1');
      expect(result.content[1].text).toContain('2-line 2');
      expect(result.content[1].text).toContain('3:pattern match');
      expect(result.content[1].text).toContain('4-line 4');
      expect(result.content[1].text).not.toContain('5-line 5');
    });

    it('should prioritize beforeLines and afterLines over contextLines', async () => {
      vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(fs.readFile).mockResolvedValue('line 1\nline 2\npattern match\nline 4\nline 5' as unknown as Buffer);

      const result = await toolHandler({
        outputId: 'test-id',
        pattern: 'pattern',
        contextLines: 2,
        beforeLines: 1,
        afterLines: 0,
      });

      expect(result.content[1].text).toContain('2-line 2');
      expect(result.content[1].text).toContain('3:pattern match');
      expect(result.content[1].text).not.toContain('1-line 1');
      expect(result.content[1].text).not.toContain('4-line 4');
    });

    it('should use contextLines when beforeLines and afterLines are not specified', async () => {
      vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(fs.readFile).mockResolvedValue('line 1\nline 2\npattern match\nline 4\nline 5' as unknown as Buffer);

      const result = await toolHandler({ outputId: 'test-id', pattern: 'pattern', contextLines: 1 });

      expect(result.content[1].text).toContain('2-line 2');
      expect(result.content[1].text).toContain('3:pattern match');
      expect(result.content[1].text).toContain('4-line 4');
    });

    it('should handle case insensitive search', async () => {
      vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(fs.readFile).mockResolvedValue('Line 1\nPATTERN match\nline 3' as unknown as Buffer);

      const result = await toolHandler({ outputId: 'test-id', pattern: 'pattern', ignoreCase: true });

      expect(result.content[1].text).toContain('2:PATTERN match');
    });

    it('should return no matches message when pattern not found', async () => {
      vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(fs.readFile).mockResolvedValue('line 1\nline 2\nline 3' as unknown as Buffer);

      const result = await toolHandler({ outputId: 'test-id', pattern: 'notfound' });

      expect(result.content[0].text).toContain('No matches found');
    });

    it('should handle invalid regex patterns', async () => {
      vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(fs.readFile).mockResolvedValue('some content' as unknown as Buffer);

      const result = await toolHandler({ outputId: 'test-id', pattern: '[invalid' });

      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain('Invalid regular expression pattern');
    });

    it('should handle file not found error', async () => {
      vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue(undefined);

      const result = await toolHandler({ outputId: 'test-id', pattern: 'test' });

      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain('Output file with ID test-id not found');
    });

    it('should handle file access error', async () => {
      vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
      vi.mocked(fs.access).mockRejectedValue(new Error('File not accessible'));

      const result = await toolHandler({ outputId: 'test-id', pattern: 'test' });

      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain('Output file does not exist');
    });

    // Multilingual and Unicode content integration tests
    it('should handle Japanese text in file content', async () => {
      vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(fs.readFile).mockResolvedValue(
        '最初の行\n日本語のパターン\n3行目\n別の日本語\n最後の行' as unknown as Buffer,
      );

      const result = await toolHandler({ outputId: 'test-id', pattern: '日本語' });

      expect(result.isError).toBeUndefined();
      expect(result.content).toHaveLength(2);
      expect(result.content[0].text).toContain('Found 2 match(es)');
      expect(result.content[1].text).toContain('2:日本語のパターン');
      expect(result.content[1].text).toContain('4:別の日本語');
    });

    it('should handle Chinese text in file content', async () => {
      vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(fs.readFile).mockResolvedValue('第一行\n中文搜索\n第三行\n更多中文\n最后一行' as unknown as Buffer);

      const result = await toolHandler({ outputId: 'test-id', pattern: '中文' });

      expect(result.isError).toBeUndefined();
      expect(result.content).toHaveLength(2);
      expect(result.content[0].text).toContain('Found 2 match(es)');
      expect(result.content[1].text).toContain('2:中文搜索');
      expect(result.content[1].text).toContain('4:更多中文');
    });

    it('should handle Korean text in file content', async () => {
      vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(fs.readFile).mockResolvedValue(
        '첫 번째 줄\n한국어 검색\n세 번째 줄\n다른 한국어\n마지막 줄' as unknown as Buffer,
      );

      const result = await toolHandler({ outputId: 'test-id', pattern: '한국어' });

      expect(result.isError).toBeUndefined();
      expect(result.content).toHaveLength(2);
      expect(result.content[0].text).toContain('Found 2 match(es)');
      expect(result.content[1].text).toContain('2:한국어 검색');
      expect(result.content[1].text).toContain('4:다른 한국어');
    });

    it('should handle emoji content in file', async () => {
      vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(fs.readFile).mockResolvedValue(
        'line 1\n🎉 celebration\nline 3\n🚀 rocket emoji\nline 5' as unknown as Buffer,
      );

      const result = await toolHandler({ outputId: 'test-id', pattern: '🎉|🚀' });

      expect(result.isError).toBeUndefined();
      expect(result.content).toHaveLength(2);
      expect(result.content[0].text).toContain('Found 2 match(es)');
      expect(result.content[1].text).toContain('2:🎉 celebration');
      expect(result.content[1].text).toContain('4:🚀 rocket emoji');
    });

    it('should handle mixed multilingual content in file', async () => {
      vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(fs.readFile).mockResolvedValue(
        'English line\n日本語とEnglish混在\n中文和English混合\n🌟 mixed content\nनमस्ते English' as unknown as Buffer,
      );

      const result = await toolHandler({ outputId: 'test-id', pattern: 'English', contextLines: 1 });

      expect(result.isError).toBeUndefined();
      expect(result.content).toHaveLength(2);
      expect(result.content[0].text).toContain('Found 4 match(es)');
      expect(result.content[1].text).toContain('1:English line');
      expect(result.content[1].text).toContain('2-日本語とEnglish混在');
      expect(result.content[1].text).toContain('3-中文和English混合');
      expect(result.content[1].text).toContain('5:नमस्ते English');
    });

    it('should handle complex Unicode regex patterns in file content', async () => {
      vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(fs.readFile).mockResolvedValue(
        'user@example.com\nユーザー@例.jp\ntest@テスト.org\n管理者@サンプル.co.jp\nnormal text' as unknown as Buffer,
      );

      const result = await toolHandler({ outputId: 'test-id', pattern: '.+@.+\\.(com|jp|org)' });

      expect(result.isError).toBeUndefined();
      expect(result.content).toHaveLength(2);
      expect(result.content[0].text).toContain('Found 4 match(es)');
      expect(result.content[1].text).toContain('1:user@example.com');
      expect(result.content[1].text).toContain('2:ユーザー@例.jp');
      expect(result.content[1].text).toContain('3:test@テスト.org');
      expect(result.content[1].text).toContain('4:管理者@サンプル.co.jp');
    });

    it('should handle special characters with escaping in file content', async () => {
      vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(fs.readFile).mockResolvedValue(
        'normal line\n$special chars #symbols\nline 3\n&more $special items\nend line' as unknown as Buffer,
      );

      const result = await toolHandler({ outputId: 'test-id', pattern: '\\$special', contextLines: 1 });

      expect(result.isError).toBeUndefined();
      expect(result.content).toHaveLength(2);
      expect(result.content[0].text).toContain('Found 2 match(es)');
      expect(result.content[1].text).toContain('2:$special chars #symbols');
      expect(result.content[1].text).toContain('4:&more $special items');
    });

    it('should handle case-insensitive search with multibyte characters in file', async () => {
      vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
      vi.mocked(fs.access).mockResolvedValue(undefined);
      vi.mocked(fs.readFile).mockResolvedValue(
        '日本語テスト\nNIPPON語test\n中文测试\nTEST中文\nnormal' as unknown as Buffer,
      );

      const result = await toolHandler({ outputId: 'test-id', pattern: 'test', ignoreCase: true });

      expect(result.isError).toBeUndefined();
      expect(result.content).toHaveLength(2);
      expect(result.content[0].text).toContain('Found 2 match(es)');
      expect(result.content[1].text).toContain('2:NIPPON語test');
      expect(result.content[1].text).toContain('4:TEST中文');
    });
  });
});
</file>

<file path="tests/mcp/tools/mcpToolRuntime.test.ts">
import crypto from 'node:crypto';
import fs from 'node:fs/promises';
import os from 'node:os';
import path from 'node:path';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import {
  buildMcpToolErrorResponse,
  buildMcpToolSuccessResponse,
  createToolWorkspace,
  formatToolError,
  formatToolResponse,
  generateOutputId,
  getOutputFilePath,
  registerOutputFile,
} from '../../../src/mcp/tools/mcpToolRuntime.js';

vi.mock('node:fs/promises');
vi.mock('node:path');
vi.mock('node:os');
vi.mock('node:crypto');

describe('mcpToolRuntime', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  describe('registerOutputFile and getOutputFilePath', () => {
    it('should register and retrieve output file paths', () => {
      const id = 'test-id';
      const filePath = '/path/to/file.txt';

      registerOutputFile(id, filePath);
      const retrievedPath = getOutputFilePath(id);

      expect(retrievedPath).toBe(filePath);
    });

    it('should return undefined for non-existent output ID', () => {
      const retrievedPath = getOutputFilePath('non-existent-id');
      expect(retrievedPath).toBeUndefined();
    });
  });

  describe('createToolWorkspace', () => {
    beforeEach(() => {
      vi.mocked(os.tmpdir).mockReturnValue('/tmp');
      vi.mocked(path.join).mockImplementation((...args) => args.join('/'));
      vi.mocked(fs.mkdir).mockResolvedValue(undefined);
      vi.mocked(fs.mkdtemp).mockResolvedValue('/tmp/repomix/mcp-outputs/temp-dir');
    });

    it('should create a temporary directory for tool operations', async () => {
      const tempDir = await createToolWorkspace();

      expect(os.tmpdir).toHaveBeenCalled();
      expect(path.join).toHaveBeenCalledWith('/tmp', 'repomix', 'mcp-outputs');
      expect(fs.mkdir).toHaveBeenCalledWith('/tmp/repomix/mcp-outputs', { recursive: true });
      expect(fs.mkdtemp).toHaveBeenCalledWith('/tmp/repomix/mcp-outputs/');
      expect(tempDir).toBe('/tmp/repomix/mcp-outputs/temp-dir');
    });

    it('should throw an error if directory creation fails', async () => {
      const error = new Error('Failed to create directory');
      vi.mocked(fs.mkdir).mockRejectedValue(error);

      await expect(createToolWorkspace()).rejects.toThrow(
        'Failed to create temporary directory: Failed to create directory',
      );
    });
  });

  describe('generateOutputId', () => {
    it('should generate a unique output ID', () => {
      vi.mocked(crypto.randomBytes).mockImplementation(() => ({
        toString: () => 'abcdef1234567890',
      }));

      const outputId = generateOutputId();

      expect(crypto.randomBytes).toHaveBeenCalledWith(8);
      expect(outputId).toBe('abcdef1234567890');
    });
  });

  describe('formatToolResponse', () => {
    beforeEach(() => {
      vi.mocked(crypto.randomBytes).mockImplementation(() => ({
        toString: () => 'abcdef1234567890',
      }));
      vi.mocked(fs.readFile).mockResolvedValue('Line 1\nLine 2\nLine 3\nLine 4\nLine 5' as unknown as Buffer);
    });

    it('should format a tool response with directory context', async () => {
      const context = { directory: '/path/to/dir' };
      const metrics = {
        totalFiles: 10,
        totalCharacters: 1000,
        totalTokens: 200,
        totalLines: 0, // Will be calculated in formatToolResponse
        fileCharCounts: {
          'file1.js': 500,
          'file2.js': 300,
          'file3.js': 200,
        },
        fileTokenCounts: {
          'file1.js': 100,
          'file2.js': 60,
          'file3.js': 40,
        },
        processedFiles: [],
        safeFilePaths: [],
      };
      const outputFilePath = '/path/to/output.xml';

      const response = await formatToolResponse(context, metrics, outputFilePath);

      expect(response).toHaveProperty('content');
      expect(response.content).toHaveLength(6);
      expect(response.content[0].type).toBe('text');
      expect(response.content[1].type).toBe('text');
      expect(response.content[1].text).toContain('"directory": "/path/to/dir"');
      expect(response.content[1].text).toContain('"outputId": "abcdef1234567890"');
      expect(response.content[1].text).toContain('"totalFiles": 10');
      expect(response.content[1].text).toContain('"totalLines": 5');
    });

    it('should format a tool response with repository context', async () => {
      const context = { repository: 'user/repo' };
      const metrics = {
        totalFiles: 5,
        totalCharacters: 500,
        totalTokens: 100,
        totalLines: 0, // Will be calculated in formatToolResponse
        fileCharCounts: {
          'file1.js': 300,
          'file2.js': 200,
        },
        fileTokenCounts: {
          'file1.js': 60,
          'file2.js': 40,
        },
        processedFiles: [],
        safeFilePaths: [],
      };
      const outputFilePath = '/path/to/output.xml';

      const response = await formatToolResponse(context, metrics, outputFilePath);

      expect(response.content[1].text).toContain('"repository": "user/repo"');
      expect(response.content[1].text).not.toContain('"directory":');
      expect(response.content[1].text).toContain('"totalLines": 5');
    });

    it('should limit the number of top files based on the parameter', async () => {
      const context = {};
      const metrics = {
        totalFiles: 10,
        totalCharacters: 1000,
        totalTokens: 200,
        totalLines: 0, // Will be calculated in formatToolResponse
        fileCharCounts: {
          'file1.js': 500,
          'file2.js': 300,
          'file3.js': 200,
          'file4.js': 100,
          'file5.js': 50,
          'file6.js': 25,
        },
        fileTokenCounts: {
          'file1.js': 100,
          'file2.js': 60,
          'file3.js': 40,
          'file4.js': 20,
          'file5.js': 10,
          'file6.js': 5,
        },
        processedFiles: [],
        safeFilePaths: [],
      };
      const outputFilePath = '/path/to/output.xml';
      const topFilesLen = 3;

      const response = await formatToolResponse(context, metrics, outputFilePath, topFilesLen);

      const jsonContent = JSON.parse(response.content[1].text as string);
      expect(jsonContent.metrics.topFiles).toHaveLength(3);
      expect(jsonContent.metrics.topFiles[0].path).toBe('file1.js');
      expect(jsonContent.metrics.topFiles[1].path).toBe('file2.js');
      expect(jsonContent.metrics.topFiles[2].path).toBe('file3.js');
      expect(jsonContent.metrics.totalLines).toBe(5);
    });
  });

  describe('buildMcpToolSuccessResponse', () => {
    it('should create a successful response with single message', () => {
      const messages = ['Operation completed successfully'];
      const response = buildMcpToolSuccessResponse(messages);

      expect(response).toEqual({
        content: [
          {
            type: 'text',
            text: 'Operation completed successfully',
          },
        ],
      });
      expect(response.isError).toBeUndefined();
    });

    it('should create a successful response with multiple messages', () => {
      const messages = ['First message', 'Second message', 'Third message'];
      const response = buildMcpToolSuccessResponse(messages);

      expect(response).toEqual({
        content: [
          {
            type: 'text',
            text: 'First message',
          },
          {
            type: 'text',
            text: 'Second message',
          },
          {
            type: 'text',
            text: 'Third message',
          },
        ],
      });
      expect(response.isError).toBeUndefined();
    });

    it('should create a successful response with empty messages array', () => {
      const messages: string[] = [];
      const response = buildMcpToolSuccessResponse(messages);

      expect(response).toEqual({
        content: [],
      });
      expect(response.isError).toBeUndefined();
    });
  });

  describe('buildMcpToolErrorResponse', () => {
    it('should create an error response with single message', () => {
      const errorMessages = ['Something went wrong'];
      const response = buildMcpToolErrorResponse(errorMessages);

      expect(response).toEqual({
        isError: true,
        content: [
          {
            type: 'text',
            text: 'Something went wrong',
          },
        ],
      });
    });

    it('should create an error response with multiple messages', () => {
      const errorMessages = ['Error 1', 'Error 2', 'Error 3'];
      const response = buildMcpToolErrorResponse(errorMessages);

      expect(response).toEqual({
        isError: true,
        content: [
          {
            type: 'text',
            text: 'Error 1',
          },
          {
            type: 'text',
            text: 'Error 2',
          },
          {
            type: 'text',
            text: 'Error 3',
          },
        ],
      });
    });

    it('should create an error response with empty messages array', () => {
      const errorMessages: string[] = [];
      const response = buildMcpToolErrorResponse(errorMessages);

      expect(response).toEqual({
        isError: true,
        content: [],
      });
    });
  });
});
</file>

<file path="tests/mcp/tools/packCodebaseTool.test.ts">
import path from 'node:path';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { runCli } from '../../../src/cli/cliRun.js';
import { createToolWorkspace, formatToolError, formatToolResponse } from '../../../src/mcp/tools/mcpToolRuntime.js';
import { registerPackCodebaseTool } from '../../../src/mcp/tools/packCodebaseTool.js';

vi.mock('node:path');
vi.mock('../../../src/cli/cliRun.js');
vi.mock('../../../src/mcp/tools/mcpToolRuntime.js', async () => {
  const actual = await vi.importActual('../../../src/mcp/tools/mcpToolRuntime.js');
  return {
    ...actual,
    createToolWorkspace: vi.fn(),
    formatToolError: vi.fn(),
    formatToolResponse: vi.fn(),
  };
});

describe('PackCodebaseTool', () => {
  const mockServer = {
    tool: vi.fn().mockReturnThis(),
  } as unknown as McpServer;

  let toolHandler: (args: {
    directory: string;
    compress?: boolean;
    includePatterns?: string;
    ignorePatterns?: string;
    topFilesLength?: number;
  }) => Promise<CallToolResult>;

  const defaultPackResult = {
    totalFiles: 10,
    totalCharacters: 1000,
    totalTokens: 500,
    fileCharCounts: { 'test.js': 100 },
    fileTokenCounts: { 'test.js': 50 },
    suspiciousFilesResults: [],
    gitDiffTokenCount: 0,
    suspiciousGitDiffResults: [],
    processedFiles: [],
    safeFilePaths: [],
  };

  beforeEach(() => {
    vi.resetAllMocks();
    registerPackCodebaseTool(mockServer);
    toolHandler = (mockServer.tool as ReturnType<typeof vi.fn>).mock.calls[0][4];

    // デフォルトのパスの動作をモック
    vi.mocked(path.join).mockImplementation((...args) => args.join('/'));

    // mcpToolRuntimeのデフォルトの動作をモック
    vi.mocked(createToolWorkspace).mockResolvedValue('/temp/dir');
    vi.mocked(formatToolResponse).mockImplementation(async () => ({
      content: [{ type: 'text', text: 'Success response' }],
    }));
    vi.mocked(formatToolError).mockReturnValue({
      isError: true,
      content: [{ type: 'text', text: 'Error response' }],
    });

    // runCliのデフォルト動作
    vi.mocked(runCli).mockImplementation(async (directories, cwd, opts = {}) => ({
      packResult: defaultPackResult,
      config: {
        input: {
          maxFileSize: 50 * 1024 * 1024,
        },
        output: {
          filePath: opts.output ?? '/temp/dir/repomix-output.xml',
          style: opts.style ?? 'xml',
          parsableStyle: false,
          stdout: false,
          fileSummary: true,
          directoryStructure: true,
          removeComments: false,
          removeEmptyLines: false,
          compress: opts.compress ?? true,
          topFilesLength: opts.topFilesLen ?? 5,
          showLineNumbers: false,
          copyToClipboard: false,
          files: true,
          git: {
            sortByChanges: true,
            sortByChangesMaxCommits: 100,
            includeDiffs: false,
          },
          includeEmptyDirectories: false,
        },
        cwd,
        include: Array.isArray(opts.include) ? opts.include : opts.include ? [opts.include] : [],
        ignore: {
          useGitignore: true,
          useDefaultPatterns: true,
          customPatterns: opts.ignore ? [opts.ignore] : [],
        },
        security: {
          enableSecurityCheck: opts.securityCheck ?? true,
        },
        tokenCount: {
          encoding: 'o200k_base' as const,
        },
      },
    }));
  });

  test('should register tool with correct parameters', () => {
    expect(mockServer.tool).toHaveBeenCalledWith(
      'pack_codebase',
      'Package a local code directory into a consolidated XML file for AI analysis. This tool analyzes the codebase structure, extracts relevant code content, and generates a comprehensive report including metrics, file tree, and formatted code content. Supports Tree-sitter compression for efficient token usage.',
      expect.any(Object),
      expect.any(Object), // annotations
      expect.any(Function),
    );
  });

  test('should handle custom options', async () => {
    const testDir = '/test/project';
    const options = {
      directory: testDir,
      compress: false,
      includePatterns: '**/*.js',
      ignorePatterns: 'test/**',
      topFilesLength: 10,
    };

    await toolHandler(options);

    expect(runCli).toHaveBeenCalledWith(
      ['.'],
      testDir,
      expect.objectContaining({
        compress: false,
        include: '**/*.js',
        ignore: 'test/**',
        topFilesLen: 10,
      }),
    );
  });

  test('should handle CLI execution failure', async () => {
    const testDir = '/test/project';
    vi.mocked(runCli).mockResolvedValue(undefined);

    const result = await toolHandler({ directory: testDir });

    expect(result).toEqual({
      isError: true,
      content: [
        {
          type: 'text',
          text: 'Failed to return a result',
        },
      ],
    });
  });

  test('should handle general error', async () => {
    const testDir = '/test/project';
    const error = new Error('Pack failed');
    vi.mocked(runCli).mockRejectedValue(error);

    const result = await toolHandler({ directory: testDir });

    expect(formatToolError).toHaveBeenCalledWith(error);
    expect(result).toEqual({
      isError: true,
      content: [{ type: 'text', text: 'Error response' }],
    });
  });

  test('should handle workspace creation error', async () => {
    const testDir = '/test/project';
    const error = new Error('Workspace creation failed');
    vi.mocked(createToolWorkspace).mockRejectedValue(error);

    const result = await toolHandler({ directory: testDir });

    expect(formatToolError).toHaveBeenCalledWith(error);
    expect(result).toEqual({
      isError: true,
      content: [{ type: 'text', text: 'Error response' }],
    });
  });
});
</file>

<file path="tests/mcp/tools/readRepomixOutputTool.test.ts">
import fs from 'node:fs/promises';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import * as mcpToolRuntime from '../../../src/mcp/tools/mcpToolRuntime.js';
import { registerReadRepomixOutputTool } from '../../../src/mcp/tools/readRepomixOutputTool.js';

vi.mock('node:fs/promises');
vi.mock('../../../src/mcp/tools/mcpToolRuntime.js', async () => {
  const actual = await vi.importActual('../../../src/mcp/tools/mcpToolRuntime.js');
  return {
    ...actual,
    getOutputFilePath: vi.fn(),
  };
});
vi.mock('../../../src/shared/logger.js', () => ({
  logger: {
    trace: vi.fn(),
    error: vi.fn(),
  },
}));

describe('readRepomixOutputTool', () => {
  const mockMcpServer = {
    tool: vi.fn(),
  } as const;

  type ToolHandlerType = (args: {
    outputId: string;
    startLine?: number;
    endLine?: number;
  }) => Promise<{
    isError?: boolean;
    content: Array<{ type: string; text: string }>;
  }>;

  let toolHandler: ToolHandlerType;

  beforeEach(() => {
    vi.resetAllMocks();

    registerReadRepomixOutputTool(mockMcpServer as unknown as McpServer);

    toolHandler = mockMcpServer.tool.mock.calls[0][4];
  });

  it('should register the tool with correct parameters', () => {
    expect(mockMcpServer.tool).toHaveBeenCalledWith(
      'read_repomix_output',
      expect.any(String),
      expect.objectContaining({
        outputId: expect.any(Object),
        startLine: expect.any(Object),
        endLine: expect.any(Object),
      }),
      expect.objectContaining({
        title: 'Read Repomix Output',
        readOnlyHint: true,
        destructiveHint: false,
        idempotentHint: true,
        openWorldHint: false,
      }),
      expect.any(Function),
    );
  });

  it('should return an error if output file ID is not found', async () => {
    vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue(undefined);

    const result = await toolHandler({ outputId: 'non-existent-id' });

    expect(mcpToolRuntime.getOutputFilePath).toHaveBeenCalledWith('non-existent-id');
    expect(result.isError).toBe(true);
    expect(result.content[0].text).toContain('Error: Output file with ID non-existent-id not found');
  });

  it('should return an error if the file does not exist', async () => {
    vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
    vi.mocked(fs.access).mockRejectedValue(new Error('File not found'));

    const result = await toolHandler({ outputId: 'test-id' });

    expect(mcpToolRuntime.getOutputFilePath).toHaveBeenCalledWith('test-id');
    expect(fs.access).toHaveBeenCalledWith('/path/to/file.xml');
    expect(result.isError).toBe(true);
    expect(result.content[0].text).toContain('Error: Output file does not exist at path: /path/to/file.xml');
  });

  it('should successfully read the file content', async () => {
    vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
    vi.mocked(fs.access).mockResolvedValue(undefined);
    vi.mocked(fs.readFile).mockResolvedValue('File content here' as unknown as Buffer);

    const result = await toolHandler({ outputId: 'test-id' });

    expect(mcpToolRuntime.getOutputFilePath).toHaveBeenCalledWith('test-id');
    expect(fs.access).toHaveBeenCalledWith('/path/to/file.xml');
    expect(fs.readFile).toHaveBeenCalledWith('/path/to/file.xml', 'utf8');
    expect(result.isError).toBeUndefined();
    expect(result.content).toHaveLength(2);
    expect(result.content[0].text).toContain('Content of Repomix output file (ID: test-id)');
    expect(result.content[1].text).toBe('File content here');
  });

  it('should handle unexpected errors during execution', async () => {
    vi.mocked(mcpToolRuntime.getOutputFilePath).mockImplementation(() => {
      throw new Error('Unexpected error');
    });

    const result = await toolHandler({ outputId: 'test-id' });

    expect(result.isError).toBe(true);
    expect(result.content[0].text).toContain('Error reading Repomix output: Unexpected error');
  });

  it('should read specific line range when startLine and endLine are provided', async () => {
    vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
    vi.mocked(fs.access).mockResolvedValue(undefined);
    vi.mocked(fs.readFile).mockResolvedValue('Line 1\nLine 2\nLine 3\nLine 4\nLine 5' as unknown as Buffer);

    const result = await toolHandler({ outputId: 'test-id', startLine: 2, endLine: 4 });

    expect(fs.readFile).toHaveBeenCalledWith('/path/to/file.xml', 'utf8');
    expect(result.isError).toBeUndefined();
    expect(result.content).toHaveLength(2);
    expect(result.content[0].text).toContain('Content of Repomix output file (ID: test-id) (lines 2-4)');
    expect(result.content[1].text).toBe('Line 2\nLine 3\nLine 4');
  });

  it('should read from startLine to end when only startLine is provided', async () => {
    vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
    vi.mocked(fs.access).mockResolvedValue(undefined);
    vi.mocked(fs.readFile).mockResolvedValue('Line 1\nLine 2\nLine 3\nLine 4\nLine 5' as unknown as Buffer);

    const result = await toolHandler({ outputId: 'test-id', startLine: 3 });

    expect(result.content[0].text).toContain('Content of Repomix output file (ID: test-id) (lines 3-end)');
    expect(result.content[1].text).toBe('Line 3\nLine 4\nLine 5');
  });

  it('should read from beginning to endLine when only endLine is provided', async () => {
    vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
    vi.mocked(fs.access).mockResolvedValue(undefined);
    vi.mocked(fs.readFile).mockResolvedValue('Line 1\nLine 2\nLine 3\nLine 4\nLine 5' as unknown as Buffer);

    const result = await toolHandler({ outputId: 'test-id', endLine: 2 });

    expect(result.content[0].text).toContain('Content of Repomix output file (ID: test-id) (lines 1-2)');
    expect(result.content[1].text).toBe('Line 1\nLine 2');
  });

  it('should return an error if startLine exceeds total lines', async () => {
    vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
    vi.mocked(fs.access).mockResolvedValue(undefined);
    vi.mocked(fs.readFile).mockResolvedValue('Line 1\nLine 2\nLine 3' as unknown as Buffer);

    const result = await toolHandler({ outputId: 'test-id', startLine: 10 });

    expect(result.isError).toBe(true);
    expect(result.content[0].text).toContain('Error: Start line 10 exceeds total lines (3)');
  });

  it('should return an error if startLine is greater than endLine', async () => {
    vi.mocked(mcpToolRuntime.getOutputFilePath).mockReturnValue('/path/to/file.xml');
    vi.mocked(fs.access).mockResolvedValue(undefined);
    vi.mocked(fs.readFile).mockResolvedValue('Line 1\nLine 2\nLine 3\nLine 4\nLine 5' as unknown as Buffer);

    const result = await toolHandler({ outputId: 'test-id', startLine: 4, endLine: 2 });

    expect(result.isError).toBe(true);
    expect(result.content[0].text).toContain('Error: Start line (4) cannot be greater than end line (2)');
  });
});
</file>

<file path="tests/mcp/mcpServer.test.ts">
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { getVersion } from '../../src/core/file/packageJsonParse.js';
import { createMcpServer, runMcpServer } from '../../src/mcp/mcpServer.js';
import { logger } from '../../src/shared/logger.js';

// Mock dependencies
vi.mock('@modelcontextprotocol/sdk/server/mcp.js');
vi.mock('@modelcontextprotocol/sdk/server/stdio.js');
vi.mock('../../src/core/file/packageJsonParse.js');
vi.mock('../../src/shared/logger.js');

describe('MCP Server', () => {
  let mockExit: ReturnType<typeof vi.fn<(code?: number) => never>>;
  const mockVersion = '1.0.0';

  const mockLogger = {
    trace: vi.fn(),
    error: vi.fn(),
  };

  beforeEach(async () => {
    vi.resetAllMocks();
    mockExit = vi.fn();
    vi.mocked(getVersion).mockResolvedValue(mockVersion);

    // ロガーのモックを設定
    vi.mocked(logger.trace).mockImplementation(mockLogger.trace);
    vi.mocked(logger.error).mockImplementation(mockLogger.error);
  });

  describe('createMcpServer', () => {
    test('should create server with correct configuration', async () => {
      const server = await createMcpServer();

      expect(McpServer).toHaveBeenCalledWith({
        name: 'repomix-mcp-server',
        version: mockVersion,
      });
      expect(server).toBeDefined();
    });
  });

  describe('runMcpServer', () => {
    test('should connect server with stdio transport', async () => {
      await expect(runMcpServer({ processExit: mockExit })).resolves.toBeUndefined();

      expect(StdioServerTransport).toHaveBeenCalled();
      expect(vi.mocked(McpServer).mock.results[0].value.connect).toHaveBeenCalledWith(
        vi.mocked(StdioServerTransport).mock.results[0].value,
      );
      expect(logger.trace).toHaveBeenCalledWith('Repomix MCP Server running on stdio');
    });

    test('should handle connection error', async () => {
      const error = new Error('Connection failed');
      const mockMcpServer = {
        tool: vi.fn().mockReturnThis(),
        prompt: vi.fn().mockReturnThis(),
        connect: vi.fn().mockRejectedValue(error),
        close: vi.fn().mockResolvedValue(undefined),
        ...createMockServerProps(),
      } as unknown as McpServer;

      vi.mocked(McpServer).mockImplementation(() => mockMcpServer);
      try {
        await runMcpServer({ processExit: mockExit });
      } catch (e) {
        expect(e).toEqual(error);
      }

      expect(logger.error).toHaveBeenCalledWith('Failed to start MCP server:', error);
      expect(mockExit).toHaveBeenCalledWith(1);
    });

    test('should handle SIGINT signal', async () => {
      const mockServer = {
        tool: vi.fn().mockReturnThis(),
        prompt: vi.fn().mockReturnThis(),
        connect: vi.fn().mockResolvedValue(undefined),
        close: vi.fn().mockResolvedValue(undefined),
        ...createMockServerProps(),
      } as unknown as McpServer;

      vi.mocked(McpServer).mockImplementation(() => mockServer);
      await expect(runMcpServer({ processExit: mockExit })).resolves.toBeUndefined();
      mockLogger.trace.mockClear();
      process.emit('SIGINT');

      // 非同期処理の完了を待つ
      await new Promise((resolve) => setTimeout(resolve, 0));

      expect(mockServer.close).toHaveBeenCalled();
      expect(logger.trace).toHaveBeenCalledWith('Repomix MCP Server shutdown complete');
      expect(mockExit).toHaveBeenCalledWith(0);
    });

    test('should handle SIGTERM signal', async () => {
      const mockServer = {
        tool: vi.fn().mockReturnThis(),
        prompt: vi.fn().mockReturnThis(),
        connect: vi.fn().mockResolvedValue(undefined),
        close: vi.fn().mockResolvedValue(undefined),
        ...createMockServerProps(),
      } as unknown as McpServer;

      vi.mocked(McpServer).mockImplementation(() => mockServer);
      await expect(runMcpServer({ processExit: mockExit })).resolves.toBeUndefined();
      mockLogger.trace.mockClear();
      process.emit('SIGTERM');

      // 非同期処理の完了を待つ
      await new Promise((resolve) => setTimeout(resolve, 0));

      expect(mockServer.close).toHaveBeenCalled();
      expect(logger.trace).toHaveBeenCalledWith('Repomix MCP Server shutdown complete');
      expect(mockExit).toHaveBeenCalledWith(0);
    });

    test('should handle shutdown error', async () => {
      const error = new Error('Shutdown failed');
      const mockServer = {
        tool: vi.fn().mockReturnThis(),
        prompt: vi.fn().mockReturnThis(),
        connect: vi.fn().mockResolvedValue(undefined),
        close: vi.fn().mockRejectedValue(error),
        ...createMockServerProps(),
      } as unknown as McpServer;

      vi.mocked(McpServer).mockImplementation(() => mockServer);
      await expect(runMcpServer({ processExit: mockExit })).resolves.toBeUndefined();
      mockLogger.error.mockClear();
      process.emit('SIGINT');

      // 非同期処理の完了を待つ
      await new Promise((resolve) => setTimeout(resolve, 0));

      expect(logger.error).toHaveBeenCalledWith('Error during MCP server shutdown:', error);
      expect(mockExit).toHaveBeenCalledWith(1);
    });
  });
});

function createMockServerProps() {
  return {
    server: {},
    _registeredResources: new Map(),
    _registeredResourceTemplates: new Map(),
    _registeredTools: new Map(),
    _registeredPrompts: new Map(),
    _registeredAgents: new Map(),
    _registeredInstructions: new Map(),
    _registeredRoutes: new Map(),
    _registeredSessions: new Map(),
    _registeredSockets: new Map(),
    _registeredStreams: new Map(),
    _registeredWebSockets: new Map(),
    _registeredWorkers: new Map(),
    _toolHandlersInitialized: false,
    _completionHandlerInitialized: false,
    setToolRequestHandlers: vi.fn(),
    setCompletionRequestHandler: vi.fn(),
    _messageHandler: vi.fn(),
    _transport: {},
    _connected: false,
    _completionHandler: vi.fn(),
    _toolHandlers: new Map(),
    _validateHandlersInitialized: vi.fn(),
    handlePromptCompletion: vi.fn(),
    handleResourceCompletion: vi.fn(),
    _resourceHandlersInitialized: false,
    setResourceRequestHandlers: vi.fn(),
    _resourceHandlers: new Map(),
    _validateSession: vi.fn(),
    _validateResource: vi.fn(),
    _resourceTemplateHandlers: new Map(),
  };
}
</file>

<file path="tests/shared/logger.test.ts">
import pc from 'picocolors';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { logger, repomixLogLevels } from '../../src/shared/logger.js';

vi.mock('picocolors', () => ({
  default: {
    red: vi.fn((str) => `RED:${str}`),
    yellow: vi.fn((str) => `YELLOW:${str}`),
    green: vi.fn((str) => `GREEN:${str}`),
    cyan: vi.fn((str) => `CYAN:${str}`),
    dim: vi.fn((str) => `DIM:${str}`),
    blue: vi.fn((str) => `BLUE:${str}`),
    gray: vi.fn((str) => `GRAY:${str}`),
  },
}));

describe('logger', () => {
  beforeEach(() => {
    vi.spyOn(console, 'error').mockImplementation(vi.fn());
    vi.spyOn(console, 'log').mockImplementation(vi.fn());
    logger.init();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('log levels', () => {
    it('should not log anything in SILENT mode', () => {
      logger.setLogLevel(repomixLogLevels.SILENT);

      logger.error('Error message');
      logger.warn('Warning message');
      logger.success('Success message');
      logger.info('Info message');
      logger.note('Note message');
      logger.debug('Debug message');
      logger.trace('Trace message');
      logger.log('Log message');

      expect(console.error).not.toHaveBeenCalled();
      expect(console.log).not.toHaveBeenCalled();
    });

    it('should only log errors in ERROR mode', () => {
      logger.setLogLevel(repomixLogLevels.ERROR);

      logger.error('Error message');
      logger.warn('Warning message');

      expect(console.error).toHaveBeenCalledWith('RED:Error message');
      expect(console.log).not.toHaveBeenCalled();
    });
  });

  it('should log error messages', () => {
    logger.error('Error message');
    expect(console.error).toHaveBeenCalledWith('RED:Error message');
  });

  it('should log warning messages', () => {
    logger.warn('Warning message');
    expect(console.log).toHaveBeenCalledWith('YELLOW:Warning message');
  });

  it('should log success messages', () => {
    logger.success('Success message');
    expect(console.log).toHaveBeenCalledWith('GREEN:Success message');
  });

  it('should log info messages', () => {
    logger.info('Info message');
    expect(console.log).toHaveBeenCalledWith('CYAN:Info message');
  });

  it('should log log messages', () => {
    logger.log('Note message');
    expect(console.log).toHaveBeenCalledWith('Note message');
  });

  it('should not log debug messages when verbose is false', () => {
    logger.debug('Debug message');
    expect(console.log).not.toHaveBeenCalled();
  });

  it('should log debug messages when verbose is true', () => {
    logger.setLogLevel(repomixLogLevels.DEBUG);
    logger.debug('Debug message');
    expect(console.log).toHaveBeenCalledWith('BLUE:Debug message');
  });

  it('should not log trace messages when verbose is false', () => {
    logger.trace('Trace message');
    expect(console.log).not.toHaveBeenCalled();
  });

  it('should log trace messages when verbose is true', () => {
    logger.setLogLevel(repomixLogLevels.DEBUG);
    logger.trace('Trace message');
    expect(console.log).toHaveBeenCalledWith(pc.gray('Trace message'));
  });

  it('should format object arguments correctly', () => {
    const obj = { key: 'value' };
    logger.info('Object:', obj);
    expect(console.log).toHaveBeenCalledWith(expect.stringContaining('CYAN:Object: '));
  });

  it('should handle multiple arguments', () => {
    logger.info('Multiple', 'arguments', 123);
    expect(console.log).toHaveBeenCalledWith('CYAN:Multiple arguments 123');
  });
});
</file>

<file path="tests/shared/patternUtils.test.ts">
import { describe, expect, it } from 'vitest';
import { splitPatterns } from '../../src/shared/patternUtils.js';

describe('patternUtils', () => {
  describe('splitPatterns', () => {
    it('should correctly split patterns without braces', () => {
      const patterns = 'src/**,tests/**,*.js';
      const result = splitPatterns(patterns);
      expect(result).toEqual(['src/**', 'tests/**', '*.js']);
    });

    it('should preserve brace expansion patterns', () => {
      const patterns = 'src/**,**/{__tests__,theme}/**,*.{js,ts}';
      const result = splitPatterns(patterns);
      expect(result).toEqual(['src/**', '**/{__tests__,theme}/**', '*.{js,ts}']);
    });

    it('should handle nested braces', () => {
      const patterns = 'src/{components/{Button,Input},utils}/**';
      const result = splitPatterns(patterns);
      expect(result).toEqual(['src/{components/{Button,Input},utils}/**']);
    });

    it('should handle empty patterns', () => {
      expect(splitPatterns('')).toEqual([]);
      expect(splitPatterns(undefined)).toEqual([]);
    });

    it('should handle patterns with escaped braces', () => {
      const patterns = 'src/\\{file\\}.js,tests/**';
      const result = splitPatterns(patterns);
      // Note: Escaped braces are treated as regular characters, not brace delimiters
      expect(result).toEqual(['src/\\{file\\}.js', 'tests/**']);
    });

    it('should handle trailing commas', () => {
      const patterns = 'src/**,tests/**,';
      const result = splitPatterns(patterns);
      expect(result).toEqual(['src/**', 'tests/**']);
    });

    it('should handle leading commas', () => {
      const patterns = ',src/**,tests/**';
      const result = splitPatterns(patterns);
      expect(result).toEqual(['src/**', 'tests/**']);
    });

    it('should trim whitespace around patterns', () => {
      const patterns = ' src/** , tests/** , **/*.js ';
      const result = splitPatterns(patterns);
      expect(result).toEqual(['src/**', 'tests/**', '**/*.js']);
    });
  });
});
</file>

<file path="tests/shared/processConcurrency.test.ts">
import os from 'node:os';
import { Piscina } from 'piscina';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { getProcessConcurrency, getWorkerThreadCount, initPiscina } from '../../src/shared/processConcurrency.js';

vi.mock('node:os');
vi.mock('piscina');

describe('processConcurrency', () => {
  describe('getProcessConcurrency', () => {
    it('should use os.availableParallelism when available', () => {
      const mockAvailableParallelism = vi.fn().mockReturnValue(4);
      vi.mocked(os).availableParallelism = mockAvailableParallelism;

      const result = getProcessConcurrency();

      expect(result).toBe(4);
      expect(mockAvailableParallelism).toHaveBeenCalled();
    });
  });

  describe('getWorkerThreadCount', () => {
    beforeEach(() => {
      vi.mocked(os).availableParallelism = vi.fn().mockReturnValue(8);
    });

    it('should return minimum 1 thread', () => {
      const { minThreads, maxThreads } = getWorkerThreadCount(1);

      expect(minThreads).toBe(1);
      expect(maxThreads).toBe(1);
    });

    it('should limit max threads based on number of tasks', () => {
      const { minThreads, maxThreads } = getWorkerThreadCount(1000);

      expect(minThreads).toBe(1);
      expect(maxThreads).toBe(8); // Limited by CPU count
    });

    it('should scale max threads based on task count', () => {
      const { maxThreads: maxThreads1 } = getWorkerThreadCount(200);
      const { maxThreads: maxThreads2 } = getWorkerThreadCount(400);

      expect(maxThreads2).toBeGreaterThan(maxThreads1);
    });

    it('should handle large numbers of tasks', () => {
      const { minThreads, maxThreads } = getWorkerThreadCount(10000);

      expect(minThreads).toBe(1);
      expect(maxThreads).toBe(8); // Limited by CPU count
    });

    it('should handle zero tasks', () => {
      const { minThreads, maxThreads } = getWorkerThreadCount(0);

      expect(minThreads).toBe(1);
      expect(maxThreads).toBe(1);
    });
  });

  describe('initPiscina', () => {
    beforeEach(() => {
      vi.mocked(os).availableParallelism = vi.fn().mockReturnValue(4);
      vi.mocked(Piscina).mockImplementation(() => ({}) as Piscina);
    });

    it('should initialize Piscina with correct configuration', () => {
      const workerPath = '/path/to/worker.js';
      const piscina = initPiscina(500, workerPath);

      expect(Piscina).toHaveBeenCalledWith({
        filename: workerPath,
        minThreads: 1,
        maxThreads: 4,
        idleTimeout: 5000,
        env: expect.objectContaining({
          ...process.env,
          REPOMIX_LOGLEVEL: '2',
        }),
      });
      expect(piscina).toBeDefined();
    });
  });
});
</file>

<file path="tests/testing/testUtils.ts">
import os from 'node:os';
import process from 'node:process';
import { type RepomixConfigMerged, defaultConfig } from '../../src/config/configSchema.js';

type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends (infer U)[]
    ? DeepPartial<U>[]
    : T[P] extends readonly (infer U)[]
      ? readonly DeepPartial<U>[]
      : T[P] extends object
        ? DeepPartial<T[P]>
        : T[P];
};

export const createMockConfig = (config: DeepPartial<RepomixConfigMerged> = {}): RepomixConfigMerged => {
  return {
    cwd: process.cwd(),
    input: {
      ...defaultConfig.input,
      ...config.input,
    },
    output: {
      ...defaultConfig.output,
      ...config.output,
      git: {
        ...defaultConfig.output.git,
        ...config.output?.git,
      },
    },
    ignore: {
      ...defaultConfig.ignore,
      ...config.ignore,
      customPatterns: [...(defaultConfig.ignore.customPatterns || []), ...(config.ignore?.customPatterns || [])],
    },
    include: [...(defaultConfig.include || []), ...(config.include || [])],
    security: {
      ...defaultConfig.security,
      ...config.security,
    },
    tokenCount: {
      ...defaultConfig.tokenCount,
      ...config.tokenCount,
    },
  };
};

export const isWindows = os.platform() === 'win32';
export const isMac = os.platform() === 'darwin';
export const isLinux = os.platform() === 'linux';
</file>

<file path="website/client/.vitepress/config/configDe.ts">
import { type DefaultTheme, defineConfig } from 'vitepress';

export const configDe = defineConfig({
  lang: 'de',
  description: 'Paketieren Sie Ihre Codebasis in KI-freundliche Formate',
  themeConfig: {
    nav: [
      { text: 'Anleitung', link: '/de/guide/', activeMatch: '^/de/guide/' },
      {
        text: 'Chrome-Erweiterung',
        link: 'https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa',
      },
      { text: 'Discord beitreten', link: 'https://discord.gg/wNYzTwZFku' },
    ],
    sidebar: {
      '/de/guide/': [
        {
          text: 'Einführung',
          items: [
            { text: 'Erste Schritte', link: '/de/guide/' },
            { text: 'Installation', link: '/de/guide/installation' },
            { text: 'Grundlegende Verwendung', link: '/de/guide/usage' },
            { text: 'Prompt-Beispiele', link: '/de/guide/prompt-examples' },
          ],
        },
        {
          text: 'Anleitung',
          items: [
            { text: 'Ausgabeformate', link: '/de/guide/output' },
            { text: 'Kommandozeilenoptionen', link: '/de/guide/command-line-options' },
            { text: 'Konfiguration', link: '/de/guide/configuration' },
            { text: 'Benutzerdefinierte Anweisungen', link: '/de/guide/custom-instructions' },
            { text: 'Remote-Repository-Verarbeitung', link: '/de/guide/remote-repository-processing' },
            { text: 'Kommentare entfernen', link: '/de/guide/comment-removal' },
            { text: 'Code-Komprimierung', link: '/de/guide/code-compress' },
            { text: 'Sicherheit', link: '/de/guide/security' },
            { text: 'MCP-Server', link: '/de/guide/mcp-server' },
            { text: 'GitHub Actions', link: '/de/guide/github-actions' },
          ],
        },
        {
          text: 'Fortgeschritten',
          items: [
            { text: 'Repomix als Bibliothek verwenden', link: '/de/guide/development/using-repomix-as-a-library' },
            { text: 'KI-unterstützte Entwicklungstipps', link: '/de/guide/tips/best-practices' },
            { text: 'Zu Repomix beitragen', link: '/de/guide/development/' },
          ],
        },
      ],
    },
  },
});

export const configDeSearch: DefaultTheme.LocalSearchOptions['locales'] = {
  de: {
    translations: {
      button: {
        buttonText: 'Suchen',
        buttonAriaLabel: 'Suchen',
      },
      modal: {
        noResultsText: 'Keine Ergebnisse gefunden',
        resetButtonTitle: 'Suche zurücksetzen',
        backButtonTitle: 'Zurück',
        displayDetails: 'Details anzeigen',
        footer: {
          selectText: 'Auswählen',
          navigateText: 'Navigieren',
          closeText: 'Schließen',
        },
      },
    },
  },
};
</file>

<file path="website/client/.vitepress/config/configEnUs.ts">
import { defineConfig } from 'vitepress';

export const configEnUs = defineConfig({
  lang: 'en-US',
  description: 'Pack your codebase into AI-friendly formats',
  themeConfig: {
    nav: [
      { text: 'Guide', link: '/guide/', activeMatch: '^/guide/' },
      {
        text: 'Chrome Extension',
        link: 'https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa',
      },
      { text: 'Join Discord', link: 'https://discord.gg/wNYzTwZFku' },
    ],
    sidebar: {
      '/guide/': [
        {
          text: 'Introduction',
          items: [
            { text: 'Getting Started', link: '/guide/' },
            { text: 'Installation', link: '/guide/installation' },
            { text: 'Basic Usage', link: '/guide/usage' },
            { text: 'Prompt Examples', link: '/guide/prompt-examples' },
          ],
        },
        {
          text: 'Guide',
          items: [
            { text: 'Output Formats', link: '/guide/output' },
            { text: 'Command Line Options', link: '/guide/command-line-options' },
            { text: 'Configuration', link: '/guide/configuration' },
            { text: 'Custom Instructions', link: '/guide/custom-instructions' },
            { text: 'Remote Repository Processing', link: '/guide/remote-repository-processing' },
            { text: 'Comment Removal', link: '/guide/comment-removal' },
            { text: 'Code Compression', link: '/guide/code-compress' },
            { text: 'Security', link: '/guide/security' },
            { text: 'MCP Server', link: '/guide/mcp-server' },
            { text: 'GitHub Actions', link: '/guide/github-actions' },
          ],
        },
        {
          text: 'Advanced',
          items: [
            { text: 'Using Repomix as a Library', link: '/guide/development/using-repomix-as-a-library' },
            { text: 'AI-Assisted Development Tips', link: '/guide/tips/best-practices' },
            { text: 'Contributing to Repomix', link: '/guide/development/' },
          ],
        },
      ],
    },
  },
});
</file>

<file path="website/client/.vitepress/config/configEs.ts">
import { type DefaultTheme, defineConfig } from 'vitepress';

export const configEs = defineConfig({
  lang: 'es',
  description: 'Empaqueta tu código en formatos amigables para IA',
  themeConfig: {
    nav: [
      { text: 'Guía', link: '/es/guide/', activeMatch: '^/es/guide/' },
      {
        text: 'Extensión de Chrome',
        link: 'https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa',
      },
      { text: 'Unirse a Discord', link: 'https://discord.gg/wNYzTwZFku' },
    ],
    sidebar: {
      '/es/guide/': [
        {
          text: 'Introducción',
          items: [
            { text: 'Comenzar', link: '/es/guide/' },
            { text: 'Instalación', link: '/es/guide/installation' },
            { text: 'Uso Básico', link: '/es/guide/usage' },
            { text: 'Ejemplos de Prompts', link: '/es/guide/prompt-examples' },
          ],
        },
        {
          text: 'Guía',
          items: [
            { text: 'Formatos de Salida', link: '/es/guide/output' },
            { text: 'Opciones de Línea de Comandos', link: '/es/guide/command-line-options' },
            { text: 'Configuración', link: '/es/guide/configuration' },
            { text: 'Instrucciones Personalizadas', link: '/es/guide/custom-instructions' },
            { text: 'Procesamiento de Repositorios Remotos', link: '/es/guide/remote-repository-processing' },
            { text: 'Eliminación de Comentarios', link: '/es/guide/comment-removal' },
            { text: 'Compresión de Código', link: '/es/guide/code-compress' },
            { text: 'Seguridad', link: '/es/guide/security' },
            { text: 'Servidor MCP', link: '/es/guide/mcp-server' },
            { text: 'GitHub Actions', link: '/es/guide/github-actions' },
          ],
        },
        {
          text: 'Avanzado',
          items: [
            { text: 'Usar Repomix como Biblioteca', link: '/es/guide/development/using-repomix-as-a-library' },
            { text: 'Consejos para Desarrollo Asistido por IA', link: '/es/guide/tips/best-practices' },
            { text: 'Contribuir a Repomix', link: '/es/guide/development/' },
          ],
        },
      ],
    },
  },
});

export const configEsSearch: DefaultTheme.LocalSearchOptions['locales'] = {
  es: {
    translations: {
      button: {
        buttonText: 'Buscar',
        buttonAriaLabel: 'Buscar',
      },
      modal: {
        noResultsText: 'No se encontraron resultados',
        resetButtonTitle: 'Reiniciar búsqueda',
        backButtonTitle: 'Atrás',
        displayDetails: 'Mostrar detalles',
        footer: {
          selectText: 'Seleccionar',
          navigateText: 'Navegar',
          closeText: 'Cerrar',
        },
      },
    },
  },
};
</file>

<file path="website/client/.vitepress/config/configFr.ts">
import { type DefaultTheme, defineConfig } from 'vitepress';

export const configFr = defineConfig({
  lang: 'fr-FR',
  description: "Empaquetez votre code dans des formats adaptés à l'IA",
  themeConfig: {
    nav: [
      { text: 'Guide', link: '/fr/guide/', activeMatch: '^/fr/guide/' },
      {
        text: 'Extension Chrome',
        link: 'https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa',
      },
      { text: 'Rejoindre Discord', link: 'https://discord.gg/wNYzTwZFku' },
    ],
    sidebar: {
      '/fr/guide/': [
        {
          text: 'Introduction',
          items: [
            { text: 'Pour commencer', link: '/fr/guide/' },
            { text: 'Installation', link: '/fr/guide/installation' },
            { text: 'Utilisation de base', link: '/fr/guide/usage' },
            { text: 'Exemples de prompts', link: '/fr/guide/prompt-examples' },
          ],
        },
        {
          text: 'Guide',
          items: [
            { text: 'Formats de sortie', link: '/fr/guide/output' },
            { text: 'Options de ligne de commande', link: '/fr/guide/command-line-options' },
            { text: 'Configuration', link: '/fr/guide/configuration' },
            { text: 'Instructions personnalisées', link: '/fr/guide/custom-instructions' },
            { text: 'Traitement des dépôts distants', link: '/fr/guide/remote-repository-processing' },
            { text: 'Suppression des commentaires', link: '/fr/guide/comment-removal' },
            { text: 'Compression de code', link: '/fr/guide/code-compress' },
            { text: 'Sécurité', link: '/fr/guide/security' },
            { text: 'Serveur MCP', link: '/fr/guide/mcp-server' },
            { text: 'GitHub Actions', link: '/fr/guide/github-actions' },
          ],
        },
        {
          text: 'Avancé',
          items: [
            {
              text: 'Utiliser Repomix comme bibliothèque',
              link: '/fr/guide/development/using-repomix-as-a-library',
            },
            { text: 'Conseils pour le développement assisté par IA', link: '/fr/guide/tips/best-practices' },
            { text: 'Contribuer à Repomix', link: '/fr/guide/development/' },
          ],
        },
      ],
    },
  },
});

export const configFrSearch: DefaultTheme.LocalSearchOptions['locales'] = {
  fr: {
    translations: {
      button: {
        buttonText: 'Rechercher',
        buttonAriaLabel: 'Rechercher',
      },
      modal: {
        noResultsText: 'Aucun résultat trouvé',
        resetButtonTitle: 'Réinitialiser la recherche',
        backButtonTitle: 'Retour',
        displayDetails: 'Afficher les détails',
        footer: {
          selectText: 'Sélectionner',
          navigateText: 'Naviguer',
          closeText: 'Fermer',
        },
      },
    },
  },
};
</file>

<file path="website/client/.vitepress/config/configHi.ts">
import { type DefaultTheme, defineConfig } from 'vitepress';

export const configHi = defineConfig({
  lang: 'hi',
  description: 'अपने कोडबेस को AI-फ्रेंडली फॉर्मेट में पैकेज करें',
  themeConfig: {
    nav: [
      { text: 'गाइड', link: '/hi/guide/', activeMatch: '^/hi/guide/' },
      {
        text: 'Chrome एक्सटेंशन',
        link: 'https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa',
      },
      { text: 'Discord में शामिल हों', link: 'https://discord.gg/wNYzTwZFku' },
    ],
    sidebar: {
      '/hi/guide/': [
        {
          text: 'परिचय',
          items: [
            { text: 'शुरुआत करना', link: '/hi/guide/' },
            { text: 'इंस्टॉलेशन', link: '/hi/guide/installation' },
            { text: 'बुनियादी उपयोग', link: '/hi/guide/usage' },
            { text: 'प्रॉम्प्ट उदाहरण', link: '/hi/guide/prompt-examples' },
          ],
        },
        {
          text: 'गाइड',
          items: [
            { text: 'आउटपुट फॉर्मेट', link: '/hi/guide/output' },
            { text: 'कमांड लाइन विकल्प', link: '/hi/guide/command-line-options' },
            { text: 'कॉन्फ़िगरेशन', link: '/hi/guide/configuration' },
            { text: 'कस्टम निर्देश', link: '/hi/guide/custom-instructions' },
            { text: 'रिमोट रिपॉजिटरी प्रोसेसिंग', link: '/hi/guide/remote-repository-processing' },
            { text: 'टिप्पणी हटाना', link: '/hi/guide/comment-removal' },
            { text: 'कोड कम्प्रेशन', link: '/hi/guide/code-compress' },
            { text: 'सुरक्षा', link: '/hi/guide/security' },
            { text: 'MCP सर्वर', link: '/hi/guide/mcp-server' },
            { text: 'GitHub Actions', link: '/hi/guide/github-actions' },
          ],
        },
        {
          text: 'उन्नत',
          items: [
            { text: 'Repomix को लाइब्रेरी के रूप में उपयोग', link: '/hi/guide/development/using-repomix-as-a-library' },
            { text: 'AI-सहायक विकास टिप्स', link: '/hi/guide/tips/best-practices' },
            { text: 'Repomix में योगदान', link: '/hi/guide/development/' },
          ],
        },
      ],
    },
  },
});

export const configHiSearch: DefaultTheme.LocalSearchOptions['locales'] = {
  hi: {
    translations: {
      button: {
        buttonText: 'खोजें',
        buttonAriaLabel: 'खोजें',
      },
      modal: {
        noResultsText: 'कोई परिणाम नहीं मिला',
        resetButtonTitle: 'खोज रीसेट करें',
        backButtonTitle: 'वापस जाएं',
        displayDetails: 'विवरण दिखाएं',
        footer: {
          selectText: 'चुनें',
          navigateText: 'नेविगेट करें',
          closeText: 'बंद करें',
        },
      },
    },
  },
};
</file>

<file path="website/client/.vitepress/config/configId.ts">
import { type DefaultTheme, defineConfig } from 'vitepress';

export const configId = defineConfig({
  lang: 'id',
  description: 'Kemas basis kode Anda ke dalam format yang ramah AI',
  themeConfig: {
    nav: [
      { text: 'Panduan', link: '/id/guide/', activeMatch: '^/id/guide/' },
      {
        text: 'Ekstensi Chrome',
        link: 'https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa',
      },
      { text: 'Bergabung Discord', link: 'https://discord.gg/wNYzTwZFku' },
    ],
    sidebar: {
      '/id/guide/': [
        {
          text: 'Pengantar',
          items: [
            { text: 'Memulai', link: '/id/guide/' },
            { text: 'Instalasi', link: '/id/guide/installation' },
            { text: 'Penggunaan Dasar', link: '/id/guide/usage' },
            { text: 'Contoh Prompt', link: '/id/guide/prompt-examples' },
          ],
        },
        {
          text: 'Panduan',
          items: [
            { text: 'Format Output', link: '/id/guide/output' },
            { text: 'Opsi Baris Perintah', link: '/id/guide/command-line-options' },
            { text: 'Konfigurasi', link: '/id/guide/configuration' },
            { text: 'Instruksi Khusus', link: '/id/guide/custom-instructions' },
            { text: 'Pemrosesan Repositori Remote', link: '/id/guide/remote-repository-processing' },
            { text: 'Penghapusan Komentar', link: '/id/guide/comment-removal' },
            { text: 'Kompresi Kode', link: '/id/guide/code-compress' },
            { text: 'Keamanan', link: '/id/guide/security' },
            { text: 'Server MCP', link: '/id/guide/mcp-server' },
            { text: 'GitHub Actions', link: '/id/guide/github-actions' },
          ],
        },
        {
          text: 'Lanjutan',
          items: [
            {
              text: 'Menggunakan Repomix sebagai Library',
              link: '/id/guide/development/using-repomix-as-a-library',
            },
            { text: 'Tips Pengembangan dengan Bantuan AI', link: '/id/guide/tips/best-practices' },
            { text: 'Berkontribusi ke Repomix', link: '/id/guide/development/' },
          ],
        },
      ],
    },
  },
});

export const configIdSearch: DefaultTheme.LocalSearchOptions['locales'] = {
  id: {
    translations: {
      button: {
        buttonText: 'Cari',
        buttonAriaLabel: 'Cari',
      },
      modal: {
        noResultsText: 'Tidak ada hasil ditemukan',
        resetButtonTitle: 'Reset pencarian',
        backButtonTitle: 'Kembali',
        displayDetails: 'Tampilkan detail',
        footer: {
          selectText: 'Pilih',
          navigateText: 'Navigasi',
          closeText: 'Tutup',
        },
      },
    },
  },
};
</file>

<file path="website/client/.vitepress/config/configJa.ts">
import { type DefaultTheme, defineConfig } from 'vitepress';

export const configJa = defineConfig({
  lang: 'ja',
  description: 'コードベースをAIフレンドリーな形式にパッケージング',
  themeConfig: {
    nav: [
      // guide
      { text: '使い方', link: '/ja/guide/', activeMatch: '^/ja/guide/' },
      { text: 'Chrome拡張', link: 'https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa' },
      { text: 'Discordに参加', link: 'https://discord.gg/wNYzTwZFku' },
    ],
    sidebar: {
      '/ja/guide/': [
        {
          text: 'はじめに',
          items: [
            { text: 'はじめに', link: '/ja/guide/' },
            { text: 'インストール', link: '/ja/guide/installation' },
            { text: '基本的な使い方', link: '/ja/guide/usage' },
            { text: 'プロンプト例', link: '/ja/guide/prompt-examples' },
          ],
        },
        {
          text: '使い方',
          items: [
            { text: '出力フォーマット', link: '/ja/guide/output' },
            { text: 'コマンドラインオプション', link: '/ja/guide/command-line-options' },
            { text: '設定', link: '/ja/guide/configuration' },
            { text: 'カスタム指示', link: '/ja/guide/custom-instructions' },
            { text: 'リモートリポジトリの処理', link: '/ja/guide/remote-repository-processing' },
            { text: 'コメントの削除', link: '/ja/guide/comment-removal' },
            { text: 'コード圧縮', link: '/ja/guide/code-compress' },
            { text: 'セキュリティ', link: '/ja/guide/security' },
            { text: 'MCPサーバー', link: '/ja/guide/mcp-server' },
            { text: 'GitHub Actions', link: '/ja/guide/github-actions' },
          ],
        },
        {
          text: '高度な使い方',
          items: [
            { text: 'ライブラリとしての使用', link: '/ja/guide/development/using-repomix-as-a-library' },
            { text: 'AI支援開発のヒント', link: '/ja/guide/tips/best-practices' },
            { text: 'Repomixへの貢献', link: '/ja/guide/development/' },
          ],
        },
      ],
    },
  },
});

export const configJaSearch: DefaultTheme.LocalSearchOptions['locales'] = {
  ja: {
    translations: {
      button: {
        buttonText: '検索',
        buttonAriaLabel: '検索',
      },
      modal: {
        noResultsText: '検索結果がありません',
        resetButtonTitle: '検索をリセット',
        backButtonTitle: '前に戻る',
        displayDetails: '詳細を表示',
        footer: {
          selectText: '選択',
          navigateText: '移動',
          closeText: '閉じる',
        },
      },
    },
  },
};
</file>

<file path="website/client/.vitepress/config/configKo.ts">
import { type DefaultTheme, defineConfig } from 'vitepress';

export const configKo = defineConfig({
  lang: 'ko',
  description: '코드베이스를 AI 친화적인 형식으로 패키징',
  themeConfig: {
    nav: [
      { text: '가이드', link: '/ko/guide/', activeMatch: '^/ko/guide/' },
      {
        text: 'Chrome 확장 프로그램',
        link: 'https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa',
      },
      { text: 'Discord 참여', link: 'https://discord.gg/wNYzTwZFku' },
    ],
    sidebar: {
      '/ko/guide/': [
        {
          text: '소개',
          items: [
            { text: '시작하기', link: '/ko/guide/' },
            { text: '설치', link: '/ko/guide/installation' },
            { text: '기본 사용법', link: '/ko/guide/usage' },
            { text: '프롬프트 예제', link: '/ko/guide/prompt-examples' },
          ],
        },
        {
          text: '가이드',
          items: [
            { text: '출력 형식', link: '/ko/guide/output' },
            { text: '명령줄 옵션', link: '/ko/guide/command-line-options' },
            { text: '설정', link: '/ko/guide/configuration' },
            { text: '사용자 정의 지침', link: '/ko/guide/custom-instructions' },
            { text: '원격 저장소 처리', link: '/ko/guide/remote-repository-processing' },
            { text: '주석 제거', link: '/ko/guide/comment-removal' },
            { text: '코드 압축', link: '/ko/guide/code-compress' },
            { text: '보안', link: '/ko/guide/security' },
            { text: 'MCP 서버', link: '/ko/guide/mcp-server' },
            { text: 'GitHub Actions', link: '/ko/guide/github-actions' },
          ],
        },
        {
          text: '고급',
          items: [
            { text: 'Repomix를 라이브러리로 사용하기', link: '/ko/guide/development/using-repomix-as-a-library' },
            { text: 'AI 지원 개발 팁', link: '/ko/guide/tips/best-practices' },
            { text: 'Repomix에 기여하기', link: '/ko/guide/development/' },
          ],
        },
      ],
    },
  },
});

export const configKoSearch: DefaultTheme.LocalSearchOptions['locales'] = {
  ko: {
    translations: {
      button: {
        buttonText: '검색',
        buttonAriaLabel: '검색',
      },
      modal: {
        noResultsText: '검색 결과가 없습니다',
        resetButtonTitle: '검색 초기화',
        backButtonTitle: '뒤로',
        displayDetails: '상세 정보 표시',
        footer: {
          selectText: '선택',
          navigateText: '이동',
          closeText: '닫기',
        },
      },
    },
  },
};
</file>

<file path="website/client/.vitepress/config/configPtBr.ts">
import { type DefaultTheme, defineConfig } from 'vitepress';

export const configPtBr = defineConfig({
  lang: 'pt-BR',
  description: 'Empacote sua base de código em formatos amigáveis para IA',
  themeConfig: {
    nav: [
      { text: 'Guia', link: '/pt-br/guide/', activeMatch: '^/pt-br/guide/' },
      {
        text: 'Extensão do Chrome',
        link: 'https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa',
      },
      { text: 'Entrar no Discord', link: 'https://discord.gg/wNYzTwZFku' },
    ],
    sidebar: {
      '/pt-br/guide/': [
        {
          text: 'Introdução',
          items: [
            { text: 'Começando', link: '/pt-br/guide/' },
            { text: 'Instalação', link: '/pt-br/guide/installation' },
            { text: 'Uso Básico', link: '/pt-br/guide/usage' },
            { text: 'Exemplos de Prompt', link: '/pt-br/guide/prompt-examples' },
          ],
        },
        {
          text: 'Guia',
          items: [
            { text: 'Formatos de Saída', link: '/pt-br/guide/output' },
            { text: 'Opções de Linha de Comando', link: '/pt-br/guide/command-line-options' },
            { text: 'Configuração', link: '/pt-br/guide/configuration' },
            { text: 'Instruções Personalizadas', link: '/pt-br/guide/custom-instructions' },
            { text: 'Processamento de Repositório Remoto', link: '/pt-br/guide/remote-repository-processing' },
            { text: 'Remoção de Comentários', link: '/pt-br/guide/comment-removal' },
            { text: 'Compressão de Código', link: '/pt-br/guide/code-compress' },
            { text: 'Segurança', link: '/pt-br/guide/security' },
            { text: 'Servidor MCP', link: '/pt-br/guide/mcp-server' },
            { text: 'GitHub Actions', link: '/pt-br/guide/github-actions' },
          ],
        },
        {
          text: 'Avançado',
          items: [
            { text: 'Usando Repomix como Biblioteca', link: '/pt-br/guide/development/using-repomix-as-a-library' },
            { text: 'Dicas de Desenvolvimento Assistido por IA', link: '/pt-br/guide/tips/best-practices' },
            { text: 'Contribuindo para o Repomix', link: '/pt-br/guide/development/' },
          ],
        },
      ],
    },
  },
});

export const configPtBrSearch: DefaultTheme.LocalSearchOptions['locales'] = {
  'pt-BR': {
    translations: {
      button: {
        buttonText: 'Pesquisar',
        buttonAriaLabel: 'Pesquisar',
      },
      modal: {
        noResultsText: 'Nenhum resultado encontrado',
        resetButtonTitle: 'Limpar pesquisa',
        backButtonTitle: 'Voltar',
        displayDetails: 'Mostrar detalhes',
        footer: {
          selectText: 'Selecionar',
          navigateText: 'Navegar',
          closeText: 'Fechar',
        },
      },
    },
  },
};
</file>

<file path="website/client/.vitepress/config/configShard.ts">
import { visualizer } from 'rollup-plugin-visualizer';
import { type ManifestOptions, VitePWA } from 'vite-plugin-pwa';
import { defineConfig } from 'vitepress';
import { configDeSearch } from './configDe';
import { configEsSearch } from './configEs';
import { configHiSearch } from './configHi';
import { configIdSearch } from './configId';
import { configJaSearch } from './configJa';
import { configKoSearch } from './configKo';
import { configPtBrSearch } from './configPtBr';
import { configViSearch } from './configVi';
import { configZhCnSearch } from './configZhCn';
import { configZhTwSearch } from './configZhTw';

const googleAnalyticsTag = 'G-7PTT4PLC69';

// PWA Manifest Configuration
const manifest: Partial<ManifestOptions> = {
  name: 'Repomix',
  short_name: 'Repomix',
  description: 'Pack your codebase into AI-friendly formats',
  theme_color: '#f97316',
  background_color: '#ffffff',
  display: 'standalone',
  icons: [
    {
      src: '/images/pwa/repomix-192x192.png',
      sizes: '192x192',
      type: 'image/png',
    },
    {
      src: '/images/pwa/repomix-512x512.png',
      sizes: '512x512',
      type: 'image/png',
    },
    {
      src: '/images/pwa/repomix-512x512.png',
      sizes: '512x512',
      type: 'image/png',
      purpose: 'any maskable',
    },
  ],
};

export const configShard = defineConfig({
  title: 'Repomix',

  srcDir: 'src',

  rewrites: {
    // rewrite to `en` locale
    'en/:rest*': ':rest*',
  },

  lastUpdated: true,
  cleanUrls: true,
  metaChunk: true,

  sitemap: {
    hostname: 'https://repomix.com/',
  },

  // Shared configuration
  themeConfig: {
    logo: { src: '/images/repomix-logo.svg', width: 24, height: 24 },
    search: {
      provider: 'local',
      options: {
        locales: {
          ...configDeSearch,
          ...configEsSearch,
          ...configHiSearch,
          ...configIdSearch,
          ...configJaSearch,
          ...configKoSearch,
          ...configPtBrSearch,
          ...configViSearch,
          ...configZhCnSearch,
          ...configZhTwSearch,
        },
      },
    },
    socialLinks: [
      { icon: 'x', link: 'https://x.com/repomix_ai' },
      { icon: 'discord', link: 'https://discord.gg/wNYzTwZFku' },
      { icon: 'github', link: 'https://github.com/yamadashy/repomix' },
    ],
    footer: {
      message: 'Released under the MIT License.',
      copyright: 'Copyright © 2024 Kazuki Yamada',
    },
    // Language selection
    langMenuLabel: 'Languages',
  },

  head: [
    // Favicon
    ['link', { rel: 'icon', href: '/images/repomix-logo.svg' }],

    // OGP
    ['meta', { property: 'og:type', content: 'website' }],
    ['meta', { property: 'og:title', content: 'Repomix' }],
    ['meta', { property: 'og:site_name', content: 'Repomix' }],
    ['meta', { property: 'og:image', content: 'https://repomix.com/images/og-image-large.png' }],
    ['meta', { property: 'og:url', content: 'https://repomix.com' }],
    ['meta', { property: 'og:description', content: 'Pack your codebase into AI-friendly formats' }],
    ['meta', { name: 'twitter:card', content: 'summary_large_image' }],
    ['meta', { property: 'twitter:domain', content: 'https://repomix.com' }],
    ['meta', { property: 'twitter:url', content: 'https://repomix.com' }],
    ['meta', { name: 'twitter:title', content: 'Repomix' }],
    ['meta', { name: 'twitter:description', content: 'Pack your codebase into AI-friendly formats' }],
    ['meta', { name: 'twitter:image', content: 'https://repomix.com/images/og-image-large.png' }],
    ['meta', { name: 'thumbnail', content: 'https://repomix.com/images/og-image-large.png' }],

    // PWA
    ['meta', { name: 'theme-color', content: '#f97316' }],
    ['meta', { name: 'apple-mobile-web-app-capable', content: 'yes' }],
    ['meta', { name: 'apple-mobile-web-app-status-bar-style', content: 'black' }],
    ['meta', { name: 'apple-mobile-web-app-title', content: 'Repomix' }],
    ['link', { rel: 'apple-touch-icon', href: '/images/pwa/repomix-192x192.png' }],
    ['link', { rel: 'mask-icon', href: '/images/repomix-logo.svg', color: '#f97316' }],

    // Google Analytics
    [
      'script',
      {
        async: 'true',
        src: `https://www.googletagmanager.com/gtag/js?id=${googleAnalyticsTag}`,
      },
    ],
    [
      'script',
      {},
      `window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', '${googleAnalyticsTag}');`,
    ],
  ],

  vite: {
    build: {
      rollupOptions: {
        plugins: [
          visualizer({
            filename: 'stats.html',
            open: false,
            template: 'treemap',
            gzipSize: true,
            brotliSize: true,
          }),
        ],
      },
    },
    plugins: [
      VitePWA({
        registerType: 'autoUpdate',
        manifest,
        workbox: {
          globPatterns: ['**/*.{js,css,html,ico,png,svg,woff,woff2}'],
          skipWaiting: true,
          clientsClaim: true,
          runtimeCaching: [
            {
              urlPattern: /\.(?:js|css|png|jpg|jpeg|svg|gif|webp)$/i,
              handler: 'NetworkFirst',
              options: {
                cacheName: 'static-resources-cache',
                expiration: {
                  maxEntries: 100,
                  maxAgeSeconds: 60 * 60 * 24, // 1 day
                },
                cacheableResponse: {
                  statuses: [0, 200],
                },
              },
            },
          ],
        },
      }),
    ],
  },
});
</file>

<file path="website/client/.vitepress/config/configVi.ts">
import { type DefaultTheme, defineConfig } from 'vitepress';

export const configVi = defineConfig({
  lang: 'vi',
  description: 'Đóng gói codebase của bạn thành các định dạng thân thiện với AI',
  themeConfig: {
    nav: [
      { text: 'Hướng dẫn', link: '/vi/guide/', activeMatch: '^/vi/guide/' },
      {
        text: 'Tiện ích Chrome',
        link: 'https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa',
      },
      { text: 'Tham gia Discord', link: 'https://discord.gg/wNYzTwZFku' },
    ],
    sidebar: {
      '/vi/guide/': [
        {
          text: 'Giới thiệu',
          items: [
            { text: 'Bắt đầu', link: '/vi/guide/' },
            { text: 'Cài đặt', link: '/vi/guide/installation' },
            { text: 'Sử dụng cơ bản', link: '/vi/guide/usage' },
            { text: 'Ví dụ Prompt', link: '/vi/guide/prompt-examples' },
          ],
        },
        {
          text: 'Hướng dẫn',
          items: [
            { text: 'Định dạng đầu ra', link: '/vi/guide/output' },
            { text: 'Tùy chọn dòng lệnh', link: '/vi/guide/command-line-options' },
            { text: 'Cấu hình', link: '/vi/guide/configuration' },
            { text: 'Hướng dẫn tùy chỉnh', link: '/vi/guide/custom-instructions' },
            { text: 'Xử lý kho lưu trữ từ xa', link: '/vi/guide/remote-repository-processing' },
            { text: 'Xóa bình luận', link: '/vi/guide/comment-removal' },
            { text: 'Nén mã', link: '/vi/guide/code-compress' },
            { text: 'Bảo mật', link: '/vi/guide/security' },
            { text: 'Máy chủ MCP', link: '/vi/guide/mcp-server' },
            { text: 'GitHub Actions', link: '/vi/guide/github-actions' },
          ],
        },
        {
          text: 'Nâng cao',
          items: [
            {
              text: 'Sử dụng Repomix như một thư viện',
              link: '/vi/guide/development/using-repomix-as-a-library',
            },
            { text: 'Mẹo phát triển hỗ trợ AI', link: '/vi/guide/tips/best-practices' },
            { text: 'Đóng góp cho Repomix', link: '/vi/guide/development/' },
          ],
        },
      ],
    },
  },
});

export const configViSearch: DefaultTheme.LocalSearchOptions['locales'] = {
  vi: {
    translations: {
      button: {
        buttonText: 'Tìm kiếm',
        buttonAriaLabel: 'Tìm kiếm',
      },
      modal: {
        noResultsText: 'Không tìm thấy kết quả',
        resetButtonTitle: 'Đặt lại tìm kiếm',
        backButtonTitle: 'Quay lại',
        displayDetails: 'Hiển thị chi tiết',
        footer: {
          selectText: 'Chọn',
          navigateText: 'Điều hướng',
          closeText: 'Đóng',
        },
      },
    },
  },
};
</file>

<file path="website/client/.vitepress/config/configZhCn.ts">
import { type DefaultTheme, defineConfig } from 'vitepress';

export const configZhCn = defineConfig({
  lang: 'zh-CN',
  description: '将代码库打包成AI友好的格式',
  themeConfig: {
    nav: [
      { text: '指南', link: '/zh-cn/guide/', activeMatch: '^/zh-cn/guide/' },
      { text: 'Chrome扩展', link: 'https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa' },
      { text: '加入 Discord', link: 'https://discord.gg/wNYzTwZFku' },
    ],
    sidebar: {
      '/zh-cn/guide/': [
        {
          text: '介绍',
          items: [
            { text: '开始使用', link: '/zh-cn/guide/' },
            { text: '安装', link: '/zh-cn/guide/installation' },
            { text: '基本用法', link: '/zh-cn/guide/usage' },
            { text: '提示示例', link: '/zh-cn/guide/prompt-examples' },
          ],
        },
        {
          text: '指南',
          items: [
            { text: '输出格式', link: '/zh-cn/guide/output' },
            { text: '命令行选项', link: '/zh-cn/guide/command-line-options' },
            { text: '配置', link: '/zh-cn/guide/configuration' },
            { text: '自定义指令', link: '/zh-cn/guide/custom-instructions' },
            { text: '远程仓库处理', link: '/zh-cn/guide/remote-repository-processing' },
            { text: '注释移除', link: '/zh-cn/guide/comment-removal' },
            { text: '代码压缩', link: '/zh-cn/guide/code-compress' },
            { text: '安全性', link: '/zh-cn/guide/security' },
            { text: 'MCP 服务器', link: '/zh-cn/guide/mcp-server' },
            { text: 'GitHub Actions', link: '/zh-cn/guide/github-actions' },
          ],
        },
        {
          text: '高级',
          items: [
            { text: '作为库使用 Repomix', link: '/zh-cn/guide/development/using-repomix-as-a-library' },
            { text: 'AI辅助开发技巧', link: '/zh-cn/guide/tips/best-practices' },
            { text: '为Repomix做贡献', link: '/zh-cn/guide/development/' },
          ],
        },
      ],
    },
  },
});

export const configZhCnSearch: DefaultTheme.LocalSearchOptions['locales'] = {
  'zh-CN': {
    translations: {
      button: {
        buttonText: '搜索',
        buttonAriaLabel: '搜索',
      },
      modal: {
        noResultsText: '未找到相关结果',
        resetButtonTitle: '清除搜索',
        backButtonTitle: '返回',
        displayDetails: '显示详情',
        footer: {
          selectText: '选择',
          navigateText: '切换',
          closeText: '关闭',
        },
      },
    },
  },
};
</file>

<file path="website/client/.vitepress/config/configZhTw.ts">
import { type DefaultTheme, defineConfig } from 'vitepress';

export const configZhTw = defineConfig({
  lang: 'zh-TW',
  description: '將程式碼庫打包成AI友好的格式',
  themeConfig: {
    nav: [
      { text: '指南', link: '/zh-tw/guide/', activeMatch: '^/zh-tw/guide/' },
      {
        text: 'Chrome擴充功能',
        link: 'https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa',
      },
      { text: '加入 Discord', link: 'https://discord.gg/wNYzTwZFku' },
    ],
    sidebar: {
      '/zh-tw/guide/': [
        {
          text: '介紹',
          items: [
            { text: '開始使用', link: '/zh-tw/guide/' },
            { text: '安裝', link: '/zh-tw/guide/installation' },
            { text: '基本用法', link: '/zh-tw/guide/usage' },
            { text: '提示範例', link: '/zh-tw/guide/prompt-examples' },
          ],
        },
        {
          text: '指南',
          items: [
            { text: '輸出格式', link: '/zh-tw/guide/output' },
            { text: '命令行選項', link: '/zh-tw/guide/command-line-options' },
            { text: '配置', link: '/zh-tw/guide/configuration' },
            { text: '自定義指令', link: '/zh-tw/guide/custom-instructions' },
            { text: '遠端倉庫處理', link: '/zh-tw/guide/remote-repository-processing' },
            { text: '註釋移除', link: '/zh-tw/guide/comment-removal' },
            { text: '程式碼壓縮', link: '/zh-tw/guide/code-compress' },
            { text: '安全性', link: '/zh-tw/guide/security' },
            { text: 'MCP 伺服器', link: '/zh-tw/guide/mcp-server' },
            { text: 'GitHub Actions', link: '/zh-tw/guide/github-actions' },
          ],
        },
        {
          text: '高級',
          items: [
            { text: '作為庫使用 Repomix', link: '/zh-tw/guide/development/using-repomix-as-a-library' },
            { text: 'AI輔助開發技巧', link: '/zh-tw/guide/tips/best-practices' },
            { text: '為Repomix做貢獻', link: '/zh-tw/guide/development/' },
          ],
        },
      ],
    },
  },
});

export const configZhTwSearch: DefaultTheme.LocalSearchOptions['locales'] = {
  'zh-TW': {
    translations: {
      button: {
        buttonText: '搜尋',
        buttonAriaLabel: '搜尋',
      },
      modal: {
        noResultsText: '未找到相關結果',
        resetButtonTitle: '清除搜尋',
        backButtonTitle: '返回',
        displayDetails: '顯示詳情',
        footer: {
          selectText: '選擇',
          navigateText: '切換',
          closeText: '關閉',
        },
      },
    },
  },
};
</file>

<file path="website/client/.vitepress/theme/component.d.ts">
declare module '*.vue' {
  import type { DefineComponent } from 'vue';
  // biome-ignore lint lint/suspicious/noExplicitAny: Vue component
  const component: DefineComponent<{}, {}, any>;
  export default component;
}
</file>

<file path="website/client/.vitepress/theme/custom.css">
:root {
  --vp-c-brand-1: #f97316;
  --vp-c-brand-2: #ea580c;
  --vp-c-brand-3: #c2410c;
  --vp-c-brand-soft: rgba(249, 115, 22, 0.1);

  --vp-c-danger: #f44336;

  --vp-home-hero-name-color: transparent;
  --vp-home-hero-name-background: linear-gradient(120deg, #f97316 30%, #ffb25c);

  --vp-home-hero-image-background-image: linear-gradient(-45deg, rgba(249, 115, 22, 0.3) 30%, rgba(249, 115, 22, 0.1));
  --vp-home-hero-image-filter: blur(96px);
}

.hero-description__accent {
  color: var(--vp-c-brand-1);
}
.cli-section {
  margin-bottom: 32px;
  max-width: 800px;
  margin-left: auto;
  margin-right: auto;
}

.cli-section h2 {
  font-size: 2.0rem;
  font-weight: 600;
  line-height: 38px;
  margin-bottom: 1.5rem;
  background: linear-gradient(120deg, #f97316 30%, #ffb25c);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}
</file>

<file path="website/client/.vitepress/theme/index.ts">
import type { Theme } from 'vitepress';
import DefaultTheme from 'vitepress/theme';
import { h } from 'vue';
import Home from '../../components/Home.vue';
import HomeBadges from '../../components/HomeBadges.vue';
import './custom.css';

export default {
  extends: DefaultTheme,
  Layout: () => {
    return h(DefaultTheme.Layout, null, {
      'home-hero-after': () => h(Home),
      'home-features-after': () => h(HomeBadges),
    });
  },
} satisfies Theme;
</file>

<file path="website/client/.vitepress/theme/style.css">
/**
 * Customize default theme styling by overriding CSS variables:
 * https://github.com/vuejs/vitepress/blob/main/src/client/theme-default/styles/vars.css
 */

/**
 * Colors
 *
 * Each colors have exact same color scale system with 3 levels of solid
 * colors with different brightness, and 1 soft color.
 *
 * - `XXX-1`: The most solid color used mainly for colored text. It must
 *   satisfy the contrast ratio against when used on top of `XXX-soft`.
 *
 * - `XXX-2`: The color used mainly for hover state of the button.
 *
 * - `XXX-3`: The color for solid background, such as bg color of the button.
 *   It must satisfy the contrast ratio with pure white (#ffffff) text on
 *   top of it.
 *
 * - `XXX-soft`: The color used for subtle background such as custom container
 *   or badges. It must satisfy the contrast ratio when putting `XXX-1` colors
 *   on top of it.
 *
 *   The soft color must be semi transparent alpha channel. This is crucial
 *   because it allows adding multiple "soft" colors on top of each other
 *   to create a accent, such as when having inline code block inside
 *   custom containers.
 *
 * - `default`: The color used purely for subtle indication without any
 *   special meanings attached to it such as bg color for menu hover state.
 *
 * - `brand`: Used for primary brand colors, such as link text, button with
 *   brand theme, etc.
 *
 * - `tip`: Used to indicate useful information. The default theme uses the
 *   brand color for this by default.
 *
 * - `warning`: Used to indicate warning to the users. Used in custom
 *   container, badges, etc.
 *
 * - `danger`: Used to show error, or dangerous message to the users. Used
 *   in custom container, badges, etc.
 * -------------------------------------------------------------------------- */

:root {
  --vp-c-default-1: var(--vp-c-gray-1);
  --vp-c-default-2: var(--vp-c-gray-2);
  --vp-c-default-3: var(--vp-c-gray-3);
  --vp-c-default-soft: var(--vp-c-gray-soft);

  --vp-c-brand-1: var(--vp-c-indigo-1);
  --vp-c-brand-2: var(--vp-c-indigo-2);
  --vp-c-brand-3: var(--vp-c-indigo-3);
  --vp-c-brand-soft: var(--vp-c-indigo-soft);

  --vp-c-tip-1: var(--vp-c-brand-1);
  --vp-c-tip-2: var(--vp-c-brand-2);
  --vp-c-tip-3: var(--vp-c-brand-3);
  --vp-c-tip-soft: var(--vp-c-brand-soft);

  --vp-c-warning-1: var(--vp-c-yellow-1);
  --vp-c-warning-2: var(--vp-c-yellow-2);
  --vp-c-warning-3: var(--vp-c-yellow-3);
  --vp-c-warning-soft: var(--vp-c-yellow-soft);

  --vp-c-danger-1: var(--vp-c-red-1);
  --vp-c-danger-2: var(--vp-c-red-2);
  --vp-c-danger-3: var(--vp-c-red-3);
  --vp-c-danger-soft: var(--vp-c-red-soft);
}

/**
 * Component: Button
 * -------------------------------------------------------------------------- */

:root {
  --vp-button-brand-border: transparent;
  --vp-button-brand-text: var(--vp-c-white);
  --vp-button-brand-bg: var(--vp-c-brand-3);
  --vp-button-brand-hover-border: transparent;
  --vp-button-brand-hover-text: var(--vp-c-white);
  --vp-button-brand-hover-bg: var(--vp-c-brand-2);
  --vp-button-brand-active-border: transparent;
  --vp-button-brand-active-text: var(--vp-c-white);
  --vp-button-brand-active-bg: var(--vp-c-brand-1);
}

/**
 * Component: Home
 * -------------------------------------------------------------------------- */

:root {
  --vp-home-hero-name-color: transparent;
  --vp-home-hero-name-background: -webkit-linear-gradient(120deg, #bd34fe 30%, #41d1ff);

  --vp-home-hero-image-background-image: linear-gradient(-45deg, #bd34fe 50%, #47caff 50%);
  --vp-home-hero-image-filter: blur(44px);
}

@media (min-width: 640px) {
  :root {
    --vp-home-hero-image-filter: blur(56px);
  }
}

@media (min-width: 960px) {
  :root {
    --vp-home-hero-image-filter: blur(68px);
  }
}

/**
 * Component: Custom Block
 * -------------------------------------------------------------------------- */

:root {
  --vp-custom-block-tip-border: transparent;
  --vp-custom-block-tip-text: var(--vp-c-text-1);
  --vp-custom-block-tip-bg: var(--vp-c-brand-soft);
  --vp-custom-block-tip-code-bg: var(--vp-c-brand-soft);
}

/**
 * Component: Algolia
 * -------------------------------------------------------------------------- */

.DocSearch {
  --docsearch-primary-color: var(--vp-c-brand-1) !important;
}
</file>

<file path="website/client/.vitepress/config.ts">
import { defineConfig } from 'vitepress';
import { configDe } from './config/configDe';
import { configEnUs } from './config/configEnUs';
import { configEs } from './config/configEs';
import { configFr } from './config/configFr';
import { configHi } from './config/configHi';
import { configId } from './config/configId';
import { configJa } from './config/configJa';
import { configKo } from './config/configKo';
import { configPtBr } from './config/configPtBr';
import { configShard } from './config/configShard';
import { configVi } from './config/configVi';
import { configZhCn } from './config/configZhCn';
import { configZhTw } from './config/configZhTw';

export default defineConfig({
  ...configShard,
  locales: {
    root: { label: 'English (United States)', ...configEnUs },
    'zh-cn': { label: '简体中文 (中国)', ...configZhCn },
    'zh-tw': { label: '繁體中文 (台灣)', ...configZhTw },
    ja: { label: '日本語 (日本)', ...configJa },
    es: { label: 'Español (España)', ...configEs },
    'pt-br': { label: 'Português (Brasil)', ...configPtBr },
    ko: { label: '한국어 (대한민국)', ...configKo },
    de: { label: 'Deutsch (Deutschland)', ...configDe },
    fr: { label: 'Français (France)', ...configFr },
    hi: { label: 'हिन्दी (भारत)', ...configHi },
    id: { label: 'Indonesia (Indonesia)', ...configId },
    vi: { label: 'Tiếng Việt (Việt Nam)', ...configVi },
  },
});
</file>

<file path="website/client/components/api/client.ts">
export interface PackOptions {
  removeComments: boolean;
  removeEmptyLines: boolean;
  showLineNumbers: boolean;
  fileSummary?: boolean;
  directoryStructure?: boolean;
  includePatterns?: string;
  ignorePatterns?: string;
  outputParsable?: boolean;
  compress?: boolean;
}

export interface PackRequest {
  url: string;
  format: 'xml' | 'markdown' | 'plain';
  options: PackOptions;
  signal?: AbortSignal;
  file?: File;
}

export interface PackResult {
  content: string;
  format: string;
  metadata: {
    repository: string;
    timestamp: string;
    summary: {
      totalFiles: number;
      totalCharacters: number;
      totalTokens: number;
    };
    topFiles: {
      path: string;
      charCount: number;
    }[];
  };
}

export interface ErrorResponse {
  error: string;
}

export class ApiError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ApiError';
  }
}

const API_BASE_URL = import.meta.env.PROD ? 'https://api.repomix.com' : 'http://localhost:8080';

export async function packRepository(request: PackRequest): Promise<PackResult> {
  const formData = new FormData();

  if (request.file) {
    formData.append('file', request.file);
  } else {
    formData.append('url', request.url);
  }
  formData.append('format', request.format);
  formData.append('options', JSON.stringify(request.options));

  const response = await fetch(`${API_BASE_URL}/api/pack`, {
    method: 'POST',
    body: formData,
    signal: request.signal,
  });

  const data = await response.json();

  if (!response.ok) {
    throw new ApiError((data as ErrorResponse).error);
  }

  return data as PackResult;
}
</file>

<file path="website/client/components/Home/Hero.vue">
<script setup>
import { useData } from 'vitepress';

const { site } = useData();
</script>

<template>
  <section class="hero">
    <h1 class="hero-title">
      {{ site.title }}
    </h1>
    <p class="hero-description">
      Pack your codebase into <span class="hero-description__accent">AI-friendly</span> formats
    </p>
  </section>
</template>

<style scoped>
.hero {
  text-align: center;
  padding: 20px 20px;
  max-width: 960px;
  margin: 0 auto;
}

.hero-title {
  font-size: 64px;
  font-weight: 700;
  line-height: 1.2;
  margin-bottom: 24px;
  background: -webkit-linear-gradient(0deg, #f97316 30%, #ffb25c);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.hero-description {
  font-size: 32px;
  font-weight: 600;
  line-height: 1.4;
  margin-bottom: 16px;
  color: var(--vp-c-text-1);
}

.hero-description__accent {
  color: var(--vp-c-brand-1);
}

.hero-tagline {
  font-size: 18px;
  color: var(--vp-c-text-2);
  margin: 0;
}

@media (max-width: 768px) {
  .hero-title {
    font-size: 48px;
  }

  .hero-description {
    font-size: 24px;
  }

  .hero-tagline {
    font-size: 16px;
  }
}
</style>
</file>

<file path="website/client/components/Home/PackButton.vue">
<template>
  <button
    class="pack-button"
    :disabled="!isValid || loading"
    aria-label="Pack repository"
    type="submit"
  >
    {{ loading ? 'Processing...' : 'Pack' }}
    <svg
      v-if="!loading"
      class="pack-button-icon"
      width="20"
      height="20"
      viewBox="96.259 93.171 300 300"
    >
      <g transform="matrix(1.160932, 0, 0, 1.160932, 97.635941, 94.725143)">
        <path
          fill="currentColor"
          d="M 128.03 -1.486 L 21.879 65.349 L 21.848 190.25 L 127.979 256.927 L 234.2 190.27 L 234.197 65.463 L 128.03 -1.486 Z M 208.832 70.323 L 127.984 121.129 L 47.173 70.323 L 128.144 19.57 L 208.832 70.323 Z M 39.669 86.367 L 119.188 136.415 L 119.255 230.529 L 39.637 180.386 L 39.669 86.367 Z M 136.896 230.506 L 136.887 136.575 L 216.469 86.192 L 216.417 180.46 L 136.896 230.506 Z M 136.622 230.849"
        />
      </g>
    </svg>
  </button>
</template>

<script setup>
defineProps({
  loading: Boolean,
  isValid: Boolean,
});
</script>

<style scoped>
.pack-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 12px 24px;
  height: 50px;
  width: 100%;
  font-size: 16px;
  font-weight: 500;
  background: var(--vp-c-brand-1);
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;

}

.pack-button:hover:not(:disabled) {
  background: var(--vp-c-brand-2);
}

.pack-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.pack-button-icon {
  font-size: 20px;
  line-height: 1;
}

@media (max-width: 768px) {
  .pack-button {
    width: 100%;
  }
}
</style>
</file>

<file path="website/client/components/Home/TryIt.vue">
<template>
  <div class="container">
    <form class="try-it-container" @submit.prevent="handleSubmit">
      <div class="input-row">
        <div class="tab-container">
          <button
            type="button"
            :class="{ active: mode === 'url' }"
            @click="setMode('url')"
          >
            <Link2 size="20" class="icon" />
          </button>
          <button
            type="button"
            :class="{ active: mode === 'folder' }"
            @click="setMode('folder')"
          >
            <FolderOpen size="20" class="icon" />
          </button>
          <button
            type="button"
            :class="{ active: mode === 'file' }"
            @click="setMode('file')"
          >
            <FolderArchive size="20" class="icon" />
          </button>
        </div>

        <div class="input-field">
          <TryItFileUpload
            v-if="mode === 'file'"
            @upload="handleFileUpload"
            :loading="loading"
            :show-button="false"
          />
          <TryItFolderUpload
            v-else-if="mode === 'folder'"
            @upload="handleFileUpload"
            :loading="loading"
            :show-button="false"
          />
          <TryItUrlInput
            v-else
            v-model:url="inputUrl"
            :loading="loading"
            @keydown="handleKeydown"
            @submit="handleSubmit"
            :show-button="false"
          />
        </div>

        <div class="pack-button-wrapper">
          <PackButton
            :loading="loading"
            :isValid="isSubmitValid"
          />
        </div>
      </div>

      <TryItPackOptions
        v-model:format="packOptions.format"
        v-model:include-patterns="packOptions.includePatterns"
        v-model:ignore-patterns="packOptions.ignorePatterns"
        v-model:file-summary="packOptions.fileSummary"
        v-model:directory-structure="packOptions.directoryStructure"
        v-model:remove-comments="packOptions.removeComments"
        v-model:remove-empty-lines="packOptions.removeEmptyLines"
        v-model:show-line-numbers="packOptions.showLineNumbers"
        v-model:output-parsable="packOptions.outputParsable"
        v-model:compress="packOptions.compress"
      />

      <div v-if="hasExecuted">
        <TryItResult
          :result="result"
          :loading="loading"
          :error="error"
          :repository-url="inputRepositoryUrl"
        />
      </div>
    </form>
  </div>
</template>

<script setup lang="ts">
import { FolderArchive, FolderOpen, Link2 } from 'lucide-vue-next';
import { nextTick, onMounted } from 'vue';
import { usePackRequest } from '../../composables/usePackRequest';
import { isValidRemoteValue } from '../utils/validation';
import PackButton from './PackButton.vue';
import TryItFileUpload from './TryItFileUpload.vue';
import TryItFolderUpload from './TryItFolderUpload.vue';
import TryItPackOptions from './TryItPackOptions.vue';
import TryItResult from './TryItResult.vue';
import TryItUrlInput from './TryItUrlInput.vue';

// Use composables for state management
const {
  // Pack options
  packOptions,

  // Input states
  inputUrl,
  inputRepositoryUrl,
  mode,
  uploadedFile,

  // Request states
  loading,
  error,
  result,
  hasExecuted,

  // Computed
  isSubmitValid,

  // Actions
  setMode,
  handleFileUpload,
  submitRequest,
} = usePackRequest();

async function handleSubmit() {
  await submitRequest();
}

function handleKeydown(event: KeyboardEvent) {
  if (event.key === 'Enter' && mode.value === 'url' && isSubmitValid.value && !loading.value) {
    handleSubmit();
  }
}

// Add repository parameter handling when component mounts
onMounted(() => {
  // Get URL parameters from window location
  const urlParams = new URLSearchParams(window.location.search);
  const repoParam = urlParams.get('repo');

  // If repository parameter exists and is valid, set it and trigger packing
  if (repoParam) {
    inputUrl.value = repoParam.trim();

    // If the URL is valid, trigger the pack process
    if (isValidRemoteValue(repoParam.trim())) {
      // Use nextTick to ensure the URL is set before submission
      nextTick(() => {
        handleSubmit();
      });
    }
  }
});
</script>

<style scoped>
.container {
  padding: 0 20px;
  margin: 0 auto;
  max-width: 960px;
}

.try-it-container {
  background: var(--vp-c-bg-soft);
  border: 1px solid var(--vp-c-border);
  border-radius: 12px;
  padding: 24px;
}

.input-row {
  display: grid;
  grid-template-columns: auto minmax(0, 1fr) auto;
  gap: 12px;
  margin-bottom: 24px;
  align-items: start;
}

.tab-container {
  display: flex;
  flex-direction: row;
  width: 240px;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid var(--vp-c-border);
}

.tab-container button {
  flex: 1;
  height: 48px;
  padding: 0 16px;
  background: var(--vp-c-bg);
  cursor: pointer;
  font-size: 16px;
  white-space: nowrap;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

.tab-container button:not(:first-child)::before {
  content: '';
  position: absolute;
  left: 0;
  top: 25%;
  height: 50%;
  width: 1px;
  background-color: var(--vp-c-border);
}

.tab-container button:first-child {
  border-radius: 8px 0 0 8px;
}

.tab-container button:last-child {
  border-radius: 0 8px 8px 0;
}

.tab-container button.active {
  background: var(--vp-c-brand-1);
  color: white;
}

.tab-container button.active::before {
  display: none;
}

.tab-container button.active + button::before {
  display: none;
}

.tab-container button .icon {
  color: var(--vp-c-text-1);
}

.tab-container button.active .icon {
  color: white;
}

.input-field {
  align-self: start;
  min-width: 0;
  flex: 1;
  overflow: hidden;
}

.pack-button-wrapper {
  display: flex;
  align-items: stretch;
  align-self: start;
  flex-shrink: 0;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .input-row {
    grid-template-columns: 1fr;
    gap: 12px;
  }

  .tab-container {
    width: 100%;
  }

  .pack-button-wrapper {
    width: 100%;
  }
}
</style>
</file>

<file path="website/client/components/Home/TryItFileUpload.vue">
<script setup lang="ts">
import { AlertTriangle, FolderArchive } from 'lucide-vue-next';
import { useFileUpload } from '../../composables/useFileUpload';
import { useZipProcessor } from '../../composables/useZipProcessor';
import PackButton from './PackButton.vue';

const props = defineProps<{
  loading: boolean;
  showButton?: boolean;
}>();

const emit = defineEmits<{
  upload: [file: File];
}>();

const { validateZipFile } = useZipProcessor();

const {
  fileInput,
  dragActive,
  selectedItem: selectedFile,
  errorMessage,
  hasError,
  isValid,
  inputAttributes,
  handleFileSelect,
  handleDragOver,
  handleDragLeave,
  handleDrop,
  triggerFileInput,
  clearSelection,
} = useFileUpload({
  mode: 'file',
  placeholder: 'Drop your ZIP file here or click to browse (max 10MB)',
  icon: 'file',
  options: {
    maxFileSize: 10 * 1024 * 1024, // 10MB
    acceptedTypes: ['.zip'],
    accept: '.zip',
    validateFile: validateZipFile,
  },
});

async function onFileSelect(files: FileList | null) {
  const result = await handleFileSelect(files);
  if (result.success && result.result) {
    emit('upload', result.result);
  }
}

async function onDrop(event: DragEvent) {
  const result = await handleDrop(event);
  if (result.success && result.result) {
    emit('upload', result.result);
  }
}

function clearFile() {
  clearSelection();
}
</script>

<template>
  <div class="upload-wrapper">
    <div
      class="upload-container"
      :class="{ 'drag-active': dragActive, 'has-error': hasError }"
      @dragover.prevent="handleDragOver"
      @dragleave="handleDragLeave"
      @drop.prevent="onDrop"
      @click="triggerFileInput"
    >
      <input
        ref="fileInput"
        v-bind="inputAttributes"
        class="hidden-input"
        @change="(e) => onFileSelect((e.target as HTMLInputElement).files)"
      />
      <div class="upload-content">
        <div class="upload-icon">
          <AlertTriangle v-if="hasError" class="icon-error" size="20" />
          <FolderArchive v-else class="icon-folder" size="20" />
        </div>
        <div class="upload-text">
          <p v-if="errorMessage" class="error-message">
            {{ errorMessage }}
          </p>
          <p v-else-if="selectedFile" class="selected-file">
            Selected: {{ selectedFile }}
            <button class="clear-button" @click.stop="clearFile">×</button>
          </p>
          <template v-else>
            <p>Drop your ZIP file here or click to browse (max 10MB)</p>
          </template>
        </div>
      </div>
    </div>
  </div>
  <div v-if="showButton" class="pack-button-container">
    <PackButton
      :loading="loading"
      :isValid="isValid"
    />
  </div>
</template>

<style scoped>
.upload-wrapper {
  width: 100%;
}

.upload-container {
  border: 2px dashed var(--vp-c-border);
  border-radius: 8px;
  padding: 0 16px;
  cursor: pointer;
  transition: all 0.2s ease;
  height: 50px;
  display: flex;
  align-items: center;
  background: var(--vp-c-bg);
  user-select: none;
}

.upload-container:hover {
  border-color: var(--vp-c-brand-1);
  background-color: var(--vp-c-bg-soft);
}

.drag-active {
  border-color: var(--vp-c-brand-1);
  background-color: var(--vp-c-bg-soft);
}

.has-error {
  border-color: var(--vp-c-danger-1);
}

.hidden-input {
  display: none;
}

.upload-content {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 12px;
  width: 100%;
  pointer-events: none; /* Allow clicks to pass through to container */
}

.upload-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.icon-folder {
  color: var(--vp-c-text-1);
}

.icon-error {
  color: var(--vp-c-danger-1);
}

.upload-text {
  flex: 1;
  font-size: 14px;
}

.upload-text p {
  margin: 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.error-message {
  color: var(--vp-c-danger-1);
}

.selected-file {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
}

.clear-button {
  background: none;
  border: none;
  color: var(--vp-c-text-2);
  cursor: pointer;
  font-size: 1.2em;
  padding: 0 4px;
  line-height: 1;
  flex-shrink: 0;
  pointer-events: auto; /* Re-enable pointer events for button */
}

.clear-button:hover {
  color: var(--vp-c-text-1);
}

.pack-button-container {
  width: 100%;
  display: flex;
  justify-content: center;
  margin-top: 16px;
}

@media (max-width: 640px) {
  .upload-text p {
    font-size: 13px;
  }
}
</style>
</file>

<file path="website/client/components/Home/TryItFolderUpload.vue">
<script setup lang="ts">
import { AlertTriangle, FolderOpen } from 'lucide-vue-next';
import { useFileUpload } from '../../composables/useFileUpload';
import { useZipProcessor } from '../../composables/useZipProcessor';
import PackButton from './PackButton.vue';

const props = defineProps<{
  loading: boolean;
  showButton?: boolean;
}>();

const emit = defineEmits<{
  upload: [file: File];
}>();

const { createZipFromFiles } = useZipProcessor();

const {
  fileInput,
  dragActive,
  selectedItem: selectedFolder,
  errorMessage,
  hasError,
  isValid,
  inputAttributes,
  handleFileSelect,
  handleDragOver,
  handleDragLeave,
  handleDrop,
  triggerFileInput,
  clearSelection,
} = useFileUpload({
  mode: 'folder',
  placeholder: 'Drop your folder here or click to browse (max 10MB)',
  icon: 'folder',
  options: {
    maxFileSize: 10 * 1024 * 1024, // 10MB
    webkitdirectory: true,
    validateFiles: (files: File[]) => {
      if (files.length === 0) {
        return { valid: false, error: 'The folder is empty.' };
      }
      return { valid: true };
    },
    preprocessFiles: async (files: File[], folderName?: string) => {
      if (!folderName) {
        throw new Error('Folder name is required');
      }
      return await createZipFromFiles(files, folderName);
    },
  },
});

async function onFileSelect(files: FileList | null) {
  const result = await handleFileSelect(files);
  if (result.success && result.result) {
    emit('upload', result.result);
  }
}

async function onDrop(event: DragEvent) {
  const result = await handleDrop(event);
  if (result.success && result.result) {
    emit('upload', result.result);
  }
}

function clearFolder() {
  clearSelection();
}
</script>

<template>
  <div class="upload-wrapper">
    <div
      class="upload-container"
      :class="{ 'drag-active': dragActive, 'has-error': hasError }"
      @dragover.prevent="handleDragOver"
      @dragleave="handleDragLeave"
      @drop.prevent="onDrop"
      @click="triggerFileInput"
    >
      <input
        ref="fileInput"
        v-bind="inputAttributes"
        class="hidden-input"
        @change="(e) => onFileSelect((e.target as HTMLInputElement).files)"
      />
      <div class="upload-content">
        <div class="upload-icon">
          <AlertTriangle v-if="hasError" class="icon-error" size="20" />
          <FolderOpen v-else class="icon-folder" size="20" />
        </div>
        <div class="upload-text">
          <p v-if="errorMessage" class="error-message">
            {{ errorMessage }}
          </p>
          <p v-else-if="selectedFolder" class="selected-file">
            Selected: {{ selectedFolder }}
            <button class="clear-button" @click.stop="clearFolder">×</button>
          </p>
          <template v-else>
            <p>Drop your folder here or click to browse (max 10MB)</p>
          </template>
        </div>
      </div>
    </div>
  </div>
  <div v-if="showButton" class="pack-button-container">
    <PackButton
      :loading="loading"
      :isValid="isValid"
    />
  </div>
</template>

<style scoped>
.upload-wrapper {
  width: 100%;
  min-width: 0;
}

.upload-container {
  border: 2px dashed var(--vp-c-border);
  border-radius: 8px;
  padding: 0 16px;
  cursor: pointer;
  transition: all 0.2s ease;
  height: 50px;
  display: flex;
  align-items: center;
  background: var(--vp-c-bg);
  user-select: none;
  width: 100%;
  box-sizing: border-box;
}

.upload-container:hover {
  border-color: var(--vp-c-brand-1);
  background-color: var(--vp-c-bg-soft);
}

.drag-active {
  border-color: var(--vp-c-brand-1);
  background-color: var(--vp-c-bg-soft);
}

.has-error {
  border-color: var(--vp-c-danger-1);
}

.hidden-input {
  display: none;
}

.upload-content {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 12px;
  width: 100%;
  pointer-events: none;
  overflow: hidden;
}

.upload-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.icon-folder {
  color: var(--vp-c-text-1);
}

.icon-error {
  color: var(--vp-c-danger-1);
}

.upload-text {
  flex: 1;
  font-size: 14px;
  min-width: 0;
  overflow: hidden;
}

.upload-text p {
  margin: 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  width: 100%;
}

.error-message {
  color: var(--vp-c-danger-1);
}

.selected-file {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
  overflow: hidden;
}

.clear-button {
  background: none;
  border: none;
  color: var(--vp-c-text-2);
  cursor: pointer;
  font-size: 1.2em;
  padding: 0 4px;
  line-height: 1;
  flex-shrink: 0;
  pointer-events: auto; /* Re-enable pointer events for button */
}

.clear-button:hover {
  color: var(--vp-c-text-1);
}

.pack-button-container {
  width: 100%;
  display: flex;
  justify-content: center;
  margin-top: 16px;
}

@media (max-width: 640px) {
  .upload-text p {
    font-size: 13px;
  }
}
</style>
</file>

<file path="website/client/components/Home/TryItPackOptions.vue">
<script setup lang="ts">
import { HelpCircle } from 'lucide-vue-next';
import { AnalyticsAction } from '../utils/analytics';
import { handleOptionChange } from '../utils/requestHandlers';

const props = defineProps<{
  format: 'xml' | 'markdown' | 'plain';
  includePatterns: string;
  ignorePatterns: string;
  fileSummary: boolean;
  directoryStructure: boolean;
  removeComments: boolean;
  removeEmptyLines: boolean;
  showLineNumbers: boolean;
  outputParsable: boolean;
  compress: boolean;
}>();

const emit = defineEmits<{
  'update:format': [value: 'xml' | 'markdown' | 'plain'];
  'update:includePatterns': [value: string];
  'update:ignorePatterns': [value: string];
  'update:fileSummary': [value: boolean];
  'update:directoryStructure': [value: boolean];
  'update:removeComments': [value: boolean];
  'update:removeEmptyLines': [value: boolean];
  'update:showLineNumbers': [value: boolean];
  'update:outputParsable': [value: boolean];
  'update:compress': [value: boolean];
}>();

function handleFormatChange(newFormat: 'xml' | 'markdown' | 'plain') {
  emit('update:format', newFormat);
  handleOptionChange(newFormat, AnalyticsAction.FORMAT_CHANGE);
}

function handleIncludePatternsUpdate(patterns: string) {
  emit('update:includePatterns', patterns);
  handleOptionChange(patterns, AnalyticsAction.UPDATE_INCLUDE_PATTERNS);
}

function handleIgnorePatternsUpdate(patterns: string) {
  emit('update:ignorePatterns', patterns);
  handleOptionChange(patterns, AnalyticsAction.UPDATE_IGNORE_PATTERNS);
}

function handleFileSummaryToggle(enabled: boolean) {
  emit('update:fileSummary', enabled);
  handleOptionChange(enabled, AnalyticsAction.TOGGLE_FILE_SUMMARY);
}

function handleDirectoryStructureToggle(enabled: boolean) {
  emit('update:directoryStructure', enabled);
  handleOptionChange(enabled, AnalyticsAction.TOGGLE_DIRECTORY_STRUCTURE);
}

function handleRemoveCommentsToggle(enabled: boolean) {
  emit('update:removeComments', enabled);
  handleOptionChange(enabled, AnalyticsAction.TOGGLE_REMOVE_COMMENTS);
}

function handleRemoveEmptyLinesToggle(enabled: boolean) {
  emit('update:removeEmptyLines', enabled);
  handleOptionChange(enabled, AnalyticsAction.TOGGLE_REMOVE_EMPTY_LINES);
}

function handleShowLineNumbersToggle(enabled: boolean) {
  emit('update:showLineNumbers', enabled);
  handleOptionChange(enabled, AnalyticsAction.TOGGLE_LINE_NUMBERS);
}

function handleOutputParsableToggle(enabled: boolean) {
  emit('update:outputParsable', enabled);
  handleOptionChange(enabled, AnalyticsAction.TOGGLE_OUTPUT_PARSABLE);
}

function handleCompressToggle(enabled: boolean) {
  emit('update:compress', enabled);
  handleOptionChange(enabled, AnalyticsAction.TOGGLE_COMPRESS);
}
</script>

<template>
  <div class="options-container">
    <div class="left-column">
      <div class="option-section">
        <p class="option-label">Output Format</p>
        <div class="format-buttons">
          <button
            class="format-button"
            :class="{ active: format === 'xml' }"
            @click="handleFormatChange('xml')"
            type="button"
          >
            XML
          </button>
          <button
            class="format-button"
            :class="{ active: format === 'markdown' }"
            @click="handleFormatChange('markdown')"
            type="button"
          >
            Markdown
          </button>
          <button
            class="format-button"
            :class="{ active: format === 'plain' }"
            @click="handleFormatChange('plain')"
            type="button"
          >
            Plain
          </button>
        </div>
      </div>

      <div class="option-section">
        <p class="option-label">Include Patterns (using <a href="https://github.com/mrmlnc/fast-glob#pattern-syntax" target="_blank" rel="noopener noreferrer">glob patterns</a>)</p>
        <div class="input-group">
          <input
            :value="includePatterns"
            @input="event => handleIncludePatternsUpdate((event.target as HTMLInputElement).value)"
            type="text"
            class="pattern-input"
            placeholder="Comma-separated patterns to include. e.g., src/**/*.ts"
            aria-label="Include patterns"
          />
        </div>
      </div>

      <div class="option-section">
        <p class="option-label">Ignore Patterns</p>
        <div class="input-group">
          <input
            :value="ignorePatterns"
            @input="event => handleIgnorePatternsUpdate((event.target as HTMLInputElement).value)"
            type="text"
            class="pattern-input"
            placeholder="Comma-separated patterns to ignore. e.g., **/*.test.ts,README.md"
            aria-label="Ignore patterns"
          />
        </div>
      </div>
    </div>

    <div class="right-column">

      <div class="option-section">
        <p class="option-label">Output Format Options</p>
        <div class="checkbox-group">
          <label class="checkbox-label">
            <input
              :checked="fileSummary"
              @change="event => handleFileSummaryToggle((event.target as HTMLInputElement).checked)"
              type="checkbox"
              class="checkbox-input"
            />
            <span>Include File Summary</span>
          </label>
          <label class="checkbox-label">
            <input
              :checked="directoryStructure"
              @change="event => handleDirectoryStructureToggle((event.target as HTMLInputElement).checked)"
              type="checkbox"
              class="checkbox-input"
            />
            <span>Include Directory Structure</span>
          </label>
          <label class="checkbox-label">
            <input
              :checked="showLineNumbers"
              @change="event => handleShowLineNumbersToggle((event.target as HTMLInputElement).checked)"
              type="checkbox"
              class="checkbox-input"
            />
            <span>Show Line Numbers</span>
          </label>
          <label class="checkbox-label">
            <input
              :checked="outputParsable"
              @change="event => handleOutputParsableToggle((event.target as HTMLInputElement).checked)"
              type="checkbox"
              class="checkbox-input"
            />
            <div class="parsable-option">
              <span>Output Parsable Format</span>
              <div class="tooltip-container">
                <HelpCircle
                  :size="16"
                  class="help-icon"
                  aria-label="More information about parsable format"
                />
                <div class="tooltip-content">
                  Whether to escape the output based on the chosen style schema. Note that this can increase token count.
                  <div class="tooltip-arrow"></div>
                </div>
              </div>
            </div>
          </label>
        </div>
      </div>

      <div class="option-section">
        <p class="option-label">File Processing Options</p>
        <div class="checkbox-group">
          <label class="checkbox-label">
            <input
              :checked="compress"
              @change="event => handleCompressToggle((event.target as HTMLInputElement).checked)"
              type="checkbox"
              class="checkbox-input"
            />
            <div class="option-with-tooltip">
              <span>Compress Code</span>
              <div class="tooltip-container">
                <HelpCircle
                  :size="16"
                  class="help-icon"
                  aria-label="More information about code compression"
                />
                <div class="tooltip-content">
                  Utilize Tree-sitter to intelligently extract essential code signatures and structure while removing implementation details, significantly reducing token usage.
                  <div class="tooltip-arrow"></div>
                </div>
              </div>
            </div>
          </label>
          <label class="checkbox-label">
            <input
              :checked="removeComments"
              @change="event => handleRemoveCommentsToggle((event.target as HTMLInputElement).checked)"
              type="checkbox"
              class="checkbox-input"
            />
            <span>Remove Comments</span>
          </label>
          <label class="checkbox-label">
            <input
              :checked="removeEmptyLines"
              @change="event => handleRemoveEmptyLinesToggle((event.target as HTMLInputElement).checked)"
              type="checkbox"
              class="checkbox-input"
            />
            <span>Remove Empty Lines</span>
          </label>
        </div>
      </div>

    </div>
  </div>
</template>

<style scoped>
.options-container {
  display: grid;
  grid-template-columns: 60% 40%;
  gap: 24px;
  margin-bottom: 24px;
}

.left-column,
.right-column {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.right-column {
  gap: 18px;
}

.option-section {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.option-label {
  font-size: 14px;
  font-weight: 500;
  margin: 0;
  color: var(--vp-c-text-2);
  padding-bottom: 4px;
}

.option-label a {
  color: var(--vp-c-brand-1);
  text-decoration: none;
}

.option-label a:hover {
  text-decoration: underline;
}

.option-with-tooltip {
  display: flex;
  align-items: center;
  gap: 4px;
}

.format-buttons {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
}

.format-button {
  padding: 8px 16px;
  font-size: 14px;
  border: 1px solid var(--vp-c-border);
  border-radius: 6px;
  background: var(--vp-c-bg);
  color: var(--vp-c-text-1);
  cursor: pointer;
  transition: all 0.2s ease;
}

.format-button:hover {
  border-color: var(--vp-c-brand-1);
}

.format-button.active {
  background: var(--vp-c-brand-1);
  border-color: var(--vp-c-brand-1);
  color: white;
}

.checkbox-group {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.checkbox-label {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  font-size: 14px;
  color: var(--vp-c-text-1);
}

.checkbox-input {
  width: 16px;
  height: 16px;
  accent-color: var(--vp-c-brand-1);
}

.parsable-option {
  display: flex;
  align-items: center;
  gap: 4px;
}

.tooltip-container {
  position: relative;
  display: inline-block;
}

.help-icon {
  color: #666;
  cursor: help;
  transition: color 0.2s;
}

.help-icon:hover {
  color: #333;
}

.tooltip-content {
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  margin-bottom: 8px;
  padding: 8px 12px;
  background: #333;
  color: white;
  font-size: 0.875rem;
  width: 250px;
  border-radius: 4px;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.2s, visibility 0.2s;
  z-index: 10;
  text-align: left;
}

.tooltip-container:hover .tooltip-content {
  opacity: 1;
  visibility: visible;
}

.tooltip-arrow {
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border-width: 8px;
  border-style: solid;
  border-color: #333 transparent transparent transparent;
}

@media (max-width: 640px) {
  .options-container {
    grid-template-columns: 1fr;
    gap: 24px;
  }

  .left-column,
  .right-column {
    gap: 24px;
  }
}

.input-group {
  display: flex;
  gap: 8px;
}

.pattern-input {
  width: 100%;
  padding: 8px 12px;
  font-size: 16px;
  border: 1px solid var(--vp-c-border);
  border-radius: 6px;
  background: var(--vp-c-bg);
  color: var(--vp-c-text-1);
  transition: border-color 0.2s;
}

.pattern-input:hover {
  border-color: var(--vp-c-brand-1);
}

.pattern-input:focus {
  outline: none;
  border-color: var(--vp-c-brand-1);
}
</style>
</file>

<file path="website/client/components/Home/TryItResult.vue">
<script setup lang="ts">
import type { PackResult } from '../api/client';
import TryItResultContent from './TryItResultContent.vue';
import TryItResultErrorContent from './TryItResultErrorContent.vue';

defineProps<{
  result: PackResult | null;
  loading: boolean;
  error: string | null;
  repositoryUrl?: string;
}>();
</script>

<template>
  <div class="result-viewer">
    <div v-if="loading" class="loading">
      <div class="spinner"></div>
      <p>Processing repository...</p>

      <div class="sponsor-section">
        <p class="sponsor-header">Special thanks to:</p>
        <a href="https://www.warp.dev/repomix" target="_blank" rel="noopener noreferrer">
          <img alt="Warp sponsorship" width="400" src="/images/sponsors/warp/Terminal-Image.png">
        </a>
        <p class="sponsor-title">
          <a href="https://www.warp.dev/repomix" target="_blank" rel="noopener noreferrer">
            Warp, the AI terminal for developers
          </a>
        </p>
        <p class="sponsor-subtitle">
          <a href="https://www.warp.dev/repomix" target="_blank" rel="noopener noreferrer">
            Available for MacOS, Linux, & Windows
          </a>
        </p>
      </div>
    </div>

    <TryItResultErrorContent
      v-else-if="error"
      :message="error"
      :repository-url="repositoryUrl"
    />

    <TryItResultContent
      v-else-if="result"
      :result="result"
    />
  </div>
</template>

<style scoped>
.result-viewer {
  margin-top: 24px;
  border: 1px solid var(--vp-c-border);
  border-radius: 8px;
  overflow: hidden;
}

.loading {
  padding: 36px;
  text-align: center;
}

.spinner {
  width: 40px;
  height: 40px;
  margin: 0 auto 16px;
  border: 3px solid var(--vp-c-brand-1);
  border-radius: 50%;
  border-top-color: transparent;
  animation: spin 1s linear infinite;
}

.sponsor-section {
  margin-top: 16px;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.sponsor-section p {
  margin: 8px 0;
}

.sponsor-section .sponsor-header {
  font-size: 0.9em;
}

.sponsor-section img {
  max-width: 100%;
  height: auto;
  margin: 12px 0;
}

.sponsor-section .sponsor-title {
  font-weight: bold;
  font-size: 1.1em;
  color: var(--vp-c-brand-1);
  text-decoration: underline;
}

.sponsor-section .sponsor-subtitle {
  font-size: 0.9em;
  color: var(--vp-c-brand-1);
  text-decoration: underline;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}
</style>
</file>

<file path="website/client/components/Home/TryItResultContent.vue">
<script setup lang="ts">
import ace, { type Ace } from 'ace-builds';
import themeTomorrowUrl from 'ace-builds/src-noconflict/theme-tomorrow?url';
import themeTomorrowNightUrl from 'ace-builds/src-noconflict/theme-tomorrow_night?url';
import { BarChart2, Copy, Download, GitFork, HeartHandshake, PackageSearch, Share, Star } from 'lucide-vue-next';
import { useData } from 'vitepress';
import { computed, onMounted, onUnmounted, ref, watch } from 'vue';
import { VAceEditor } from 'vue3-ace-editor';
import type { PackResult } from '../api/client';
import {
  canShareFiles,
  copyToClipboard,
  downloadResult,
  formatTimestamp,
  getEditorOptions,
  shareResult,
} from '../utils/resultViewer';

ace.config.setModuleUrl('ace/theme/tomorrow', themeTomorrowUrl);
ace.config.setModuleUrl('ace/theme/tomorrow_night', themeTomorrowNightUrl);

const lightTheme = 'tomorrow';
const darkTheme = 'tomorrow_night';

const props = defineProps<{
  result: PackResult;
}>();

const copied = ref(false);
const shared = ref(false);
const canShare = ref(canShareFiles());
const { isDark } = useData();
const editorInstance = ref<Ace.Editor | null>(null);
const isMobile = ref(false);
const tooltipContainer = ref<HTMLElement | null>(null);
const tooltipContent = ref<HTMLElement | null>(null);

const editorOptions = computed(() => ({
  ...getEditorOptions(),
  theme: isDark.value ? `ace/theme/${darkTheme}` : `ace/theme/${lightTheme}`,
}));

watch(isDark, (newIsDark) => {
  if (editorInstance.value) {
    editorInstance.value.setTheme(newIsDark ? `ace/theme/${darkTheme}` : `ace/theme/${lightTheme}`);
  }
});

const formattedTimestamp = computed(() => {
  return formatTimestamp(props.result.metadata.timestamp);
});

const handleCopy = async (event: Event) => {
  event.preventDefault();
  event.stopPropagation();

  const success = await copyToClipboard(props.result.content, props.result.format);
  if (success) {
    copied.value = true;
    setTimeout(() => {
      copied.value = false;
    }, 2000);
  }
};

const handleDownload = (event: Event) => {
  event.preventDefault();
  event.stopPropagation();
  downloadResult(props.result.content, props.result.format, props.result);
};

const handleShare = async (event: Event) => {
  event.preventDefault();
  event.stopPropagation();

  // Only allow sharing on mobile devices with Web Share API support
  if (!isMobile.value || !canShare.value) {
    console.log('Share is only available on mobile devices');
    return;
  }

  const success = await shareResult(props.result.content, props.result.format, props.result);
  if (success) {
    shared.value = true;
    setTimeout(() => {
      shared.value = false;
    }, 2000);
  } else {
    console.log('Share was cancelled or failed');
  }
};

const handleEditorMount = (editor: Ace.Editor) => {
  editorInstance.value = editor;
};

const updateTooltipPosition = () => {
  if (!tooltipContainer.value || !tooltipContent.value || isMobile.value) return;

  const containerRect = tooltipContainer.value.getBoundingClientRect();
  const tooltipEl = tooltipContent.value;

  // Position above the button with proper spacing for the arrow (like existing tooltips)
  tooltipEl.style.top = `${containerRect.top - 46}px`;
  tooltipEl.style.left = `${containerRect.left + containerRect.width / 2}px`;

  // Show tooltip (override CSS hover states)
  tooltipEl.style.opacity = '1';
  tooltipEl.style.visibility = 'visible';
};

const hideTooltip = () => {
  if (tooltipContent.value) {
    tooltipContent.value.style.opacity = '0';
    tooltipContent.value.style.visibility = 'hidden';
  }
};

const messages = [
  {
    type: 'sponsor',
    link: 'https://github.com/sponsors/yamadashy',
    icon: HeartHandshake,
    text: 'Your support helps maintain and improve it. Thank you!',
    color: '#b04386',
  },
  {
    type: 'star',
    link: 'https://github.com/yamadashy/repomix',
    icon: Star,
    text: 'If you like Repomix, please give us a star on GitHub!',
    color: '#f1c40f',
  },
];

const currentMessageIndex = ref(Math.floor(Math.random() * messages.length));
const supportMessage = computed(() => ({
  type: messages[currentMessageIndex.value].type,
  link: messages[currentMessageIndex.value].link,
  icon: messages[currentMessageIndex.value].icon,
  text: messages[currentMessageIndex.value].text,
  color: messages[currentMessageIndex.value].color,
}));

const handleResize = () => {
  isMobile.value = window.innerWidth <= 768;
};

const handleScroll = () => {
  // Hide tooltip on scroll to prevent detachment from button
  if (tooltipContent.value) {
    tooltipContent.value.style.opacity = '0';
    tooltipContent.value.style.visibility = 'hidden';
  }
};

onMounted(() => {
  isMobile.value = window.innerWidth <= 768;
  window.addEventListener('resize', handleResize);
  window.addEventListener('scroll', handleScroll, { passive: true });
});

onUnmounted(() => {
  window.removeEventListener('resize', handleResize);
  window.removeEventListener('scroll', handleScroll);
});
</script>

<template>
  <div class="content-wrapper">
    <div class="metadata-panel">
      <div class="metadata-section">
        <h3><GitFork :size="16" class="section-icon" /> Repository Info</h3>
        <dl>
          <dt>Repository</dt>
          <dd>{{ result.metadata.repository }}</dd>
          <dt>Generated At</dt>
          <dd>{{ formattedTimestamp }}</dd>
          <dt>Format</dt>
          <dd>{{ result.format }}</dd>
        </dl>
      </div>

      <div class="metadata-section">
        <h3><PackageSearch :size="16" class="section-icon" /> Pack Summary</h3>
        <dl v-if="result.metadata.summary">
          <dt>Total Files</dt>
          <dd>{{ result.metadata.summary.totalFiles.toLocaleString() }} <span class="unit">files</span></dd>
          <dt>Total Tokens</dt>
          <dd>{{ result.metadata.summary.totalTokens.toLocaleString() }} <span class="unit">tokens</span></dd>
          <dt>Total Size</dt>
          <dd>{{ result.metadata.summary.totalCharacters.toLocaleString() }} <span class="unit">chars</span></dd>
        </dl>
      </div>

      <div class="metadata-section" v-if="result.metadata.topFiles">
        <h3><BarChart2 :size="16" class="section-icon" /> Top {{ result.metadata.topFiles.length }} Files</h3>
        <ol class="top-files-list">
          <li v-for="file in result.metadata.topFiles" :key="file.path">
            <div class="file-path">{{ file.path }}</div>
            <div class="file-stats">
              {{ file.tokenCount.toLocaleString() }} <span class="unit">tokens</span> <span class="separator-unit">|</span> {{ file.charCount.toLocaleString() }} <span class="unit">chars</span> <span class="separator-unit">|</span> {{ ((file.tokenCount / result.metadata.summary.totalTokens) * 100).toFixed(1) }}<span class="unit">%</span>
            </div>
          </li>
        </ol>
      </div>
    </div>

    <div class="output-panel">
      <div class="output-actions">
        <button
          class="action-button"
          @click="handleCopy"
          :class="{ copied }"
        >
          <Copy :size="16" />
          {{ copied ? 'Copied!' : 'Copy' }}
        </button>
        <button
          class="action-button"
          @click="handleDownload"
        >
          <Download :size="16" />
          Download
        </button>
        <div v-if="canShare" class="mobile-only" style="flex-basis: 100%"></div>
        <div v-if="canShare" class="tooltip-container" ref="tooltipContainer" @mouseenter="updateTooltipPosition" @mouseleave="hideTooltip">
          <button
            class="action-button"
            @click="handleShare"
            :class="{ shared }"
            :disabled="!isMobile"
            aria-label="Share output via mobile apps"
          >
            <Share :size="16" />
            {{ shared ? 'Shared!' : 'Open with your app' }}
          </button>
          <div class="tooltip-content desktop-only" ref="tooltipContent">
            Only available on mobile devices
            <div class="tooltip-arrow"></div>
          </div>
        </div>
      </div>
      <div class="editor-container">
        <VAceEditor
          v-model:value="result.content"
          :lang="'text'"
          :style="{ height: '100%', width: '100%' }"
          :options="editorOptions"
          @mount="handleEditorMount"
        />
      </div>
    </div>
    <div class="support-notice">
      <div class="support-message">
        <a :href="supportMessage.link" target="_blank" rel="noopener noreferrer" class="support-link">
          <component :is="supportMessage.icon" :size="14" class="support-icon" />
          {{ supportMessage.text }}
        </a>
      </div>
    </div>
  </div>
</template>

<style scoped>
.content-wrapper {
  display: grid;
  grid-template-columns: 300px 1fr;
  grid-template-rows: 445px auto;
}

.metadata-panel {
  padding: 16px;
  border-right: 1px solid var(--vp-c-border);
  background: var(--vp-c-bg-soft);
  overflow-y: auto;
}

.metadata-section {
  margin-bottom: 24px;
}

.metadata-section:last-child {
  margin-bottom: 0;
}

.metadata-section h3 {
  font-size: 14px;
  font-weight: 600;
  margin: 0 0 12px;
  color: var(--vp-c-text-1);
  display: flex;
  align-items: center;
  gap: 6px;
}

.section-icon {
  color: var(--vp-c-text-2);
}

dl {
  margin: 0;
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 8px;
  font-size: 13px;
}

dt {
  color: var(--vp-c-text-2);
  font-weight: 500;
}

dd {
  margin: 0;
  color: var(--vp-c-text-1);
  text-transform: lowercase;
}

.unit {
  color: var(--vp-c-text-2);
  margin-left: 0.3em;
}

.separator-unit {
  color: var(--vp-c-text-3);
  margin: 0 0.5em;
}

.top-files-list {
  margin: 0;
  padding: 0 0 0 0;
  font-size: 13px;
}

.top-files-list li {
  margin-bottom: 8px;
  border-left: 2px solid var(--vp-c-divider);
  padding-left: 8px;
}

.file-path {
  color: var(--vp-c-text-1);
  margin-bottom: 2px;
  word-break: break-all;
}

.file-stats {
  font-size: 12px;
  color: var(--vp-c-text-1);
  display: flex;
  align-items: center;
}

.output-panel {
  display: flex;
  flex-direction: column;
  height: 100%;
  max-height: 500px;
  background: var(--vp-c-bg);
  overflow: hidden;
}

.output-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  padding: 12px;
  background: var(--vp-c-bg);
  border-bottom: 1px solid var(--vp-c-border);
  flex-shrink: 0;
}

.action-button {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  border: 1px solid var(--vp-c-border);
  border-radius: 6px;
  background: var(--vp-c-bg-soft);
  color: var(--vp-c-text-1);
  cursor: pointer;
  transition: all 0.2s ease;
}

.action-button:hover {
  border-color: var(--vp-c-brand-1);
}

.action-button.copied {
  background: var(--vp-c-brand-1);
  color: white;
  border-color: var(--vp-c-brand-1);
}

.action-button.shared {
  background: var(--vp-c-brand-1);
  color: white;
  border-color: var(--vp-c-brand-1);
}

.editor-container {
  height: 100%;
  width: 100%;
  font-family: var(--vp-font-family-mono);
}

.support-notice {
  grid-column: 1 / -1;
  padding: 8px;
  background: var(--vp-c-bg-soft);
  border-top: 1px solid var(--vp-c-border);
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
  min-height: 45px;
}

.support-message {
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--vp-c-text-2);
  font-size: 12px;
  width: 100%;
}

.support-icon {
  flex-shrink: 0;
  transition: color 0.3s ease;
  color: v-bind('supportMessage.color');
}

.support-link {
  text-decoration: none;
  font-weight: normal;
  transition: color 0.3s ease;
  display: flex;
  align-items: center;
  gap: 6px;
}

.support-link:hover {
  color: var(--vp-c-brand-1);
}

.mobile-only {
  display: none;
}

@media (max-width: 768px) {
  .content-wrapper {
    grid-template-columns: 1fr;
    grid-template-rows: auto minmax(500px, auto) auto;
    height: auto;
  }

  .metadata-panel {
    border-right: none;
    border-bottom: 1px solid var(--vp-c-border);
    max-height: 400px;
    overflow-y: auto;
  }

  .output-panel {
    height: 500px;
  }

  .support-notice {
    padding: 16px;
  }

  .support-message {
    max-width: 100%;
  }

  .mobile-only {
    display: inline-flex;
  }
}

.tooltip-container {
  position: relative;
  display: inline-block;
}

.tooltip-content {
  position: fixed;
  transform: translateX(-50%);
  margin-bottom: 8px;
  padding: 8px 12px;
  background: #333;
  color: white;
  font-size: 0.875rem;
  white-space: nowrap;
  border-radius: 4px;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.2s, visibility 0.2s;
  z-index: 9999;
  pointer-events: none;
  text-align: left;
}

.tooltip-arrow {
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border-width: 8px;
  border-style: solid;
  border-color: #333 transparent transparent transparent;
}

.tooltip-container:hover .tooltip-content {
  opacity: 1;
  visibility: visible;
}

.desktop-only {
  display: block;
}

@media (max-width: 768px) {
  .desktop-only {
    display: none;
  }
}

.action-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.action-button:disabled:hover {
  opacity: 0.5;
}

/* Dark mode support for tooltip */
html.dark .tooltip-content {
  background: #333;
  color: #ffffff;
}

html.dark .tooltip-arrow {
  border-color: #333 transparent transparent transparent;
}
</style>
</file>

<file path="website/client/components/Home/TryItResultErrorContent.vue">
<script setup lang="ts">
import { AlertTriangle, Copy } from 'lucide-vue-next';
import { computed, ref } from 'vue';

const props = defineProps<{
  message: string;
  repositoryUrl?: string;
}>();

const copied = ref(false);
const commandWithRepo = computed(() => {
  const baseCommand = 'npx repomix --remote';
  return props.repositoryUrl ? `${baseCommand} ${props.repositoryUrl}` : `${baseCommand} <repository-url>`;
});

const copyCommand = async (event: Event) => {
  event.preventDefault();
  event.stopPropagation();
  await navigator.clipboard.writeText(commandWithRepo.value);
  copied.value = true;
  setTimeout(() => {
    copied.value = false;
  }, 2000);
};
</script>

<template>
  <div class="error">
    <div class="error-content">
      <AlertTriangle :size="32" class="error-icon" />
      <p class="error-message">{{ message }}</p>
      <div class="suggestion">
        <p>Try using the command line tool instead:</p>
        <div class="command-block">
          <code>{{ commandWithRepo }}</code>
          <button class="copy-button" @click="copyCommand" :class="{ copied }">
            <Copy :size="14" />
            {{ copied ? 'Copied!' : 'Copy' }}
          </button>
        </div>
        <p class="guide-link">
          See <a href="#using-the-cli-tool">Using the CLI Tool</a> for more details.
        </p>
      </div>
    </div>
  </div>
</template>

<style scoped>
.error {
  padding: 32px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.error-content {
  max-width: 700px;
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
}

.error-icon {
  color: var(--vp-c-danger-1);
  margin-bottom: 16px;
}

.error-message {
  color: var(--vp-c-danger-1);
  font-size: 1.1em;
  margin: 0 0 24px;
}

.suggestion {
  background: var(--vp-c-bg-soft);
  padding: 16px;
  border-radius: 8px;
  border: 1px solid var(--vp-c-border);
  width: 100%;
}

.suggestion p {
  margin: 0 0 12px;
  color: var(--vp-c-text-2);
}

.command-block {
  background: var(--vp-c-bg-alt);
  border: 1px solid var(--vp-c-border);
  border-radius: 6px;
  padding: 12px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  font-family: var(--vp-font-family-mono);
}

code {
  color: var(--vp-c-text-1);
}

.copy-button {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 8px;
  border: 1px solid var(--vp-c-border);
  border-radius: 4px;
  background: var(--vp-c-bg-soft);
  color: var(--vp-c-text-2);
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.copy-button:hover {
  border-color: var(--vp-c-brand-1);
  color: var(--vp-c-brand-1);
}

.copy-button.copied {
  background: var(--vp-c-brand-1);
  color: white;
  border-color: var(--vp-c-brand-1);
}

.guide-link a {
  color: var(--vp-c-brand-1);
  text-decoration: none;
  font-weight: 500;
}

.guide-link a:hover {
  text-decoration: underline;
}
</style>
</file>

<file path="website/client/components/Home/TryItUrlInput.vue">
<script setup lang="ts">
import { AlertTriangle } from 'lucide-vue-next';
import { computed, onMounted, ref } from 'vue';
import { isValidRemoteValue } from '../utils/validation';
import PackButton from './PackButton.vue';

const props = defineProps<{
  url: string;
  loading: boolean;
  showButton?: boolean;
}>();

const emit = defineEmits<{
  'update:url': [value: string];
  submit: [];
  keydown: [event: KeyboardEvent];
}>();

const isValidUrl = computed(() => {
  if (!props.url) return false;
  return isValidRemoteValue(props.url.trim());
});

// Array to manage input history
const urlHistory = ref<string[]>([]);
const historyListId = 'repository-url-history';

// Load URL history when component is mounted
onMounted(() => {
  loadUrlHistory();
});

// Load URL history from localStorage
function loadUrlHistory() {
  try {
    const savedHistory = localStorage.getItem('repomix-url-history');
    if (savedHistory) {
      urlHistory.value = JSON.parse(savedHistory);
    }
  } catch (error) {
    console.error('Failed to load URL history from localStorage:', error);
    // Continue with empty history rather than displaying an error to the user
    // as this is a non-critical feature
    urlHistory.value = [];
  }
}

// Save URL to history
function saveUrlToHistory(url: string) {
  if (!url) return;

  const trimmedUrl = url.trim();
  if (!isValidRemoteValue(trimmedUrl)) return;

  // Remove existing entry and add to the beginning
  const filteredHistory = urlHistory.value.filter((item) => item !== trimmedUrl);
  urlHistory.value = [trimmedUrl, ...filteredHistory].slice(0, 5); // Keep only the latest 10 entries

  try {
    localStorage.setItem('repomix-url-history', JSON.stringify(urlHistory.value));
  } catch (error) {
    console.error('Failed to save URL history to localStorage:', error);
    // Non-critical error, so we don't need to show it to the user
  }
}

function handleUrlInput(event: Event) {
  const input = event.target as HTMLInputElement;
  emit('update:url', input.value);
}

// Process and save valid URL
function processValidUrl() {
  if (isValidUrl.value) {
    saveUrlToHistory(props.url);
  }
}

function handleSubmit() {
  processValidUrl();
  emit('submit');
}

function handleKeydown(event: KeyboardEvent) {
  if (event.key === 'Enter' && isValidUrl.value) {
    processValidUrl();
  }
  emit('keydown', event);
}
</script>

<template>
  <div class="input-group">
    <div class="url-input-container">
      <input
        :value="url"
        @input="handleUrlInput"
        @keydown="handleKeydown"
        type="text"
        placeholder="GitHub repository URL or user/repo (e.g., yamadashy/repomix)"
        class="repository-input"
        :class="{ 'invalid': url && !isValidUrl }"
        aria-label="GitHub repository URL"
        autocomplete="on"
        :list="historyListId"
      />
      <datalist :id="historyListId">
        <option v-for="historyUrl in urlHistory" :key="historyUrl" :value="historyUrl" />
      </datalist>
    </div>

    <div v-if="url && !isValidUrl" class="url-warning">
      <AlertTriangle class="warning-icon" :size="16" />
      <span>Please enter a valid GitHub repository URL (e.g., yamadashy/repomix)</span>
    </div>
    <div v-if="showButton" class="pack-button-container">
      <PackButton :isValid="isValidUrl" :loading="loading" @click="handleSubmit"/>
    </div>
  </div>
</template>

<style scoped>
.input-group {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
}

.url-input-container {
  flex: 1;
  position: relative;
  height: 100%;
}

.repository-input {
  width: 100%;
  height: 50px;
  padding: 12px 16px;
  font-size: 16px;
  border: 1px solid var(--vp-c-border);
  border-radius: 8px;
  background: var(--vp-c-bg);
  color: var(--vp-c-text-1);
  transition: border-color 0.2s;
  /* Hide datalist dropdown arrow in different browsers */
  &::-webkit-calendar-picker-indicator {
    display: none !important;
  }
  &::-webkit-list-button {
    display: none !important;
  }
  &::-webkit-inner-spin-button {
    display: none !important;
  }
  -moz-appearance: none;
  -webkit-appearance: none;
  appearance: none;
}

.repository-input:focus {
  outline: none;
  border-color: var(--vp-c-brand-1);
}

.repository-input.invalid {
  border-color: var(--vp-c-danger-1);
}

.url-warning {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 6px;
  color: var(--vp-c-warning-1);
  font-size: 14px;
}

.warning-icon {
  flex-shrink: 0;
  color: var(--vp-c-warning-1);
}

.pack-button-container {
  margin-top: 16px;
  display: flex;
  justify-content: center;
  width: 100%;
}
</style>
</file>

<file path="website/client/components/utils/analytics.ts">
// Analytics event categories
export const AnalyticsCategory = {
  REPOSITORY: 'repository',
  FORMAT: 'format',
  OPTIONS: 'options',
  OUTPUT: 'output',
} as const;

// Analytics event actions
export const AnalyticsAction = {
  // Repository events
  PACK_START: 'pack_start',
  PACK_SUCCESS: 'pack_success',
  PACK_SUCCESS_FILES: 'pack_success_files',
  PACK_SUCCESS_CHARS: 'pack_success_chars',
  PACK_ERROR: 'pack_error',

  // Format events
  FORMAT_CHANGE: 'format_change',

  // Options events
  TOGGLE_REMOVE_COMMENTS: 'toggle_remove_comments',
  TOGGLE_REMOVE_EMPTY_LINES: 'toggle_remove_empty_lines',
  TOGGLE_LINE_NUMBERS: 'toggle_line_numbers',
  TOGGLE_FILE_SUMMARY: 'toggle_file_summary',
  TOGGLE_DIRECTORY_STRUCTURE: 'toggle_directory_structure',
  TOGGLE_OUTPUT_PARSABLE: 'toggle_output_parsable',
  TOGGLE_COMPRESS: 'toggle_compress',
  UPDATE_INCLUDE_PATTERNS: 'update_include_patterns',
  UPDATE_IGNORE_PATTERNS: 'update_ignore_patterns',

  // Output events
  COPY_OUTPUT: 'copy_output',
  DOWNLOAD_OUTPUT: 'download_output',
  SHARE_OUTPUT: 'share_output',
} as const;

export type AnalyticsCategoryType = (typeof AnalyticsCategory)[keyof typeof AnalyticsCategory];
export type AnalyticsActionType = (typeof AnalyticsAction)[keyof typeof AnalyticsAction];

// Google Analytics event tracking interface
interface GAEventParams {
  category: AnalyticsCategoryType;
  action: AnalyticsActionType;
  label?: string;
  value?: number;
}

// Track an event using gtag
export function trackEvent({ category, action, label, value }: GAEventParams): void {
  if (typeof window === 'undefined' || !window.gtag) {
    return;
  }

  window.gtag('event', action, {
    event_category: category,
    event_label: label,
    value: value,
  });
}

// Analytics utility functions for specific events
export const analyticsUtils = {
  // Repository events
  trackPackStart(repoUrl: string): void {
    trackEvent({
      category: AnalyticsCategory.REPOSITORY,
      action: AnalyticsAction.PACK_START,
      label: repoUrl,
    });
  },

  trackPackSuccess(repoUrl: string, totalFiles: number, totalChars: number): void {
    trackEvent({
      category: AnalyticsCategory.REPOSITORY,
      action: AnalyticsAction.PACK_SUCCESS_FILES,
      label: `${repoUrl}_files`,
      value: totalFiles,
    });
    trackEvent({
      category: AnalyticsCategory.REPOSITORY,
      action: AnalyticsAction.PACK_SUCCESS_CHARS,
      label: `${repoUrl}_chars`,
      value: totalChars,
    });
  },

  trackPackError(repoUrl: string, error: string): void {
    trackEvent({
      category: AnalyticsCategory.REPOSITORY,
      action: AnalyticsAction.PACK_ERROR,
      label: `${repoUrl} - ${error}`,
    });
  },

  // Options events
  trackOptionToggle(action: AnalyticsActionType, enabled: boolean): void {
    trackEvent({
      category: AnalyticsCategory.OPTIONS,
      action: action,
      label: enabled ? 'enabled' : 'disabled',
    });
  },

  // Output events
  trackCopyOutput(format: string): void {
    trackEvent({
      category: AnalyticsCategory.OUTPUT,
      action: AnalyticsAction.COPY_OUTPUT,
      label: format,
    });
  },

  trackDownloadOutput(format: string): void {
    trackEvent({
      category: AnalyticsCategory.OUTPUT,
      action: AnalyticsAction.DOWNLOAD_OUTPUT,
      label: format,
    });
  },

  trackShareOutput(format: string): void {
    trackEvent({
      category: AnalyticsCategory.OUTPUT,
      action: AnalyticsAction.SHARE_OUTPUT,
      label: format,
    });
  },
};

// Type definitions for window.gtag
declare global {
  interface Window {
    gtag: (
      command: 'event',
      action: string,
      params: {
        event_category: string;
        event_label?: string;
        value?: number;
      },
    ) => void;
  }
}
</file>

<file path="website/client/components/utils/requestHandlers.ts">
import type { PackOptions, PackRequest, PackResult } from '../api/client';
import { packRepository } from '../api/client';
import { type AnalyticsActionType, analyticsUtils } from './analytics';

interface RequestHandlerOptions {
  onSuccess?: (result: PackResult) => void;
  onError?: (error: string) => void;
  signal?: AbortSignal;
  file?: File;
}

/**
 * Handle repository packing request
 */
export async function handlePackRequest(
  url: string,
  format: 'xml' | 'markdown' | 'plain',
  options: PackOptions,
  handlerOptions: RequestHandlerOptions = {},
): Promise<void> {
  const { onSuccess, onError, signal, file } = handlerOptions;
  const processedUrl = url.trim();

  // Track pack start
  analyticsUtils.trackPackStart(processedUrl);

  try {
    const request: PackRequest = {
      url: processedUrl,
      format,
      options,
      signal,
      file,
    };

    const response = await packRepository(request);

    // Track successful pack
    if (response.metadata.summary) {
      analyticsUtils.trackPackSuccess(
        processedUrl,
        response.metadata.summary.totalFiles,
        response.metadata.summary.totalCharacters,
      );
    }

    onSuccess?.(response);
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : 'An unexpected error occurred';

    if (errorMessage === 'AbortError') {
      onError?.('Request was cancelled');
      return;
    }

    analyticsUtils.trackPackError(processedUrl, errorMessage);
    console.error('Error processing repository:', err);
    onError?.(errorMessage);
  }
}

/**
 * Handle form input changes with analytics tracking
 */
export function handleOptionChange(value: boolean | string, analyticsAction: AnalyticsActionType): void {
  if (typeof value === 'boolean') {
    analyticsUtils.trackOptionToggle(analyticsAction, value);
  } else {
    analyticsUtils.trackOptionToggle(analyticsAction, Boolean(value));
  }
}
</file>

<file path="website/client/components/utils/resultViewer.ts">
import type { Ace } from 'ace-builds';
import type { PackResult } from '../api/client';
import { analyticsUtils } from './analytics';

/**
 * Format timestamp to locale string
 */
export function formatTimestamp(timestamp: string): string {
  return new Date(timestamp).toLocaleString();
}

/**
 * Handle clipboard copy with analytics tracking
 */
export async function copyToClipboard(content: string, format: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(content);
    analyticsUtils.trackCopyOutput(format);
    return true;
  } catch (err) {
    console.error('Failed to copy:', err);
    return false;
  }
}

/**
 * Convert repository name to format suitable for filename
 */
function formatRepositoryName(repository: string): string {
  // Extract owner and repo from GitHub URL format or use as is
  const match = repository.match(/(?:https:\/\/github\.com\/)?([^/]+)\/([^/]+)(?:\.git)?$/);
  if (match) {
    const [, owner, repo] = match;
    return `${owner}-${repo}`;
  }
  // For non-GitHub repositories or local files, clean up the name
  return repository.replace(/[\/\\]/g, '-').replace(/\.git$/, '');
}

/**
 * Handle file download with analytics tracking
 */
export function downloadResult(content: string, format: string, result: PackResult): void {
  const blob = new Blob([content], { type: 'text/plain' });
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  const extension = format === 'markdown' ? 'md' : format === 'xml' ? 'xml' : 'txt';

  const repoName = formatRepositoryName(result.metadata.repository);
  a.href = url;
  a.download = `repomix-output-${repoName}.${extension}`;
  document.body.appendChild(a);
  a.click();

  analyticsUtils.trackDownloadOutput(format);
  window.URL.revokeObjectURL(url);
  document.body.removeChild(a);
}

/**
 * Handle sharing with Web Share API as file
 */
export async function shareResult(content: string, format: string, result: PackResult): Promise<boolean> {
  try {
    const repoName = formatRepositoryName(result.metadata.repository);
    const extension = format === 'markdown' ? 'md' : format === 'xml' ? 'xml' : 'txt';
    const filename = `repomix-output-${repoName}.${extension}`;

    const mimeType = format === 'markdown' ? 'text/markdown' : format === 'xml' ? 'application/xml' : 'text/plain';
    const blob = new Blob([content], { type: mimeType });
    const file = new File([blob], filename, { type: mimeType });

    const shareData = {
      files: [file],
    };

    if (navigator.canShare?.(shareData)) {
      await navigator.share(shareData);
      analyticsUtils.trackShareOutput(format);
      return true;
    }

    return false;
  } catch (err) {
    console.error('Failed to share:', err);
    return false;
  }
}

/**
 * Check if Web Share API is supported for file sharing
 */
export function canShareFiles(): boolean {
  if (navigator.canShare && typeof navigator.canShare === 'function') {
    try {
      const dummyFile = new File([''], 'dummy.txt', { type: 'text/plain' });
      return navigator.canShare({ files: [dummyFile] });
    } catch {
      return false;
    }
  }
  return false;
}

/**
 * Get Ace editor options
 */
export function getEditorOptions(): Partial<Ace.EditorOptions> {
  return {
    readOnly: true,
    wrap: false,
    showPrintMargin: false,
    fontSize: '13px',
    useWorker: false,
    highlightActiveLine: false,
  };
}
</file>

<file path="website/client/components/utils/validation.ts">
/**
 * Validates a GitHub repository URL or shorthand format
 * TODO: Share this validation logic with repomix core (src/cli/actions/remoteAction.ts)
 */
export function isValidRemoteValue(remoteValue: string): boolean {
  // Check the short form of the GitHub URL. e.g. yamadashy/repomix
  const namePattern = '[a-zA-Z0-9](?:[a-zA-Z0-9._-]*[a-zA-Z0-9])?';
  const shortFormRegex = new RegExp(`^${namePattern}/${namePattern}$`);
  if (shortFormRegex.test(remoteValue)) {
    return true;
  }

  // Check the direct form of the GitHub URL. e.g.  https://github.com/yamadashy/repomix or https://gist.github.com/yamadashy/1234567890abcdef
  try {
    new URL(remoteValue);
    return true;
  } catch (error) {
    return false;
  }
}
</file>

<file path="website/client/components/Home.vue">
<script setup>
import Hero from './Home/Hero.vue';
import TryIt from './Home/TryIt.vue';
</script>

<template>
  <div class="home">
    <Hero />
    <TryIt />
  </div>
</template>

<style scoped>
.home {
  padding-bottom: 60px;
}
</style>
</file>

<file path="website/client/components/HomeBadges.vue">
<template>
  <div class="home-badges">
    <a href="https://www.npmjs.com/package/repomix" target="_blank" rel="noopener noreferrer">
      <img
        src="https://img.shields.io/npm/v/repomix.svg?maxAge=1000"
        alt="npm version"
      />
    </a>
    <a href="https://www.npmjs.com/package/repomix" target="_blank" rel="noopener noreferrer">
      <img
        src="https://img.shields.io/npm/d18m/repomix"
        alt="npm downloads"
      />
    </a>

    <a href="https://discord.gg/wNYzTwZFku" target="_blank" rel="noopener noreferrer">
      <img
        src="https://badgen.net/discord/online-members/wNYzTwZFku?icon=discord&label=discord"
        alt="Discord"
      />
    </a>
    <a href="https://github.com/sponsors/yamadashy" target="_blank" rel="noopener noreferrer">
      <img
        src="https://img.shields.io/github/sponsors/yamadashy?logo=github"
        alt="Sponsors"
      />
    </a>
    <a href="https://github.com/yamadashy/repomix" target="_blank" rel="noopener noreferrer">
      <img
        src="https://img.shields.io/github/stars/yamadashy/repomix?style=flat&logo=github"
        alt="GitHub stars"
      />
    </a>
  </div>
</template>

<style scoped>
.home-badges {
  margin-top: 48px;
  display: flex;
  align-items: center;
  gap: 10px;
  justify-content: center;
}

.home-badges img {
  display: inline-block;
}

.home-badges a {
  display: inline-block;
  transition: opacity 0.2s ease;
}

.home-badges a:hover {
  opacity: 0.8;
}

@media (max-width: 768px) {
  .home-badges {
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 32px;
  }
}
</style>
</file>

<file path="website/client/components/YouTubeVideo.vue">
<script setup lang="ts">
import type { VideoId } from '../constants/videos';

defineProps<{
  videoId: VideoId | string;
}>();
</script>

<template>
  <div class="full-width-youtube-video">
    <iframe
      width="560"
      height="315"
      :src="`https://www.youtube.com/embed/${videoId}`"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
    ></iframe>
  </div>
</template>

<style scoped>
.full-width-youtube-video {
  position: relative;
  padding-bottom: 56.25%;
  height: 0;
}

.full-width-youtube-video iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border: none;
  border-radius: 0.5rem;
}
</style>
</file>

<file path="website/client/composables/useFileUpload.ts">
import { computed, ref } from 'vue';

export interface FileUploadOptions {
  maxFileSize?: number;
  acceptedTypes?: string[];
  accept?: string;
  multiple?: boolean;
  webkitdirectory?: boolean;
  validateFile?: (file: File) => { valid: boolean; error?: string };
  validateFiles?: (files: File[]) => { valid: boolean; error?: string };
  preprocessFiles?: (files: File[], folderName?: string) => Promise<File>;
}

export interface FileUploadConfig {
  mode: 'file' | 'folder';
  placeholder: string;
  icon: 'file' | 'folder';
  options: FileUploadOptions;
}

export function useFileUpload(config: FileUploadConfig) {
  const {
    maxFileSize = 10 * 1024 * 1024, // 10MB default
    acceptedTypes = [],
    accept = '',
    multiple = false,
    webkitdirectory = false,
    validateFile,
    validateFiles,
    preprocessFiles,
  } = config.options;

  // Reactive state
  const fileInput = ref<HTMLInputElement | null>(null);
  const dragActive = ref(false);
  const selectedItem = ref<string | null>(null);
  const errorMessage = ref<string | null>(null);
  const isProcessing = ref(false);

  // Computed
  const hasError = computed(() => !!errorMessage.value);
  const hasSelection = computed(() => !!selectedItem.value);
  const isValid = computed(() => hasSelection.value && !hasError.value);

  // Default file validation
  function defaultValidateFile(file: File): { valid: boolean; error?: string } {
    if (acceptedTypes.length > 0) {
      const isValidType = acceptedTypes.some((type) => {
        if (type.startsWith('.')) {
          return file.name.toLowerCase().endsWith(type.toLowerCase());
        }
        return file.type === type;
      });

      if (!isValidType) {
        return {
          valid: false,
          error: `Please upload a ${acceptedTypes.join(' or ')} file`,
        };
      }
    }

    if (file.size > maxFileSize) {
      const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
      const limitMB = (maxFileSize / (1024 * 1024)).toFixed(0);
      return {
        valid: false,
        error: `File size (${sizeMB}MB) exceeds the ${limitMB}MB limit`,
      };
    }

    return { valid: true };
  }

  // Default files validation (for folder/multiple files)
  function defaultValidateFiles(files: File[]): { valid: boolean; error?: string } {
    if (files.length === 0) {
      return { valid: false, error: 'No files found' };
    }

    const totalSize = files.reduce((sum, file) => sum + file.size, 0);
    if (totalSize > maxFileSize) {
      const sizeMB = (totalSize / (1024 * 1024)).toFixed(1);
      const limitMB = (maxFileSize / (1024 * 1024)).toFixed(0);
      return {
        valid: false,
        error: `Total size (${sizeMB}MB) exceeds the ${limitMB}MB limit`,
      };
    }

    return { valid: true };
  }

  // Clear error and selection
  function clearError() {
    errorMessage.value = null;
  }

  function clearSelection() {
    selectedItem.value = null;
    errorMessage.value = null;
    // Clear file input to prevent re-selection issues
    if (fileInput.value) {
      fileInput.value.value = '';
    }
  }

  // Validate and process files
  async function processFiles(
    files: File[],
    folderName?: string,
  ): Promise<{ success: boolean; result?: File; error?: string }> {
    clearError();
    isProcessing.value = true;

    try {
      // Validation
      const validator =
        config.mode === 'folder' || multiple
          ? validateFiles || defaultValidateFiles
          : validateFile || defaultValidateFile;

      let validationResult: { valid: boolean; error?: string };
      if (config.mode === 'folder' || multiple) {
        validationResult = (validator as typeof defaultValidateFiles)(files);
      } else {
        validationResult = (validator as typeof defaultValidateFile)(files[0]);
      }

      if (!validationResult.valid) {
        errorMessage.value = validationResult.error || 'Validation failed';
        return { success: false, error: validationResult.error };
      }

      // Preprocessing (e.g., ZIP creation for folders)
      let resultFile: File;
      if (preprocessFiles) {
        resultFile = await preprocessFiles(files, folderName);
      } else {
        if ((config.mode === 'folder' || multiple) && files.length > 1) {
          throw new Error('Multiple files require a preprocessor function');
        }
        resultFile = files[0];
      }

      // Update selection
      selectedItem.value = folderName || resultFile.name;

      // Clear file input to prevent re-selection issues
      if (fileInput.value) {
        fileInput.value.value = '';
      }

      return { success: true, result: resultFile };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Processing failed';
      errorMessage.value = errorMsg;
      return { success: false, error: errorMsg };
    } finally {
      isProcessing.value = false;
    }
  }

  // Handle file input selection
  async function handleFileSelect(
    files: FileList | null,
  ): Promise<{ success: boolean; result?: File; error?: string }> {
    if (!files || files.length === 0) {
      return { success: false, error: 'No files selected' };
    }

    const fileArray = Array.from(files);
    let folderName: string | undefined;

    if (config.mode === 'folder' && files[0].webkitRelativePath) {
      folderName = files[0].webkitRelativePath.split('/')[0];
    }

    return await processFiles(fileArray, folderName);
  }

  // Handle drag and drop
  function handleDragOver(event: DragEvent) {
    event.preventDefault();
    dragActive.value = true;
  }

  function handleDragLeave() {
    dragActive.value = false;
  }

  async function handleDrop(event: DragEvent): Promise<{ success: boolean; result?: File; error?: string }> {
    event.preventDefault();
    dragActive.value = false;

    if (config.mode === 'folder') {
      return await handleFolderDrop(event);
    }
    return await handleFileSelect(event.dataTransfer?.files || null);
  }

  // Specialized folder drop handling
  async function handleFolderDrop(event: DragEvent): Promise<{ success: boolean; result?: File; error?: string }> {
    if (!event.dataTransfer?.items?.length) {
      return { success: false, error: 'No items found' };
    }

    // Check directory reading capability
    if (!('webkitGetAsEntry' in DataTransferItem.prototype)) {
      const error = "Your browser doesn't support folder drop. Please use the browse button instead.";
      errorMessage.value = error;
      return { success: false, error };
    }

    const entry = event.dataTransfer.items[0].webkitGetAsEntry();
    if (!entry?.isDirectory) {
      const error = 'Please drop a folder, not a file.';
      errorMessage.value = error;
      return { success: false, error };
    }

    try {
      const files = await collectFilesFromEntry(entry);
      return await processFiles(files, entry.name);
    } catch (error) {
      const errorMsg = 'Failed to process the folder. Please try again or use the browse button.';
      errorMessage.value = errorMsg;
      return { success: false, error: errorMsg };
    }
  }

  // Constants for safety limits
  const MAX_DEPTH = 20;
  const MAX_FILES = 10000;

  // Helper functions for folder processing
  async function collectFilesFromEntry(
    entry: FileSystemEntry,
    path = '',
    depth = 0,
    fileCount = { current: 0 },
  ): Promise<File[]> {
    // Check depth limit
    if (depth > MAX_DEPTH) {
      throw new Error(`Directory structure too deep (max depth: ${MAX_DEPTH})`);
    }

    // Check file count limit
    if (fileCount.current > MAX_FILES) {
      throw new Error(`Too many files in directory structure (max files: ${MAX_FILES})`);
    }

    if (entry.isFile) {
      return new Promise((resolve, reject) => {
        (entry as FileSystemFileEntry).file((file: File) => {
          // Check file count before adding
          if (fileCount.current >= MAX_FILES) {
            reject(new Error(`Too many files in directory structure (max files: ${MAX_FILES})`));
            return;
          }

          fileCount.current++;

          const customFile = new File([file], file.name, {
            type: file.type,
            lastModified: file.lastModified,
          });

          Object.defineProperty(customFile, 'webkitRelativePath', {
            value: path ? `${path}/${file.name}` : file.name,
          });

          resolve([customFile]);
        }, reject);
      });
    }

    if (entry.isDirectory && (entry as FileSystemDirectoryEntry).createReader) {
      return new Promise((resolve, reject) => {
        const dirReader = (entry as FileSystemDirectoryEntry).createReader();
        const allFiles: File[] = [];

        function readEntries() {
          dirReader.readEntries(async (entries: FileSystemEntry[]) => {
            if (entries.length === 0) {
              resolve(allFiles);
            } else {
              try {
                for (const childEntry of entries) {
                  // Check limits before processing each entry
                  if (depth + 1 > MAX_DEPTH) {
                    throw new Error(`Directory structure too deep (max depth: ${MAX_DEPTH})`);
                  }
                  if (fileCount.current > MAX_FILES) {
                    throw new Error(`Too many files in directory structure (max files: ${MAX_FILES})`);
                  }

                  const newPath = path ? `${path}/${childEntry.name}` : childEntry.name;
                  const files = await collectFilesFromEntry(childEntry, newPath, depth + 1, fileCount);
                  allFiles.push(...files);
                }
                readEntries();
              } catch (error) {
                reject(error);
              }
            }
          }, reject);
        }

        readEntries();
      });
    }

    return [];
  }

  // Trigger file input
  function triggerFileInput() {
    fileInput.value?.click();
  }

  // Input attributes for template
  const inputAttributes = computed(() => ({
    type: 'file',
    accept,
    multiple,
    webkitdirectory: webkitdirectory || config.mode === 'folder',
    ...(config.mode === 'folder' && {
      directory: true,
      mozdirectory: true,
    }),
  }));

  return {
    // Refs
    fileInput,
    dragActive,
    selectedItem,
    errorMessage,
    isProcessing,

    // Computed
    hasError,
    hasSelection,
    isValid,
    inputAttributes,

    // Methods
    handleFileSelect,
    handleDragOver,
    handleDragLeave,
    handleDrop,
    triggerFileInput,
    clearError,
    clearSelection,
    processFiles,
  };
}
</file>

<file path="website/client/composables/usePackOptions.ts">
import { computed, reactive } from 'vue';

export interface PackOptions {
  format: 'xml' | 'markdown' | 'plain';
  removeComments: boolean;
  removeEmptyLines: boolean;
  showLineNumbers: boolean;
  fileSummary: boolean;
  directoryStructure: boolean;
  includePatterns: string;
  ignorePatterns: string;
  outputParsable: boolean;
  compress: boolean;
}

const DEFAULT_PACK_OPTIONS: PackOptions = {
  format: 'xml',
  removeComments: false,
  removeEmptyLines: false,
  showLineNumbers: false,
  fileSummary: true,
  directoryStructure: true,
  includePatterns: '',
  ignorePatterns: '',
  outputParsable: false,
  compress: false,
};

export function usePackOptions() {
  const packOptions = reactive<PackOptions>({ ...DEFAULT_PACK_OPTIONS });

  const getPackRequestOptions = computed(() => ({
    removeComments: packOptions.removeComments,
    removeEmptyLines: packOptions.removeEmptyLines,
    showLineNumbers: packOptions.showLineNumbers,
    fileSummary: packOptions.fileSummary,
    directoryStructure: packOptions.directoryStructure,
    includePatterns: packOptions.includePatterns ? packOptions.includePatterns.trim() : undefined,
    ignorePatterns: packOptions.ignorePatterns ? packOptions.ignorePatterns.trim() : undefined,
    outputParsable: packOptions.outputParsable,
    compress: packOptions.compress,
  }));

  function updateOption<K extends keyof PackOptions>(key: K, value: PackOptions[K]) {
    packOptions[key] = value;
  }

  function resetOptions() {
    Object.assign(packOptions, DEFAULT_PACK_OPTIONS);
  }

  return {
    packOptions,
    getPackRequestOptions,
    updateOption,
    resetOptions,
  };
}
</file>

<file path="website/client/composables/usePackRequest.ts">
import { computed, ref } from 'vue';
import type { PackResult } from '../components/api/client';
import { handlePackRequest } from '../components/utils/requestHandlers';
import { isValidRemoteValue } from '../components/utils/validation';
import { usePackOptions } from './usePackOptions';

export type InputMode = 'url' | 'file' | 'folder';

export function usePackRequest() {
  const packOptionsComposable = usePackOptions();
  const { packOptions, getPackRequestOptions } = packOptionsComposable;

  // Input states
  const inputUrl = ref('');
  const inputRepositoryUrl = ref('');
  const mode = ref<InputMode>('url');
  const uploadedFile = ref<File | null>(null);

  // Request states
  const loading = ref(false);
  const error = ref<string | null>(null);
  const result = ref<PackResult | null>(null);
  const hasExecuted = ref(false);

  // Request controller for cancellation
  let requestController: AbortController | null = null;
  const TIMEOUT_MS = 30_000;

  // Computed validation
  const isSubmitValid = computed(() => {
    switch (mode.value) {
      case 'url':
        return !!inputUrl.value && isValidRemoteValue(inputUrl.value.trim());
      case 'file':
      case 'folder':
        return !!uploadedFile.value;
      default:
        return false;
    }
  });

  function setMode(newMode: InputMode) {
    mode.value = newMode;
  }

  function handleFileUpload(file: File) {
    uploadedFile.value = file;
  }

  function resetRequest() {
    error.value = null;
    result.value = null;
    hasExecuted.value = false;
  }

  async function submitRequest() {
    if (!isSubmitValid.value) return;

    // Cancel any pending request
    if (requestController) {
      requestController.abort();
    }
    requestController = new AbortController();

    loading.value = true;
    error.value = null;
    result.value = null;
    hasExecuted.value = true;
    inputRepositoryUrl.value = inputUrl.value;

    const timeoutId = setTimeout(() => {
      if (requestController) {
        requestController.abort('Request timed out');
      }
    }, TIMEOUT_MS);

    try {
      await handlePackRequest(
        mode.value === 'url' ? inputUrl.value : '',
        packOptions.format,
        getPackRequestOptions.value,
        {
          onSuccess: (response) => {
            result.value = response;
          },
          onError: (errorMessage) => {
            error.value = errorMessage;
          },
          signal: requestController.signal,
          file: mode.value === 'file' || mode.value === 'folder' ? uploadedFile.value || undefined : undefined,
        },
      );
    } finally {
      clearTimeout(timeoutId);
      loading.value = false;
      requestController = null;
    }
  }

  function cancelRequest() {
    if (requestController) {
      requestController.abort();
      requestController = null;
    }
    loading.value = false;
  }

  return {
    // Pack options (re-exported for convenience)
    ...packOptionsComposable,

    // Input states
    inputUrl,
    inputRepositoryUrl,
    mode,
    uploadedFile,

    // Request states
    loading,
    error,
    result,
    hasExecuted,

    // Computed
    isSubmitValid,

    // Actions
    setMode,
    handleFileUpload,
    resetRequest,
    submitRequest,
    cancelRequest,
  };
}
</file>

<file path="website/client/composables/useZipProcessor.ts">
import { zip } from 'fflate';

export function useZipProcessor() {
  async function createZipFromFiles(files: File[], folderName: string): Promise<File> {
    try {
      const fileMap: { [key: string]: Uint8Array } = {};

      for (const file of files) {
        const path = file.webkitRelativePath || file.name;
        const arrayBuffer = await file.arrayBuffer();
        fileMap[path] = new Uint8Array(arrayBuffer);
      }

      return new Promise((resolve, reject) => {
        zip(fileMap, (err, data) => {
          if (err) {
            reject(new Error(`Failed to create ZIP file: ${err.message}`));
          } else {
            const zipBlob = new Blob([data], { type: 'application/zip' });
            resolve(new File([zipBlob], `${folderName}.zip`, { type: 'application/zip' }));
          }
        });
      });
    } catch (error) {
      throw new Error(`Failed to create ZIP file: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  function validateZipFile(file: File): { valid: boolean; error?: string } {
    if (file.type !== 'application/zip' && !file.name.endsWith('.zip')) {
      return { valid: false, error: 'Please upload a ZIP file' };
    }
    return { valid: true };
  }

  return {
    createZipFromFiles,
    validateZipFile,
  };
}
</file>

<file path="website/client/constants/videos.ts">
export const VIDEO_IDS = {
  REPOMIX_DEMO: '0a3eKNTBtxg',
} as const;

export type VideoId = (typeof VIDEO_IDS)[keyof typeof VIDEO_IDS];
</file>

<file path="website/client/scripts/generateSchema.ts">
import fs from 'node:fs/promises';
import path from 'node:path';
import { zodToJsonSchema } from 'zod-to-json-schema';
import { repomixConfigFileSchema } from '../../../src/config/configSchema.js';

const getPackageVersion = async (): Promise<string> => {
  const packageJsonPath = path.resolve('./package.json');
  const packageJsonContent = await fs.readFile(packageJsonPath, 'utf-8');
  const packageJson = JSON.parse(packageJsonContent);
  return packageJson.version;
};

const generateSchema = async () => {
  const version = await getPackageVersion();
  const versionParts = version.split('.');
  const majorMinorVersion = `${versionParts[0]}.${versionParts[1]}.${versionParts[2]}`;

  const jsonSchema = zodToJsonSchema(repomixConfigFileSchema, {
    $refStrategy: 'none',
    definitionPath: 'definitions',
    markdownDescription: true,
  });

  const schemaWithMeta = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    ...jsonSchema,
    title: 'Repomix Configuration',
    description: 'Schema for repomix.config.json configuration file',
  };

  const baseOutputDir = path.resolve('./website/client/src/public/schemas');
  await fs.mkdir(baseOutputDir, { recursive: true });

  const versionedOutputDir = path.resolve(baseOutputDir, majorMinorVersion);
  await fs.mkdir(versionedOutputDir, { recursive: true });

  const versionedOutputPath = path.resolve(versionedOutputDir, 'schema.json');
  await fs.writeFile(versionedOutputPath, JSON.stringify(schemaWithMeta, null, 2), 'utf-8');

  const latestOutputDir = path.resolve(baseOutputDir, 'latest');
  await fs.mkdir(latestOutputDir, { recursive: true });
  const latestOutputPath = path.resolve(latestOutputDir, 'schema.json');
  await fs.writeFile(latestOutputPath, JSON.stringify(schemaWithMeta, null, 2), 'utf-8');

  console.log(`Schema generated at ${versionedOutputPath}`);
  console.log(`Schema also generated at ${latestOutputPath}`);
};

generateSchema().catch(console.error);
</file>

<file path="website/client/src/de/guide/development/index.md">
# Zu Repomix beitragen

Vielen Dank für Ihr Interesse an **Repomix**! 🚀 Wir freuen uns über Ihre Hilfe, um es noch besser zu machen. Dieser Leitfaden hilft Ihnen, mit der Mitarbeit am Projekt zu beginnen.

## Wie Sie beitragen können

- **Repository mit Stern versehen**: Zeigen Sie Ihre Unterstützung, indem Sie [das Repository mit einem Stern versehen](https://github.com/yamadashy/repomix)!
- **Issue erstellen**: Einen Fehler entdeckt? Eine Idee für ein neues Feature? Lassen Sie es uns wissen, indem Sie [ein Issue erstellen](https://github.com/yamadashy/repomix/issues).
- **Pull Request einreichen**: Etwas zum Beheben oder Verbessern gefunden? Reichen Sie einen PR ein!
- **Weitersagen**: Teilen Sie Ihre Erfahrung mit Repomix in sozialen Medien, Blogs oder in Ihrer Tech-Community.
- **Repomix verwenden**: Das wertvollste Feedback kommt aus der realen Nutzung. Integrieren Sie Repomix gerne in Ihre eigenen Projekte!
- **Sponsern**: Unterstützen Sie die Entwicklung von Repomix, indem Sie [Sponsor werden](https://github.com/sponsors/yamadashy).

## Schnellstart

```bash
git clone https://github.com/yamadashy/repomix.git
cd repomix
npm install
```

## Entwicklungsbefehle

```bash
# CLI ausführen
npm run repomix

# Tests ausführen
npm run test
npm run test-coverage

# Code linting
npm run lint
```

## Code-Stil

- [Biome](https://biomejs.dev/) für Linting und Formatierung verwenden
- Dependency Injection für Testbarkeit
- Dateien unter 250 Zeilen halten
- Tests für neue Funktionen hinzufügen

## Pull-Request-Richtlinien

1. Alle Tests ausführen
2. Linting-Prüfungen bestehen
3. Dokumentation aktualisieren
4. Bestehenden Code-Stil befolgen

## Entwicklungsumgebung

### Voraussetzungen

- Node.js ≥ 18.0.0
- Git
- npm
- Docker (optional, für die Ausführung der Website oder containerisierte Entwicklung)

### Lokale Entwicklung

So richten Sie Repomix für die lokale Entwicklung ein:

```bash
# Repository klonen
git clone https://github.com/yamadashy/repomix.git
cd repomix

# Abhängigkeiten installieren
npm install

# CLI ausführen
npm run repomix
```

### Docker-Entwicklung

Sie können Repomix auch mit Docker ausführen:

```bash
# Image bauen
docker build -t repomix .

# Container ausführen
docker run -v ./:/app -it --rm repomix
```

### Projektstruktur

Das Projekt ist in folgende Verzeichnisse unterteilt:

```
src/
├── cli/          # CLI-Implementierung
├── config/       # Konfigurationsverarbeitung
├── core/         # Kernfunktionalität
│   ├── file/     # Dateiverarbeitung
│   ├── metrics/  # Metriken-Berechnung
│   ├── output/   # Ausgabegenerierung
│   ├── security/ # Sicherheitsprüfungen
├── mcp/          # MCP-Server-Integration
└── shared/       # Gemeinsame Dienstprogramme
tests/            # Tests, die die src/-Struktur widerspiegeln
website/          # Dokumentationswebsite
├── client/       # Frontend (VitePress)
└── server/       # Backend-API
```

## Website-Entwicklung

Die Repomix-Website ist mit [VitePress](https://vitepress.dev/) erstellt. So führen Sie die Website lokal aus:

```bash
# Voraussetzungen: Docker muss auf Ihrem System installiert sein

# Starten Sie den Website-Entwicklungsserver
npm run website

# Zugriff auf die Website unter http://localhost:5173/
```

Bei der Aktualisierung der Dokumentation müssen Sie nur zuerst die englische Version aktualisieren. Die Maintainer kümmern sich um die Übersetzungen in andere Sprachen.

## Release-Prozess

Für Maintainer und Mitwirkende, die am Release-Prozess interessiert sind:

1. Version aktualisieren
```bash
npm version patch  # oder minor/major
```

2. Tests und Build ausführen
```bash
npm run test-coverage
npm run build
```

3. Veröffentlichen
```bash
npm publish
```

Neue Versionen werden vom Maintainer verwaltet. Wenn Sie der Meinung sind, dass eine Veröffentlichung notwendig ist, öffnen Sie ein Issue, um es zu besprechen.

## Hilfe benötigt?

- [Issue erstellen](https://github.com/yamadashy/repomix/issues)
- [Discord beitreten](https://discord.gg/wNYzTwZFku)
</file>

<file path="website/client/src/de/guide/development/using-repomix-as-a-library.md">
# Repomix als Bibliothek verwenden

Neben der Verwendung von Repomix als CLI-Tool können Sie seine Funktionalität direkt in Ihre Node.js-Anwendungen integrieren.

## Installation

Installieren Sie Repomix als Abhängigkeit in Ihrem Projekt:

```bash
npm install repomix
```

## Grundlegende Verwendung

Der einfachste Weg, Repomix zu verwenden, ist über die Funktion `runCli`, die die gleiche Funktionalität wie die Befehlszeilenschnittstelle bietet:

```javascript
import { runCli, type CliOptions } from 'repomix';

// Aktuelles Verzeichnis mit benutzerdefinierten Optionen verarbeiten
async function packProject() {
  const options = {
    output: 'output.xml',
    style: 'xml',
    compress: true,
    quiet: true
  } as CliOptions;
  
  const result = await runCli(['.'], process.cwd(), options);
  return result.packResult;
}
```

Das `result.packResult` enthält Informationen über die verarbeiteten Dateien, darunter:
- `totalFiles`: Anzahl der verarbeiteten Dateien
- `totalCharacters`: Gesamtanzahl der Zeichen
- `totalTokens`: Gesamtanzahl der Tokens (nützlich für LLM-Kontextgrenzen)
- `fileCharCounts`: Zeichenanzahl pro Datei
- `fileTokenCounts`: Token-Anzahl pro Datei

## Verarbeitung von Remote-Repositories

Sie können ein Remote-Repository klonen und verarbeiten:

```javascript
import { runCli, type CliOptions } from 'repomix';

// GitHub-Repository klonen und verarbeiten
async function processRemoteRepo(repoUrl) {
  const options = {
    remote: repoUrl,
    output: 'output.xml',
    compress: true
  } as CliOptions;
  
  return await runCli(['.'], process.cwd(), options);
}
```

## Verwendung der Kernkomponenten

Für mehr Kontrolle können Sie die Low-Level-APIs von Repomix direkt verwenden:

```javascript
import { searchFiles, collectFiles, processFiles, TokenCounter } from 'repomix';

async function analyzeFiles(directory) {
  // Dateien suchen und sammeln
  const { filePaths } = await searchFiles(directory, { /* Konfiguration */ });
  const rawFiles = await collectFiles(filePaths, directory);
  const processedFiles = await processFiles(rawFiles, { /* Konfiguration */ });
  
  // Tokens zählen
  const tokenCounter = new TokenCounter('o200k_base');
  
  // Analyseergebnisse zurückgeben
  return processedFiles.map(file => ({
    path: file.path,
    tokens: tokenCounter.countTokens(file.content)
  }));
}
```

## Reales Beispiel

Die Repomix-Website ([repomix.com](https://repomix.com)) verwendet Repomix als Bibliothek zur Verarbeitung von Remote-Repositories. Sie können die Implementierung in [website/server/src/remoteRepo.ts](https://github.com/yamadashy/repomix/blob/main/website/server/src/remoteRepo.ts) sehen.
</file>

<file path="website/client/src/de/guide/tips/best-practices.md">
# Best Practices für KI-unterstützte Entwicklung: Aus meiner Erfahrung

Obwohl ich noch kein großes Projekt mit KI erfolgreich abgeschlossen habe, möchte ich meine bisherigen Erfahrungen in der Entwicklung mit KI teilen.

## Grundlegender Entwicklungsansatz

Bei der Arbeit mit KI kann der Versuch, alle Funktionen auf einmal zu implementieren, zu unerwarteten Problemen und Projektstillstand führen. Deshalb ist es effektiver, mit der Kernfunktionalität zu beginnen und jede Funktion einzeln aufzubauen, wobei eine solide Implementierung sichergestellt wird, bevor man weitermacht.

### Die Kraft des bestehenden Codes

Dieser Ansatz ist effektiv, weil die Implementierung der Kernfunktionalität es Ihnen ermöglicht, Ihr ideales Design und Ihren Codierungsstil durch tatsächlichen Code zu materialisieren. Der effektivste Weg, Ihre Projektvision zu kommunizieren, ist durch Code, der Ihre Standards und Präferenzen widerspiegelt.

Indem Sie mit Kernfunktionen beginnen und sicherstellen, dass jede Komponente richtig funktioniert, bevor Sie weitergehen, behält das gesamte Projekt seine Konsistenz, was es der KI erleichtert, angemesseneren Code zu generieren.

## Der modulare 

Ansatz
Code in kleinere Module aufzuteilen ist entscheidend. Nach meiner Erfahrung macht es die Begrenzung von Dateien auf etwa 250 Codezeilen einfacher, der KI klare Anweisungen zu geben und den Versuch-und-Irrtum-Prozess effizienter zu gestalten. Während die Token-Anzahl ein genaueres Maß wäre, ist die Zeilenanzahl für menschliche Entwickler praktischer, daher verwenden wir diese als Richtlinie.

Diese Modularisierung beschränkt sich nicht nur auf die Trennung von Frontend, Backend und Datenbankkomponenten - es geht darum, die Funktionalität auf einer viel feineren Ebene aufzuteilen. Zum Beispiel könnten Sie innerhalb einer einzelnen Funktion die Validierung, Fehlerbehandlung und andere spezifische Funktionalitäten in separate Module aufteilen.

## Qualitätssicherung durch Tests

Ich halte Tests für entscheidend in der KI-unterstützten Entwicklung. Tests dienen nicht nur als Qualitätssicherungsmaßnahmen, sondern auch als Dokumentation, die die Codeabsichten klar demonstriert. Wenn Sie die KI bitten, neue Funktionen zu implementieren, fungiert der bestehende Testcode effektiv als Spezifikationsdokument.

Tests sind auch ein ausgezeichnetes Werkzeug zur Validierung der Korrektheit von KI-generiertem Code. Wenn Sie beispielsweise die KI neue Funktionalität für ein Modul implementieren lassen, ermöglicht das vorherige Schreiben von Testfällen eine objektive Bewertung, ob der generierte Code wie erwartet funktioniert.

## Balance zwischen Planung und Implementierung

Bevor Sie umfangreiche Funktionen implementieren, empfehle ich, zunächst den Plan mit der KI zu besprechen. Die Organisation von Anforderungen und die Berücksichtigung der Architektur führen zu einer reibungsloseren Implementierung. Eine gute Praxis ist es, zuerst die Anforderungen zusammenzustellen und dann zu einer separaten Chat-Sitzung für die Implementierungsarbeit überzugehen.

## Fazit

Durch die Befolgung dieser Praktiken können Sie die Stärken der KI nutzen und gleichzeitig eine konsistente, hochwertige Codebasis aufbauen. Selbst wenn Ihr Projekt wächst, bleibt jede Komponente gut definiert und handhabbar.
</file>

<file path="website/client/src/de/guide/code-compress.md">
# Code-Komprimierung

Die Code-Komprimierung ist eine leistungsstarke Funktion, die wichtige Code-Strukturen intelligent extrahiert und dabei Implementierungsdetails entfernt. Dies ist besonders nützlich, um die Token-Anzahl zu reduzieren und gleichzeitig wichtige strukturelle Informationen über Ihre Codebasis beizubehalten.

> [!NOTE]
> Dies ist eine experimentelle Funktion, die wir basierend auf Benutzerfeedback und praktischer Nutzung aktiv verbessern werden.

## Grundlegende Verwendung

Aktivieren Sie die Code-Komprimierung mit der Option `--compress`:

```bash
repomix --compress
```

Sie können sie auch mit Remote-Repositories verwenden:

```bash
repomix --remote user/repo --compress
```

## Funktionsweise

Der Komprimierungsalgorithmus verarbeitet Code mithilfe von Tree-Sitter-Parsing, um wesentliche strukturelle Elemente zu extrahieren und zu bewahren, während Implementierungsdetails entfernt werden.

Die Komprimierung bewahrt:
- Funktions- und Methodensignaturen
- Schnittstellen- und Typdefinitionen
- Klassenstrukturen und Eigenschaften
- Wichtige strukturelle Elemente

Während sie entfernt:
- Funktions- und Methodenimplementierungen
- Details zu Schleifen- und Bedingungslogik
- Interne Variablendeklarationen
- Implementierungsspezifischen Code

### Beispiel

Ursprünglicher TypeScript-Code:

```typescript
import { ShoppingItem } from './shopping-item';

/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
  let total = 0;
  for (const item of items) {
    total += item.price * item.quantity;
  }
  return total;
}

// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

Nach der Komprimierung:

```typescript
import { ShoppingItem } from './shopping-item';
⋮----
/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
⋮----
// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

## Konfiguration

Sie können die Komprimierung in Ihrer Konfigurationsdatei aktivieren:

```json
{
  "output": {
    "compress": true
  }
}
```

## Anwendungsfälle

Die Code-Komprimierung ist besonders nützlich wenn:
- Code-Struktur und Architektur analysiert werden
- Token-Anzahl für LLM-Verarbeitung reduziert werden soll
- Hochrangige Dokumentation erstellt wird
- Code-Muster und Signaturen verstanden werden sollen
- API- und Schnittstellendesigns geteilt werden

## Verwandte Optionen

Sie können die Komprimierung mit anderen Optionen kombinieren:
- `--remove-comments`: Code-Kommentare entfernen
- `--remove-empty-lines`: Leere Zeilen entfernen
- `--output-show-line-numbers`: Zeilennummern zur Ausgabe hinzufügen
</file>

<file path="website/client/src/de/guide/command-line-options.md">
# Kommandozeilenoptionen

## Grundlegende Optionen
- `-v, --version`: Zeigt die Version an

## Ausgabeoptionen
- `-o, --output <file>`: Ausgabedateiname (Standard: `repomix-output.txt`)
- `--stdout`: Ausgabe an die Standardausgabe anstatt in eine Datei (kann nicht mit der Option `--output` verwendet werden)
- `--style <type>`: Ausgabeformat (`plain`, `xml`, `markdown`) (Standard: `xml`)
- `--parsable-style`: Aktiviert parsbare Ausgabe basierend auf dem gewählten Formatschema (Standard: `false`)
- `--compress`: Führt eine intelligente Code-Extraktion durch, die sich auf Funktions- und Klassensignaturen konzentriert und Implementierungsdetails entfernt. Weitere Details und Beispiele finden Sie im [Code-Komprimierungsleitfaden](code-compress)
- `--output-show-line-numbers`: Fügt Zeilennummern hinzu (Standard: `false`)
- `--copy`: In die Zwischenablage kopieren (Standard: `false`)
- `--no-file-summary`: Deaktiviert die Dateizusammenfassung (Standard: `true`)
- `--no-directory-structure`: Deaktiviert die Verzeichnisstruktur (Standard: `true`)
- `--no-files`: Deaktiviert die Ausgabe des Dateiinhalts (Nur-Metadaten-Modus) (Standard: `true`)
- `--remove-comments`: Entfernt Kommentare (Standard: `false`)
- `--remove-empty-lines`: Entfernt leere Zeilen (Standard: `false`)
- `--header-text <text>`: Benutzerdefinierter Text für den Dateikopf
- `--instruction-file-path <path>`: Pfad zu einer Datei mit detaillierten benutzerdefinierten Anweisungen
- `--include-empty-directories`: Leere Verzeichnisse in die Ausgabe einbeziehen (Standard: `false`)
- `--include-diffs`: Git-Unterschiede in die Ausgabe einbeziehen (enthält sowohl Arbeitsbaum- als auch gestaged Änderungen separat) (Standard: `false`)

## Filteroptionen
- `--include <patterns>`: Einzuschließende Muster (durch Komma getrennt)
- `-i, --ignore <patterns>`: Zu ignorierende Muster (durch Komma getrennt)
- `--stdin`: Dateipfade von stdin lesen anstatt Dateien automatisch zu erkennen
- `--no-gitignore`: Deaktiviert die Verwendung der .gitignore-Datei
- `--no-default-patterns`: Deaktiviert Standardmuster

## Remote-Repository-Optionen
- `--remote <url>`: Remote-Repository verarbeiten
- `--remote-branch <name>`: Remote-Branch-Name, Tag oder Commit-Hash angeben (Standard ist der Standard-Branch des Repositories)

## Konfigurationsoptionen
- `-c, --config <path>`: Pfad zur benutzerdefinierten Konfigurationsdatei
- `--init`: Konfigurationsdatei erstellen
- `--global`: Globale Konfiguration verwenden

## Sicherheitsoptionen
- `--no-security-check`: Deaktiviert die Sicherheitsprüfung (Standard: `true`)

## Token-Zähloptionen
- `--token-count-encoding <encoding>`: Token-Zählkodierung festlegen (z.B. `o200k_base`, `cl100k_base`) (Standard: `o200k_base`)

## Weitere Optionen
- `--top-files-len <number>`: Anzahl der anzuzeigenden Top-Dateien (Standard: `5`)
- `--verbose`: Ausführliche Protokollierung aktivieren
- `--quiet`: Deaktiviert alle Ausgaben an stdout

## Beispiele

```bash
# Grundlegende Verwendung
repomix

# Benutzerdefinierte Ausgabe
repomix -o output.xml --style xml

# Ausgabe an die Standardausgabe
repomix --stdout > custom-output.txt

# Ausgabe an die Standardausgabe senden, dann in einen anderen Befehl weiterleiten (zum Beispiel: simonw/llm)
repomix --stdout | llm "Bitte erkläre, was dieser Code macht"

# Benutzerdefinierte Ausgabe mit Komprimierung
repomix --compress

# Bestimmte Dateien verarbeiten
repomix --include "src/**/*.ts" --ignore "**/*.test.ts"

# Remote-Repository mit Branch
repomix --remote https://github.com/user/repo/tree/main

# Remote-Repository mit Commit
repomix --remote https://github.com/user/repo/commit/836abcd7335137228ad77feb28655d85712680f1

# Remote-Repository mit Kurzform
repomix --remote user/repo

# Dateiliste mit stdin
find src -name "*.ts" -type f | repomix --stdin
git ls-files "*.js" | repomix --stdin
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```
</file>

<file path="website/client/src/de/guide/comment-removal.md">
# Kommentarentfernung

Repomix kann beim Generieren der Ausgabedatei automatisch Kommentare aus Ihrer Codebasis entfernen. Dies kann helfen, Störungen zu reduzieren und sich auf den eigentlichen Code zu konzentrieren.

## Verwendung

Um die Kommentarentfernung zu aktivieren, setzen Sie die Option `removeComments` in Ihrer `repomix.config.json` auf `true`:

```json
{
  "output": {
    "removeComments": true
  }
}
```

## Unterstützte Sprachen

Repomix unterstützt die Kommentarentfernung für eine Vielzahl von Programmiersprachen, einschließlich:

- JavaScript/TypeScript (`//`, `/* */`)
- Python (`#`, `"""`, `'''`)
- Java (`//`, `/* */`)
- C/C++ (`//`, `/* */`)
- HTML (`<!-- -->`)
- CSS (`/* */`)
- Und viele mehr...

## Beispiel

Gegeben sei der folgende JavaScript-Code:

```javascript
// Dies ist ein einzeiliger Kommentar
function test() {
  /* Dies ist ein
     mehrzeiliger Kommentar */
  return true;
}
```

Mit aktivierter Kommentarentfernung wird die Ausgabe wie folgt aussehen:

```javascript
function test() {
  return true;
}
```

## Hinweise

- Die Kommentarentfernung wird vor anderen Verarbeitungsschritten durchgeführt, wie z.B. der Zeilennummerierung.
- Einige Kommentare, wie JSDoc-Kommentare, können je nach Sprache und Kontext erhalten bleiben.
</file>

<file path="website/client/src/de/guide/configuration.md">
# Konfiguration

Repomix kann über eine Konfigurationsdatei (`repomix.config.json`) oder Kommandozeilenoptionen konfiguriert werden. Die Konfigurationsdatei ermöglicht es Ihnen, die Verarbeitung und Ausgabe Ihres Codes anzupassen.

## Schnellstart

Erstellen Sie eine Konfigurationsdatei in Ihrem Projektverzeichnis:
```bash
repomix --init
```

Dies erstellt eine `repomix.config.json`-Datei mit Standardeinstellungen. Sie können auch eine globale Konfigurationsdatei erstellen, die als Fallback verwendet wird, wenn keine lokale Konfiguration gefunden wird:

```bash
repomix --init --global
```

## Schema-Validierung

Sie können die Schema-Validierung für Ihre Konfigurationsdatei aktivieren, indem Sie die Eigenschaft `$schema` hinzufügen:

```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "output": {
    "filePath": "repomix-output.md",
    "style": "markdown"
  }
}
```

Dies bietet Autovervollständigung und Validierung in Editoren, die JSON-Schema unterstützen.

## Konfigurationsoptionen

| Option                           | Beschreibung                                                                                                                | Standardwert           |
|----------------------------------|-----------------------------------------------------------------------------------------------------------------------------|------------------------|
| `input.maxFileSize`              | Maximale zu verarbeitende Dateigröße in Bytes. Größere Dateien werden übersprungen. Nützlich zum Ausschließen großer Binär- oder Datendateien | `50000000`            |
| `output.filePath`                | Name der Ausgabedatei. Unterstützt XML-, Markdown- und Textformate                                                         | `"repomix-output.xml"` |
| `output.style`                   | Ausgabestil (`xml`, `markdown`, `plain`). Jedes Format hat seine Vorteile für verschiedene KI-Tools                       | `"xml"`                |
| `output.parsableStyle`           | Ob die Ausgabe gemäß dem gewählten Stilschema escaped werden soll. Ermöglicht besseres Parsing, kann aber die Token-Anzahl erhöhen | `false`                |
| `output.compress`                | Ob Tree-sitter verwendet werden soll, um intelligente Codeextraktion durchzuführen und dabei die Struktur beizubehalten, während die Token-Anzahl reduziert wird | `false`                |
| `output.headerText`              | Benutzerdefinierter Text für den Dateikopf. Nützlich für die Bereitstellung von Kontext oder Anweisungen für KI-Tools    | `null`                 |
| `output.instructionFilePath`     | Pfad zu einer Datei mit detaillierten benutzerdefinierten Anweisungen für die KI-Verarbeitung                            | `null`                 |
| `output.fileSummary`             | Ob eine Zusammenfassung mit Dateianzahl, -größen und anderen Metriken am Anfang der Ausgabe eingefügt werden soll        | `true`                 |
| `output.directoryStructure`      | Ob die Verzeichnisstruktur in der Ausgabe enthalten sein soll. Hilft der KI, die Projektorganisation zu verstehen       | `true`                 |
| `output.files`                   | Ob Dateiinhalte in der Ausgabe enthalten sein sollen. Bei false werden nur Struktur und Metadaten einbezogen            | `true`                 |
| `output.removeComments`          | Ob Kommentare aus unterstützten Dateitypen entfernt werden sollen. Kann Rauschen und Token-Anzahl reduzieren            | `false`                |
| `output.removeEmptyLines`        | Ob leere Zeilen aus der Ausgabe entfernt werden sollen, um die Token-Anzahl zu reduzieren                                | `false`                |
| `output.showLineNumbers`         | Ob Zeilennummern hinzugefügt werden sollen. Hilfreich für das Referenzieren bestimmter Codestellen                      | `false`                |
| `output.copyToClipboard`         | Ob die Ausgabe zusätzlich zum Speichern in die Zwischenablage kopiert werden soll                                        | `false`                |
| `output.topFilesLength`          | Anzahl der in der Zusammenfassung anzuzeigenden Top-Dateien. Bei 0 wird keine Zusammenfassung angezeigt                  | `5`                    |
| `output.includeEmptyDirectories` | Ob leere Verzeichnisse in der Repository-Struktur enthalten sein sollen                                                   | `false`                |
| `output.git.sortByChanges`       | Ob Dateien nach Git-Änderungen sortiert werden sollen. Häufiger geänderte Dateien erscheinen am Ende                     | `true`                 |
| `output.git.sortByChangesMaxCommits` | Maximale Anzahl zu analysierender Commits für Git-Änderungen. Begrenzt die Historien-Tiefe für bessere Performance   | `100`                  |
| `output.git.includeDiffs`        | Ob Git-Unterschiede in der Ausgabe enthalten sein sollen. Zeigt Arbeitsverzeichnis- und Stage-Änderungen separat an     | `false`                |
| `include`                        | Zu einschließende Dateimuster (verwendet [glob-Muster](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)) | `[]`                   |
| `ignore.useGitignore`            | Ob Muster aus der `.gitignore`-Datei des Projekts verwendet werden sollen                                                 | `true`                 |
| `ignore.useDefaultPatterns`      | Ob Standard-Ignorier-Muster (node_modules, .git etc.) verwendet werden sollen                                             | `true`                 |
| `ignore.customPatterns`          | Zusätzliche Ignorier-Muster (verwendet [glob-Muster](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)) | `[]`                   |
| `security.enableSecurityCheck`   | Ob Secretlint verwendet werden soll, um Sicherheitsprüfungen auf sensible Informationen durchzuführen                    | `true`                 |
| `tokenCount.encoding`            | Token-Count-Encoding für OpenAIs [tiktoken](https://github.com/openai/tiktoken) Tokenizer. Verwenden Sie `o200k_base` für GPT-4o, `cl100k_base` für GPT-4/3.5. Details siehe [tiktoken model.py](https://github.com/openai/tiktoken/blob/main/tiktoken/model.py#L24) | `"o200k_base"`         |

Die Konfigurationsdatei unterstützt [JSON5](https://json5.org/)-Syntax, die Folgendes erlaubt:
- Kommentare (einzeilig und mehrzeilig)
- Nachfolgende Kommas in Objekten und Arrays
- Unquotierte Eigenschaftsnamen
- Flexiblere String-Syntax

## Beispiel-Konfigurationsdatei

Hier ist ein Beispiel einer vollständigen Konfigurationsdatei (`repomix.config.json`):

```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 50000000
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "compress": false,
    "headerText": "Benutzerdefinierte Header-Informationen für die gepackte Datei",
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "includeEmptyDirectories": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false
    }
  },
  "include": ["**/*"],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    // Muster können auch in .repomixignore angegeben werden
    "customPatterns": [
      "additional-folder",
      "**/*.log"
    ],
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
```

## Speicherorte der Konfigurationsdatei

Repomix sucht in folgender Reihenfolge nach Konfigurationsdateien:
1. Lokale Konfigurationsdatei (`repomix.config.json`) im aktuellen Verzeichnis
2. Globale Konfigurationsdatei:
   - Windows: `%LOCALAPPDATA%\Repomix\repomix.config.json`
   - macOS/Linux: `~/.config/repomix/repomix.config.json`

Kommandozeilenoptionen haben Vorrang vor Einstellungen in der Konfigurationsdatei.

## Ignorier-Muster

Repomix bietet mehrere Möglichkeiten, zu ignorierende Dateien anzugeben. Die Muster werden in folgender Prioritätsreihenfolge verarbeitet:

1. CLI-Optionen (`--ignore`)
2. `.repomixignore`-Datei im Projektverzeichnis
3. `.gitignore` und `.git/info/exclude` (wenn `ignore.useGitignore` true ist)
4. Standardmuster (wenn `ignore.useDefaultPatterns` true ist)

Beispiel für `.repomixignore`:
```text
# Cache-Verzeichnisse
.cache/
tmp/

# Build-Ausgaben
dist/
build/

# Logs
*.log
```

## Standard-Ignorier-Muster

Wenn `ignore.useDefaultPatterns` true ist, ignoriert Repomix automatisch folgende häufige Muster:
```text
node_modules/**
.git/**
coverage/**
dist/**
```

Die vollständige Liste finden Sie in [defaultIgnore.ts](https://github.com/yamadashy/repomix/blob/main/src/config/defaultIgnore.ts)

## Erweiterte Funktionen

### Code-Komprimierung

Die Code-Komprimierungsfunktion (aktiviert durch `output.compress: true`) verwendet [Tree-sitter](https://github.com/tree-sitter/tree-sitter), um wesentliche Code-Strukturen intelligent zu extrahieren und dabei Implementierungsdetails zu entfernen. Dies hilft, die Token-Anzahl zu reduzieren und gleichzeitig wichtige strukturelle Informationen beizubehalten.

Hauptvorteile:
- Signifikante Reduzierung der Token-Anzahl
- Beibehaltung von Klassen- und Funktionssignaturen
- Beibehaltung von Imports und Exports
- Beibehaltung von Typdefinitionen und Interfaces
- Entfernung von Funktionskörpern und Implementierungsdetails

Weitere Details und Beispiele finden Sie im [Code-Komprimierungs-Leitfaden](code-compress).

### Git-Integration

Die `output.git`-Konfiguration bietet leistungsstarke Git-bewusste Funktionen:

- `sortByChanges`: Wenn auf true gesetzt, werden Dateien nach der Anzahl der Git-Änderungen (Commits, die die Datei modifiziert haben) sortiert. Häufiger geänderte Dateien erscheinen am Ende der Ausgabe. Dies hilft, aktiver entwickelte Dateien zu priorisieren. Standard: `true`
- `sortByChangesMaxCommits`: Maximale Anzahl zu analysierender Commits bei der Zählung von Dateiänderungen. Standard: `100`
- `includeDiffs`: Wenn auf true gesetzt, werden Git-Unterschiede in die Ausgabe einbezogen (enthält sowohl Arbeitsverzeichnis- als auch Stage-Änderungen separat). Dies ermöglicht es dem Leser, ausstehende Änderungen im Repository zu sehen. Standard: `false`

Beispielkonfiguration:
```json
{
  "output": {
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": true
    }
  }
}
```

### Sicherheitsprüfungen

Wenn `security.enableSecurityCheck` aktiviert ist, verwendet Repomix [Secretlint](https://github.com/secretlint/secretlint), um sensible Informationen zu erkennen, bevor der Code in die Ausgabe aufgenommen wird. Dies hilft, versehentliche Offenlegung zu verhindern von:

- API-Schlüsseln
- Zugriffstoken
- Privaten Schlüsseln
- Passwörtern
- Anderen sensiblen Anmeldeinformationen

### Kommentarentfernung

Wenn `output.removeComments` auf `true` gesetzt ist, werden Kommentare aus unterstützten Dateitypen entfernt, um die Ausgabegröße zu reduzieren und sich auf den wesentlichen Code-Inhalt zu konzentrieren. Dies ist besonders nützlich in folgenden Fällen:

- Verarbeitung stark dokumentierten Codes
- Versuch, die Token-Anzahl zu reduzieren
- Fokussierung auf Code-Struktur und -Logik

Unterstützte Sprachen und detaillierte Beispiele finden Sie im [Kommentarentfernungs-Leitfaden](comment-removal).
</file>

<file path="website/client/src/de/guide/custom-instructions.md">
# Benutzerdefinierte Anweisungen

Repomix ermöglicht es Ihnen, benutzerdefinierte Anweisungen bereitzustellen, die in die Ausgabedatei aufgenommen werden. Dies kann nützlich sein, um Kontext oder spezifische Richtlinien für KI-Systeme hinzuzufügen, die das Repository verarbeiten.

## Verwendung

Um eine benutzerdefinierte Anweisung einzufügen, erstellen Sie eine Markdown-Datei (z.B. `repomix-instruction.md`) im Stammverzeichnis Ihres Repositories. Geben Sie dann den Pfad zu dieser Datei in Ihrer `repomix.config.json` an:

```json
{
  "output": {
    "instructionFilePath": "repomix-instruction.md"
  }
}
```

Der Inhalt dieser Datei wird in der Ausgabe unter dem Abschnitt "Instruction" aufgenommen.

## Beispiel

```markdown
# Repository-Anweisungen

Dieses Repository enthält den Quellcode für das Repomix-Tool. Bitte beachten Sie diese Richtlinien bei der Analyse des Codes:

1. Konzentrieren Sie sich auf die Kernfunktionalität im Verzeichnis `src/core`.
2. Achten Sie besonders auf die Sicherheitsprüfungen in `src/core/security`.
3. Ignorieren Sie alle Dateien im Verzeichnis `tests`.
```

Dies führt zu folgendem Abschnitt in der Ausgabe:

```xml
<instruction>
# Repository-Anweisungen

Dieses Repository enthält den Quellcode für das Repomix-Tool. Bitte beachten Sie diese Richtlinien bei der Analyse des Codes:

1. Konzentrieren Sie sich auf die Kernfunktionalität im Verzeichnis `src/core`.
2. Achten Sie besonders auf die Sicherheitsprüfungen in `src/core/security`.
3. Ignorieren Sie alle Dateien im Verzeichnis `tests`.
</instruction>
```
</file>

<file path="website/client/src/de/guide/github-actions.md">
# Verwendung von Repomix mit GitHub Actions

Sie können den Verpackungsprozess Ihres Codebases für die KI-Analyse automatisieren, indem Sie Repomix in Ihre GitHub Actions Workflows integrieren. Dies ist nützlich für Continuous Integration (CI), Code-Reviews oder die Vorbereitung für LLM-Tools.

## Grundlegende Nutzung

Fügen Sie den folgenden Schritt zu Ihrer Workflow-YAML-Datei hinzu, um Ihr Repository zu verpacken:

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.xml
```

## Verwendung verschiedener Ausgabeformate

Sie können verschiedene Ausgabeformate mit dem Parameter `style` festlegen (Standard ist `xml`):

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.md
    style: markdown
```

## Mehrere Verzeichnisse mit Komprimierung verpacken

Sie können mehrere Verzeichnisse, Include-/Exclude-Patterns und intelligente Komprimierung angeben:

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src tests
    include: "**/*.ts,**/*.md"
    ignore: "**/*.test.ts"
    output: repomix-output.xml
    compress: true
```

## Ausgabedatei als Artefakt hochladen

Um die verpackte Datei für nachfolgende Schritte oder zum Download bereitzustellen, laden Sie sie als Artefakt hoch:

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src
    output: repomix-output.xml
    compress: true

- name: Upload Repomix output
  uses: actions/upload-artifact@v4
  with:
    name: repomix-output
    path: repomix-output.xml
```

## Action-Eingabeparameter

| Name               | Beschreibung                                 | Standardwert      |
|--------------------|----------------------------------------------|-------------------|
| `directories`      | Zu verpackende Verzeichnisse (Leerzeichen-getrennt) | `.`         |
| `include`          | Einzuschließende Glob-Patterns (kommagetrennt) | `""`         |
| `ignore`           | Auszuschließende Glob-Patterns (kommagetrennt) | `""`         |
| `output`           | Pfad der Ausgabedatei                         | `repomix-output.xml`     |
| `style`            | Ausgabestil (xml, markdown, plain)            | `xml`             |
| `compress`         | Intelligente Komprimierung aktivieren          | `true`            |
| `additional-args`  | Zusätzliche Argumente für repomix CLI          | `""`         |
| `repomix-version`  | Zu installierende npm-Paketversion             | `latest`          |

## Action-Ausgaben

| Name          | Beschreibung                        |
|---------------|-------------------------------------|
| `output_file` | Pfad zur generierten Ausgabedatei    |

## Komplettes Workflow-Beispiel

## Beispiel: Vollständiger Workflow

Hier ein vollständiges Beispiel für einen GitHub Actions Workflow mit Repomix:

```yaml
name: Pack repository with Repomix

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  pack-repo:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Pack repository with Repomix
        uses: yamadashy/repomix/.github/actions/repomix@main
        with:
          output: repomix-output.xml

      - name: Upload Repomix output
        uses: actions/upload-artifact@v4
        with:
          name: repomix-output.xml
          path: repomix-output.xml
          retention-days: 30
```

Das [vollständige Workflow-Beispiel](https://github.com/yamadashy/repomix/blob/main/.github/workflows/pack-repository.yml) finden Sie hier.
</file>

<file path="website/client/src/de/guide/index.md">
# Erste Schritte mit Repomix

<script setup>
import HomeBadges from '../../../components/HomeBadges.vue'
import YouTubeVideo from '../../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../../utils/videos'
</script>

Repomix ist ein Tool, das Ihr gesamtes Repository in eine einzige, KI-freundliche Datei verpackt. Es wurde entwickelt, um Ihren Codebase an große Sprachmodelle (LLMs) wie ChatGPT, DeepSeek, Perplexity, Gemini, Gemma, Llama, Grok und mehr zu übergeben.

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

<HomeBadges />

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## Schnellstart

Führen Sie diesen Befehl in Ihrem Projektverzeichnis aus:

```bash
npx repomix
```

Das war's! Sie finden eine `repomix-output.xml` Datei, die Ihr gesamtes Repository in einem KI-freundlichen Format enthält.

Sie können diese Datei dann mit einem Prompt wie diesem an einen KI-Assistenten senden:

```
Diese Datei enthält alle Dateien im Repository in einer Datei zusammengefasst.
Ich möchte den Code refaktorieren, bitte überprüfen Sie ihn zuerst.
```

Die KI wird Ihren gesamten Codebase analysieren und umfassende Einblicke geben:

![Repomix File Usage 1](/images/docs/repomix-file-usage-1.png)

Bei der Diskussion spezifischer Änderungen kann die KI bei der Code-Generierung helfen. Mit Funktionen wie Claudes Artifacts können Sie sogar mehrere voneinander abhängige Dateien erhalten:

![Repomix File Usage 2](/images/docs/repomix-file-usage-2.png)

Viel Spaß beim Programmieren! 🚀

## Kernfunktionen

- **KI-optimierte Ausgabe**: Formatiert Ihren Codebase für einfache KI-Verarbeitung
- **Token-Zählung**: Verfolgt Token-Nutzung für LLM-Kontextgrenzen
- **Git-bewusst**: Berücksichtigt Ihre `.gitignore`-Dateien und `.git/info/exclude`-Dateien
- **Sicherheitsorientiert**: Erkennt sensible Informationen
- **Mehrere Ausgabeformate**: Wählen Sie zwischen Klartext, XML oder Markdown

## Was kommt als Nächstes?

- [Installationsanleitung](installation.md): Verschiedene Möglichkeiten, Repomix zu installieren
- [Verwendungsleitfaden](usage.md): Lernen Sie grundlegende und erweiterte Funktionen kennen
- [Konfiguration](configuration.md): Passen Sie Repomix an Ihre Bedürfnisse an
- [Sicherheitsfunktionen](security.md): Erfahren Sie mehr über Sicherheitsprüfungen

## Community

Treten Sie unserer [Discord-Community](https://discord.gg/wNYzTwZFku) bei für:
- Hilfe mit Repomix
- Teilen Sie Ihre Erfahrungen
- Vorschlagen neuer Funktionen
- Verbindung mit anderen Benutzern

## Unterstützung

Haben Sie einen Fehler gefunden oder brauchen Sie Hilfe?
- [Öffnen Sie ein Issue auf GitHub](https://github.com/yamadashy/repomix/issues)
- Treten Sie unserem Discord-Server bei
- Lesen Sie die [Dokumentation](https://repomix.com)
</file>

<file path="website/client/src/de/guide/installation.md">
# Installation

## Verwendung von npx (Keine Installation erforderlich)

```bash
npx repomix
```

## Globale Installation

### npm
```bash
npm install -g repomix
```

### Yarn
```bash
yarn global add repomix
```

### Bun
```bash
bun add -g repomix
```

### Homebrew (macOS/Linux)
```bash
brew install repomix
```

## Docker Installation

Docker-Image herunterladen und ausführen:

```bash
# Aktuelles Verzeichnis
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix

# Bestimmtes Verzeichnis
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory

# Remote-Repository
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote yamadashy/repomix
```

## VSCode-Erweiterung

Führen Sie Repomix direkt in VSCode mit der von der Community gepflegten [Repomix Runner](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner) Erweiterung aus.

Funktionen:
- Packen Sie jeden Ordner mit wenigen Klicks
- Wählen Sie zwischen Datei- oder Inhaltsmodus zum Kopieren
- Automatische Bereinigung von Ausgabedateien
- Funktioniert mit repomix.config.json

Installieren Sie sie vom [VSCode Marketplace](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner).

## Browser-Erweiterung

Erhalten Sie direkten Zugang zu Repomix von jedem GitHub-Repository! Unsere Chrome-Erweiterung fügt einen praktischen "Repomix"-Button zu GitHub-Repository-Seiten hinzu.

![Repomix Browser Extension](/images/docs/browser-extension.png)

### Installation
- Chrome-Erweiterung: [Repomix - Chrome Web Store](https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa)
- Firefox-Add-on: [Repomix - Firefox Add-ons](https://addons.mozilla.org/firefox/addon/repomix/)

### Funktionen
- Ein-Klick-Zugang zu Repomix für jedes GitHub-Repository
- Weitere aufregende Funktionen kommen bald!

## Systemanforderungen

- Node.js: ≥ 18.0.0
- Git: Erforderlich für die Verarbeitung von Remote-Repositories

## Überprüfung

Überprüfen Sie nach der Installation, ob Repomix funktioniert:

```bash
repomix --version
repomix --help
```
</file>

<file path="website/client/src/de/guide/mcp-server.md">
# MCP-Server

Repomix unterstützt das [Model Context Protocol (MCP)](https://modelcontextprotocol.io), das es KI-Assistenten ermöglicht, direkt mit Ihrer Codebasis zu interagieren. Wenn Repomix als MCP-Server ausgeführt wird, stellt es Tools bereit, die es KI-Assistenten ermöglichen, lokale oder entfernte Repositories ohne manuelle Dateivorbereitung für die Analyse zu verpacken.

> [!NOTE]  
> Dies ist eine experimentelle Funktion, die wir basierend auf Benutzerfeedback und praktischer Nutzung aktiv verbessern werden

## Repomix als MCP-Server ausführen

Um Repomix als MCP-Server auszuführen, verwenden Sie die `--mcp`-Flag:

```bash
repomix --mcp
```

Dadurch wird Repomix im MCP-Server-Modus gestartet und steht KI-Assistenten zur Verfügung, die das Model Context Protocol unterstützen.

## MCP-Server konfigurieren

Um Repomix als MCP-Server mit KI-Assistenten wie Claude zu verwenden, müssen Sie die MCP-Einstellungen konfigurieren:

### Für VS Code

Sie können den Repomix MCP-Server in VS Code mit einer dieser Methoden installieren:

1. **Über das Installations-Badge:**

  [![Install in VS Code](https://img.shields.io/badge/VS_Code-VS_Code?style=flat-square&label=Install%20Server&color=0098FF)](vscode:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)<br>
  [![Install in VS Code Insiders](https://img.shields.io/badge/VS_Code_Insiders-VS_Code_Insiders?style=flat-square&label=Install%20Server&color=24bfa5)](vscode-insiders:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)

2. **Über die Kommandozeile:**

  ```bash
  code --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

  Für VS Code Insiders:
  ```bash
  code-insiders --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

### Für Cline (VS Code-Erweiterung)

Bearbeiten Sie die `cline_mcp_settings.json`-Datei:

```json
{
  "mcpServers": {
    "repomix": {
      "command": "npx",
      "args": [
        "-y",
        "repomix",
        "--mcp"
      ]
    }
  }
}
```

### Für Cursor

In Cursor fügen Sie einen neuen MCP-Server aus `Cursor Settings` > `MCP` > `+ Add new global MCP server` mit einer ähnlichen Konfiguration wie bei Cline hinzu.

### Für Claude Desktop

Bearbeiten Sie die `claude_desktop_config.json`-Datei mit einer ähnlichen Konfiguration wie bei Cline.

### Für Claude Code

Um Repomix als MCP-Server in [Claude Code](https://docs.anthropic.com/en/docs/claude-code/overview) zu konfigurieren, verwenden Sie den folgenden Befehl:

```bash
claude mcp add repomix -- npx -y repomix --mcp
```

### Docker anstelle von npx verwenden

Anstatt npx zu verwenden, können Sie auch Docker verwenden, um Repomix als MCP-Server auszuführen:

```json
{
  "mcpServers": {
    "repomix-docker": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "ghcr.io/yamadashy/repomix",
        "--mcp"
      ]
    }
  }
}
```

## Verfügbare MCP-Tools

Wenn Repomix als MCP-Server ausgeführt wird, stellt es die folgenden Tools bereit:

### pack_codebase

Dieses Tool verpackt ein lokales Code-Verzeichnis in eine XML-Datei für die KI-Analyse. Es analysiert die Codebase-Struktur, extrahiert relevanten Code-Inhalt und generiert einen umfassenden Bericht mit Metriken, Dateibaum und formatiertem Code-Inhalt.

**Parameter:**
- `directory`: (Erforderlich) Absoluter Pfad zum zu verpackenden Verzeichnis
- `compress`: (Optional, Standard: false) Aktiviert Tree-sitter-Komprimierung zur Extraktion wesentlicher Code-Signaturen und -Strukturen bei gleichzeitiger Entfernung von Implementierungsdetails. Reduziert die Token-Nutzung um ~70% bei Beibehaltung der semantischen Bedeutung. Normalerweise nicht erforderlich, da grep_repomix_output inkrementelle Inhaltsabrufung ermöglicht. Verwenden Sie dies nur, wenn Sie speziell den gesamten Codebase-Inhalt für große Repositories benötigen.
- `includePatterns`: (Optional) Spezifiziert Dateien zum Einschließen mit fast-glob-Mustern. Mehrere Muster können durch Kommas getrennt werden (z.B. "**/*.{js,ts}", "src/**,docs/**"). Nur übereinstimmende Dateien werden verarbeitet.
- `ignorePatterns`: (Optional) Spezifiziert zusätzliche Dateien zum Ausschließen mit fast-glob-Mustern. Mehrere Muster können durch Kommas getrennt werden (z.B. "test/**,*.spec.js", "node_modules/**,dist/**"). Diese Muster ergänzen .gitignore und eingebaute Ausschlüsse.
- `topFilesLength`: (Optional, Standard: 10) Anzahl der größten Dateien nach Größe, die in der Metrik-Zusammenfassung für die Codebase-Analyse angezeigt werden.

**Beispiel:**
```json
{
  "directory": "/path/to/your/project",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### pack_remote_repository

Dieses Tool holt, klont und verpackt ein GitHub-Repository in eine XML-Datei für die KI-Analyse. Es klont automatisch das entfernte Repository, analysiert seine Struktur und generiert einen umfassenden Bericht.

**Parameter:**
- `remote`: (Erforderlich) GitHub-Repository-URL oder user/repo-Format (z.B. "yamadashy/repomix", "https://github.com/user/repo", oder "https://github.com/user/repo/tree/branch")
- `compress`: (Optional, Standard: false) Aktiviert Tree-sitter-Komprimierung zur Extraktion wesentlicher Code-Signaturen und -Strukturen bei gleichzeitiger Entfernung von Implementierungsdetails. Reduziert die Token-Nutzung um ~70% bei Beibehaltung der semantischen Bedeutung. Normalerweise nicht erforderlich, da grep_repomix_output inkrementelle Inhaltsabrufung ermöglicht. Verwenden Sie dies nur, wenn Sie speziell den gesamten Codebase-Inhalt für große Repositories benötigen.
- `includePatterns`: (Optional) Spezifiziert Dateien zum Einschließen mit fast-glob-Mustern. Mehrere Muster können durch Kommas getrennt werden (z.B. "**/*.{js,ts}", "src/**,docs/**"). Nur übereinstimmende Dateien werden verarbeitet.
- `ignorePatterns`: (Optional) Spezifiziert zusätzliche Dateien zum Ausschließen mit fast-glob-Mustern. Mehrere Muster können durch Kommas getrennt werden (z.B. "test/**,*.spec.js", "node_modules/**,dist/**"). Diese Muster ergänzen .gitignore und eingebaute Ausschlüsse.
- `topFilesLength`: (Optional, Standard: 10) Anzahl der größten Dateien nach Größe, die in der Metrik-Zusammenfassung für die Codebase-Analyse angezeigt werden.

**Beispiel:**
```json
{
  "remote": "yamadashy/repomix",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### read_repomix_output

Dieses Tool liest den Inhalt einer von Repomix generierten Ausgabedatei. Es unterstützt partielles Lesen mit Zeilenbereichen für große Dateien. Dieses Tool ist für Umgebungen konzipiert, in denen der direkte Dateisystemzugriff eingeschränkt ist.

**Parameter:**
- `outputId`: (Erforderlich) ID der zu lesenden Repomix-Ausgabedatei
- `startLine`: (Optional) Startzeilennummer (1-basiert, inklusive). Wenn nicht angegeben, wird vom Anfang gelesen.
- `endLine`: (Optional) Endzeilennummer (1-basiert, inklusive). Wenn nicht angegeben, wird bis zum Ende gelesen.

**Funktionen:**
- Speziell für webbasierte Umgebungen oder Sandbox-Anwendungen entwickelt
- Ruft den Inhalt zuvor generierter Ausgaben über ihre ID ab
- Bietet sicheren Zugriff auf verpackte Codebase ohne Dateisystemzugriff
- Unterstützt partielles Lesen für große Dateien

**Beispiel:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "startLine": 100,
  "endLine": 200
}
```

### grep_repomix_output

Dieses Tool durchsucht Muster in einer Repomix-Ausgabedatei mit grep-ähnlicher Funktionalität unter Verwendung der JavaScript RegExp-Syntax. Es gibt übereinstimmende Zeilen mit optionalen Kontextzeilen um die Übereinstimmungen zurück.

**Parameter:**
- `outputId`: (Erforderlich) ID der zu durchsuchenden Repomix-Ausgabedatei
- `pattern`: (Erforderlich) Suchmuster (JavaScript RegExp-Syntax für reguläre Ausdrücke)
- `contextLines`: (Optional, Standard: 0) Anzahl der Kontextzeilen, die vor und nach jeder Übereinstimmung angezeigt werden. Wird von beforeLines/afterLines überschrieben, wenn angegeben.
- `beforeLines`: (Optional) Anzahl der Kontextzeilen, die vor jeder Übereinstimmung angezeigt werden (wie grep -B). Hat Vorrang vor contextLines.
- `afterLines`: (Optional) Anzahl der Kontextzeilen, die nach jeder Übereinstimmung angezeigt werden (wie grep -A). Hat Vorrang vor contextLines.
- `ignoreCase`: (Optional, Standard: false) Führt groß-/kleinschreibungsunabhängige Übereinstimmung durch

**Funktionen:**
- Verwendet JavaScript RegExp-Syntax für leistungsstarke Musterübereinstimmung
- Unterstützt Kontextzeilen für besseres Verständnis der Übereinstimmungen
- Ermöglicht separate Kontrolle von Vor-/Nach-Kontextzeilen
- Groß-/kleinschreibungsabhängige und -unabhängige Suchoptionen

**Beispiel:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "pattern": "function\\s+\\w+\\(",
  "contextLines": 3,
  "ignoreCase": false
}
```

### file_system_read_file und file_system_read_directory

Der Repomix MCP-Server bietet zwei Dateisystemwerkzeuge, die es KI-Assistenten ermöglichen, sicher mit dem lokalen Dateisystem zu interagieren:

1. `file_system_read_file`
  - Liest Dateiinhalte aus dem lokalen Dateisystem unter Verwendung absoluter Pfade
  - Beinhaltet eingebaute Sicherheitsvalidierung zur Erkennung und Verhinderung des Zugriffs auf Dateien mit sensiblen Informationen
  - Implementiert Sicherheitsvalidierung mit [Secretlint](https://github.com/secretlint/secretlint)
  - Verhindert den Zugriff auf Dateien mit sensiblen Informationen (API-Schlüssel, Passwörter, Geheimnisse)
  - Validiert absolute Pfade zur Verhinderung von Directory Traversal-Angriffen
  - Liefert klare Fehlermeldungen für ungültige Pfade und Sicherheitsprobleme

2. `file_system_read_directory`
  - Listet den Inhalt eines Verzeichnisses unter Verwendung eines absoluten Pfads
  - Gibt eine formatierte Liste zurück, die Dateien und Unterverzeichnisse mit klaren Indikatoren zeigt
  - Zeigt Dateien und Verzeichnisse mit klaren Indikatoren (`[FILE]` oder `[DIR]`)
  - Bietet sichere Verzeichnisnavigation mit angemessener Fehlerbehandlung
  - Validiert Pfade und stellt sicher, dass sie absolut sind
  - Nützlich für die Erkundung der Projektstruktur und das Verständnis der Codebase-Organisation

Beide Werkzeuge beinhalten robuste Sicherheitsmaßnahmen:
- Validierung absoluter Pfade zur Verhinderung von Directory Traversal-Angriffen
- Berechtigungsprüfungen zur Gewährleistung angemessener Zugriffsrechte
- Integration mit Secretlint zur Erkennung sensibler Informationen
- Klare Fehlermeldungen für Debugging und Sicherheitsbewusstsein

**Beispiel:**
```typescript
// Datei lesen
const fileContent = await tools.file_system_read_file({
  path: '/absolute/path/to/file.txt'
});

// Verzeichnisinhalt auflisten
const dirContent = await tools.file_system_read_directory({
  path: '/absolute/path/to/directory'
});
```

Diese Werkzeuge sind besonders nützlich, wenn KI-Assistenten:
- Bestimmte Dateien in der Codebase analysieren müssen
- Verzeichnisstrukturen navigieren müssen
- Existenz und Zugänglichkeit von Dateien überprüfen müssen
- Sichere Dateisystemoperationen gewährleisten müssen

## Vorteile der Verwendung von Repomix als MCP-Server

Die Verwendung von Repomix als MCP-Server bietet mehrere Vorteile:

1. **Direkte Integration**: KI-Assistenten können Ihre Codebasis ohne manuelle Dateivorbereitung direkt analysieren.
2. **Effizienter Workflow**: Optimiert den Prozess der Codeanalyse, indem die Notwendigkeit entfällt, Dateien manuell zu generieren und hochzuladen.
3. **Konsistente Ausgabe**: Stellt sicher, dass der KI-Assistent die Codebasis in einem konsistenten, optimierten Format erhält.
4. **Erweiterte Funktionen**: Nutzt alle Funktionen von Repomix wie Code-Komprimierung, Token-Zählung und Sicherheitsprüfungen.

Nach der Konfiguration kann Ihr KI-Assistent die Funktionen von Repomix direkt nutzen, um Codebasen zu analysieren, was Codeanalyse-Workflows effizienter macht.
</file>

<file path="website/client/src/de/guide/output.md">
# Ausgabeformate

Repomix unterstützt drei Ausgabeformate:
- XML (Standard)
- Markdown
- Klartext

## XML-Format

```bash
repomix --style xml
```

Das XML-Format ist für die KI-Verarbeitung optimiert:

::: tip Warum XML?
XML-Tags helfen KI-Modellen wie Claude, Inhalte genauer zu analysieren. Die [Claude-Dokumentation](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags) empfiehlt die Verwendung von XML-Tags für strukturierte Prompts.
:::

```xml
Diese Datei ist eine zusammengeführte Darstellung der gesamten Codebasis...

<file_summary>
(Metadaten und KI-Anweisungen)
</file_summary>

<directory_structure>
src/
  index.ts
  utils/
    helper.ts
</directory_structure>

<files>
<file path="src/index.ts">
// Dateiinhalt hier
</file>
</files>

## Markdown-Format

```bash
repomix --style markdown
```

Markdown bietet lesbare Formatierung:

```markdown
Diese Datei ist eine zusammengeführte Darstellung der gesamten Codebasis...

# Dateizusammenfassung
(Metadaten und KI-Anweisungen)

# Verzeichnisstruktur
```text
src/
  index.ts
  utils/
    helper.ts
```

# Dateien

## Datei: src/index.ts
```typescript
// Dateiinhalt hier
``` 

## Klartext-Format

```bash
repomix --style plain
```

Ausgabestruktur:
```text
Diese Datei ist eine zusammengeführte Darstellung der gesamten Codebasis...

================
Dateizusammenfassung
================
(Metadaten und KI-Anweisungen)

================
Verzeichnisstruktur
================
src/
  index.ts
  utils/
    helper.ts

================
Dateien
================

================
Datei: src/index.ts
================
// Dateiinhalt hier
```
</file>

<file path="website/client/src/de/guide/prompt-examples.md">
# Prompt-Beispiele

## Code-Review

### Architektur-Review
```
Analysieren Sie die Architektur dieser Codebasis:
1. Bewerten Sie die Gesamtstruktur und Muster
2. Identifizieren Sie potenzielle Architekturprobleme
3. Schlagen Sie Verbesserungen für die Skalierbarkeit vor
4. Notieren Sie Bereiche, die Best Practices folgen

Konzentrieren Sie sich auf Wartbarkeit und Modularität.
```

### Sicherheits-Review
```
Führen Sie eine Sicherheitsüberprüfung dieser Codebasis durch:
1. Identifizieren Sie potenzielle Sicherheitslücken
2. Prüfen Sie auf häufige Sicherheits-Anti-Patterns
3. Überprüfen Sie die Fehlerbehandlung und Eingabevalidierung
4. Bewerten Sie die Abhängigkeitssicherheit

Geben Sie konkrete Beispiele und Behebungsschritte an.
```

### Performance-Review
```
Überprüfen Sie die Codebasis auf Leistung:
1. Identifizieren Sie Leistungsengpässe
2. Überprüfen Sie die Ressourcennutzung
3. Überprüfen Sie die algorithmische Effizienz
4. Bewerten Sie Caching-Strategien

Fügen Sie spezifische Optimierungsempfehlungen hinzu.
```

## Dokumentationsgenerierung

### API-Dokumentation
```
Generieren Sie eine umfassende API-Dokumentation:
1. Listen und beschreiben Sie alle öffentlichen Endpunkte
2. Dokumentieren Sie Anfrage-/Antwortformate
3. Fügen Sie Verwendungsbeispiele hinzu
4. Notieren Sie eventuelle Einschränkungen
```

### Entwicklerhandbuch
```
Erstellen Sie ein Entwicklerhandbuch, das Folgendes umfasst:
1. Einrichtungsanweisungen
2. Projektstrukturübersicht
3. Entwicklungsworkflow
4. Testansatz
5. Häufige Fehlerbehebungsschritte
```

### Architektur-Dokumentation
```
Dokumentieren Sie die Systemarchitektur:
1. Überblick auf hoher Ebene
2. Komponenteninteraktionen
3. Datenflussdiagramme
4. Designentscheidungen und Begründung
5. Systembeschränkungen und -grenzen
```

## Analyse und Verbesserung

### Abhängigkeitsanalyse
```
Analysieren Sie die Projektabhängigkeiten:
1. Identifizieren Sie veraltete Pakete
2. Prüfen Sie auf Sicherheitslücken
3. Schlagen Sie alternative Pakete vor
4. Überprüfen Sie Abhängigkeitsnutzungsmuster

Fügen Sie spezifische Upgrade-Empfehlungen hinzu.
```

### Testabdeckung
```
Überprüfen Sie die Testabdeckung:
1. Identifizieren Sie ungetestete Komponenten
2. Schlagen Sie zusätzliche Testfälle vor
3. Überprüfen Sie die Testqualität
4. Empfehlen Sie Teststrategien
```

### Codequalität
```
Bewerten Sie die Codequalität und schlagen Sie Verbesserungen vor:
1. Überprüfen Sie Namenskonventionen
2. Prüfen Sie die Codeorganisation
3. Bewerten Sie die Fehlerbehandlung
4. Überprüfen Sie Kommentierungspraktiken

Geben Sie konkrete Beispiele für gute und problematische Muster an.
```

## Tipps für bessere Ergebnisse

1. **Seien Sie spezifisch**: Formulieren Sie klare Ziele und Bewertungskriterien
2. **Setzen Sie Kontext**: Geben Sie Ihre Rolle und das benötigte Expertiseniveau an
3. **Antwortformat**: Definieren Sie, wie die Antwort strukturiert sein soll
4. **Priorisieren**: Geben Sie an, welche Aspekte am wichtigsten sind

## Modellspezifische Hinweise

### Claude
- Verwenden Sie das XML-Ausgabeformat
- Platzieren Sie wichtige Anweisungen am Ende
- Spezifizieren Sie die Antwortstruktur

### ChatGPT
- Verwenden Sie das Markdown-Format
- Teilen Sie große Codebasen in Abschnitte auf
- Verwenden Sie System-Rollen-Prompts

### Gemini
- Funktioniert mit allen Formaten
- Konzentrieren Sie sich pro Anfrage auf bestimmte Bereiche
- Verwenden Sie schrittweise Analyse
</file>

<file path="website/client/src/de/guide/remote-repository-processing.md">
# Remote-Repository-Verarbeitung

## Grundlegende Verwendung

Öffentliche Repositories verarbeiten:
```bash
# Mit vollständiger URL
repomix --remote https://github.com/user/repo

# Mit GitHub-Kurzform
repomix --remote user/repo
```

## Branch- und Commit-Auswahl

```bash
# Bestimmter Branch
repomix --remote user/repo --remote-branch main

# Tag
repomix --remote user/repo --remote-branch v1.0.0

# Commit-Hash
repomix --remote user/repo --remote-branch 935b695
```

## Voraussetzungen

- Git muss installiert sein
- Internetverbindung
- Lesezugriff auf das Repository

## Ausgabekontrolle

```bash
# Benutzerdefinierter Ausgabeort
repomix --remote user/repo -o custom-output.xml

# Mit XML-Format
repomix --remote user/repo --style xml

# Kommentare entfernen
repomix --remote user/repo --remove-comments
```

## Docker-Verwendung

```bash
# Verarbeitung und Ausgabe in das aktuelle Verzeichnis
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo

# Ausgabe in bestimmtes Verzeichnis
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo
```

## Häufige Probleme

### Zugriffsprobleme
- Stellen Sie sicher, dass das Repository öffentlich ist
- Überprüfen Sie die Git-Installation
- Überprüfen Sie die Internetverbindung

### Große Repositories
- Verwenden Sie `--include`, um bestimmte Pfade auszuwählen
- Aktivieren Sie `--remove-comments`
- Verarbeiten Sie Branches separat
</file>

<file path="website/client/src/de/guide/security.md">
# Sicherheit

## Sicherheitsprüfungsfunktion

Repomix verwendet [Secretlint](https://github.com/secretlint/secretlint) zur Erkennung sensibler Informationen in Ihren Dateien:
- API-Schlüssel
- Zugangstoken
- Anmeldedaten
- Private Schlüssel
- Umgebungsvariablen

## Konfiguration

Sicherheitsprüfungen sind standardmäßig aktiviert.

Deaktivierung über CLI:
```bash
repomix --no-security-check
```

Oder in `repomix.config.json`:
```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

## Sicherheitsmaßnahmen

1. **Ausschluss von Binärdateien**: Binärdateien werden nicht in die Ausgabe aufgenommen
2. **Git-bewusst**: Berücksichtigt `.gitignore`-Muster
3. **Automatische Erkennung**: Sucht nach häufigen Sicherheitsproblemen:
  - AWS-Anmeldedaten
  - Datenbankverbindungszeichenfolgen
  - Authentifizierungstoken
  - Private Schlüssel

## Wenn die Sicherheitsprüfung Probleme findet

Beispielausgabe:
```bash
🔍 Sicherheitsprüfung:
──────────────────
2 verdächtige Datei(en) erkannt und ausgeschlossen:
1. config/credentials.json
  - AWS-Zugriffsschlüssel gefunden
2. .env.local
  - Datenbank-Passwort gefunden
```

## Best Practices

1. Überprüfen Sie die Ausgabe immer vor dem Teilen
2. Verwenden Sie `.repomixignore` für sensible Pfade
3. Lassen Sie Sicherheitsprüfungen aktiviert
4. Entfernen Sie sensible Dateien aus dem Repository

## Melden von Sicherheitsproblemen

Haben Sie eine Sicherheitslücke gefunden? Bitte:
1. Öffnen Sie kein öffentliches Issue
2. E-Mail: koukun0120@gmail.com
3. Oder nutzen Sie [GitHub Security Advisories](https://github.com/yamadashy/repomix/security/advisories/new)
</file>

<file path="website/client/src/de/guide/usage.md">
# Grundlegende Verwendung

## Schnellstart

Packen Sie Ihr gesamtes Repository:
```bash
repomix
```

## Häufige Anwendungsfälle

### Bestimmte Verzeichnisse packen
```bash
repomix path/to/directory
```

### Bestimmte Dateien einschließen
Verwenden Sie [Glob-Muster](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):
```bash
repomix --include "src/**/*.ts,**/*.md"
```

### Dateien ausschließen
```bash
repomix --ignore "**/*.log,tmp/"
```

### Remote-Repositories
```bash
# Mit GitHub-URL
repomix --remote https://github.com/user/repo

# Mit Kurzform
repomix --remote user/repo

# Bestimmter Branch/Tag/Commit
repomix --remote user/repo --remote-branch main
repomix --remote user/repo --remote-branch 935b695
```

### Dateiliste-Eingabe (stdin)

Übergeben Sie Dateipfade über stdin für ultimative Flexibilität:

```bash
# Mit find-Befehl
find src -name "*.ts" -type f | repomix --stdin

# Mit Git für verfolgte Dateien
git ls-files "*.ts" | repomix --stdin

# Mit ls und Glob-Mustern
ls src/**/*.ts | repomix --stdin

# Aus einer Datei mit Dateipfaden
cat file-list.txt | repomix --stdin

# Direkte Eingabe mit echo
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```

Die `--stdin`-Option ermöglicht es Ihnen, eine Liste von Dateipfaden an Repomix zu übertragen und bietet ultimative Flexibilität bei der Auswahl der zu packenden Dateien.

> [!NOTE]
> Bei der Verwendung von `--stdin` können Dateipfade relativ oder absolut angegeben werden, und Repomix übernimmt automatisch die Pfadauflösung und Deduplizierung.

## Ausgabeformate

### XML (Standard)
```bash
repomix --style xml
```

### Markdown
```bash
repomix --style markdown
```

### Klartext
```bash
repomix --style plain
```

## Zusätzliche Optionen

### Kommentare entfernen
```bash
repomix --remove-comments
```

### Zeilennummern anzeigen
```bash
repomix --output-show-line-numbers
```

### In die Zwischenablage kopieren
```bash
repomix --copy
```

### Sicherheitsprüfung deaktivieren
```bash
repomix --no-security-check
```

## Konfiguration

Konfigurationsdatei initialisieren:
```bash
repomix --init
```

Siehe [Konfigurationsleitfaden](/de/guide/configuration) für detaillierte Optionen.
</file>

<file path="website/client/src/de/index.md">
---
layout: home
title: Repomix
titleTemplate: Packen Sie Ihren Codebase in KI-freundliche Formate
aside: false
editLink: false

features:
  - icon: 🤖
    title: KI-Optimiert
    details: Formatiert Ihren Codebase so, dass er für KI leicht zu verstehen und zu verarbeiten ist.

  - icon: ⚙️
    title: Git-Bewusst
    details: Berücksichtigt automatisch Ihre .gitignore-Dateien.

  - icon: 🛡️
    title: Sicherheitsorientiert
    details: Integriert Secretlint für robuste Sicherheitsprüfungen zur Erkennung und Verhinderung der Aufnahme sensibler Informationen.

  - icon: 📊
    title: Token-Zählung
    details: Bietet Token-Zählungen für jede Datei und das gesamte Repository, nützlich für LLM-Kontextgrenzen.

---

<script setup>
import YouTubeVideo from '../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../utils/videos'
</script>

<div class="cli-section">

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## 🏆 Nominierung für die Open Source Awards

Wir fühlen uns geehrt! Repomix wurde in der Kategorie **Powered by AI** für die [JSNation Open Source Awards 2025](https://osawards.com/javascript/) nominiert.

Dies wäre ohne Sie alle, die Repomix nutzen und unterstützen, nicht möglich gewesen. Vielen Dank!

Wenn Repomix Ihnen bei der Analyse oder Paketierung von Codebasen für KI-Tools geholfen hat, würden wir uns über Ihre Stimme in der Kategorie **Powered by AI** freuen.

## Was ist Repomix?

Repomix ist ein leistungsstarkes Tool, das Ihre gesamte Codebasis in eine einzige KI-freundliche Datei paketiert. Ob Sie an Code-Reviews, Refactoring arbeiten oder KI-Unterstützung für Ihr Projekt benötigen, Repomix macht es einfach, den gesamten Repository-Kontext mit KI-Tools zu teilen.

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

## Schnellstart

Sobald Sie mit Repomix eine gepackte Datei (`repomix-output.xml`) erstellt haben, können Sie diese mit einer Aufforderung wie dieser an einen KI-Assistenten (wie ChatGPT, Claude) senden:

```
Diese Datei enthält alle Dateien im Repository in einer Datei zusammengefasst.
Ich möchte den Code refaktorieren, bitte überprüfen Sie ihn zuerst.
```

Die KI wird Ihren gesamten Codebase analysieren und umfassende Einblicke geben:

![Repomix File Usage 1](/images/docs/repomix-file-usage-1.png)

Bei der Diskussion spezifischer Änderungen kann die KI bei der Code-Generierung helfen. Mit Funktionen wie Claudes Artifacts können Sie sogar mehrere voneinander abhängige Dateien erhalten:

![Repomix File Usage 2](/images/docs/repomix-file-usage-2.png)

Viel Spaß beim Programmieren! 🚀

## Verwendung des CLI-Tools {#using-the-cli-tool}

Repomix kann als Kommandozeilen-Tool verwendet werden und bietet leistungsstarke Funktionen und Anpassungsoptionen.

**Das CLI-Tool kann auf private Repositories zugreifen**, da es Ihr lokal installiertes Git verwendet.

### Schnellstart

Sie können Repomix sofort in Ihrem Projektverzeichnis ohne Installation ausprobieren:

```bash
npx repomix
```

Oder installieren Sie es global für wiederholte Verwendung:

```bash
# Installation mit npm
npm install -g repomix

# Alternativ mit yarn
yarn global add repomix

# Alternativ mit bun
bun add -g repomix

# Alternativ mit Homebrew (macOS/Linux)
brew install repomix

# Dann in einem beliebigen Projektverzeichnis ausführen
repomix
```

Das war's! Repomix generiert eine `repomix-output.xml` Datei in Ihrem aktuellen Verzeichnis, die Ihr gesamtes Repository in einem KI-freundlichen Format enthält.

### Verwendung

Um Ihr gesamtes Repository zu packen:

```bash
repomix
```

Um ein bestimmtes Verzeichnis zu packen:

```bash
repomix path/to/directory
```

Um bestimmte Dateien oder Verzeichnisse mit [Glob-Mustern](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax) zu packen:

```bash
repomix --include "src/**/*.ts,**/*.md"
```

Um bestimmte Dateien oder Verzeichnisse auszuschließen:

```bash
repomix --ignore "**/*.log,tmp/"
```

Um ein Remote-Repository zu packen:
```bash
# Kurzform verwenden
npx repomix --remote yamadashy/repomix

# Vollständige URL verwenden (unterstützt Branches und spezifische Pfade)
npx repomix --remote https://github.com/yamadashy/repomix
npx repomix --remote https://github.com/yamadashy/repomix/tree/main

# Commit-URL verwenden
npx repomix --remote https://github.com/yamadashy/repomix/commit/836abcd7335137228ad77feb28655d85712680f1
```

Um eine neue Konfigurationsdatei (`repomix.config.json`) zu initialisieren:

```bash
repomix --init
```

Sobald Sie die gepackte Datei erstellt haben, können Sie sie mit generativen KI-Tools wie Claude, ChatGPT und Gemini verwenden.

#### Docker-Verwendung

Sie können Repomix auch mit Docker ausführen 🐳  
Dies ist nützlich, wenn Sie Repomix in einer isolierten Umgebung ausführen oder Container bevorzugen.

Grundlegende Verwendung (aktuelles Verzeichnis):

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

Um ein bestimmtes Verzeichnis zu packen:
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

Ein Remote-Repository verarbeiten und in ein `output`-Verzeichnis ausgeben:

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### Ausgabeformate

Wählen Sie Ihr bevorzugtes Ausgabeformat:

```bash
# XML-Format (Standard)
repomix --style xml

# Markdown-Format
repomix --style markdown

# Klartext-Format
repomix --style plain
```

### Anpassung

Erstellen Sie eine `repomix.config.json` für dauerhafte Einstellungen:

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

## Power-User-Leitfaden

Repomix bietet leistungsstarke Funktionen für fortgeschrittene Anwendungsfälle. Hier sind einige wichtige Leitfäden für Power-User:

- **[MCP-Server](./guide/mcp-server)** - Model Context Protocol-Integration für KI-Assistenten
- **[GitHub Actions](./guide/github-actions)** - Automatisierung der Codebase-Paketierung in CI/CD-Workflows
- **[Code-Komprimierung](./guide/code-compress)** - Tree-sitter-basierte intelligente Komprimierung (~70% Token-Reduktion)
- **[Als Bibliothek verwenden](./guide/development/using-repomix-as-a-library)** - Repomix in Node.js-Anwendungen integrieren
- **[Benutzerdefinierte Anweisungen](./guide/custom-instructions)** - Benutzerdefinierte Prompts und Anweisungen zu Ausgaben hinzufügen
- **[Sicherheitsfunktionen](./guide/security)** - Eingebaute Secretlint-Integration und Sicherheitsprüfungen
- **[Best Practices](./guide/tips/best-practices)** - KI-Workflows mit bewährten Strategien optimieren

### Weitere Beispiele
::: tip Benötigen Sie weitere Hilfe? 💡
Schauen Sie sich unseren [Leitfaden](./guide/) für detaillierte Anleitungen an oder besuchen Sie das [GitHub-Repository](https://github.com/yamadashy/repomix) für weitere Beispiele und Quellcode.
:::

</div>
</file>

<file path="website/client/src/en/guide/development/index.md">
# Contributing to Repomix

Thank you for your interest in **Repomix**! 🚀 We'd love your help to make it even better. This guide will help you get started with contributing to the project.

## How to Contribute

- **Star the Repository**: Show your support by [starring the repository](https://github.com/yamadashy/repomix)!
- **Create an Issue**: Spot a bug? Have an idea for a new feature? Let us know by [creating an issue](https://github.com/yamadashy/repomix/issues).
- **Submit a Pull Request**: Found something to fix or improve? Jump in and submit a PR!
- **Spread the Word**: Share your experience with Repomix on social media, blogs, or with your tech community.
- **Use Repomix**: The best feedback comes from real-world usage, so feel free to integrate Repomix into your own projects!
- **Sponsor**: Support the development of Repomix by [becoming a sponsor](https://github.com/sponsors/yamadashy).

## Development Setup

### Prerequisites

- Node.js ≥ 18.0.0
- Git
- npm
- Docker (optional, for running the website or containerized development)

### Local Development

To set up Repomix for local development:

```bash
# Clone repository
git clone https://github.com/yamadashy/repomix.git
cd repomix

# Install dependencies
npm install

# Run CLI
npm run repomix
```

### Docker Development

You can also run Repomix using Docker:

```bash
# Build image
docker build -t repomix .

# Run container
docker run -v ./:/app -it --rm repomix
```

### Project Structure

The project is organized into the following directories:

```
src/
├── cli/          # CLI implementation
├── config/       # Configuration handling
├── core/         # Core functionality
│   ├── file/     # File handling
│   ├── metrics/  # Metrics calculation
│   ├── output/   # Output generation
│   ├── security/ # Security checks
├── mcp/          # MCP server integration
└── shared/       # Shared utilities
tests/            # Tests mirroring src/ structure
website/          # Documentation website
├── client/       # Frontend (VitePress)
└── server/       # Backend API
```

## Development Commands

```bash
# Run CLI
npm run repomix

# Run tests
npm run test
npm run test-coverage

# Lint code
npm run lint
```

### Testing

We use [Vitest](https://vitest.dev/) for testing. To run the tests:

```bash
# Run tests
npm run test

# Test coverage
npm run test-coverage

# Linting
npm run lint-biome
npm run lint-ts
npm run lint-secretlint
```

## Code Style

- Use [Biome](https://biomejs.dev/) for linting and formatting
- Dependency injection for testability
- Keep files under 250 lines
- Add tests for new features

We use [Biome](https://biomejs.dev/) for linting and formatting. Please make sure your code follows the style guide by running:

```bash
npm run lint
```

## Pull Request Guidelines

Before submitting a Pull Request, please ensure:

1. Your code passes all tests: Run `npm run test`
2. Your code adheres to our linting standards: Run `npm run lint`
3. You have updated relevant documentation
4. You follow the existing code style

## Website Development

The Repomix website is built with [VitePress](https://vitepress.dev/). To run the website locally:

```bash
# Prerequisites: Docker must be installed on your system

# Start the website development server
npm run website

# Access the website at http://localhost:5173/
```

When updating documentation, you only need to update the English version first. The maintainers will handle translations to other languages.

## Release Process

For maintainers and contributors interested in the release process:

1. Update version
```bash
npm version patch  # or minor/major
```

2. Run tests and build
```bash
npm run test-coverage
npm run build
```

3. Publish
```bash
npm publish
```

New versions are managed by the maintainer. If you think a release is needed, open an issue to discuss it.

## Need Help?

- [Open an issue](https://github.com/yamadashy/repomix/issues)
- [Join Discord](https://discord.gg/wNYzTwZFku)
</file>

<file path="website/client/src/en/guide/development/using-repomix-as-a-library.md">
# Using Repomix as a Library

In addition to using Repomix as a CLI tool, you can integrate its functionality directly into your Node.js applications.

## Installation

Install Repomix as a dependency in your project:

```bash
npm install repomix
```

## Basic Usage

The simplest way to use Repomix is through the `runCli` function, which provides the same functionality as the command-line interface:

```javascript
import { runCli, type CliOptions } from 'repomix';

// Process current directory with custom options
async function packProject() {
  const options = {
    output: 'output.xml',
    style: 'xml',
    compress: true,
    quiet: true
  } as CliOptions;
  
  const result = await runCli(['.'], process.cwd(), options);
  return result.packResult;
}
```

The `result.packResult` contains information about the processed files, including:
- `totalFiles`: Number of files processed
- `totalCharacters`: Total character count
- `totalTokens`: Total token count (useful for LLM context limits)
- `fileCharCounts`: Character counts per file
- `fileTokenCounts`: Token counts per file

## Processing Remote Repositories

You can clone and process a remote repository:

```javascript
import { runCli, type CliOptions } from 'repomix';

// Clone and process a GitHub repo
async function processRemoteRepo(repoUrl) {
  const options = {
    remote: repoUrl,
    output: 'output.xml',
    compress: true
  } as CliOptions;
  
  return await runCli(['.'], process.cwd(), options);
}
```

## Using Core Components

For more control, you can use Repomix's low-level APIs directly:

```javascript
import { searchFiles, collectFiles, processFiles, TokenCounter } from 'repomix';

async function analyzeFiles(directory) {
  // Find and collect files
  const { filePaths } = await searchFiles(directory, { /* config */ });
  const rawFiles = await collectFiles(filePaths, directory);
  const processedFiles = await processFiles(rawFiles, { /* config */ });
  
  // Count tokens
  const tokenCounter = new TokenCounter('o200k_base');
  
  // Return analysis results
  return processedFiles.map(file => ({
    path: file.path,
    tokens: tokenCounter.countTokens(file.content)
  }));
}
```

## Real-World Example

The Repomix website ([repomix.com](https://repomix.com)) uses Repomix as a library to process remote repositories. You can see the implementation in [website/server/src/remoteRepo.ts](https://github.com/yamadashy/repomix/blob/main/website/server/src/remoteRepo.ts).
</file>

<file path="website/client/src/en/guide/tips/best-practices.md">
# AI-Assisted Development Best Practices: From My Experience

While I haven't successfully completed a large-scale project using AI yet, I'd like to share what I've learned so far from my experience working with AI in development.

## Basic Development Approach

When working with AI, attempting to implement all features at once can lead to unexpected issues and project stagnation. That's why it's more effective to start with core functionality and build each feature one at a time, ensuring solid implementation before moving forward.

### The Power of Existing Code

This approach is effective because implementing core functionality allows you to materialize your ideal design and coding style through actual code. The most effective way to communicate your project vision is through code that reflects your standards and preferences.

By starting with core features and ensuring each component works properly before moving on, the entire project maintains consistency, making it easier for AI to generate more appropriate code.

## The Modular Approach

Breaking code into smaller modules is crucial. In my experience, keeping files around 250 lines of code makes it easier to give clear instructions to AI and makes the trial-and-error process more efficient. While token count would be a more accurate metric, line count is more practical for human developers to work with, so we use that as a guideline.

This modularization isn't just about separating frontend, backend, and database components - it's about breaking down functionality at a much finer level. For example, within a single feature, you might separate validation, error handling, and other specific functionalities into distinct modules. Of course, high-level separation is also important, and implementing this modular approach gradually helps maintain clear instructions and enables AI to generate more appropriate code. This approach is effective not just for AI but for human developers as well.

## Ensuring Quality Through Testing

I consider testing to be crucial in AI-assisted development. Tests serve not only as quality assurance measures but also as documentation that clearly demonstrates code intentions. When asking AI to implement new features, existing test code effectively acts as a specification document.

Tests are also an excellent tool for validating the correctness of AI-generated code. For instance, when having AI implement new functionality for a module, writing test cases beforehand allows you to objectively evaluate whether the generated code behaves as expected. This aligns well with Test-Driven Development (TDD) principles and is particularly effective when collaborating with AI.

## Balancing Planning and Implementation

Before implementing large-scale features, I recommend first discussing the plan with AI. Organizing requirements and considering architecture leads to smoother implementation. A good practice is to compile requirements first, then move to a separate chat session for implementation work.

It's essential to have human review of AI output and make adjustments as needed. While the quality of AI-generated code is generally moderate, it still accelerates development compared to writing everything from scratch.

## Conclusion

By following these practices, you can leverage AI's strengths while building a consistent, high-quality codebase. Even as your project grows in size, each component remains well-defined and manageable.
</file>

<file path="website/client/src/en/guide/code-compress.md">
# Code Compression

Code compression is a powerful feature that intelligently extracts essential code structures while removing implementation details. This is particularly useful for reducing token count while maintaining important structural information about your codebase.

> [!NOTE]  
> This is an experimental feature that we'll be actively improving based on user feedback and real-world usage

## Basic Usage

Enable code compression using the `--compress` flag:

```bash
repomix --compress
```

You can also use it with remote repositories:

```bash
repomix --remote user/repo --compress
```

## How It Works

The compression algorithm processes code using tree-sitter parsing to extract and preserve essential structural elements while removing implementation details.

The compression preserves:
- Function and method signatures
- Interface and type definitions
- Class structures and properties
- Important structural elements

While removing:
- Function and method implementations
- Loop and conditional logic details
- Internal variable declarations
- Implementation-specific code

### Example

Original TypeScript code:

```typescript
import { ShoppingItem } from './shopping-item';

/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
  let total = 0;
  for (const item of items) {
    total += item.price * item.quantity;
  }
  return total;
}

// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

After compression:

```typescript
import { ShoppingItem } from './shopping-item';
⋮----
/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
⋮----
// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

## Configuration

You can enable compression in your configuration file:

```json
{
  "output": {
    "compress": true
  }
}
```

## Use Cases

Code compression is particularly useful when:
- Analyzing code structure and architecture
- Reducing token count for LLM processing
- Creating high-level documentation
- Understanding code patterns and signatures
- Sharing API and interface designs

## Related Options

You can combine compression with other options:
- `--remove-comments`: Remove code comments
- `--remove-empty-lines`: Remove empty lines
- `--output-show-line-numbers`: Add line numbers to output
</file>

<file path="website/client/src/en/guide/command-line-options.md">
# Command Line Options

## Basic Options
- `-v, --version`: Show tool version

## Output Options
- `-o, --output <file>`: Output file name (default: `repomix-output.txt`)
- `--stdout`: Output to stdout instead of writing to a file (cannot be used with `--output` option)
- `--style <type>`: Output style (`plain`, `xml`, `markdown`) (default: `xml`)
- `--parsable-style`: Enable parsable output based on the chosen style schema (default: `false`)
- `--compress`: Perform intelligent code extraction, focusing on essential function and class signatures while removing implementation details. For more details and examples, see [Code Compression Guide](code-compress).
- `--output-show-line-numbers`: Add line numbers (default: `false`)
- `--copy`: Copy to clipboard (default: `false`)
- `--no-file-summary`: Disable file summary (default: `true`)
- `--no-directory-structure`: Disable directory structure (default: `true`)
- `--no-files`: Disable files content output (metadata-only mode) (default: `true`)
- `--remove-comments`: Remove comments (default: `false`)
- `--remove-empty-lines`: Remove empty lines (default: `false`)
- `--header-text <text>`: Custom text to include in the file header
- `--instruction-file-path <path>`: Path to a file containing detailed custom instructions
- `--include-empty-directories`: Include empty directories in the output (default: `false`)
- `--include-diffs`: Include git diffs in the output (includes both work tree and staged changes separately) (default: `false`)
- `--no-git-sort-by-changes`: Disable sorting files by git change count (default: `true`)

## Filter Options
- `--include <patterns>`: Include patterns (comma-separated)
- `-i, --ignore <patterns>`: Ignore patterns (comma-separated)
- `--stdin`: Read file paths from stdin instead of discovering files automatically
- `--no-gitignore`: Disable .gitignore file usage
- `--no-default-patterns`: Disable default patterns

## Remote Repository Options
- `--remote <url>`: Process remote repository
- `--remote-branch <name>`: Specify the remote branch name, tag, or commit hash (defaults to repository default branch)

## Configuration Options
- `-c, --config <path>`: Custom config file path
- `--init`: Create config file
- `--global`: Use global config

## Security Options
- `--no-security-check`: Disable security check (default: `true`)

## Token Count Options
- `--token-count-encoding <encoding>`: Specify token count encoding (e.g., `o200k_base`, `cl100k_base`) (default: `o200k_base`)

## Other Options
- `--top-files-len <number>`: Number of top files to show (default: `5`)
- `--verbose`: Enable verbose logging
- `--quiet`: Disable all output to stdout

## Examples

```bash
# Basic usage
repomix

# Custom output
repomix -o output.xml --style xml

# Output to stdout
repomix --stdout > custom-output.txt

# Send output to stdout, then pipe into another command (for example, simonw/llm)
repomix --stdout | llm "Please explain what this code does."

# Custom output with compression
repomix --compress

# Process specific files
repomix --include "src/**/*.ts" --ignore "**/*.test.ts"

# Remote repository with branch
repomix --remote https://github.com/user/repo/tree/main

# Remote repository with commit
repomix --remote https://github.com/user/repo/commit/836abcd7335137228ad77feb28655d85712680f1

# Remote repository with shorthand
repomix --remote user/repo

# Using stdin for file list
find src -name "*.ts" -type f | repomix --stdin
git ls-files "*.js" | repomix --stdin
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```
</file>

<file path="website/client/src/en/guide/comment-removal.md">
# Comment Removal

Repomix can automatically remove comments from your codebase when generating the output file. This can help reduce noise and focus on the actual code.

## Usage

To enable comment removal, set the `removeComments` option to `true` in your `repomix.config.json`:

```json
{
  "output": {
    "removeComments": true
  }
}
```

## Supported Languages

Repomix supports comment removal for a wide range of programming languages, including:

- JavaScript/TypeScript (`//`, `/* */`)
- Python (`#`, `"""`, `'''`)
- Java (`//`, `/* */`)
- C/C++ (`//`, `/* */`)
- HTML (`<!-- -->`)
- CSS (`/* */`)
- And many more...

## Example

Given the following JavaScript code:

```javascript
// This is a single-line comment
function test() {
  /* This is a
     multi-line comment */
  return true;
}
```

With comment removal enabled, the output will be:

```javascript
function test() {
  return true;
}
```

## Notes

- Comment removal is performed before other processing steps, such as line number addition.
- Some comments, such as JSDoc comments, may be preserved depending on the language and context.
</file>

<file path="website/client/src/en/guide/configuration.md">
# Configuration

Repomix can be configured using a configuration file (`repomix.config.json`) or command-line options. The configuration file allows you to customize various aspects of how Repomix processes and outputs your codebase.

## Quick Start

Create a configuration file in your project directory:
```bash
repomix --init
```

This will create a `repomix.config.json` file with default settings. You can also create a global configuration file that will be used as a fallback when no local configuration is found:

```bash
repomix --init --global
```

## Configuration Options

| Option                           | Description                                                                                                                  | Default                |
|----------------------------------|------------------------------------------------------------------------------------------------------------------------------|------------------------|
| `input.maxFileSize`              | Maximum file size in bytes to process. Files larger than this will be skipped. Useful for excluding large binary files or data files | `50000000`            |
| `output.filePath`                | The name of the output file. Supports XML, Markdown, and plain text formats                                                   | `"repomix-output.xml"` |
| `output.style`                   | The style of the output (`xml`, `markdown`, `plain`). Each format has its own advantages for different AI tools              | `"xml"`                |
| `output.parsableStyle`           | Whether to escape the output based on the chosen style schema. Enables better parsing but may increase token count           | `false`                |
| `output.compress`                | Whether to perform intelligent code extraction using Tree-sitter to reduce token count while preserving structure             | `false`                |
| `output.headerText`              | Custom text to include in the file header. Useful for providing context or instructions for AI tools                         | `null`                 |
| `output.instructionFilePath`     | Path to a file containing detailed custom instructions for AI processing                                                     | `null`                 |
| `output.fileSummary`             | Whether to include a summary section at the beginning showing file counts, sizes, and other metrics                          | `true`                 |
| `output.directoryStructure`      | Whether to include the directory structure in the output. Helps AI understand the project organization                       | `true`                 |
| `output.files`                   | Whether to include file contents in the output. Set to false to only include structure and metadata                          | `true`                 |
| `output.removeComments`          | Whether to remove comments from supported file types. Can reduce noise and token count                                       | `false`                |
| `output.removeEmptyLines`        | Whether to remove empty lines from the output to reduce token count                                                          | `false`                |
| `output.showLineNumbers`         | Whether to add line numbers to each line. Helpful for referencing specific parts of code                                     | `false`                |
| `output.copyToClipboard`         | Whether to copy the output to system clipboard in addition to saving the file                                                | `false`                |
| `output.topFilesLength`          | Number of top files to display in the summary. If set to 0, no summary will be displayed                                     | `5`                    |
| `output.includeEmptyDirectories` | Whether to include empty directories in the repository structure                                                             | `false`                |
| `output.git.sortByChanges`       | Whether to sort files by git change count. Files with more changes appear at the bottom                                      | `true`                 |
| `output.git.sortByChangesMaxCommits` | Maximum number of commits to analyze for git changes. Limits the history depth for performance                           | `100`                  |
| `output.git.includeDiffs`        | Whether to include git diffs in the output. Shows both work tree and staged changes separately                               | `false`                |
| `include`                        | Patterns of files to include using [glob patterns](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)    | `[]`                   |
| `ignore.useGitignore`            | Whether to use patterns from the project's `.gitignore` file                                                                 | `true`                 |
| `ignore.useDefaultPatterns`      | Whether to use default ignore patterns (node_modules, .git, etc.)                                                           | `true`                 |
| `ignore.customPatterns`          | Additional patterns to ignore using [glob patterns](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)   | `[]`                   |
| `security.enableSecurityCheck`   | Whether to perform security checks using Secretlint to detect sensitive information                                          | `true`                 |
| `tokenCount.encoding`            | Token count encoding used by OpenAI's [tiktoken](https://github.com/openai/tiktoken) tokenizer. Use `o200k_base` for GPT-4o, `cl100k_base` for GPT-4/3.5. See [tiktoken model.py](https://github.com/openai/tiktoken/blob/main/tiktoken/model.py#L24) for details. | `"o200k_base"`         |

The configuration file supports [JSON5](https://json5.org/) syntax, which allows:
- Comments (both single-line and multi-line)
- Trailing commas in objects and arrays
- Unquoted property names
- More relaxed string syntax

## Schema Validation

You can enable schema validation for your configuration file by adding the `$schema` property:

```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "output": {
    "filePath": "repomix-output.md",
    "style": "markdown"
  }
}
```

This provides auto-completion and validation in editors that support JSON schema.

## Example Configuration File

Here's an example of a complete configuration file (`repomix.config.json`):

```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 50000000
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "compress": false,
    "headerText": "Custom header information for the packed file.",
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "includeEmptyDirectories": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false
    }
  },
  "include": ["**/*"],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    // Patterns can also be specified in .repomixignore
    "customPatterns": [
      "additional-folder",
      "**/*.log"
    ],
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
```

## Configuration File Locations

Repomix looks for configuration files in the following order:
1. Local configuration file (`repomix.config.json`) in the current directory
2. Global configuration file:
   - Windows: `%LOCALAPPDATA%\Repomix\repomix.config.json`
   - macOS/Linux: `~/.config/repomix/repomix.config.json`

Command-line options take precedence over configuration file settings.

## Ignore Patterns

Repomix provides multiple ways to specify which files should be ignored. The patterns are processed in the following priority order:

1. CLI options (`--ignore`)
2. `.repomixignore` file in the project directory
3. `.gitignore` and `.git/info/exclude` (if `ignore.useGitignore` is true)
4. Default patterns (if `ignore.useDefaultPatterns` is true)

Example of `.repomixignore`:
```text
# Cache directories
.cache/
tmp/

# Build outputs
dist/
build/

# Logs
*.log
```

## Default Ignore Patterns

When `ignore.useDefaultPatterns` is true, Repomix automatically ignores common patterns:
```text
node_modules/**
.git/**
coverage/**
dist/**
```

For the complete list, see [defaultIgnore.ts](https://github.com/yamadashy/repomix/blob/main/src/config/defaultIgnore.ts)

## Advanced Features

### Code Compression

The code compression feature, enabled with `output.compress: true`, uses [Tree-sitter](https://github.com/tree-sitter/tree-sitter) to intelligently extract essential code structures while removing implementation details. This helps reduce token count while maintaining important structural information.

Key benefits:
- Reduces token count significantly
- Preserves class and function signatures
- Maintains imports and exports
- Keeps type definitions and interfaces
- Removes function bodies and implementation details

For more details and examples, see the [Code Compression Guide](code-compress).

### Git Integration

The `output.git` configuration provides powerful Git-aware features:

- `sortByChanges`: When true, files are sorted by the number of Git changes (commits that modified the file). Files with more changes appear at the bottom of the output. This helps prioritize more actively developed files. Default: `true`
- `sortByChangesMaxCommits`: The maximum number of commits to analyze when counting file changes. Default: `100`
- `includeDiffs`: When true, includes Git differences in the output (includes both work tree and staged changes separately). This allows the reader to see pending changes in the repository. Default: `false`

Example configuration:
```json
{
  "output": {
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": true
    }
  }
}
```

### Security Checks

When `security.enableSecurityCheck` is enabled, Repomix uses [Secretlint](https://github.com/secretlint/secretlint) to detect sensitive information in your codebase before including it in the output. This helps prevent accidental exposure of:

- API keys
- Access tokens
- Private keys
- Passwords
- Other sensitive credentials

### Comment Removal

When `output.removeComments` is set to `true`, comments are removed from supported file types to reduce output size and focus on essential code content. This can be particularly useful when:

- Working with heavily documented code
- Trying to reduce token count
- Focusing on code structure and logic

For supported languages and detailed examples, see the [Comment Removal Guide](comment-removal).
</file>

<file path="website/client/src/en/guide/custom-instructions.md">
# Custom Instructions

Repomix allows you to provide custom instructions that will be included in the output file. This can be useful for adding context or specific guidelines for AI systems processing the repository.

## Usage

To include a custom instruction, create a markdown file (e.g., `repomix-instruction.md`) in the root of your repository. Then, specify the path to this file in your `repomix.config.json`:

```json
{
  "output": {
    "instructionFilePath": "repomix-instruction.md"
  }
}
```

The content of this file will be included in the output under the "Instruction" section.

## Example

```markdown
# Repository Instructions

This repository contains the source code for the Repomix tool. Please follow these guidelines when analyzing the code:

1. Focus on the core functionality in the `src/core` directory.
2. Pay special attention to the security checks in `src/core/security`.
3. Ignore any files in the `tests` directory.
```

This will result in the following section in the output:

```xml
<instruction>
# Repository Instructions

This repository contains the source code for the Repomix tool. Please follow these guidelines when analyzing the code:

1. Focus on the core functionality in the `src/core` directory.
2. Pay special attention to the security checks in `src/core/security`.
3. Ignore any files in the `tests` directory.
</instruction>
```
</file>

<file path="website/client/src/en/guide/github-actions.md">
# Using Repomix with GitHub Actions

You can automate the process of packing your codebase for AI analysis by integrating Repomix into your GitHub Actions workflows. This is useful for continuous integration (CI), code review, or preparing your repository for LLM-based tools.

## Basic Usage

Add the following step to your workflow YAML to pack your repository:

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.xml
```

## Using Different Output Formats

You can specify different output formats using the `style` parameter (the default is `xml`):

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.md
    style: markdown
```

## Packing Multiple Directories with Compression

You can specify multiple directories, include/exclude patterns, and enable smart compression:

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src tests
    include: "**/*.ts,**/*.md"
    ignore: "**/*.test.ts"
    output: repomix-output.xml
    compress: true
```

## Uploading the Output as an Artifact

To make the packed file available for later workflow steps or for download, upload it as an artifact:

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src
    output: repomix-output.xml
    compress: true

- name: Upload Repomix output
  uses: actions/upload-artifact@v4
  with:
    name: repomix-output
    path: repomix-output.xml
```

## Action Inputs

| Name              | Description                                 | Default           |
|-------------------|---------------------------------------------|-------------------|
| `directories`     | Space-separated list of directories to pack | `.`               |
| `include`         | Comma-separated glob patterns to include    | `""`             |
| `ignore`          | Comma-separated glob patterns to ignore     | `""`             |
| `output`          | Output file path                            | `repomix-output.xml`     |
| `compress`        | Enable smart compression                    | `true`            |
| `style`           | Output style (xml, markdown, plain)         | `xml`             |
| `additional-args` | Extra CLI arguments for repomix             | `""`             |
| `repomix-version` | Version of the npm package to install       | `latest`          |

## Action Outputs

| Name          | Description                        |
|---------------|------------------------------------|
| `output_file` | Path to the generated output file   |

## Example: Full Workflow

Here is a complete example of a GitHub Actions workflow using Repomix:

```yaml
name: Pack repository with Repomix

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  pack-repo:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Pack repository with Repomix
        uses: yamadashy/repomix/.github/actions/repomix@main
        with:
          output: repomix-output.xml

      - name: Upload Repomix output
        uses: actions/upload-artifact@v4
        with:
          name: repomix-output.xml
          path: repomix-output.xml
          retention-days: 30
```

See the [complete workflow example](https://github.com/yamadashy/repomix/blob/main/.github/workflows/pack-repository.yml).
</file>

<file path="website/client/src/en/guide/index.md">
# Getting Started with Repomix

<script setup>
import HomeBadges from '../../../components/HomeBadges.vue'
import YouTubeVideo from '../../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../../utils/videos'
</script>

Repomix is a tool that packs your entire repository into a single, AI-friendly file. It's designed to help you feed your codebase to Large Language Models (LLMs) like ChatGPT, DeepSeek, Perplexity, Gemini, Gemma, Llama, Grok, and more.

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

<HomeBadges />

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## Quick Start

Run this command in your project directory:

```bash
npx repomix
```

That's it! You'll find a `repomix-output.xml` file containing your entire repository in an AI-friendly format.

You can then send this file to an AI assistant with a prompt like:

```
This file contains all the files in the repository combined into one.
I want to refactor the code, so please review it first.
```

The AI will analyze your entire codebase and provide comprehensive insights:

![Repomix File Usage 1](/images/docs/repomix-file-usage-1.png)

When discussing specific changes, the AI can help generate code. With features like Claude's Artifacts, you can even receive multiple interdependent files:

![Repomix File Usage 2](/images/docs/repomix-file-usage-2.png)

Happy coding! 🚀

## Core Features

- **AI-Optimized Output**: Formats your codebase for easy AI processing
- **Token Counting**: Tracks token usage for LLM context limits
- **Git-Aware**: Respects your `.gitignore` and `.git/info/exclude` files
- **Security-Focused**: Detects sensitive information
- **Multiple Output Formats**: Choose between plain text, XML, or Markdown

## What's Next?

- [Installation Guide](installation.md): Different ways to install Repomix
- [Usage Guide](usage.md): Learn about basic and advanced features
- [Configuration](configuration.md): Customize Repomix for your needs
- [Security Features](security.md): Learn about security checks

## Community

Join our [Discord community](https://discord.gg/wNYzTwZFku) for:
- Getting help with Repomix
- Sharing your experiences
- Suggesting new features
- Connecting with other users

## Support

Found a bug or need help?
- [Open an issue on GitHub](https://github.com/yamadashy/repomix/issues)
- Join our Discord server
- Check the [documentation](https://repomix.com)
</file>

<file path="website/client/src/en/guide/installation.md">
# Installation

## Using npx (No Installation Required)

```bash
npx repomix
```

## Global Installation

### npm
```bash
npm install -g repomix
```

### Yarn
```bash
yarn global add repomix
```

### Bun
```bash
bun add -g repomix
```

### Homebrew (macOS/Linux)
```bash
brew install repomix
```

## Docker Installation

Pull and run the Docker image:

```bash
# Current directory
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix

# Specific directory
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory

# Remote repository
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote yamadashy/repomix
```

## VSCode Extension

Run Repomix directly in VSCode with the community-maintained [Repomix Runner](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner) extension.

Features:
- Pack any folder with just a few clicks
- Choose between file or content mode for copying
- Automatic cleanup of output files
- Works with repomix.config.json

Install it from the [VSCode Marketplace](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner).

## Browser Extension

Get instant access to Repomix directly from any GitHub repository! Our Chrome extension adds a convenient "Repomix" button to GitHub repository pages.

![Repomix Browser Extension](/images/docs/browser-extension.png)

### Install
- Chrome Extension: [Repomix - Chrome Web Store](https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa)
- Firefox Add-on: [Repomix - Firefox Add-ons](https://addons.mozilla.org/firefox/addon/repomix/)

### Features
- One-click access to Repomix for any GitHub repository
- More exciting features coming soon!

## System Requirements

- Node.js: ≥ 18.0.0
- Git: Required for remote repository processing

## Verification

After installation, verify that Repomix is working:

```bash
repomix --version
repomix --help
```
</file>

<file path="website/client/src/en/guide/mcp-server.md">
# MCP Server

Repomix supports the [Model Context Protocol (MCP)](https://modelcontextprotocol.io), allowing AI assistants to directly interact with your codebase. When run as an MCP server, Repomix provides tools that enable AI assistants to package local or remote repositories for analysis without requiring manual file preparation.

> [!NOTE]  
> This is an experimental feature that we'll be actively improving based on user feedback and real-world usage

## Running Repomix as an MCP Server

To run Repomix as an MCP server, use the `--mcp` flag:

```bash
repomix --mcp
```

This starts Repomix in MCP server mode, making it available for AI assistants that support the Model Context Protocol.

## Configuring MCP Servers

To use Repomix as an MCP server with AI assistants like Claude, you need to configure the MCP settings:

### For VS Code

You can install the Repomix MCP server in VS Code using one of these methods:

1. **Using the Install Badge:**

  [![Install in VS Code](https://img.shields.io/badge/VS_Code-VS_Code?style=flat-square&label=Install%20Server&color=0098FF)](vscode:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)<br>
  [![Install in VS Code Insiders](https://img.shields.io/badge/VS_Code_Insiders-VS_Code_Insiders?style=flat-square&label=Install%20Server&color=24bfa5)](vscode-insiders:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)

2. **Using the Command Line:**

  ```bash
  code --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

  For VS Code Insiders:
  ```bash
  code-insiders --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

### For Cline (VS Code extension)

Edit the `cline_mcp_settings.json` file:

```json
{
  "mcpServers": {
    "repomix": {
      "command": "npx",
      "args": [
        "-y",
        "repomix",
        "--mcp"
      ]
    }
  }
}
```

### For Cursor

In Cursor, add a new MCP server from `Cursor Settings` > `MCP` > `+ Add new global MCP server` with a configuration similar to Cline.

### For Claude Desktop

Edit the `claude_desktop_config.json` file with similar configuration to Cline's config.

### For Claude Code

Configure Repomix as an MCP server in [Claude Code](https://docs.anthropic.com/en/docs/claude-code/overview) using the following command:

```bash
claude mcp add repomix -- npx -y repomix --mcp
```

### Using Docker instead of npx

Instead of using npx, you can also use Docker to run Repomix as an MCP server:

```json
{
  "mcpServers": {
    "repomix-docker": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "ghcr.io/yamadashy/repomix",
        "--mcp"
      ]
    }
  }
}
```

## Available MCP Tools

When running as an MCP server, Repomix provides the following tools:

### pack_codebase

This tool packages a local code directory into a consolidated XML file for AI analysis. It analyzes the codebase structure, extracts relevant code content, and generates a comprehensive report including metrics, file tree, and formatted code content.

**Parameters:**
- `directory`: (Required) Absolute path to the directory to pack
- `compress`: (Optional, default: false) Enable Tree-sitter compression to extract essential code signatures and structure while removing implementation details. Reduces token usage by ~70% while preserving semantic meaning. Generally not needed since grep_repomix_output allows incremental content retrieval. Use only when you specifically need the entire codebase content for large repositories.
- `includePatterns`: (Optional) Specify files to include using fast-glob patterns. Multiple patterns can be comma-separated (e.g., "**/*.{js,ts}", "src/**,docs/**"). Only matching files will be processed.
- `ignorePatterns`: (Optional) Specify additional files to exclude using fast-glob patterns. Multiple patterns can be comma-separated (e.g., "test/**,*.spec.js", "node_modules/**,dist/**"). These patterns supplement .gitignore and built-in exclusions.
- `topFilesLength`: (Optional, default: 10) Number of largest files by size to display in the metrics summary for codebase analysis.

**Example:**
```json
{
  "directory": "/path/to/your/project",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### pack_remote_repository

This tool fetches, clones, and packages a GitHub repository into a consolidated XML file for AI analysis. It automatically clones the remote repository, analyzes its structure, and generates a comprehensive report.

**Parameters:**
- `remote`: (Required) GitHub repository URL or user/repo format (e.g., "yamadashy/repomix", "https://github.com/user/repo", or "https://github.com/user/repo/tree/branch")
- `compress`: (Optional, default: false) Enable Tree-sitter compression to extract essential code signatures and structure while removing implementation details. Reduces token usage by ~70% while preserving semantic meaning. Generally not needed since grep_repomix_output allows incremental content retrieval. Use only when you specifically need the entire codebase content for large repositories.
- `includePatterns`: (Optional) Specify files to include using fast-glob patterns. Multiple patterns can be comma-separated (e.g., "**/*.{js,ts}", "src/**,docs/**"). Only matching files will be processed.
- `ignorePatterns`: (Optional) Specify additional files to exclude using fast-glob patterns. Multiple patterns can be comma-separated (e.g., "test/**,*.spec.js", "node_modules/**,dist/**"). These patterns supplement .gitignore and built-in exclusions.
- `topFilesLength`: (Optional, default: 10) Number of largest files by size to display in the metrics summary for codebase analysis.

**Example:**
```json
{
  "remote": "yamadashy/repomix",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### read_repomix_output

This tool reads the contents of a Repomix-generated output file. Supports partial reading with line range specification for large files. This tool is designed for environments where direct file system access is limited.

**Parameters:**
- `outputId`: (Required) ID of the Repomix output file to read
- `startLine`: (Optional) Starting line number (1-based, inclusive). If not specified, reads from beginning.
- `endLine`: (Optional) Ending line number (1-based, inclusive). If not specified, reads to end.

**Features:**
- Specifically designed for web-based environments or sandboxed applications
- Retrieves the content of previously generated outputs using their ID
- Provides secure access to packed codebase without requiring file system access
- Supports partial reading for large files

**Example:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "startLine": 100,
  "endLine": 200
}
```

### grep_repomix_output

This tool searches for patterns in a Repomix output file using grep-like functionality with JavaScript RegExp syntax. Returns matching lines with optional context lines around matches.

**Parameters:**
- `outputId`: (Required) ID of the Repomix output file to search
- `pattern`: (Required) Search pattern (JavaScript RegExp regular expression syntax)
- `contextLines`: (Optional, default: 0) Number of context lines to show before and after each match. Overridden by beforeLines/afterLines if specified.
- `beforeLines`: (Optional) Number of context lines to show before each match (like grep -B). Takes precedence over contextLines.
- `afterLines`: (Optional) Number of context lines to show after each match (like grep -A). Takes precedence over contextLines.
- `ignoreCase`: (Optional, default: false) Perform case-insensitive matching

**Features:**
- Uses JavaScript RegExp syntax for powerful pattern matching
- Supports context lines for better understanding of matches
- Allows separate control of before/after context lines
- Case-sensitive and case-insensitive search options

**Example:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "pattern": "function\\s+\\w+\\(",
  "contextLines": 3,
  "ignoreCase": false
}
```

### file_system_read_file and file_system_read_directory

Repomix's MCP server provides two file system tools that allow AI assistants to safely interact with the local file system:

1. `file_system_read_file`
  - Reads file contents from the local file system using absolute paths
  - Includes built-in security validation to detect and prevent access to files containing sensitive information
  - Implements security validation using [Secretlint](https://github.com/secretlint/secretlint)
  - Prevents access to files containing sensitive information (API keys, passwords, secrets)
  - Validates absolute paths to prevent directory traversal attacks
  - Returns formatted content with clear error messages for invalid paths or security issues

2. `file_system_read_directory`
  - Lists the contents of a directory using an absolute path
  - Returns a formatted list showing files and subdirectories with clear indicators
  - Shows both files and directories with clear indicators (`[FILE]` or `[DIR]`)
  - Provides safe directory traversal with proper error handling
  - Validates paths and ensures they are absolute
  - Useful for exploring project structure and understanding codebase organization

Both tools incorporate robust security measures:
- Absolute path validation to prevent directory traversal attacks
- Permission checks to ensure proper access rights
- Integration with Secretlint for sensitive information detection
- Clear error messaging for better debugging and security awareness

**Example:**
```typescript
// Reading a file
const fileContent = await tools.file_system_read_file({
  path: '/absolute/path/to/file.txt'
});

// Listing directory contents
const dirContent = await tools.file_system_read_directory({
  path: '/absolute/path/to/directory'
});
```

These tools are particularly useful when AI assistants need to:
- Analyze specific files in the codebase
- Navigate directory structures
- Verify file existence and accessibility
- Ensure secure file system operations

## Benefits of Using Repomix as an MCP Server

Using Repomix as an MCP server offers several advantages:

1. **Direct Integration**: AI assistants can directly analyze your codebase without manual file preparation.
2. **Efficient Workflow**: Streamlines the process of code analysis by eliminating the need to manually generate and upload files.
3. **Consistent Output**: Ensures that the AI assistant receives the codebase in a consistent, optimized format.
4. **Advanced Features**: Leverages all of Repomix's features like code compression, token counting, and security checks.

Once configured, your AI assistant can directly use Repomix's capabilities to analyze codebases, making code analysis workflows more efficient.
</file>

<file path="website/client/src/en/guide/output.md">
# Output Formats

Repomix supports three output formats:
- XML (default)
- Markdown
- Plain Text 

## XML Format

```bash
repomix --style xml
```

XML format is optimized for AI processing:

```xml
This file is a merged representation of the entire codebase...

<file_summary>
(Metadata and AI instructions)
</file_summary>

<directory_structure>
src/
  index.ts
  utils/
    helper.ts
</directory_structure>

<files>
<file path="src/index.ts">
// File contents here
</file>
</files>
```

::: tip Why XML?
XML tags help AI models like Claude parse content more accurately. [Claude Documentation](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags) recommends using XML tags for structured prompts.
:::

## Markdown Format

```bash
repomix --style markdown
```

Markdown provides readable formatting:

```markdown
This file is a merged representation of the entire codebase...

# File Summary
(Metadata and AI instructions)

# Directory Structure
```
src/
index.ts
utils/
helper.ts
```

# Files

## File: src/index.ts
```typescript
// File contents here
```
```

## Usage with AI Models

Each format works well with AI models, but consider:
- Use XML for Claude (best parsing accuracy)
- Use Markdown for general readability
- Use Plain Text for simplicity and universal compatibility

## Customization

Set default format in `repomix.config.json`:
```json
{
  "output": {
    "style": "xml",
    "filePath": "output.xml"
  }
}
```

## Plain Text Format

```bash
repomix --style plain
```

Output structure:
```text
This file is a merged representation of the entire codebase...

================
File Summary
================
(Metadata and AI instructions)

================
Directory Structure
================
src/
  index.ts
  utils/
    helper.ts

================
Files
================

================
File: src/index.ts
================
// File contents here
```
</file>

<file path="website/client/src/en/guide/prompt-examples.md">
# Prompt Examples

## Code Review

### Architecture Review
```
Analyze this codebase's architecture:
1. Evaluate the overall structure and patterns
2. Identify potential architectural issues
3. Suggest improvements for scalability
4. Note areas that follow best practices

Focus on maintainability and modularity.
```

### Security Review
```
Perform a security review of this codebase:
1. Identify potential security vulnerabilities
2. Check for common security anti-patterns
3. Review error handling and input validation
4. Assess dependency security

Provide specific examples and remediation steps.
```

### Performance Review
```
Review the codebase for performance:
1. Identify performance bottlenecks
2. Check resource utilization
3. Review algorithmic efficiency
4. Assess caching strategies

Include specific optimization recommendations.
```

## Documentation Generation

### API Documentation
```
Generate comprehensive API documentation:
1. List and describe all public endpoints
2. Document request/response formats
3. Include usage examples
4. Note any limitations or constraints
```

### Developer Guide
```
Create a developer guide covering:
1. Setup instructions
2. Project structure overview
3. Development workflow
4. Testing approach
5. Common troubleshooting steps
```

### Architecture Documentation
```
Document the system architecture:
1. High-level overview
2. Component interactions
3. Data flow diagrams
4. Design decisions and rationale
5. System constraints and limitations
```

## Analysis and Improvement

### Dependency Analysis
```
Analyze the project dependencies:
1. Identify outdated packages
2. Check for security vulnerabilities
3. Suggest alternative packages
4. Review dependency usage patterns

Include specific upgrade recommendations.
```

### Test Coverage
```
Review the test coverage:
1. Identify untested components
2. Suggest additional test cases
3. Review test quality
4. Recommend testing strategies
```

### Code Quality
```
Assess code quality and suggest improvements:
1. Review naming conventions
2. Check code organization
3. Evaluate error handling
4. Review commenting practices

Provide specific examples of good and problematic patterns.
```

## Tips for Better Results

1. **Be Specific**: Include clear objectives and evaluation criteria
2. **Set Context**: Specify your role and expertise level needed
3. **Request Format**: Define how you want the response structured
4. **Prioritize**: Indicate which aspects are most important

## Model-Specific Notes

### Claude
- Use XML output format
- Place important instructions at the end
- Specify response structure

### ChatGPT
- Use Markdown format
- Break large codebases into sections
- Include system role prompts

### Gemini
- Works with all formats
- Focus on specific areas per request
- Use step-by-step analysis
</file>

<file path="website/client/src/en/guide/remote-repository-processing.md">
# Remote Repository Processing

## Basic Usage

Process public repositories:
```bash
# Using full URL
repomix --remote https://github.com/user/repo

# Using GitHub shorthand
repomix --remote user/repo
```

## Branch and Commit Selection

```bash
# Specific branch
repomix --remote user/repo --remote-branch main

# Tag
repomix --remote user/repo --remote-branch v1.0.0

# Commit hash
repomix --remote user/repo --remote-branch 935b695
```

## Requirements

- Git must be installed
- Internet connection
- Read access to repository

## Output Control

```bash
# Custom output location
repomix --remote user/repo -o custom-output.xml

# With XML format
repomix --remote user/repo --style xml

# Remove comments
repomix --remote user/repo --remove-comments
```

## Docker Usage

```bash
# Process and output to current directory
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo

# Output to specific directory
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo
```

## Common Issues

### Access Issues
- Ensure repository is public
- Check Git installation
- Verify internet connection

### Large Repositories
- Use `--include` to select specific paths
- Enable `--remove-comments`
- Process branches separately
</file>

<file path="website/client/src/en/guide/security.md">
# Security

## Security Check Feature

Repomix uses [Secretlint](https://github.com/secretlint/secretlint) to detect sensitive information in your files:
- API keys
- Access tokens
- Credentials
- Private keys
- Environment variables

## Configuration

Security checks are enabled by default.

Disable via CLI:
```bash
repomix --no-security-check
```

Or in `repomix.config.json`:
```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

## Security Measures

1. **Binary File Exclusion**: Binary files are not included in output
2. **Git-Aware**: Respects `.gitignore` patterns
3. **Automated Detection**: Scans for common security issues:
  - AWS credentials
  - Database connection strings
  - Authentication tokens
  - Private keys

## When Security Check Finds Issues

Example output:
```bash
🔍 Security Check:
──────────────────
2 suspicious file(s) detected and excluded:
1. config/credentials.json
  - Found AWS access key
2. .env.local
  - Found database password
```

## Best Practices

1. Always review output before sharing
2. Use `.repomixignore` for sensitive paths
3. Keep security checks enabled
4. Remove sensitive files from repository

## Reporting Security Issues

Found a security vulnerability? Please:
1. Do not open a public issue
2. Email: koukun0120@gmail.com
3. Or use [GitHub Security Advisories](https://github.com/yamadashy/repomix/security/advisories/new)
</file>

<file path="website/client/src/en/guide/usage.md">
# Basic Usage

## Quick Start

Pack your entire repository:
```bash
repomix
```

## Common Use Cases

### Pack Specific Directories
```bash
repomix path/to/directory
```

### Include Specific Files
Use [glob patterns](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):
```bash
repomix --include "src/**/*.ts,**/*.md"
```

### Exclude Files
```bash
repomix --ignore "**/*.log,tmp/"
```

### Remote Repositories
```bash
# Using GitHub URL
repomix --remote https://github.com/user/repo

# Using shorthand
repomix --remote user/repo

# Specific branch/tag/commit
repomix --remote user/repo --remote-branch main
repomix --remote user/repo --remote-branch 935b695
```

### File List Input (stdin)

Pass file paths via stdin for ultimate flexibility:

```bash
# Using find command
find src -name "*.ts" -type f | repomix --stdin

# Using git to get tracked files
git ls-files "*.ts" | repomix --stdin

# Using ls with glob patterns
ls src/**/*.ts | repomix --stdin

# From a file containing file paths
cat file-list.txt | repomix --stdin

# Direct input with echo
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```

The `--stdin` option allows you to pipe a list of file paths to Repomix, giving you ultimate flexibility in selecting which files to pack.

> [!NOTE]
> When using `--stdin`, file paths can be relative or absolute, and Repomix will automatically handle path resolution and deduplication.

### Code Compression

```bash
repomix --compress

# You can also use it with remote repositories:
repomix --remote yamadashy/repomix --compress
```

## Output Formats

### XML (Default)
```bash
repomix --style xml
```

### Markdown
```bash
repomix --style markdown
```

### Plain Text
```bash
repomix --style plain
```

## Additional Options

### Remove Comments
```bash
repomix --remove-comments
```

### Show Line Numbers
```bash
repomix --output-show-line-numbers
```

### Copy to Clipboard
```bash
repomix --copy
```

### Disable Security Check
```bash
repomix --no-security-check
```

## Configuration

Initialize configuration file:
```bash
repomix --init
```

See [Configuration Guide](/guide/configuration) for detailed options.
</file>

<file path="website/client/src/en/index.md">
---
layout: home
title: Repomix
titleTemplate: Pack your codebase into AI-friendly formats
aside: false
editLink: false

features:
  - icon: 🤖
    title: AI-Optimized
    details: Formats your codebase in a way that's easy for AI to understand and process.

  - icon: ⚙️
    title: Git-Aware
    details: Automatically respects your .gitignore files.

  - icon: 🛡️
    title: Security-Focused
    details: Incorporates Secretlint for robust security checks to detect and prevent inclusion of sensitive information.

  - icon: 📊
    title: Token Counting
    details: Provides token counts for each file and the entire repository, useful for LLM context limits.

---

<script setup>
import YouTubeVideo from '../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../utils/videos'
</script>

<div class="cli-section">

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## 🏆 Open Source Awards Nomination

We're honored! Repomix has been nominated for the **Powered by AI** category at the [JSNation Open Source Awards 2025](https://osawards.com/javascript/).

This wouldn't have been possible without all of you using and supporting Repomix. Thank you!

If Repomix has helped you analyze or pack codebases for AI tools, we'd be grateful for your vote in the **Powered by AI** category.

## What is Repomix?

Repomix is a powerful tool that packages your entire codebase into a single AI-friendly file. Whether you're working on code reviews, refactoring, or getting AI assistance with your project, Repomix makes it easy to share your entire repository context with AI tools.

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

## Quick Start

Once you've generated a packed file (`repomix-output.xml`) using Repomix, you can send it to an AI assistant (like ChatGPT, Claude) with a prompt like:

```
This file contains all the files in the repository combined into one.
I want to refactor the code, so please review it first.
```

The AI will analyze your entire codebase and provide comprehensive insights:

![Repomix File Usage 1](/images/docs/repomix-file-usage-1.png)

When discussing specific changes, the AI can help generate code. With features like Claude's Artifacts, you can even receive multiple interdependent files:

![Repomix File Usage 2](/images/docs/repomix-file-usage-2.png)

Happy coding! 🚀

## Using the CLI Tool {#using-the-cli-tool}

Repomix can be used as a command-line tool, offering powerful features and customization options.

**The CLI tool can access private repositories** as it uses your locally installed git.

### Quick Start

You can try Repomix instantly in your project directory without installation:

```bash
npx repomix
```

Or install globally for repeated use:

```bash
# Install using npm
npm install -g repomix

# Alternatively using yarn
yarn global add repomix

# Alternatively using bun
bun add -g repomix

# Alternatively using Homebrew (macOS/Linux)
brew install repomix

# Then run in any project directory
repomix
```

That's it! Repomix will generate a `repomix-output.xml` file in your current directory, containing your entire repository in an AI-friendly format.



### Usage

To pack your entire repository:

```bash
repomix
```

To pack a specific directory:

```bash
repomix path/to/directory
```

To pack specific files or directories using [glob patterns](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):

```bash
repomix --include "src/**/*.ts,**/*.md"
```

To exclude specific files or directories:

```bash
repomix --ignore "**/*.log,tmp/"
```

To pack a remote repository:
```bash
# Using shorthand format
npx repomix --remote yamadashy/repomix

# Using full URL (supports branches and specific paths)
npx repomix --remote https://github.com/yamadashy/repomix
npx repomix --remote https://github.com/yamadashy/repomix/tree/main

# Using commit's URL
npx repomix --remote https://github.com/yamadashy/repomix/commit/836abcd7335137228ad77feb28655d85712680f1
```

To initialize a new configuration file (`repomix.config.json`):

```bash
repomix --init
```

Once you have generated the packed file, you can use it with Generative AI tools like Claude, ChatGPT, and Gemini.

#### Docker Usage

You can also run Repomix using Docker 🐳  
This is useful if you want to run Repomix in an isolated environment or prefer using containers.

Basic usage (current directory):

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

To pack a specific directory:
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

Process a remote repository and output to a `output` directory:

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### Output Formats

Choose your preferred output format:

```bash
# XML format (default)
repomix --style xml

# Markdown format
repomix --style markdown

# Plain text format
repomix --style plain
```

### Customization

Create a `repomix.config.json` for persistent settings:

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

## Power Users Guide

Repomix offers powerful features for advanced use cases. Here are some essential guides for power users:

- **[MCP Server](/guide/mcp-server)** - Model Context Protocol integration for AI assistants
- **[GitHub Actions](/guide/github-actions)** - Automate codebase packing in CI/CD workflows
- **[Code Compression](/guide/code-compress)** - Tree-sitter based intelligent compression (~70% token reduction)
- **[Using as Library](/guide/development/using-repomix-as-a-library)** - Integrate Repomix into your Node.js applications
- **[Custom Instructions](/guide/custom-instructions)** - Add custom prompts and instructions to outputs
- **[Security Features](/guide/security)** - Built-in Secretlint integration and safety checks
- **[Best Practices](/guide/tips/best-practices)** - Optimize your AI workflows with proven strategies

### More Examples
::: tip Need more help? 💡
Check out our comprehensive documentation in the [Guide](/guide/) or explore the [GitHub Repository](https://github.com/yamadashy/repomix) for more examples and source code.
:::

</div>
</file>

<file path="website/client/src/es/guide/development/index.md">
# Contribuir a Repomix

¡Gracias por tu interés en **Repomix**! 🚀 Nos encantaría contar con tu ayuda para mejorarlo aún más. Esta guía te ayudará a comenzar a contribuir al proyecto.

## Cómo contribuir

- **Marcar el repositorio con una estrella**: ¡Muestra tu apoyo [marcando el repositorio con una estrella](https://github.com/yamadashy/repomix)!
- **Crear un issue**: ¿Has encontrado un error? ¿Tienes una idea para una nueva función? Háznoslo saber [creando un issue](https://github.com/yamadashy/repomix/issues).
- **Enviar un Pull Request**: ¿Has encontrado algo para arreglar o mejorar? ¡Envía un PR!
- **Difundir la palabra**: Comparte tu experiencia con Repomix en redes sociales, blogs o con tu comunidad tecnológica.
- **Usar Repomix**: Los mejores comentarios provienen del uso en el mundo real, así que no dudes en integrar Repomix en tus propios proyectos.
- **Patrocinar**: Apoya el desarrollo de Repomix [convirtiéndote en patrocinador](https://github.com/sponsors/yamadashy).

## Inicio rápido

```bash
git clone https://github.com/yamadashy/repomix.git
cd repomix
npm install
```

## Comandos de desarrollo

```bash
# Ejecutar CLI
npm run repomix

# Ejecutar pruebas
npm run test
npm run test-coverage

# Linting de código
npm run lint
```

## Estilo de código

- Usa [Biome](https://biomejs.dev/) para linting y formateo
- Inyección de dependencias para la testabilidad
- Mantén los archivos por debajo de las 250 líneas
- Agrega pruebas para las nuevas funciones

## Pautas para Pull Requests

1. Ejecuta todas las pruebas
2. Pasa las comprobaciones de linting
3. Actualiza la documentación
4. Sigue el estilo de código existente

## Configuración de Desarrollo

### Requisitos previos

- Node.js ≥ 18.0.0
- Git
- npm
- Docker (opcional, para ejecutar el sitio web o el desarrollo en contenedores)

### Desarrollo local

Para configurar Repomix para desarrollo local:

```bash
# Clonar el repositorio
git clone https://github.com/yamadashy/repomix.git
cd repomix

# Instalar dependencias
npm install

# Ejecutar CLI
npm run repomix
```

### Desarrollo con Docker

También puedes ejecutar Repomix usando Docker:

```bash
# Construir imagen
docker build -t repomix .

# Ejecutar contenedor
docker run -v ./:/app -it --rm repomix
```

### Estructura del proyecto

El proyecto está organizado en los siguientes directorios:

```
src/
├── cli/          # Implementación de CLI
├── config/       # Manejo de configuración
├── core/         # Funcionalidad principal
│   ├── file/     # Manejo de archivos
│   ├── metrics/  # Cálculo de métricas
│   ├── output/   # Generación de salida
│   ├── security/ # Comprobaciones de seguridad
├── mcp/          # Integración de servidor MCP
└── shared/       # Utilidades compartidas
tests/            # Pruebas que reflejan la estructura src/
website/          # Sitio web de documentación
├── client/       # Frontend (VitePress)
└── server/       # API de Backend
```

## Desarrollo del sitio web

El sitio web de Repomix está construido con [VitePress](https://vitepress.dev/). Para ejecutar el sitio web localmente:

```bash
# Requisitos previos: Docker debe estar instalado en su sistema

# Iniciar el servidor de desarrollo del sitio web
npm run website

# Acceder al sitio web en http://localhost:5173/
```

Al actualizar la documentación, solo necesita actualizar primero la versión en inglés. Los mantenedores se encargarán de las traducciones a otros idiomas.

## Proceso de lanzamiento

Para mantenedores y colaboradores interesados en el proceso de lanzamiento:

1. Actualizar versión
```bash
npm version patch  # o minor/major
```

2. Ejecutar pruebas y construcción
```bash
npm run test-coverage
npm run build
```

3. Publicar
```bash
npm publish
```

Las nuevas versiones son gestionadas por el mantenedor. Si crees que es necesario un lanzamiento, abre un issue para discutirlo.

## ¿Necesitas ayuda?

- [Abre un issue](https://github.com/yamadashy/repomix/issues)
- [Únete a Discord](https://discord.gg/wNYzTwZFku)
</file>

<file path="website/client/src/es/guide/development/using-repomix-as-a-library.md">
# Usar Repomix como Biblioteca

Además de usar Repomix como herramienta CLI, puedes integrar su funcionalidad directamente en tus aplicaciones Node.js.

## Instalación

Instala Repomix como dependencia en tu proyecto:

```bash
npm install repomix
```

## Uso Básico

La forma más sencilla de usar Repomix es a través de la función `runCli`, que proporciona la misma funcionalidad que la interfaz de línea de comandos:

```javascript
import { runCli, type CliOptions } from 'repomix';

// Procesar el directorio actual con opciones personalizadas
async function packProject() {
  const options = {
    output: 'output.xml',
    style: 'xml',
    compress: true,
    quiet: true
  } as CliOptions;
  
  const result = await runCli(['.'], process.cwd(), options);
  return result.packResult;
}
```

El `result.packResult` contiene información sobre los archivos procesados, incluyendo:
- `totalFiles`: Número de archivos procesados
- `totalCharacters`: Recuento total de caracteres
- `totalTokens`: Recuento total de tokens (útil para límites de contexto de LLM)
- `fileCharCounts`: Recuento de caracteres por archivo
- `fileTokenCounts`: Recuento de tokens por archivo

## Procesamiento de Repositorios Remotos

Puedes clonar y procesar un repositorio remoto:

```javascript
import { runCli, type CliOptions } from 'repomix';

// Clonar y procesar un repositorio de GitHub
async function processRemoteRepo(repoUrl) {
  const options = {
    remote: repoUrl,
    output: 'output.xml',
    compress: true
  } as CliOptions;
  
  return await runCli(['.'], process.cwd(), options);
}
```

## Uso de Componentes Principales

Para un mayor control, puedes usar las APIs de bajo nivel de Repomix directamente:

```javascript
import { searchFiles, collectFiles, processFiles, TokenCounter } from 'repomix';

async function analyzeFiles(directory) {
  // Encontrar y recopilar archivos
  const { filePaths } = await searchFiles(directory, { /* configuración */ });
  const rawFiles = await collectFiles(filePaths, directory);
  const processedFiles = await processFiles(rawFiles, { /* configuración */ });
  
  // Contar tokens
  const tokenCounter = new TokenCounter('o200k_base');
  
  // Devolver resultados del análisis
  return processedFiles.map(file => ({
    path: file.path,
    tokens: tokenCounter.countTokens(file.content)
  }));
}
```

## Ejemplo del Mundo Real

El sitio web de Repomix ([repomix.com](https://repomix.com)) utiliza Repomix como biblioteca para procesar repositorios remotos. Puedes ver la implementación en [website/server/src/remoteRepo.ts](https://github.com/yamadashy/repomix/blob/main/website/server/src/remoteRepo.ts).
</file>

<file path="website/client/src/es/guide/tips/best-practices.md">
# Mejores prácticas para el desarrollo asistido por IA: Desde mi experiencia

Aunque todavía no he completado con éxito un proyecto a gran escala utilizando IA, me gustaría compartir lo que he aprendido hasta ahora de mi experiencia trabajando con IA en el desarrollo.

## Enfoque de desarrollo básico

Cuando se trabaja con IA, intentar implementar todas las funciones a la vez puede llevar a problemas inesperados y al estancamiento del proyecto. Por eso es más efectivo comenzar con la funcionalidad principal y construir cada función una por una, asegurando una implementación sólida antes de seguir adelante.

### El poder del código existente

Este enfoque es efectivo porque implementar la funcionalidad principal te permite materializar tu diseño ideal y estilo de codificación a través de código real. La forma más efectiva de comunicar la visión de tu proyecto es a través de código que refleje tus estándares y preferencias.

Al comenzar con las funciones principales y asegurar que cada componente funcione correctamente antes de continuar, todo el proyecto mantiene la consistencia, lo que facilita que la IA genere código más apropiado.

## El enfoque modular

Dividir el código en módulos más pequeños es crucial. En mi experiencia, mantener los archivos alrededor de 250 líneas de código facilita dar instrucciones claras a la IA y hace que el proceso de prueba y error sea más eficiente. Si bien el recuento de tokens sería una métrica más precisa, el recuento de líneas es más práctico para los desarrolladores humanos, por lo que lo usamos como una guía.

Esta modularización no se trata solo de separar los componentes de frontend, backend y base de datos, sino de desglosar la funcionalidad a un nivel mucho más fino. Por ejemplo, dentro de una sola función, podrías separar la validación, el manejo de errores y otras funcionalidades específicas en módulos distintos. Por supuesto, la separación de alto nivel también es importante, e implementar este enfoque modular gradualmente ayuda a mantener instrucciones claras y permite que la IA genere código más apropiado. Este enfoque es efectivo no solo para la IA sino también para los desarrolladores humanos.

## Asegurar la calidad a través de las pruebas

Considero que las pruebas son cruciales en el desarrollo asistido por IA. Las pruebas no solo sirven como medidas de garantía de calidad, sino también como documentación que demuestra claramente las intenciones del código. Al pedirle a la IA que implemente nuevas funciones, el código de prueba existente actúa efectivamente como un documento de especificación.

Las pruebas también son una excelente herramienta para validar la corrección del código generado por IA. Por ejemplo, al hacer que la IA implemente una nueva funcionalidad para un módulo, escribir casos de prueba de antemano te permite evaluar objetivamente si el código generado se comporta como se espera. Esto se alinea bien con los principios de desarrollo basado en pruebas (TDD) y es particularmente efectivo cuando se colabora con la IA.

## Equilibrar la planificación y la implementación

Antes de implementar funciones a gran escala, recomiendo discutir primero el plan con la IA. Organizar los requisitos y considerar la arquitectura conduce a una implementación más fluida. Una buena práctica es compilar primero los requisitos y luego pasar a una sesión de chat separada para el trabajo de implementación.

Es esencial que un humano revise el resultado de la IA y haga los ajustes necesarios. Si bien la calidad del código generado por IA es generalmente moderada, aún acelera el desarrollo en comparación con escribir todo desde cero.

## Conclusión

Siguiendo estas prácticas, puedes aprovechar las fortalezas de la IA mientras construyes una base de código consistente y de alta calidad. Incluso a medida que tu proyecto crece en tamaño, cada componente permanece bien definido y manejable.
</file>

<file path="website/client/src/es/guide/code-compress.md">
# Compresión de Código

La compresión de código es una función poderosa que extrae de manera inteligente las estructuras esenciales del código mientras elimina los detalles de implementación. Esto es particularmente útil para reducir el conteo de tokens mientras se mantiene la información estructural importante de tu base de código.

> [!NOTE]
> Esta es una función experimental que mejoraremos activamente según los comentarios de los usuarios y el uso en el mundo real.

## Uso Básico

Habilita la compresión de código usando la bandera `--compress`:

```bash
repomix --compress
```

También puedes usarlo con repositorios remotos:

```bash
repomix --remote user/repo --compress
```

## Cómo Funciona

El algoritmo de compresión procesa el código utilizando el análisis de Tree-sitter para extraer y preservar elementos estructurales esenciales mientras elimina los detalles de implementación.

La compresión preserva:
- Firmas de funciones y métodos
- Definiciones de interfaces y tipos
- Estructuras de clases y propiedades
- Elementos estructurales importantes

Mientras elimina:
- Implementaciones de funciones y métodos
- Detalles de lógica de bucles y condicionales
- Declaraciones de variables internas
- Código específico de implementación

### Ejemplo

Código TypeScript original:

```typescript
import { ShoppingItem } from './shopping-item';

/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
  let total = 0;
  for (const item of items) {
    total += item.price * item.quantity;
  }
  return total;
}

// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

Después de la compresión:

```typescript
import { ShoppingItem } from './shopping-item';
⋮----
/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
⋮----
// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

## Configuración

Puedes habilitar la compresión en tu archivo de configuración:

```json
{
  "output": {
    "compress": true
  }
}
```

## Casos de Uso

La compresión de código es particularmente útil cuando:
- Analizas la estructura y arquitectura del código
- Reduces el conteo de tokens para procesamiento con LLM
- Creas documentación de alto nivel
- Comprendes patrones y firmas de código
- Compartes diseños de API e interfaces

## Opciones Relacionadas

Puedes combinar la compresión con otras opciones:
- `--remove-comments`: Eliminar comentarios del código
- `--remove-empty-lines`: Eliminar líneas vacías
- `--output-show-line-numbers`: Agregar números de línea a la salida
</file>

<file path="website/client/src/es/guide/command-line-options.md">
# Opciones de Línea de Comandos

## Opciones Básicas
- `-v, --version`: Muestra la versión

## Opciones de Salida
- `-o, --output <file>`: Nombre del archivo de salida (predeterminado: `repomix-output.txt`)
- `--stdout`: Salida a la salida estándar en lugar de escribir a un archivo (no puede usarse con la opción `--output`)
- `--style <type>`: Estilo de salida (`plain`, `xml`, `markdown`) (predeterminado: `xml`)
- `--parsable-style`: Habilita la salida analizable basada en el esquema del estilo elegido (predeterminado: `false`)
- `--compress`: Realiza una extracción inteligente de código, centrándose en las firmas de funciones y clases mientras elimina los detalles de implementación. Para más detalles y ejemplos, consulte la [Guía de Compresión de Código](code-compress)
- `--output-show-line-numbers`: Agrega números de línea (predeterminado: `false`)
- `--copy`: Copiar al portapapeles (predeterminado: `false`)
- `--no-file-summary`: Deshabilita el resumen de archivos (predeterminado: `true`)
- `--no-directory-structure`: Deshabilita la estructura de directorios (predeterminado: `true`)
- `--no-files`: Deshabilita la salida del contenido de archivos (modo solo metadatos) (predeterminado: `true`)
- `--remove-comments`: Elimina comentarios (predeterminado: `false`)
- `--remove-empty-lines`: Elimina líneas vacías (predeterminado: `false`)
- `--header-text <text>`: Texto personalizado para incluir en el encabezado del archivo
- `--instruction-file-path <path>`: Ruta al archivo con instrucciones personalizadas detalladas
- `--include-empty-directories`: Incluye directorios vacíos en la salida (predeterminado: `false`)
- `--include-diffs`: Incluye las diferencias de git en la salida (incluye por separado los cambios del árbol de trabajo y los cambios preparados) (predeterminado: `false`)

## Opciones de Filtrado
- `--include <patterns>`: Patrones a incluir (separados por comas)
- `-i, --ignore <patterns>`: Patrones a ignorar (separados por comas)
- `--stdin`: Leer rutas de archivos desde stdin en lugar de descubrir archivos automáticamente
- `--no-gitignore`: Deshabilita el uso del archivo .gitignore
- `--no-default-patterns`: Deshabilita los patrones predeterminados

## Opciones de Repositorio Remoto
- `--remote <url>`: Procesa repositorio remoto
- `--remote-branch <name>`: Especifica el nombre de la rama remota, etiqueta o hash de commit (por defecto es la rama principal del repositorio)

## Opciones de Configuración
- `-c, --config <path>`: Ruta del archivo de configuración personalizado
- `--init`: Crea archivo de configuración
- `--global`: Usa configuración global

## Opciones de Seguridad
- `--no-security-check`: Deshabilita la verificación de seguridad (predeterminado: `true`)

## Opciones de Conteo de Tokens
- `--token-count-encoding <encoding>`: Especifica la codificación para el conteo de tokens (ej. `o200k_base`, `cl100k_base`) (predeterminado: `o200k_base`)

## Otras Opciones
- `--top-files-len <number>`: Número de archivos principales a mostrar (predeterminado: `5`)
- `--verbose`: Habilita el registro detallado
- `--quiet`: Deshabilita toda la salida a stdout

## Ejemplos

```bash
# Uso básico
repomix

# Salida personalizada
repomix -o output.xml --style xml

# Salida a la salida estándar
repomix --stdout > custom-output.txt

# Enviar salida a la salida estándar, luego canalizar a otro comando (por ejemplo, simonw/llm)
repomix --stdout | llm "Por favor explica qué hace este código"

# Salida personalizada con compresión
repomix --compress

# Procesar archivos específicos
repomix --include "src/**/*.ts" --ignore "**/*.test.ts"

# Repositorio remoto con rama
repomix --remote https://github.com/user/repo/tree/main

# Repositorio remoto con commit
repomix --remote https://github.com/user/repo/commit/836abcd7335137228ad77feb28655d85712680f1

# Repositorio remoto con formato abreviado
repomix --remote user/repo

# Lista de archivos usando stdin
find src -name "*.ts" -type f | repomix --stdin
git ls-files "*.js" | repomix --stdin
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```
</file>

<file path="website/client/src/es/guide/comment-removal.md">
# Eliminación de comentarios

Repomix puede eliminar automáticamente los comentarios de tu código al generar el archivo de salida. Esto puede ayudar a reducir el ruido y centrarse en el código real.

## Uso

Para habilitar la eliminación de comentarios, establece la opción `removeComments` a `true` en tu archivo `repomix.config.json`:

```json
{
  "output": {
    "removeComments": true
  }
}
```

## Lenguajes soportados

Repomix soporta la eliminación de comentarios para una amplia gama de lenguajes de programación, incluyendo:

- JavaScript/TypeScript (`//`, `/* */`)
- Python (`#`, `"""`, `'''`)
- Java (`//`, `/* */`)
- C/C++ (`//`, `/* */`)
- HTML (`<!-- -->`)
- CSS (`/* */`)
- Y muchos más...

## Ejemplo

Dado el siguiente código JavaScript:

```javascript
// Este es un comentario de una sola línea
function test() {
  /* Este es un
     comentario multilínea */
  return true;
}
```

Con la eliminación de comentarios habilitada, la salida será:

```javascript
function test() {
  return true;
}
```

## Notas

- La eliminación de comentarios se realiza antes que otros pasos de procesamiento, como la adición de números de línea.
- Algunos comentarios, como los comentarios JSDoc, pueden conservarse dependiendo del lenguaje y el contexto.
</file>

<file path="website/client/src/es/guide/configuration.md">
# Configuración

Repomix puede configurarse mediante un archivo de configuración (`repomix.config.json`) o opciones de línea de comandos. El archivo de configuración le permite personalizar varios aspectos de cómo se procesa y genera la salida de su base de código.

## Inicio rápido

Cree un archivo de configuración en el directorio de su proyecto:
```bash
repomix --init
```

Esto creará un archivo `repomix.config.json` con la configuración predeterminada. También puede crear un archivo de configuración global que se utilizará como respaldo cuando no se encuentre una configuración local:

```bash
repomix --init --global
```

## Opciones de configuración

| Opción                           | Descripción                                                                                                                  | Predeterminado        |
|----------------------------------|------------------------------------------------------------------------------------------------------------------------------|------------------------|
| `input.maxFileSize`              | Tamaño máximo de archivo en bytes para procesar. Los archivos más grandes serán ignorados. Útil para excluir archivos binarios grandes o archivos de datos | `50000000`            |
| `output.filePath`                | Nombre del archivo de salida. Admite formatos XML, Markdown y texto plano                                                    | `"repomix-output.xml"` |
| `output.style`                   | Estilo de salida (`xml`, `markdown`, `plain`). Cada formato tiene sus propias ventajas para diferentes herramientas de IA    | `"xml"`                |
| `output.parsableStyle`           | Indica si se debe escapar la salida según el esquema de estilo elegido. Permite un mejor análisis pero puede aumentar el recuento de tokens | `false`                |
| `output.compress`                | Indica si se debe realizar una extracción inteligente de código usando Tree-sitter para reducir el recuento de tokens mientras se preserva la estructura | `false`                |
| `output.headerText`              | Texto personalizado para incluir en el encabezado del archivo. Útil para proporcionar contexto o instrucciones a las herramientas de IA | `null`                 |
| `output.instructionFilePath`     | Ruta a un archivo que contiene instrucciones personalizadas detalladas para el procesamiento de IA                          | `null`                 |
| `output.fileSummary`             | Indica si se debe incluir una sección de resumen al principio mostrando recuentos de archivos, tamaños y otras métricas    | `true`                 |
| `output.directoryStructure`      | Indica si se debe incluir la estructura de directorios en la salida. Ayuda a la IA a entender la organización del proyecto | `true`                 |
| `output.files`                   | Indica si se debe incluir el contenido de los archivos en la salida. Establecer en false para incluir solo estructura y metadatos | `true`                 |
| `output.removeComments`          | Indica si se deben eliminar los comentarios de los tipos de archivos soportados. Puede reducir el ruido y el recuento de tokens | `false`                |
| `output.removeEmptyLines`        | Indica si se deben eliminar las líneas vacías de la salida para reducir el recuento de tokens                              | `false`                |
| `output.showLineNumbers`         | Indica si se deben agregar números de línea a cada línea. Útil para referenciar partes específicas del código              | `false`                |
| `output.copyToClipboard`         | Indica si se debe copiar la salida al portapapeles del sistema además de guardar el archivo                                | `false`                |
| `output.topFilesLength`          | Número de archivos principales para mostrar en el resumen. Si se establece en 0, no se mostrará ningún resumen             | `5`                    |
| `output.includeEmptyDirectories` | Indica si se deben incluir directorios vacíos en la estructura del repositorio                                             | `false`                |
| `output.git.sortByChanges`       | Indica si se deben ordenar los archivos por número de cambios git. Los archivos con más cambios aparecen al final         | `true`                 |
| `output.git.sortByChangesMaxCommits` | Número máximo de commits para analizar al contar cambios git. Limita la profundidad del historial por rendimiento      | `100`                  |
| `output.git.includeDiffs`        | Indica si se deben incluir las diferencias git en la salida. Muestra por separado los cambios del árbol de trabajo y los cambios preparados | `false`                |
| `include`                        | Patrones de archivos a incluir usando [patrones glob](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax) | `[]`                   |
| `ignore.useGitignore`            | Indica si se deben usar los patrones del archivo `.gitignore` del proyecto                                                  | `true`                 |
| `ignore.useDefaultPatterns`      | Indica si se deben usar los patrones de ignorar predeterminados (node_modules, .git, etc.)                                | `true`                 |
| `ignore.customPatterns`          | Patrones adicionales para ignorar usando [patrones glob](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax) | `[]`                   |
| `security.enableSecurityCheck`   | Indica si se deben realizar comprobaciones de seguridad usando Secretlint para detectar información sensible               | `true`                 |
| `tokenCount.encoding`            | Codificación de recuento de tokens utilizada por el tokenizador [tiktoken](https://github.com/openai/tiktoken) de OpenAI. Use `o200k_base` para GPT-4o, `cl100k_base` para GPT-4/3.5. Ver [tiktoken model.py](https://github.com/openai/tiktoken/blob/main/tiktoken/model.py#L24) para más detalles. | `"o200k_base"`         |

El archivo de configuración admite la sintaxis [JSON5](https://json5.org/), que permite:
- Comentarios (tanto de una línea como multilínea)
- Comas finales en objetos y arrays
- Nombres de propiedades sin comillas
- Sintaxis de cadena más flexible

## Validación de esquema

Puede habilitar la validación de esquema para su archivo de configuración agregando la propiedad `$schema`:

```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "output": {
    "filePath": "repomix-output.md",
    "style": "markdown"
  }
}
```

Esto proporciona autocompletado y validación en editores que admiten esquemas JSON.

## Ejemplo de archivo de configuración

Aquí hay un ejemplo de un archivo de configuración completo (`repomix.config.json`):

```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 50000000
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "compress": false,
    "headerText": "Información de encabezado personalizada para el archivo empaquetado.",
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "includeEmptyDirectories": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false
    }
  },
  "include": ["**/*"],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    // Los patrones también se pueden especificar en .repomixignore
    "customPatterns": [
      "additional-folder",
      "**/*.log"
    ],
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
```

## Ubicaciones de los archivos de configuración

Repomix busca los archivos de configuración en el siguiente orden:
1. Archivo de configuración local (`repomix.config.json`) en el directorio actual
2. Archivo de configuración global:
   - Windows: `%LOCALAPPDATA%\Repomix\repomix.config.json`
   - macOS/Linux: `~/.config/repomix/repomix.config.json`

Las opciones de línea de comandos tienen prioridad sobre la configuración del archivo.

## Patrones de ignorar

Repomix proporciona múltiples formas de especificar qué archivos deben ignorarse. Los patrones se procesan en el siguiente orden de prioridad:

1. Opciones de CLI (`--ignore`)
2. Archivo `.repomixignore` en el directorio del proyecto
3. `.gitignore` y `.git/info/exclude` (si `ignore.useGitignore` es verdadero)
4. Patrones predeterminados (si `ignore.useDefaultPatterns` es verdadero)

Ejemplo de `.repomixignore`:
```text
# Directorios de caché
.cache/
tmp/

# Salidas de compilación
dist/
build/

# Registros
*.log
```

## Patrones de ignorar predeterminados

Cuando `ignore.useDefaultPatterns` es verdadero, Repomix ignora automáticamente patrones comunes:
```text
node_modules/**
.git/**
coverage/**
dist/**
```

Para la lista completa, vea [defaultIgnore.ts](https://github.com/yamadashy/repomix/blob/main/src/config/defaultIgnore.ts)

## Características avanzadas

### Compresión de código

La función de compresión de código, habilitada con `output.compress: true`, utiliza [Tree-sitter](https://github.com/tree-sitter/tree-sitter) para extraer inteligentemente estructuras de código esenciales mientras elimina detalles de implementación. Esto ayuda a reducir el recuento de tokens mientras mantiene información estructural importante.

Beneficios principales:
- Reduce significativamente el recuento de tokens
- Preserva las firmas de clases y funciones
- Mantiene importaciones y exportaciones
- Conserva definiciones de tipos e interfaces
- Elimina cuerpos de funciones y detalles de implementación

Para más detalles y ejemplos, consulte la [Guía de compresión de código](code-compress).

### Integración con Git

La configuración `output.git` proporciona potentes características relacionadas con Git:

- `sortByChanges`: Cuando es verdadero, los archivos se ordenan por número de cambios Git (commits que modificaron el archivo). Los archivos con más cambios aparecen al final de la salida. Esto ayuda a priorizar los archivos más activamente desarrollados. Predeterminado: `true`
- `sortByChangesMaxCommits`: El número máximo de commits para analizar al contar cambios de archivos. Predeterminado: `100`
- `includeDiffs`: Cuando es verdadero, incluye las diferencias Git en la salida (incluye por separado los cambios del árbol de trabajo y los cambios preparados). Esto permite al lector ver los cambios pendientes en el repositorio. Predeterminado: `false`

Ejemplo de configuración:
```json
{
  "output": {
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": true
    }
  }
}
```

### Comprobaciones de seguridad

Cuando `security.enableSecurityCheck` está habilitado, Repomix utiliza [Secretlint](https://github.com/secretlint/secretlint) para detectar información sensible en su base de código antes de incluirla en la salida. Esto ayuda a prevenir la exposición accidental de:

- Claves de API
- Tokens de acceso
- Claves privadas
- Contraseñas
- Otras credenciales sensibles

### Eliminación de comentarios

Cuando `output.removeComments` se establece en `true`, los comentarios se eliminan de los tipos de archivos soportados para reducir el tamaño de salida y enfocarse en el contenido esencial del código. Esto puede ser particularmente útil cuando:

- Está trabajando con código muy documentado
- Está tratando de reducir el recuento de tokens
- Se está enfocando en la estructura y lógica del código

Para los lenguajes soportados y ejemplos detallados, consulte la [Guía de eliminación de comentarios](comment-removal).
</file>

<file path="website/client/src/es/guide/custom-instructions.md">
# Instrucciones Personalizadas

Repomix te permite proporcionar instrucciones personalizadas que se incluirán en el archivo de salida. Esto puede ser útil para agregar contexto o pautas específicas para los sistemas de IA que procesan el repositorio.

## Uso

Para incluir una instrucción personalizada, crea un archivo markdown (por ejemplo, `repomix-instruction.md`) en la raíz de tu repositorio. Luego, especifica la ruta a este archivo en tu `repomix.config.json`:

```json
{
  "output": {
    "instructionFilePath": "repomix-instruction.md"
  }
}
```

El contenido de este archivo se incluirá en la salida bajo la sección "Instruction".

## Ejemplo

```markdown
# Instrucciones del Repositorio

Este repositorio contiene el código fuente de la herramienta Repomix. Por favor, sigue estas pautas al analizar el código:

1. Concéntrate en la funcionalidad principal en el directorio `src/core`.
2. Presta especial atención a las verificaciones de seguridad en `src/core/security`.
3. Ignora cualquier archivo en el directorio `tests`.
```

Esto resultará en la siguiente sección en la salida:

```xml
<instruction>
# Instrucciones del Repositorio

Este repositorio contiene el código fuente de la herramienta Repomix. Por favor, sigue estas pautas al analizar el código:

1. Concéntrate en la funcionalidad principal en el directorio `src/core`.
2. Presta especial atención a las verificaciones de seguridad en `src/core/security`.
3. Ignora cualquier archivo en el directorio `tests`.
</instruction>
</file>

<file path="website/client/src/es/guide/github-actions.md">
# Usar Repomix con GitHub Actions

Puedes automatizar el empaquetado de tu base de código para análisis por IA integrando Repomix en tus flujos de trabajo de GitHub Actions. Esto es útil para integración continua (CI), revisión de código o preparación para herramientas LLM.

## Uso básico

Agrega el siguiente paso a tu archivo YAML de workflow para empaquetar tu repositorio:

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.xml
```

## Usar diferentes formatos de salida

Puedes especificar diferentes formatos de salida utilizando el parámetro `style` (el predeterminado es `xml`):

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.md
    style: markdown
```

## Empaquetar múltiples directorios con compresión

Puedes especificar múltiples directorios, patrones de inclusión/exclusión y habilitar la compresión inteligente:

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src tests
    include: "**/*.ts,**/*.md"
    ignore: "**/*.test.ts"
    output: repomix-output.xml
    compress: true
```

## Subir el archivo de salida como artefacto

Para que el archivo empaquetado esté disponible para pasos posteriores o para descarga, súbelo como artefacto:

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src
    output: repomix-output.xml
    compress: true

- name: Upload Repomix output
  uses: actions/upload-artifact@v4
  with:
    name: repomix-output
    path: repomix-output.xml
```

## Parámetros de entrada de la Action

| Nombre             | Descripción                                 | Predeterminado    |
|--------------------|---------------------------------------------|-------------------|
| `directories`      | Lista de directorios a empaquetar (separados por espacio) | `.`         |
| `include`          | Patrones glob a incluir (separados por coma) | `""`         |
| `ignore`           | Patrones glob a excluir (separados por coma) | `""`         |
| `output`           | Ruta del archivo de salida                   | `repomix-output.xml`     |
| `compress`         | Habilitar compresión inteligente             | `true`            |
| `style`            | Formato de salida (xml, markdown, plain)     | `xml`             |
| `additional-args`  | Argumentos extra para repomix CLI            | `""`         |
| `repomix-version`  | Versión del paquete npm a instalar           | `latest`          |

## Salidas de la Action

| Nombre         | Descripción                        |
|---------------|------------------------------------|
| `output_file` | Ruta del archivo generado           |

## Ejemplo de workflow completo

Aquí tienes un ejemplo completo de workflow de GitHub Actions usando Repomix:

```yaml
name: Pack repository with Repomix

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  pack-repo:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Pack repository with Repomix
        uses: yamadashy/repomix/.github/actions/repomix@main
        with:
          output: repomix-output.xml

      - name: Upload Repomix output
        uses: actions/upload-artifact@v4
        with:
          name: repomix-output.xml
          path: repomix-output.xml
          retention-days: 30
```

Ver el [ejemplo completo del workflow](https://github.com/yamadashy/repomix/blob/main/.github/workflows/pack-repository.yml).
</file>

<file path="website/client/src/es/guide/index.md">
# Primeros pasos con Repomix

<script setup>
import HomeBadges from '../../../components/HomeBadges.vue'
import YouTubeVideo from '../../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../../utils/videos'
</script>

Repomix es una herramienta que empaqueta todo tu repositorio en un solo archivo amigable para la IA. Está diseñado para ayudarte a alimentar tu código a modelos de lenguaje grandes (LLMs) como ChatGPT, DeepSeek, Perplexity, Gemini, Gemma, Llama, Grok y más.

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

<HomeBadges />

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## Inicio rápido

Ejecuta este comando en el directorio de tu proyecto:

```bash
npx repomix
```

¡Eso es todo! Encontrarás un archivo `repomix-output.xml` que contiene todo tu repositorio en un formato amigable para la IA.

Luego puedes enviar este archivo a un asistente de IA con un prompt como:

```
Este archivo contiene todos los archivos del repositorio combinados en uno.
Quiero refactorizar el código, así que por favor revísalo primero.
```

La IA analizará todo tu código y proporcionará información completa:

![Repomix File Usage 1](/images/docs/repomix-file-usage-1.png)

Al discutir cambios específicos, la IA puede ayudar a generar código. Con funciones como los Artefactos de Claude, incluso puedes recibir múltiples archivos interdependientes:

![Repomix File Usage 2](/images/docs/repomix-file-usage-2.png)

¡Feliz programación! 🚀

## Características principales

- **Salida optimizada para IA**: Formatea tu código para un fácil procesamiento por parte de la IA
- **Conteo de tokens**: Realiza un seguimiento del uso de tokens para los límites de contexto de los LLM
- **Compatible con Git**: Respeta tus archivos `.gitignore` y `.git/info/exclude`
- **Enfocado en la seguridad**: Detecta información sensible
- **Múltiples formatos de salida**: Elige entre texto plano, XML o Markdown

## ¿Qué sigue?

- [Guía de instalación](installation.md): Diferentes formas de instalar Repomix
- [Guía de uso](usage.md): Aprende sobre las funciones básicas y avanzadas
- [Configuración](configuration.md): Personaliza Repomix para tus necesidades
- [Funciones de seguridad](security.md): Aprende sobre las comprobaciones de seguridad

## Comunidad

Únete a nuestra [comunidad de Discord](https://discord.gg/wNYzTwZFku) para:
- Obtener ayuda con Repomix
- Compartir tus experiencias
- Sugerir nuevas funciones
- Conectarte con otros usuarios

## Soporte

¿Encontraste un error o necesitas ayuda?
- [Abre un issue en GitHub](https://github.com/yamadashy/repomix/issues)
- Únete a nuestro servidor de Discord
- Consulta la [documentación](https://repomix.com)
</file>

<file path="website/client/src/es/guide/installation.md">
# Instalación

## Usando npx (no requiere instalación)

```bash
npx repomix
```

## Instalación global

### npm
```bash
npm install -g repomix
```

### Yarn
```bash
yarn global add repomix
```

### Bun
```bash
bun add -g repomix
```

### Homebrew (macOS/Linux)
```bash
brew install repomix
```

## Instalación con Docker

Extrae y ejecuta la imagen de Docker:

```bash
# Directorio actual
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix

# Directorio específico
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix ruta/al/directorio

# Repositorio remoto
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote yamadashy/repomix
```

## Extensión de VSCode

Ejecuta Repomix directamente en VSCode con la extensión [Repomix Runner](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner) mantenida por la comunidad.

Características:
- Empaqueta cualquier carpeta con unos pocos clics
- Elige entre modo archivo o contenido para copiar
- Limpieza automática de archivos de salida
- Compatible con repomix.config.json

Instálala desde el [VSCode Marketplace](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner).

## Extensión del navegador

¡Obtén acceso instantáneo a Repomix directamente desde cualquier repositorio de GitHub! Nuestra extensión de Chrome añade un botón "Repomix" conveniente a las páginas de repositorio de GitHub.

![Repomix Browser Extension](/images/docs/browser-extension.png)

### Instalación
- Extensión de Chrome: [Repomix - Chrome Web Store](https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa)
- Complemento de Firefox: [Repomix - Firefox Add-ons](https://addons.mozilla.org/firefox/addon/repomix/)

### Características
- Acceso con un clic a Repomix para cualquier repositorio de GitHub
- ¡Más características emocionantes próximamente!

## Requisitos del sistema

- Node.js: ≥ 18.0.0
- Git: Requerido para el procesamiento de repositorios remotos

## Verificación

Después de la instalación, verifica que Repomix esté funcionando:

```bash
repomix --version
repomix --help
</file>

<file path="website/client/src/es/guide/mcp-server.md">
# Servidor MCP

Repomix es compatible con el [Model Context Protocol (MCP)](https://modelcontextprotocol.io), lo que permite a los asistentes de IA interactuar directamente con tu código. Cuando se ejecuta como servidor MCP, Repomix proporciona herramientas que permiten a los asistentes de IA empaquetar repositorios locales o remotos para su análisis sin necesidad de preparación manual de archivos.

> [!NOTE]  
> Esta es una función experimental que mejoraremos activamente según los comentarios de los usuarios y el uso en el mundo real

## Ejecutar Repomix como servidor MCP

Para ejecutar Repomix como servidor MCP, utiliza la opción `--mcp`:

```bash
repomix --mcp
```

Esto inicia Repomix en modo servidor MCP, haciéndolo disponible para asistentes de IA que soporten el Model Context Protocol.

## Configuración de servidores MCP

Para usar Repomix como servidor MCP con asistentes de IA como Claude, necesitas configurar los ajustes de MCP:

### Para VS Code

Puedes instalar el servidor MCP de Repomix en VS Code usando uno de estos métodos:

1. **Usando la insignia de instalación:**

  [![Install in VS Code](https://img.shields.io/badge/VS_Code-VS_Code?style=flat-square&label=Install%20Server&color=0098FF)](vscode:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)<br>
  [![Install in VS Code Insiders](https://img.shields.io/badge/VS_Code_Insiders-VS_Code_Insiders?style=flat-square&label=Install%20Server&color=24bfa5)](vscode-insiders:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)

2. **Usando la línea de comandos:**

  ```bash
  code --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

  Para VS Code Insiders:
  ```bash
  code-insiders --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

### Para Cline (extensión de VS Code)

Edita el archivo `cline_mcp_settings.json`:

```json
{
  "mcpServers": {
    "repomix": {
      "command": "npx",
      "args": [
        "-y",
        "repomix",
        "--mcp"
      ]
    }
  }
}
```

### Para Cursor

En Cursor, añade un nuevo servidor MCP desde `Cursor Settings` > `MCP` > `+ Add new global MCP server` con una configuración similar a la de Cline.

### Para Claude Desktop

Edita el archivo `claude_desktop_config.json` con una configuración similar a la de Cline.

### Para Claude Code

Para configurar Repomix como servidor MCP en [Claude Code](https://docs.anthropic.com/en/docs/claude-code/overview), usa el siguiente comando:

```bash
claude mcp add repomix -- npx -y repomix --mcp
```

### Usando Docker en lugar de npx

En lugar de usar npx, puedes usar Docker para ejecutar Repomix como servidor MCP:

```json
{
  "mcpServers": {
    "repomix-docker": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "ghcr.io/yamadashy/repomix",
        "--mcp"
      ]
    }
  }
}
```

## Herramientas MCP disponibles

Cuando se ejecuta como servidor MCP, Repomix proporciona las siguientes herramientas:

### pack_codebase

Esta herramienta empaqueta un directorio de código local en un archivo XML para análisis de IA. Analiza la estructura del código base, extrae contenido de código relevante y genera un informe completo que incluye métricas, árbol de archivos y contenido de código formateado.

**Parámetros:**
- `directory`: (Requerido) Ruta absoluta al directorio a empaquetar
- `compress`: (Opcional, predeterminado: false) Habilita la compresión Tree-sitter para extraer firmas de código esenciales y estructura mientras elimina detalles de implementación. Reduce el uso de tokens en ~70% manteniendo el significado semántico. Generalmente no es necesario ya que grep_repomix_output permite recuperación incremental de contenido. Úsalo solo cuando específicamente necesites el contenido completo del código base para repositorios grandes.
- `includePatterns`: (Opcional) Especifica archivos a incluir usando patrones fast-glob. Múltiples patrones pueden separarse por comas (ej: "**/*.{js,ts}", "src/**,docs/**"). Solo se procesarán archivos coincidentes.
- `ignorePatterns`: (Opcional) Especifica archivos adicionales a excluir usando patrones fast-glob. Múltiples patrones pueden separarse por comas (ej: "test/**,*.spec.js", "node_modules/**,dist/**"). Estos patrones complementan .gitignore y exclusiones integradas.
- `topFilesLength`: (Opcional, predeterminado: 10) Número de archivos más grandes por tamaño para mostrar en el resumen de métricas para análisis del código base.

**Ejemplo:**
```json
{
  "directory": "/path/to/your/project",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### pack_remote_repository

Esta herramienta obtiene, clona y empaqueta un repositorio de GitHub en un archivo XML para análisis de IA. Clona automáticamente el repositorio remoto, analiza su estructura y genera un informe completo.

**Parámetros:**
- `remote`: (Requerido) URL del repositorio de GitHub o formato usuario/repo (ej: "yamadashy/repomix", "https://github.com/user/repo", o "https://github.com/user/repo/tree/branch")
- `compress`: (Opcional, predeterminado: false) Habilita la compresión Tree-sitter para extraer firmas de código esenciales y estructura mientras elimina detalles de implementación. Reduce el uso de tokens en ~70% manteniendo el significado semántico. Generalmente no es necesario ya que grep_repomix_output permite recuperación incremental de contenido. Úsalo solo cuando específicamente necesites el contenido completo del código base para repositorios grandes.
- `includePatterns`: (Opcional) Especifica archivos a incluir usando patrones fast-glob. Múltiples patrones pueden separarse por comas (ej: "**/*.{js,ts}", "src/**,docs/**"). Solo se procesarán archivos coincidentes.
- `ignorePatterns`: (Opcional) Especifica archivos adicionales a excluir usando patrones fast-glob. Múltiples patrones pueden separarse por comas (ej: "test/**,*.spec.js", "node_modules/**,dist/**"). Estos patrones complementan .gitignore y exclusiones integradas.
- `topFilesLength`: (Opcional, predeterminado: 10) Número de archivos más grandes por tamaño para mostrar en el resumen de métricas para análisis del código base.

**Ejemplo:**
```json
{
  "remote": "yamadashy/repomix",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### read_repomix_output

Esta herramienta lee el contenido de un archivo de salida generado por Repomix. Soporta lectura parcial con especificación de rango de líneas para archivos grandes. Esta herramienta está diseñada para entornos donde el acceso directo al sistema de archivos está limitado.

**Parámetros:**
- `outputId`: (Requerido) ID del archivo de salida de Repomix para leer
- `startLine`: (Opcional) Número de línea de inicio (basado en 1, inclusivo). Si no se especifica, lee desde el principio.
- `endLine`: (Opcional) Número de línea final (basado en 1, inclusivo). Si no se especifica, lee hasta el final.

**Características:**
- Diseñado específicamente para entornos basados en web o aplicaciones en sandbox
- Recupera el contenido de salidas generadas previamente usando su ID
- Proporciona acceso seguro al código empaquetado sin requerir acceso al sistema de archivos
- Soporta lectura parcial para archivos grandes

**Ejemplo:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "startLine": 100,
  "endLine": 200
}
```

### grep_repomix_output

Esta herramienta busca patrones en un archivo de salida de Repomix usando funcionalidad similar a grep con sintaxis JavaScript RegExp. Devuelve líneas coincidentes con líneas de contexto opcionales alrededor de las coincidencias.

**Parámetros:**
- `outputId`: (Requerido) ID del archivo de salida de Repomix para buscar
- `pattern`: (Requerido) Patrón de búsqueda (sintaxis de expresión regular JavaScript RegExp)
- `contextLines`: (Opcional, predeterminado: 0) Número de líneas de contexto para mostrar antes y después de cada coincidencia. Sobrescrito por beforeLines/afterLines si se especifica.
- `beforeLines`: (Opcional) Número de líneas de contexto para mostrar antes de cada coincidencia (como grep -B). Tiene precedencia sobre contextLines.
- `afterLines`: (Opcional) Número de líneas de contexto para mostrar después de cada coincidencia (como grep -A). Tiene precedencia sobre contextLines.
- `ignoreCase`: (Opcional, predeterminado: false) Realiza coincidencia insensible a mayúsculas y minúsculas

**Características:**
- Usa sintaxis JavaScript RegExp para coincidencia de patrones potente
- Soporta líneas de contexto para mejor comprensión de las coincidencias
- Permite control separado de líneas de contexto antes/después
- Opciones de búsqueda sensible e insensible a mayúsculas y minúsculas

**Ejemplo:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "pattern": "function\\s+\\w+\\(",
  "contextLines": 3,
  "ignoreCase": false
}
```

### file_system_read_file y file_system_read_directory

El servidor MCP de Repomix proporciona dos herramientas de sistema de archivos que permiten a los asistentes de IA interactuar de manera segura con el sistema de archivos local:

1. `file_system_read_file`
  - Lee contenido de archivos del sistema de archivos local usando rutas absolutas
  - Incluye validación de seguridad integrada para detectar y prevenir acceso a archivos que contienen información sensible
  - Implementa validación de seguridad usando [Secretlint](https://github.com/secretlint/secretlint)
  - Previene el acceso a archivos que contienen información sensible (claves API, contraseñas, secretos)
  - Valida rutas absolutas para prevenir ataques de traversal de directorios
  - Devuelve mensajes de error claros para rutas inválidas y problemas de seguridad

2. `file_system_read_directory`
  - Lista contenidos de un directorio usando una ruta absoluta
  - Devuelve una lista formateada mostrando archivos y subdirectorios con indicadores claros
  - Muestra archivos y directorios con indicadores claros (`[FILE]` o `[DIR]`)
  - Proporciona navegación segura de directorios con manejo apropiado de errores
  - Valida rutas y asegura que sean absolutas
  - Útil para explorar estructura de proyectos y entender organización del código base

Ambas herramientas incorporan medidas de seguridad robustas:
- Validación de rutas absolutas para prevenir ataques de traversal de directorios
- Verificaciones de permisos para asegurar derechos de acceso apropiados
- Integración con Secretlint para detección de información sensible
- Mensajes de error claros para depuración y conciencia de seguridad

**Ejemplo:**
```typescript
// Leer un archivo
const fileContent = await tools.file_system_read_file({
  path: '/absolute/path/to/file.txt'
});

// Listar contenidos de directorio
const dirContent = await tools.file_system_read_directory({
  path: '/absolute/path/to/directory'
});
```

Estas herramientas son particularmente útiles cuando los asistentes de IA necesitan:
- Analizar archivos específicos en el código base
- Navegar estructuras de directorios
- Verificar existencia y accesibilidad de archivos
- Asegurar operaciones seguras del sistema de archivos

## Beneficios de usar Repomix como servidor MCP

Usar Repomix como servidor MCP ofrece varias ventajas:

1. **Integración directa**: Los asistentes de IA pueden analizar tu código directamente sin preparación manual de archivos.
2. **Flujo de trabajo eficiente**: Optimiza el proceso de análisis de código eliminando la necesidad de generar y cargar archivos manualmente.
3. **Salida consistente**: Asegura que el asistente de IA reciba el código en un formato consistente y optimizado.
4. **Funciones avanzadas**: Aprovecha todas las características de Repomix como compresión de código, conteo de tokens y verificaciones de seguridad.

Una vez configurado, tu asistente de IA puede usar directamente las capacidades de Repomix para analizar bases de código, haciendo que los flujos de trabajo de análisis de código sean más eficientes.
</file>

<file path="website/client/src/es/guide/output.md">
# Formatos de salida

Repomix admite tres formatos de salida:
- XML (predeterminado)
- Markdown
- Texto sin formato

## Formato XML

```bash
repomix --style xml
```

El formato XML está optimizado para el procesamiento de IA:

```xml
Este archivo es una representación fusionada de toda la base de código...

<file_summary>
(Metadatos e instrucciones de IA)
</file_summary>

<directory_structure>
src/
  index.ts
  utils/
    helper.ts
</directory_structure>

<files>
<file path="src/index.ts">
// Contenido del archivo aquí
</file>
</files>
```

::: tip ¿Por qué XML?
Las etiquetas XML ayudan a los modelos de IA como Claude a analizar el contenido con mayor precisión. La [documentación de Claude](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags) recomienda usar etiquetas XML para prompts estructurados.
:::

## Formato Markdown

```bash
repomix --style markdown
```

Markdown proporciona un formato legible:

```markdown
Este archivo es una representación fusionada de toda la base de código...

# Resumen de archivos
(Metadatos e instrucciones de IA)

# Estructura de directorios
```
src/
index.ts
utils/
helper.ts
```

# Archivos

## Archivo: src/index.ts
```typescript
// Contenido del archivo aquí
```
```

## Uso con modelos de IA

Cada formato funciona bien con modelos de IA, pero considera:
- Usar XML para Claude (mejor precisión de análisis)
- Usar Markdown para legibilidad general
- Usar texto sin formato para simplicidad y compatibilidad universal

## Personalización

Establece el formato predeterminado en `repomix.config.json`:
```json
{
  "output": {
    "style": "xml",
    "filePath": "output.xml"
  }
}

## Formato de texto sin formato

```bash
repomix --style plain
```

Estructura de salida:
```text
Este archivo es una representación fusionada de toda la base de código...

================
Resumen de archivos
================
(Metadatos e instrucciones de IA)

================
Estructura de directorios
================
src/
  index.ts
  utils/
    helper.ts

================
Archivos
================

================
Archivo: src/index.ts
================
// Contenido del archivo aquí
```
</file>

<file path="website/client/src/es/guide/prompt-examples.md">
# Ejemplos de prompts

## Revisión de código

### Revisión de arquitectura
```
Analiza la arquitectura de esta base de código:
1. Evalúa la estructura general y los patrones
2. Identifica posibles problemas de arquitectura
3. Sugiere mejoras para la escalabilidad
4. Señala las áreas que siguen las mejores prácticas

Concéntrate en la mantenibilidad y la modularidad.
```

### Revisión de seguridad
```
Realiza una revisión de seguridad de esta base de código:
1. Identifica posibles vulnerabilidades de seguridad
2. Busca antipatrones de seguridad comunes
3. Revisa el manejo de errores y la validación de entradas
4. Evalúa la seguridad de las dependencias

Proporciona ejemplos específicos y pasos de remediación.
```

### Revisión de rendimiento
```
Revisa el rendimiento de la base de código:
1. Identifica cuellos de botella de rendimiento
2. Comprueba la utilización de recursos
3. Revisa la eficiencia algorítmica
4. Evalúa las estrategias de almacenamiento en caché

Incluye recomendaciones de optimización específicas.
```

## Generación de documentación

### Documentación de API
```
Genera documentación de API completa:
1. Enumera y describe todos los endpoints públicos
2. Documenta los formatos de solicitud/respuesta
3. Incluye ejemplos de uso
4. Señala cualquier limitación o restricción
```

### Guía para desarrolladores
```
Crea una guía para desarrolladores que cubra:
1. Instrucciones de configuración
2. Descripción general de la estructura del proyecto
3. Flujo de trabajo de desarrollo
4. Enfoque de pruebas
5. Pasos comunes para la solución de problemas
```

### Documentación de arquitectura
```
Documenta la arquitectura del sistema:
1. Descripción general de alto nivel
2. Interacciones entre componentes
3. Diagramas de flujo de datos
4. Decisiones de diseño y justificación
5. Restricciones y limitaciones del sistema
```

## Análisis y mejora

### Análisis de dependencias
```
Analiza las dependencias del proyecto:
1. Identifica paquetes obsoletos
2. Busca vulnerabilidades de seguridad
3. Sugiere paquetes alternativos
4. Revisa los patrones de uso de dependencias

Incluye recomendaciones de actualización específicas.
```

### Cobertura de pruebas
```
Revisa la cobertura de pruebas:
1. Identifica componentes no probados
2. Sugiere casos de prueba adicionales
3. Revisa la calidad de las pruebas
4. Recomienda estrategias de prueba
```

### Calidad del código
```
Evalúa la calidad del código y sugiere mejoras:
1. Revisa las convenciones de nomenclatura
2. Comprueba la organización del código
3. Evalúa el manejo de errores
4. Revisa las prácticas de comentarios

Proporciona ejemplos específicos de patrones buenos y problemáticos.
```

## Consejos para obtener mejores resultados

1. **Sé específico**: Incluye objetivos claros y criterios de evaluación
2. **Establece el contexto**: Especifica tu rol y el nivel de experiencia necesario
3. **Solicita un formato**: Define cómo quieres que se estructure la respuesta
4. **Prioriza**: Indica qué aspectos son más importantes

## Notas específicas del modelo

### Claude
- Usa el formato de salida XML
- Coloca las instrucciones importantes al final
- Especifica la estructura de la respuesta

### ChatGPT
- Usa el formato Markdown
- Divide las bases de código grandes en secciones
- Incluye prompts de rol del sistema

### Gemini
- Funciona con todos los formatos
- Concéntrate en áreas específicas por solicitud
- Usa un análisis paso a paso
</file>

<file path="website/client/src/es/guide/remote-repository-processing.md">
# Procesamiento de repositorios remotos

## Uso básico

Procesar repositorios públicos:
```bash
# Usando URL completo
repomix --remote https://github.com/usuario/repositorio

# Usando la abreviatura de GitHub
repomix --remote usuario/repositorio
```

## Selección de rama y commit

```bash
# Rama específica
repomix --remote usuario/repositorio --remote-branch main

# Etiqueta
repomix --remote usuario/repositorio --remote-branch v1.0.0

# Hash de commit
repomix --remote usuario/repositorio --remote-branch 935b695
```

## Requisitos

- Git debe estar instalado
- Conexión a Internet
- Acceso de lectura al repositorio

## Control de salida

```bash
# Ubicación de salida personalizada
repomix --remote usuario/repositorio -o salida-personalizada.xml

# Con formato XML
repomix --remote usuario/repositorio --style xml

# Eliminar comentarios
repomix --remote usuario/repositorio --remove-comments
```

## Uso de Docker

```bash
# Procesar y generar la salida en el directorio actual
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote usuario/repositorio

# Generar la salida en un directorio específico
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote usuario/repositorio
```

## Problemas comunes

### Problemas de acceso
- Asegúrate de que el repositorio sea público
- Comprueba la instalación de Git
- Verifica la conexión a Internet

### Repositorios grandes
- Usa `--include` para seleccionar rutas específicas
- Habilita `--remove-comments`
- Procesa las ramas por separado
</file>

<file path="website/client/src/es/guide/security.md">
# Seguridad

## Función de verificación de seguridad

Repomix utiliza [Secretlint](https://github.com/secretlint/secretlint) para detectar información sensible en tus archivos:
- Claves de API
- Tokens de acceso
- Credenciales
- Claves privadas
- Variables de entorno

## Configuración

Las verificaciones de seguridad están habilitadas de forma predeterminada.

Deshabilitar a través de CLI:
```bash
repomix --no-security-check
```

O en `repomix.config.json`:
```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

## Medidas de seguridad

1. **Exclusión de archivos binarios**: Los archivos binarios no se incluyen en la salida
2. **Compatible con Git**: Respeta los patrones de `.gitignore`
3. **Detección automatizada**: Busca problemas de seguridad comunes:
    - Credenciales de AWS
    - Cadenas de conexión de bases de datos
    - Tokens de autenticación
    - Claves privadas

## Cuando la verificación de seguridad encuentra problemas

Ejemplo de salida:
```bash
🔍 Verificación de seguridad:
──────────────────
2 archivo(s) sospechoso(s) detectado(s) y excluido(s):
1. config/credentials.json
  - Se encontró la clave de acceso de AWS
2. .env.local
  - Se encontró la contraseña de la base de datos
```

## Mejores prácticas

1. Siempre revisa la salida antes de compartirla
2. Usa `.repomixignore` para rutas sensibles
3. Mantén las verificaciones de seguridad habilitadas
4. Elimina los archivos sensibles del repositorio

## Reportar problemas de seguridad

¿Encontraste una vulnerabilidad de seguridad? Por favor:
1. No abras un issue público
2. Envía un correo electrónico a: koukun0120@gmail.com
3. O usa [GitHub Security Advisories](https://github.com/yamadashy/repomix/security/advisories/new)
</file>

<file path="website/client/src/es/guide/usage.md">
# Uso básico

## Inicio rápido

Empaqueta todo tu repositorio:
```bash
repomix
```

## Casos de uso comunes

### Empaquetar directorios específicos
```bash
repomix ruta/al/directorio
```

### Incluir archivos específicos
Usa [patrones glob](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):
```bash
repomix --include "src/**/*.ts,**/*.md"
```

### Excluir archivos
```bash
repomix --ignore "**/*.log,tmp/"
```

### Repositorios remotos
```bash
# Usando la URL de GitHub
repomix --remote https://github.com/usuario/repositorio

# Usando la abreviatura
repomix --remote usuario/repositorio

# Rama/etiqueta/commit específico
repomix --remote usuario/repositorio --remote-branch main
repomix --remote usuario/repositorio --remote-branch 935b695
```

### Entrada de lista de archivos (stdin)

Pasa rutas de archivos a través de stdin para máxima flexibilidad:

```bash
# Usando el comando find
find src -name "*.ts" -type f | repomix --stdin

# Usando git para obtener archivos rastreados
git ls-files "*.ts" | repomix --stdin

# Usando ls con patrones glob
ls src/**/*.ts | repomix --stdin

# Desde un archivo que contiene rutas de archivos
cat file-list.txt | repomix --stdin

# Entrada directa con echo
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```

La opción `--stdin` te permite canalizar una lista de rutas de archivos a Repomix, brindando máxima flexibilidad en la selección de qué archivos empaquetar.

> [!NOTE]
> Cuando uses `--stdin`, las rutas de archivos pueden ser relativas o absolutas, y Repomix manejará automáticamente la resolución de rutas y la eliminación de duplicados.

## Formatos de salida

### XML (predeterminado)
```bash
repomix --style xml
```

### Markdown
```bash
repomix --style markdown
```

### Texto sin formato
```bash
repomix --style plain
```

## Opciones adicionales

### Eliminar comentarios
```bash
repomix --remove-comments
```

### Mostrar números de línea
```bash
repomix --output-show-line-numbers
```

### Copiar al portapapeles
```bash
repomix --copy
```

### Deshabilitar la verificación de seguridad
```bash
repomix --no-security-check
```

## Configuración

Inicializar el archivo de configuración:
```bash
repomix --init
```

Consulta la [Guía de configuración](/guide/configuration) para obtener opciones detalladas.
</file>

<file path="website/client/src/es/index.md">
---
layout: home
title: Repomix
titleTemplate: Empaqueta tu código en formatos amigables para la IA
aside: false
editLink: false

features:
  - icon: 🤖
    title: Optimizado para IA
    details: Formatea tu código de una manera que sea fácil de entender y procesar para la IA.

  - icon: ⚙️
    title: Compatible con Git
    details: Respeta automáticamente tus archivos .gitignore.

  - icon: 🛡️
    title: Enfocado en la seguridad
    details: Incorpora Secretlint para realizar robustas comprobaciones de seguridad que detectan y previenen la inclusión de información sensible.

  - icon: 📊
    title: Conteo de tokens
    details: Proporciona recuentos de tokens para cada archivo y para todo el repositorio, útil para los límites de contexto de los LLM.

---

<script setup>
import YouTubeVideo from '../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../utils/videos'
</script>

<div class="cli-section">

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## 🏆 Nominación a los Open Source Awards

¡Estamos honrados! Repomix ha sido nominado en la categoría **Powered by AI** en los [JSNation Open Source Awards 2025](https://osawards.com/javascript/).

¡Esto no habría sido posible sin todos ustedes que usan y apoyan Repomix. ¡Gracias!

Si Repomix te ha ayudado a analizar o empaquetar bases de código para herramientas de IA, agradeceríamos tu voto en la categoría **Powered by AI**.

## ¿Qué es Repomix?

Repomix es una herramienta poderosa que empaqueta toda tu base de código en un solo archivo compatible con IA. Ya sea que estés trabajando en revisiones de código, refactoring o necesites asistencia de IA para tu proyecto, Repomix facilita compartir todo el contexto de tu repositorio con herramientas de IA.

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

## Inicio rápido

Una vez que hayas generado un archivo empaquetado (`repomix-output.xml`) usando Repomix, puedes enviarlo a un asistente de IA (como ChatGPT, Claude) con un prompt como:

```
Este archivo contiene todos los archivos del repositorio combinados en uno.
Quiero refactorizar el código, así que por favor revísalo primero.
```

La IA analizará todo tu código y proporcionará información completa:

![Repomix File Usage 1](/images/docs/repomix-file-usage-1.png)

Al discutir cambios específicos, la IA puede ayudar a generar código. Con funciones como los Artefactos de Claude, incluso puedes recibir múltiples archivos interdependientes:

![Repomix File Usage 2](/images/docs/repomix-file-usage-2.png)

¡Feliz programación! 🚀



## Usando la herramienta CLI {#using-the-cli-tool}

Repomix puede usarse como una herramienta de línea de comandos, ofreciendo potentes funciones y opciones de personalización.

**La herramienta CLI puede acceder a repositorios privados** ya que utiliza tu Git instalado localmente.

### Inicio rápido

Puedes probar Repomix instantáneamente en el directorio de tu proyecto sin necesidad de instalación:

```bash
npx repomix
```

O instalarlo globalmente para uso repetido:

```bash
# Instalar usando npm
npm install -g repomix

# O con yarn
yarn global add repomix

# O con bun
bun add -g repomix

# O con Homebrew (macOS/Linux)
brew install repomix

# Luego ejecutar en cualquier directorio de proyecto
repomix
```

¡Eso es todo! Repomix generará un archivo `repomix-output.xml` en tu directorio actual, que contendrá todo tu repositorio en un formato amigable para la IA.



### Uso

Para empaquetar todo tu repositorio:

```bash
repomix
```

Para empaquetar un directorio específico:

```bash
repomix ruta/al/directorio
```

Para empaquetar archivos o directorios específicos usando [patrones glob](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):

```bash
repomix --include "src/**/*.ts,**/*.md"
```

Para excluir archivos o directorios específicos:

```bash
repomix --ignore "**/*.log,tmp/"
```

Para empaquetar un repositorio remoto:
```bash
# Usando formato abreviado
npx repomix --remote yamadashy/repomix

# Usando URL completa (soporta ramas y rutas específicas)
npx repomix --remote https://github.com/yamadashy/repomix
npx repomix --remote https://github.com/yamadashy/repomix/tree/main

# Usando URL de confirmación
npx repomix --remote https://github.com/yamadashy/repomix/commit/836abcd7335137228ad77feb28655d85712680f1
```

Para inicializar un nuevo archivo de configuración (`repomix.config.json`):

```bash
repomix --init
```

Una vez que hayas generado el archivo empaquetado, puedes usarlo con herramientas de IA generativa como Claude, ChatGPT y Gemini.

#### Uso de Docker

También puedes ejecutar Repomix usando Docker 🐳  
Esto es útil si deseas ejecutar Repomix en un entorno aislado o prefieres usar contenedores.

Uso básico (directorio actual):

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

Para empaquetar un directorio específico:
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix ruta/al/directorio
```

Procesar un repositorio remoto y generar la salida en un directorio `output`:

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### Formatos de salida

Elige tu formato de salida preferido:

```bash
# Formato XML (predeterminado)
repomix --style xml

# Formato Markdown
repomix --style markdown

# Formato de texto plano
repomix --style plain
```

### Personalización

Crea un archivo `repomix.config.json` para configuraciones persistentes:

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

## Guía para Usuarios Avanzados

Repomix ofrece características poderosas para casos de uso avanzados. Aquí tienes algunas guías esenciales para usuarios avanzados:

- **[Servidor MCP](./guide/mcp-server)** - Integración del Protocolo de Contexto de Modelo para asistentes de IA
- **[GitHub Actions](./guide/github-actions)** - Automatiza el empaquetado de código base en flujos de trabajo CI/CD
- **[Compresión de Código](./guide/code-compress)** - Compresión inteligente basada en Tree-sitter (~70% de reducción de tokens)
- **[Usar como Biblioteca](./guide/development/using-repomix-as-a-library)** - Integra Repomix en tus aplicaciones Node.js
- **[Instrucciones Personalizadas](./guide/custom-instructions)** - Añade prompts e instrucciones personalizadas a las salidas
- **[Características de Seguridad](./guide/security)** - Integración incorporada de Secretlint y verificaciones de seguridad
- **[Mejores Prácticas](./guide/tips/best-practices)** - Optimiza tus flujos de trabajo de IA con estrategias probadas

### Más ejemplos
::: tip ¿Necesitas más ayuda? 💡
Consulta nuestra [guía](./guide/) para instrucciones detalladas, o visita nuestro [repositorio de GitHub](https://github.com/yamadashy/repomix) para más ejemplos y código fuente.
:::

</div>
</file>

<file path="website/client/src/fr/guide/development/index.md">
# Contribuer à Repomix

Merci pour votre intérêt pour **Repomix** ! 🚀 Nous apprécions votre aide pour l'améliorer davantage. Ce guide vous aidera à commencer à contribuer au projet.

## Comment contribuer

- **Mettre une étoile au dépôt** : Montrez votre soutien en [ajoutant une étoile au dépôt](https://github.com/yamadashy/repomix) !
- **Créer un ticket** : Vous avez repéré un bug ? Vous avez une idée pour une nouvelle fonctionnalité ? Faites-le nous savoir en [créant un ticket](https://github.com/yamadashy/repomix/issues).
- **Soumettre une Pull Request** : Vous avez trouvé quelque chose à corriger ou à améliorer ? Soumettez une PR !
- **Faire passer le mot** : Partagez votre expérience avec Repomix sur les réseaux sociaux, les blogs ou avec votre communauté tech.
- **Utiliser Repomix** : Les meilleurs retours viennent de l'utilisation réelle, alors n'hésitez pas à intégrer Repomix dans vos propres projets !
- **Sponsoriser** : Soutenez le développement de Repomix en [devenant sponsor](https://github.com/sponsors/yamadashy).

## Démarrage rapide

```bash
git clone https://github.com/yamadashy/repomix.git
cd repomix
npm install
```

## Commandes de développement

```bash
# Exécuter le CLI
npm run repomix
# Exécuter les tests
npm run test
npm run test-coverage
# Linter le code
npm run lint
```

## Style de code

- Utiliser [Biome](https://biomejs.dev/) pour le linting et le formatage
- Injection de dépendances pour la testabilité
- Maintenir les fichiers en dessous de 250 lignes
- Ajouter des tests pour les nouvelles fonctionnalités

## Directives pour les Pull Requests

1. Exécuter tous les tests
2. Passer les vérifications de linting
3. Mettre à jour la documentation
4. Suivre le style de code existant

## Configuration de développement

### Prérequis

- Node.js ≥ 18.0.0
- Git
- npm
- Docker (optionnel, pour exécuter le site web ou le développement conteneurisé)

### Développement local

Pour configurer Repomix pour le développement local :

```bash
# Cloner le dépôt
git clone https://github.com/yamadashy/repomix.git
cd repomix

# Installer les dépendances
npm install

# Exécuter le CLI
npm run repomix
```

### Développement avec Docker

Vous pouvez également exécuter Repomix en utilisant Docker :

```bash
# Construire l'image
docker build -t repomix .

# Exécuter le conteneur
docker run -v ./:/app -it --rm repomix
```

### Structure du projet

Le projet est organisé dans les répertoires suivants :

```
src/
├── cli/          # Implémentation CLI
├── config/       # Gestion de la configuration
├── core/         # Fonctionnalités principales
│   ├── file/     # Gestion des fichiers
│   ├── metrics/  # Calcul des métriques
│   ├── output/   # Génération de sortie
│   ├── security/ # Vérifications de sécurité
├── mcp/          # Intégration du serveur MCP
└── shared/       # Utilitaires partagés
tests/            # Tests reflétant la structure src/
website/          # Site web de documentation
├── client/       # Frontend (VitePress)
└── server/       # API Backend
```

## Développement du site web

Le site web Repomix est construit avec [VitePress](https://vitepress.dev/). Pour exécuter le site web localement :

```bash
# Prérequis : Docker doit être installé sur votre système

# Démarrer le serveur de développement du site web
npm run website

# Accéder au site web à http://localhost:5173/
```

Lors de la mise à jour de la documentation, vous devez uniquement mettre à jour la version anglaise en premier. Les mainteneurs s'occuperont des traductions vers d'autres langues.

## Processus de publication

Pour les mainteneurs et les contributeurs intéressés par le processus de publication :

1. Mettre à jour la version
```bash
npm version patch  # ou minor/major
```

2. Exécuter les tests et la construction
```bash
npm run test-coverage
npm run build
```

3. Publier
```bash
npm publish
```

Les nouvelles versions sont gérées par le mainteneur. Si vous pensez qu'une publication est nécessaire, ouvrez un ticket pour en discuter.

## Besoin d'aide?

- [Ouvrir un ticket](https://github.com/yamadashy/repomix/issues)
- [Rejoindre Discord](https://discord.gg/wNYzTwZFku)
</file>

<file path="website/client/src/fr/guide/development/using-repomix-as-a-library.md">
# Utiliser Repomix comme bibliothèque

En plus d'utiliser Repomix comme outil CLI, vous pouvez intégrer ses fonctionnalités directement dans vos applications Node.js.

## Installation

Installez Repomix comme dépendance dans votre projet :

```bash
npm install repomix
```

## Utilisation de base

La façon la plus simple d'utiliser Repomix est via la fonction `runCli`, qui fournit les mêmes fonctionnalités que l'interface en ligne de commande :

```javascript
import { runCli, type CliOptions } from 'repomix';

// Traiter le répertoire courant avec des options personnalisées
async function packProject() {
  const options = {
    output: 'output.xml',
    style: 'xml',
    compress: true,
    quiet: true
  } as CliOptions;
  
  const result = await runCli(['.'], process.cwd(), options);
  return result.packResult;
}
```

Le `result.packResult` contient des informations sur les fichiers traités, notamment :
- `totalFiles` : Nombre de fichiers traités
- `totalCharacters` : Nombre total de caractères
- `totalTokens` : Nombre total de tokens (utile pour les limites de contexte des LLM)
- `fileCharCounts` : Nombre de caractères par fichier
- `fileTokenCounts` : Nombre de tokens par fichier

## Traitement des dépôts distants

Vous pouvez cloner et traiter un dépôt distant :

```javascript
import { runCli, type CliOptions } from 'repomix';

// Cloner et traiter un dépôt GitHub
async function processRemoteRepo(repoUrl) {
  const options = {
    remote: repoUrl,
    output: 'output.xml',
    compress: true
  } as CliOptions;
  
  return await runCli(['.'], process.cwd(), options);
}
```

## Utilisation des composants principaux

Pour un contrôle plus précis, vous pouvez utiliser directement les API de bas niveau de Repomix :

```javascript
import { searchFiles, collectFiles, processFiles, TokenCounter } from 'repomix';

async function analyzeFiles(directory) {
  // Rechercher et collecter les fichiers
  const { filePaths } = await searchFiles(directory, { /* configuration */ });
  const rawFiles = await collectFiles(filePaths, directory);
  const processedFiles = await processFiles(rawFiles, { /* configuration */ });
  
  // Compter les tokens
  const tokenCounter = new TokenCounter('o200k_base');
  
  // Retourner les résultats d'analyse
  return processedFiles.map(file => ({
    path: file.path,
    tokens: tokenCounter.countTokens(file.content)
  }));
}
```

## Exemple concret

Le site web de Repomix ([repomix.com](https://repomix.com)) utilise Repomix comme bibliothèque pour traiter les dépôts distants. Vous pouvez consulter l'implémentation dans [website/server/src/remoteRepo.ts](https://github.com/yamadashy/repomix/blob/main/website/server/src/remoteRepo.ts).
</file>

<file path="website/client/src/fr/guide/tips/best-practices.md">
# Meilleures pratiques de développement assisté par IA : De mon expérience

Bien que je n'aie pas encore réussi à mener à bien un projet à grande échelle en utilisant l'IA, je souhaite partager ce que j'ai appris jusqu'à présent de mon expérience de travail avec l'IA dans le développement.

## Approche de développement de base

Lorsque l'on travaille avec l'IA, tenter d'implémenter toutes les fonctionnalités en une fois peut conduire à des problèmes inattendus et à une stagnation du projet. C'est pourquoi il est plus efficace de commencer par les fonctionnalités principales et de construire chaque fonctionnalité une par une, en s'assurant d'une implémentation solide avant d'avancer.

### La puissance du code existant

Cette approche est efficace car l'implémentation des fonctionnalités principales vous permet de matérialiser votre design idéal et votre style de codage à travers du code réel. La manière la plus efficace de communiquer votre vision du projet est à travers du code qui reflète vos standards et préférences.

En commençant par les fonctionnalités principales et en s'assurant que chaque composant fonctionne correctement avant de passer à la suite, l'ensemble du projet maintient sa cohérence, rendant plus facile pour l'IA de générer du code plus approprié.

## L'approche modulaire

La décomposition du code en modules plus petits est cruciale. D'après mon expérience, maintenir les fichiers autour de 250 lignes de code rend plus facile de donner des instructions claires à l'IA et rend le processus d'essai-erreur plus efficace. Bien que le nombre de tokens serait une métrique plus précise, le nombre de lignes est plus pratique pour les développeurs humains, nous utilisons donc cela comme ligne directrice.

Cette modularisation ne consiste pas seulement à séparer les composants frontend, backend et base de données - il s'agit de décomposer les fonctionnalités à un niveau beaucoup plus fin. Par exemple, au sein d'une même fonctionnalité, vous pourriez séparer la validation, la gestion des erreurs et d'autres fonctionnalités spécifiques en modules distincts. Bien sûr, la séparation de haut niveau est également importante, et implémenter cette approche modulaire progressivement aide à maintenir des instructions claires et permet à l'IA de générer du code plus approprié. Cette approche est efficace non seulement pour l'IA mais aussi pour les développeurs humains.

## Assurer la qualité par les tests

Je considère que les tests sont cruciaux dans le développement assisté par IA. Les tests servent non seulement de mesures d'assurance qualité mais aussi de documentation qui démontre clairement les intentions du code. Lorsque vous demandez à l'IA d'implémenter de nouvelles fonctionnalités, le code de test existant agit efficacement comme un document de spécification.

Les tests sont également un excellent outil pour valider l'exactitude du code généré par l'IA. Par exemple, lorsque vous faites implémenter une nouvelle fonctionnalité pour un module par l'IA, écrire des cas de test au préalable vous permet d'évaluer objectivement si le code généré se comporte comme prévu. Cela s'aligne bien avec les principes du Développement Piloté par les Tests (TDD) et est particulièrement efficace lors de la collaboration avec l'IA.

## Équilibrer planification et implémentation

Avant d'implémenter des fonctionnalités à grande échelle, je recommande de d'abord discuter du plan avec l'IA. Organiser les exigences et réfléchir à l'architecture conduit à une implémentation plus fluide. Une bonne pratique consiste à compiler d'abord les exigences, puis passer à une session de chat séparée pour le travail d'implémentation.

Il est essentiel que les humains examinent la sortie de l'IA et fassent des ajustements si nécessaire. Bien que la qualité du code généré par l'IA soit généralement modérée, cela accélère tout de même le développement par rapport à l'écriture de tout à partir de zéro.

## Conclusion

En suivant ces pratiques, vous pouvez exploiter les points forts de l'IA tout en construisant une base de code cohérente et de haute qualité. Même lorsque votre projet grandit en taille, chaque composant reste bien défini et gérable.
</file>

<file path="website/client/src/fr/guide/code-compress.md">
# Compression de code

La compression de code est une fonctionnalité puissante qui extrait intelligemment les structures de code essentielles tout en supprimant les détails d'implémentation. C'est particulièrement utile pour réduire le nombre de tokens tout en conservant les informations structurelles importantes de votre base de code.

> [!NOTE]  
> Il s'agit d'une fonctionnalité expérimentale que nous améliorerons activement en fonction des retours utilisateurs et de l'usage réel

## Utilisation de base

Activez la compression de code en utilisant l'option `--compress`:

```bash
repomix --compress
```

Vous pouvez également l'utiliser avec des dépôts distants:

```bash
repomix --remote user/repo --compress
```

## Fonctionnement

L'algorithme de compression traite le code en utilisant l'analyse tree-sitter pour extraire et préserver les éléments structurels essentiels tout en supprimant les détails d'implémentation.

La compression préserve:
- Les signatures de fonctions et de méthodes
- Les définitions d'interfaces et de types
- Les structures de classes et leurs propriétés
- Les éléments structurels importants

Tout en supprimant:
- Les implémentations de fonctions et de méthodes
- Les détails de logique des boucles et conditions
- Les déclarations de variables internes
- Le code spécifique à l'implémentation

### Exemple

Code TypeScript original:

```typescript
import { ShoppingItem } from './shopping-item';
/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
  let total = 0;
  for (const item of items) {
    total += item.price * item.quantity;
  }
  return total;
}
// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

Après compression:

```typescript
import { ShoppingItem } from './shopping-item';
⋮----
/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
⋮----
// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

## Configuration

Vous pouvez activer la compression dans votre fichier de configuration:

```json
{
  "output": {
    "compress": true
  }
}
```

## Cas d'utilisation

La compression de code est particulièrement utile pour:
- Analyser la structure et l'architecture du code
- Réduire le nombre de tokens pour le traitement par les LLM
- Créer une documentation de haut niveau
- Comprendre les motifs de code et les signatures
- Partager les conceptions d'API et d'interfaces

## Options associées

Vous pouvez combiner la compression avec d'autres options:
- `--remove-comments`: Supprimer les commentaires du code
- `--remove-empty-lines`: Supprimer les lignes vides
- `--output-show-line-numbers`: Ajouter les numéros de ligne à la sortie
</file>

<file path="website/client/src/fr/guide/command-line-options.md">
# Options de ligne de commande

## Options de base
- `-v, --version`: Afficher la version de l'outil

## Options de sortie
- `-o, --output <fichier>`: Nom du fichier de sortie (par défaut: `repomix-output.txt`)
- `--stdout`: Sortie vers la sortie standard au lieu d'écrire dans un fichier (ne peut pas être utilisé avec l'option `--output`)
- `--style <type>`: Style de sortie (`plain`, `xml`, `markdown`) (par défaut: `xml`)
- `--parsable-style`: Activer une sortie analysable basée sur le schéma du style choisi (par défaut: `false`)
- `--compress`: Effectuer une extraction intelligente du code, en se concentrant sur les signatures essentielles de fonctions et de classes tout en supprimant les détails d'implémentation. Pour plus de détails et d'exemples, voir [Guide de compression de code](code-compress).
- `--output-show-line-numbers`: Ajouter les numéros de ligne (par défaut: `false`)
- `--copy`: Copier dans le presse-papiers (par défaut: `false`)
- `--no-file-summary`: Désactiver le résumé des fichiers (par défaut: `true`)
- `--no-directory-structure`: Désactiver la structure des répertoires (par défaut: `true`)
- `--no-files`: Désactiver la sortie du contenu des fichiers (mode métadonnées uniquement) (par défaut: `true`)
- `--remove-comments`: Supprimer les commentaires (par défaut: `false`)
- `--remove-empty-lines`: Supprimer les lignes vides (par défaut: `false`)
- `--header-text <texte>`: Texte personnalisé à inclure dans l'en-tête du fichier
- `--instruction-file-path <chemin>`: Chemin vers un fichier contenant des instructions personnalisées détaillées
- `--include-empty-directories`: Inclure les répertoires vides dans la sortie (par défaut: `false`)
- `--include-diffs`: Inclure les différences git dans la sortie (inclut séparément les modifications de l'arbre de travail et les modifications indexées) (par défaut: `false`)

## Options de filtrage
- `--include <motifs>`: Motifs d'inclusion (séparés par des virgules)
- `-i, --ignore <motifs>`: Motifs d'exclusion (séparés par des virgules)
- `--stdin`: Lire les chemins de fichiers depuis stdin au lieu de découvrir automatiquement les fichiers
- `--no-gitignore`: Désactiver l'utilisation du fichier .gitignore
- `--no-default-patterns`: Désactiver les motifs par défaut

## Options de dépôt distant
- `--remote <url>`: Traiter un dépôt distant
- `--remote-branch <n>`: Spécifier le nom de la branche distante, le tag ou le hash de commit (par défaut: branche par défaut du dépôt)

## Options de configuration
- `-c, --config <chemin>`: Chemin du fichier de configuration personnalisé
- `--init`: Créer un fichier de configuration
- `--global`: Utiliser la configuration globale

## Options de sécurité
- `--no-security-check`: Désactiver la vérification de sécurité (par défaut: `true`)

## Options de comptage de tokens
- `--token-count-encoding <encodage>`: Spécifier l'encodage du comptage de tokens (par exemple, `o200k_base`, `cl100k_base`) (par défaut: `o200k_base`)

## Autres options
- `--top-files-len <nombre>`: Nombre de fichiers principaux à afficher (par défaut: `5`)
- `--verbose`: Activer la journalisation détaillée
- `--quiet`: Désactiver toutes les sorties vers stdout

## Exemples

```bash
# Utilisation de base
repomix

# Sortie personnalisée
repomix -o output.xml --style xml

# Sortie vers la sortie standard
repomix --stdout > custom-output.txt

# Envoi de la sortie vers la sortie standard, puis redirection vers une autre commande (par exemple, simonw/llm)
repomix --stdout | llm "Veuillez expliquer ce que fait ce code"

# Sortie personnalisée avec compression
repomix --compress

# Traiter des fichiers spécifiques
repomix --include "src/**/*.ts" --ignore "**/*.test.ts"

# Dépôt distant avec branche
repomix --remote https://github.com/user/repo/tree/main

# Dépôt distant avec commit
repomix --remote https://github.com/user/repo/commit/836abcd7335137228ad77feb28655d85712680f1

# Dépôt distant avec format abrégé
repomix --remote user/repo

# Liste de fichiers utilisant stdin
find src -name "*.ts" -type f | repomix --stdin
git ls-files "*.js" | repomix --stdin
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```
</file>

<file path="website/client/src/fr/guide/comment-removal.md">
# Suppression des commentaires

Repomix peut automatiquement supprimer les commentaires de votre base de code lors de la génération du fichier de sortie. Cela peut aider à réduire le bruit et à se concentrer sur le code réel.

## Utilisation

Pour activer la suppression des commentaires, définissez l'option `removeComments` sur `true` dans votre `repomix.config.json`:

```json
{
  "output": {
    "removeComments": true
  }
}
```

## Langages pris en charge

Repomix prend en charge la suppression des commentaires pour une large gamme de langages de programmation, notamment:

- JavaScript/TypeScript (`//`, `/* */`)
- Python (`#`, `"""`, `'''`)
- Java (`//`, `/* */`)
- C/C++ (`//`, `/* */`)
- HTML (`<!-- -->`)
- CSS (`/* */`)
- Et bien d'autres...

## Exemple

Considérons le code JavaScript suivant:

```javascript
// Ceci est un commentaire sur une ligne
function test() {
  /* Ceci est un
     commentaire sur
     plusieurs lignes */
  return true;
}
```

Avec la suppression des commentaires activée, la sortie sera:

```javascript
function test() {
  return true;
}
```

## Remarques

- La suppression des commentaires est effectuée avant les autres étapes de traitement, comme l'ajout de numéros de ligne.
- Certains commentaires, comme les commentaires JSDoc, peuvent être préservés selon le langage et le contexte.
</file>

<file path="website/client/src/fr/guide/configuration.md">
# Configuration

Repomix peut être configuré à l'aide d'un fichier de configuration (`repomix.config.json`) ou d'options en ligne de commande. Le fichier de configuration vous permet de personnaliser divers aspects du traitement et de la sortie de votre base de code.

## Démarrage rapide

Créez un fichier de configuration dans votre répertoire de projet :
```bash
repomix --init
```

Cela créera un fichier `repomix.config.json` avec les paramètres par défaut. Vous pouvez également créer un fichier de configuration global qui sera utilisé comme solution de repli lorsqu'aucune configuration locale n'est trouvée :

```bash
repomix --init --global
```

## Options de configuration

| Option                           | Description                                                                                                                  | Défaut                |
|----------------------------------|------------------------------------------------------------------------------------------------------------------------------|------------------------|
| `input.maxFileSize`              | Taille maximale des fichiers à traiter en octets. Les fichiers plus grands seront ignorés. Utile pour exclure les fichiers binaires volumineux ou les fichiers de données | `50000000`            |
| `output.filePath`                | Nom du fichier de sortie. Prend en charge les formats XML, Markdown et texte brut                                            | `"repomix-output.xml"` |
| `output.style`                   | Style de sortie (`xml`, `markdown`, `plain`). Chaque format a ses propres avantages pour différents outils d'IA              | `"xml"`                |
| `output.parsableStyle`           | Indique s'il faut échapper la sortie selon le schéma de style choisi. Permet une meilleure analyse mais peut augmenter le nombre de tokens | `false`                |
| `output.compress`                | Indique s'il faut effectuer une extraction intelligente du code à l'aide de Tree-sitter pour réduire le nombre de tokens tout en préservant la structure | `false`                |
| `output.headerText`              | Texte personnalisé à inclure dans l'en-tête du fichier. Utile pour fournir du contexte ou des instructions aux outils d'IA   | `null`                 |
| `output.instructionFilePath`     | Chemin vers un fichier contenant des instructions personnalisées détaillées pour le traitement par l'IA                      | `null`                 |
| `output.fileSummary`             | Indique s'il faut inclure une section de résumé au début montrant le nombre de fichiers, les tailles et d'autres métriques  | `true`                 |
| `output.directoryStructure`      | Indique s'il faut inclure la structure des répertoires dans la sortie. Aide l'IA à comprendre l'organisation du projet      | `true`                 |
| `output.files`                   | Indique s'il faut inclure le contenu des fichiers dans la sortie. Mettre à false pour n'inclure que la structure et les métadonnées | `true`                 |
| `output.removeComments`          | Indique s'il faut supprimer les commentaires des types de fichiers pris en charge. Peut réduire le bruit et le nombre de tokens | `false`                |
| `output.removeEmptyLines`        | Indique s'il faut supprimer les lignes vides de la sortie pour réduire le nombre de tokens                                   | `false`                |
| `output.showLineNumbers`         | Indique s'il faut ajouter des numéros de ligne à chaque ligne. Utile pour référencer des parties spécifiques du code        | `false`                |
| `output.copyToClipboard`         | Indique s'il faut copier la sortie dans le presse-papiers système en plus de sauvegarder le fichier                         | `false`                |
| `output.topFilesLength`          | Nombre de fichiers principaux à afficher dans le résumé. Si défini à 0, aucun résumé ne sera affiché                        | `5`                    |
| `output.includeEmptyDirectories` | Indique s'il faut inclure les répertoires vides dans la structure du dépôt                                                   | `false`                |
| `output.git.sortByChanges`       | Indique s'il faut trier les fichiers par nombre de modifications git. Les fichiers avec plus de modifications apparaissent en bas | `true`                 |
| `output.git.sortByChangesMaxCommits` | Nombre maximum de commits à analyser pour les modifications git. Limite la profondeur de l'historique pour les performances | `100`                  |
| `output.git.includeDiffs`        | Indique s'il faut inclure les différences git dans la sortie. Montre séparément les modifications de l'arborescence de travail et les modifications indexées | `false`                |
| `include`                        | Motifs des fichiers à inclure en utilisant les [motifs glob](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax) | `[]`                   |
| `ignore.useGitignore`            | Indique s'il faut utiliser les motifs du fichier `.gitignore` du projet                                                      | `true`                 |
| `ignore.useDefaultPatterns`      | Indique s'il faut utiliser les motifs d'ignorance par défaut (node_modules, .git, etc.)                                    | `true`                 |
| `ignore.customPatterns`          | Motifs supplémentaires à ignorer en utilisant les [motifs glob](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax) | `[]`                   |
| `security.enableSecurityCheck`   | Indique s'il faut effectuer des vérifications de sécurité à l'aide de Secretlint pour détecter les informations sensibles   | `true`                 |
| `tokenCount.encoding`            | Encodage du comptage des tokens utilisé par le tokenizer [tiktoken](https://github.com/openai/tiktoken) d'OpenAI. Utilisez `o200k_base` pour GPT-4o, `cl100k_base` pour GPT-4/3.5. Voir [tiktoken model.py](https://github.com/openai/tiktoken/blob/main/tiktoken/model.py#L24) pour plus de détails. | `"o200k_base"`         |

Le fichier de configuration prend en charge la syntaxe [JSON5](https://json5.org/), qui permet :
- Les commentaires (à la fois sur une seule ligne et sur plusieurs lignes)
- Les virgules finales dans les objets et les tableaux
- Les noms de propriétés non entre guillemets
- Une syntaxe de chaîne plus souple

## Validation de schéma

Vous pouvez activer la validation de schéma pour votre fichier de configuration en ajoutant la propriété `$schema` :

```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "output": {
    "filePath": "repomix-output.md",
    "style": "markdown"
  }
}
```

Cela fournit l'auto-complétion et la validation dans les éditeurs qui prennent en charge le schéma JSON.

## Exemple de fichier de configuration

Voici un exemple de fichier de configuration complet (`repomix.config.json`) :

```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 50000000
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "compress": false,
    "headerText": "Informations d'en-tête personnalisées pour le fichier compressé.",
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "includeEmptyDirectories": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false
    }
  },
  "include": ["**/*"],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    // Les motifs peuvent également être spécifiés dans .repomixignore
    "customPatterns": [
      "additional-folder",
      "**/*.log"
    ],
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
```

## Emplacements des fichiers de configuration

Repomix recherche les fichiers de configuration dans l'ordre suivant :
1. Fichier de configuration local (`repomix.config.json`) dans le répertoire courant
2. Fichier de configuration global :
   - Windows : `%LOCALAPPDATA%\Repomix\repomix.config.json`
   - macOS/Linux : `~/.config/repomix/repomix.config.json`

Les options en ligne de commande ont la priorité sur les paramètres du fichier de configuration.

## Motifs d'ignorance

Repomix propose plusieurs façons de spécifier quels fichiers doivent être ignorés. Les motifs sont traités dans l'ordre de priorité suivant :

1. Options CLI (`--ignore`)
2. Fichier `.repomixignore` dans le répertoire du projet
3. `.gitignore` et `.git/info/exclude` (si `ignore.useGitignore` est vrai)
4. Motifs par défaut (si `ignore.useDefaultPatterns` est vrai)

Exemple de `.repomixignore` :
```text
# Répertoires de cache
.cache/
tmp/

# Sorties de build
dist/
build/

# Logs
*.log
```

## Motifs d'ignorance par défaut

Lorsque `ignore.useDefaultPatterns` est vrai, Repomix ignore automatiquement les motifs courants :
```text
node_modules/**
.git/**
coverage/**
dist/**
```

Pour la liste complète, voir [defaultIgnore.ts](https://github.com/yamadashy/repomix/blob/main/src/config/defaultIgnore.ts)

## Fonctionnalités avancées

### Compression du code

La fonction de compression du code, activée avec `output.compress: true`, utilise [Tree-sitter](https://github.com/tree-sitter/tree-sitter) pour extraire intelligemment les structures de code essentielles tout en supprimant les détails d'implémentation. Cela aide à réduire le nombre de tokens tout en maintenant les informations structurelles importantes.

Avantages principaux :
- Réduit significativement le nombre de tokens
- Préserve les signatures des classes et des fonctions
- Maintient les imports et exports
- Conserve les définitions de types et les interfaces
- Supprime les corps de fonctions et les détails d'implémentation

Pour plus de détails et d'exemples, consultez le [Guide de compression du code](code-compress).

### Intégration Git

La configuration `output.git` fournit des fonctionnalités puissantes liées à Git :

- `sortByChanges` : Lorsque vrai, les fichiers sont triés par nombre de modifications Git (commits qui ont modifié le fichier). Les fichiers avec plus de modifications apparaissent en bas de la sortie. Cela aide à prioriser les fichiers plus activement développés. Par défaut : `true`
- `sortByChangesMaxCommits` : Le nombre maximum de commits à analyser lors du comptage des modifications de fichiers. Par défaut : `100`
- `includeDiffs` : Lorsque vrai, inclut les différences Git dans la sortie (inclut séparément les modifications de l'arborescence de travail et les modifications indexées). Cela permet au lecteur de voir les modifications en attente dans le dépôt. Par défaut : `false`

Exemple de configuration :
```json
{
  "output": {
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": true
    }
  }
}
```

### Vérifications de sécurité

Lorsque `security.enableSecurityCheck` est activé, Repomix utilise [Secretlint](https://github.com/secretlint/secretlint) pour détecter les informations sensibles dans votre base de code avant de les inclure dans la sortie. Cela aide à prévenir l'exposition accidentelle de :

- Clés API
- Jetons d'accès
- Clés privées
- Mots de passe
- Autres informations d'identification sensibles

### Suppression des commentaires

Lorsque `output.removeComments` est défini à `true`, les commentaires sont supprimés des types de fichiers pris en charge pour réduire la taille de sortie et se concentrer sur le contenu essentiel du code. Cela peut être particulièrement utile lorsque :

- Vous travaillez avec du code fortement documenté
- Vous essayez de réduire le nombre de tokens
- Vous vous concentrez sur la structure et la logique du code

Pour les langages pris en charge et des exemples détaillés, consultez le [Guide de suppression des commentaires](comment-removal).
</file>

<file path="website/client/src/fr/guide/custom-instructions.md">
# Instructions personnalisées

Repomix vous permet de fournir des instructions personnalisées qui seront incluses dans le fichier de sortie. Cela peut être utile pour ajouter du contexte ou des directives spécifiques pour les systèmes d'IA traitant le dépôt.

## Utilisation

Pour inclure une instruction personnalisée, créez un fichier markdown (par exemple, `repomix-instruction.md`) à la racine de votre dépôt. Ensuite, spécifiez le chemin vers ce fichier dans votre `repomix.config.json`:

```json
{
  "output": {
    "instructionFilePath": "repomix-instruction.md"
  }
}
```

Le contenu de ce fichier sera inclus dans la sortie sous la section "Instruction".

## Exemple

```markdown
# Instructions du dépôt
Ce dépôt contient le code source de l'outil Repomix. Veuillez suivre ces directives lors de l'analyse du code:
1. Concentrez-vous sur les fonctionnalités principales dans le répertoire `src/core`.
2. Portez une attention particulière aux vérifications de sécurité dans `src/core/security`.
3. Ignorez tous les fichiers dans le répertoire `tests`.
```

Cela donnera la section suivante dans la sortie:

```xml
<instruction>
# Instructions du dépôt
Ce dépôt contient le code source de l'outil Repomix. Veuillez suivre ces directives lors de l'analyse du code:
1. Concentrez-vous sur les fonctionnalités principales dans le répertoire `src/core`.
2. Portez une attention particulière aux vérifications de sécurité dans `src/core/security`.
3. Ignorez tous les fichiers dans le répertoire `tests`.
</instruction>
```
</file>

<file path="website/client/src/fr/guide/github-actions.md">
# Utiliser Repomix avec GitHub Actions

Vous pouvez automatiser le packaging de votre codebase pour l'analyse par IA en intégrant Repomix dans vos workflows GitHub Actions. Ceci est utile pour l'intégration continue (CI), la revue de code ou la préparation pour des outils LLM.

## Utilisation de base

Ajoutez l'étape suivante à votre fichier YAML de workflow pour packager votre dépôt :

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.xml
```

## Utiliser différents formats de sortie

Vous pouvez spécifier différents formats de sortie en utilisant le paramètre `style` (le format par défaut est `xml`) :

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.md
    style: markdown
```

## Packager plusieurs dossiers avec compression

Vous pouvez spécifier plusieurs dossiers, des patterns d'inclusion/exclusion et activer la compression intelligente :

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src tests
    include: "**/*.ts,**/*.md"
    ignore: "**/*.test.ts"
    output: repomix-output.txt
    compress: true
```

## Télécharger le fichier généré comme artefact

Pour rendre le fichier packagé disponible pour les étapes suivantes ou pour le téléchargement, téléchargez-le comme artefact :

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src
    output: repomix-output.xml
    compress: true

- name: Upload Repomix output
  uses: actions/upload-artifact@v4
  with:
    name: repomix-output
    path: repomix-output.xml
```

## Paramètres d'entrée de l'Action

| Nom                | Description                                   | Par défaut        |
|--------------------|-----------------------------------------------|-------------------|
| `directories`      | Liste des dossiers à packager (séparés par espace) | `.`           |
| `include`          | Patterns glob à inclure (séparés par virgule) | `""`           |
| `ignore`           | Patterns glob à exclure (séparés par virgule) | `""`           |
| `output`           | Chemin du fichier de sortie                   | `repomix-output.xml`     |
| `style`            | Style de sortie (xml, markdown, plain)        | `xml`             |
| `compress`         | Activer la compression intelligente           | `true`            |
| `additional-args`  | Arguments supplémentaires pour repomix CLI    | `""`           |
| `repomix-version`  | Version du package npm à installer            | `latest`          |

## Sorties de l'Action

| Nom           | Description                        |
|---------------|------------------------------------|
| `output_file` | Chemin du fichier généré            |

## Exemple de workflow complet

Voici un exemple complet de workflow GitHub Actions utilisant Repomix :

```yaml
name: Pack repository with Repomix

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  pack-repo:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Pack repository with Repomix
        uses: yamadashy/repomix/.github/actions/repomix@main
        with:
          output: repomix-output.xml

      - name: Upload Repomix output
        uses: actions/upload-artifact@v4
        with:
          name: repomix-output.xml
          path: repomix-output.xml
          retention-days: 30
```

Consultez [l'exemple complet du workflow](https://github.com/yamadashy/repomix/blob/main/.github/workflows/pack-repository.yml).
</file>

<file path="website/client/src/fr/guide/index.md">
# Commencer avec Repomix

<script setup>
import HomeBadges from '../../../components/HomeBadges.vue'
import YouTubeVideo from '../../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../../utils/videos'
</script>

Repomix est un outil qui regroupe l'ensemble de votre dépôt de code en un seul fichier adapté à l'IA. Il est conçu pour vous aider à fournir votre base de code aux Grands Modèles de Langage (LLMs) comme ChatGPT, DeepSeek, Perplexity, Gemini, Gemma, Llama, Grok, et plus encore.

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

<HomeBadges />

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## Démarrage rapide

Exécutez cette commande dans le répertoire de votre projet:

```bash
npx repomix
```

C'est tout! Vous trouverez un fichier `repomix-output.xml` contenant l'intégralité de votre dépôt dans un format adapté à l'IA.

Vous pouvez ensuite envoyer ce fichier à un assistant IA avec une instruction comme:

```
Ce fichier contient tous les fichiers du dépôt combinés en un seul.
Je souhaite refactoriser le code, veuillez donc d'abord l'examiner.
```

L'IA analysera votre base de code complète et fournira des informations détaillées:

![Utilisation du fichier Repomix 1](/images/docs/repomix-file-usage-1.png)

Lors de la discussion de modifications spécifiques, l'IA peut vous aider à générer du code. Avec des fonctionnalités comme les Artefacts de Claude, vous pouvez même recevoir plusieurs fichiers interdépendants:

![Utilisation du fichier Repomix 2](/images/docs/repomix-file-usage-2.png)

Bon codage! 🚀

## Fonctionnalités principales

- **Sortie optimisée pour l'IA**: Formate votre base de code pour un traitement facile par l'IA
- **Comptage de tokens**: Suit l'utilisation des tokens pour les limites de contexte des LLM
- **Compatible avec Git**: Respecte vos fichiers `.gitignore` et `.git/info/exclude`
- **Axé sur la sécurité**: Détecte les informations sensibles
- **Plusieurs formats de sortie**: Choisissez entre texte brut, XML ou Markdown

## Prochaines étapes

- [Guide d'installation](installation.md): Différentes façons d'installer Repomix
- [Guide d'utilisation](usage.md): Découvrez les fonctionnalités de base et avancées
- [Configuration](configuration.md): Personnalisez Repomix selon vos besoins
- [Fonctionnalités de sécurité](security.md): Découvrez les vérifications de sécurité

## Communauté

Rejoignez notre [communauté Discord](https://discord.gg/wNYzTwZFku) pour:
- Obtenir de l'aide avec Repomix
- Partager vos expériences
- Suggérer de nouvelles fonctionnalités
- Vous connecter avec d'autres utilisateurs

## Support

Vous avez trouvé un bug ou besoin d'aide?
- [Ouvrez un ticket sur GitHub](https://github.com/yamadashy/repomix/issues)
- Rejoignez notre serveur Discord
- Consultez la [documentation](https://repomix.com)
</file>

<file path="website/client/src/fr/guide/installation.md">
# Installation

## Utilisation avec npx (Sans installation requise)

```bash
npx repomix
```

## Installation globale

### npm

```bash
npm install -g repomix
```

### Yarn

```bash
yarn global add repomix
```

### Bun

```bash
bun add -g repomix
```

### Homebrew (macOS/Linux)

```bash
brew install repomix
```

## Installation avec Docker

Téléchargez et exécutez l'image Docker:

```bash
# Répertoire courant
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
# Répertoire spécifique
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
# Dépôt distant
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote yamadashy/repomix
```

## Extension VSCode

Exécutez Repomix directement dans VSCode avec l'extension communautaire [Repomix Runner](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner).

Fonctionnalités:
- Empaquetez n'importe quel dossier en quelques clics
- Choisissez entre le mode fichier ou contenu pour la copie
- Nettoyage automatique des fichiers de sortie
- Compatible avec repomix.config.json

Installez-la depuis le [Marketplace VSCode](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner).

## Extension de navigateur

Accédez instantanément à Repomix directement depuis n'importe quel dépôt GitHub ! Notre extension Chrome ajoute un bouton "Repomix" pratique aux pages de dépôt GitHub.

![Repomix Browser Extension](/images/docs/browser-extension.png)

### Installation
- Extension Chrome : [Repomix - Chrome Web Store](https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa)
- Module Firefox : [Repomix - Firefox Add-ons](https://addons.mozilla.org/firefox/addon/repomix/)

### Fonctionnalités
- Accès en un clic à Repomix pour n'importe quel dépôt GitHub
- D'autres fonctionnalités passionnantes arrivent bientôt !

## Configuration requise

- Node.js: ≥ 18.0.0
- Git: Requis pour le traitement des dépôts distants

## Vérification

Après l'installation, vérifiez que Repomix fonctionne:

```bash
repomix --version
repomix --help
```
</file>

<file path="website/client/src/fr/guide/mcp-server.md">
# Serveur MCP

Repomix prend en charge le [Model Context Protocol (MCP)](https://modelcontextprotocol.io), permettant aux assistants IA d'interagir directement avec votre base de code. Lorsqu'il est exécuté en tant que serveur MCP, Repomix fournit des outils permettant aux assistants IA de packager des dépôts locaux ou distants pour analyse sans nécessiter de préparation manuelle des fichiers.

> [!NOTE]  
> Il s'agit d'une fonctionnalité expérimentale que nous améliorerons activement en fonction des retours utilisateurs et de l'usage réel

## Exécuter Repomix comme serveur MCP

Pour exécuter Repomix en tant que serveur MCP, utilisez l'option `--mcp`:
```bash
repomix --mcp
```

Cela démarre Repomix en mode serveur MCP, le rendant disponible pour les assistants IA qui prennent en charge le Model Context Protocol.

## Configuration des serveurs MCP

Pour utiliser Repomix comme serveur MCP avec des assistants IA comme Claude, vous devez configurer les paramètres MCP:

### Pour VS Code

Vous pouvez installer le serveur MCP Repomix dans VS Code en utilisant l'une de ces méthodes:

1. **Utilisation du badge d'installation :**

  [![Install in VS Code](https://img.shields.io/badge/VS_Code-VS_Code?style=flat-square&label=Install%20Server&color=0098FF)](vscode:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)<br>
  [![Install in VS Code Insiders](https://img.shields.io/badge/VS_Code_Insiders-VS_Code_Insiders?style=flat-square&label=Install%20Server&color=24bfa5)](vscode-insiders:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)

2. **Utilisation de la ligne de commande :**

  ```bash
  code --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

  Pour VS Code Insiders :
  ```bash
  code-insiders --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

### Pour Cline (extension VS Code)

Modifiez le fichier `cline_mcp_settings.json`:
```json
{
  "mcpServers": {
    "repomix": {
      "command": "npx",
      "args": [
        "-y",
        "repomix",
        "--mcp"
      ]
    }
  }
}
```

### Pour Cursor

Dans Cursor, ajoutez un nouveau serveur MCP depuis `Cursor Settings` > `MCP` > `+ Add new global MCP server` avec une configuration similaire à celle de Cline.

### Pour Claude Desktop

Modifiez le fichier `claude_desktop_config.json` avec une configuration similaire à celle de Cline.

### Pour Claude Code

Pour configurer Repomix comme serveur MCP dans [Claude Code](https://docs.anthropic.com/en/docs/claude-code/overview), utilisez la commande suivante:

```bash
claude mcp add repomix -- npx -y repomix --mcp
```

### Utilisation de Docker au lieu de npx

Au lieu d'utiliser npx, vous pouvez utiliser Docker pour exécuter Repomix en tant que serveur MCP:

```json
{
  "mcpServers": {
    "repomix-docker": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "ghcr.io/yamadashy/repomix",
        "--mcp"
      ]
    }
  }
}
```

## Outils MCP disponibles

En mode serveur MCP, Repomix fournit les outils suivants:

### pack_codebase

Cet outil package un répertoire de code local dans un fichier XML pour l'analyse par IA. Il analyse la structure de la base de code, extrait le contenu de code pertinent et génère un rapport complet incluant les métriques, l'arbre des fichiers et le contenu de code formaté.

**Paramètres:**
- `directory`: (Requis) Chemin absolu vers le répertoire à packager
- `compress`: (Optionnel, par défaut: false) Active la compression Tree-sitter pour extraire les signatures de code essentielles et la structure tout en supprimant les détails d'implémentation. Réduit l'utilisation de tokens d'environ 70% tout en préservant la signification sémantique. Généralement non nécessaire car grep_repomix_output permet la récupération incrémentale de contenu. Utilisez uniquement lorsque vous avez spécifiquement besoin du contenu complet de la base de code pour de gros dépôts.
- `includePatterns`: (Optionnel) Spécifie les fichiers à inclure en utilisant des motifs fast-glob. Plusieurs motifs peuvent être séparés par des virgules (ex: "**/*.{js,ts}", "src/**,docs/**"). Seuls les fichiers correspondants seront traités.
- `ignorePatterns`: (Optionnel) Spécifie les fichiers supplémentaires à exclure en utilisant des motifs fast-glob. Plusieurs motifs peuvent être séparés par des virgules (ex: "test/**,*.spec.js", "node_modules/**,dist/**"). Ces motifs complètent .gitignore et les exclusions intégrées.
- `topFilesLength`: (Optionnel, par défaut: 10) Nombre de plus gros fichiers par taille à afficher dans le résumé des métriques pour l'analyse de la base de code.

**Exemple:**
```json
{
  "directory": "/path/to/your/project",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### pack_remote_repository

Cet outil récupère, clone et package un dépôt GitHub dans un fichier XML pour l'analyse par IA. Il clone automatiquement le dépôt distant, analyse sa structure et génère un rapport complet.

**Paramètres:**
- `remote`: (Requis) URL du dépôt GitHub ou format utilisateur/dépôt (ex: "yamadashy/repomix", "https://github.com/user/repo", ou "https://github.com/user/repo/tree/branch")
- `compress`: (Optionnel, par défaut: false) Active la compression Tree-sitter pour extraire les signatures de code essentielles et la structure tout en supprimant les détails d'implémentation. Réduit l'utilisation de tokens d'environ 70% tout en préservant la signification sémantique. Généralement non nécessaire car grep_repomix_output permet la récupération incrémentale de contenu. Utilisez uniquement lorsque vous avez spécifiquement besoin du contenu complet de la base de code pour de gros dépôts.
- `includePatterns`: (Optionnel) Spécifie les fichiers à inclure en utilisant des motifs fast-glob. Plusieurs motifs peuvent être séparés par des virgules (ex: "**/*.{js,ts}", "src/**,docs/**"). Seuls les fichiers correspondants seront traités.
- `ignorePatterns`: (Optionnel) Spécifie les fichiers supplémentaires à exclure en utilisant des motifs fast-glob. Plusieurs motifs peuvent être séparés par des virgules (ex: "test/**,*.spec.js", "node_modules/**,dist/**"). Ces motifs complètent .gitignore et les exclusions intégrées.
- `topFilesLength`: (Optionnel, par défaut: 10) Nombre de plus gros fichiers par taille à afficher dans le résumé des métriques pour l'analyse de la base de code.

**Exemple:**
```json
{
  "remote": "yamadashy/repomix",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### read_repomix_output

Cet outil lit le contenu d'un fichier de sortie généré par Repomix. Il prend en charge la lecture partielle avec spécification de plage de lignes pour les gros fichiers. Cet outil est conçu pour les environnements où l'accès direct au système de fichiers est limité.

**Paramètres:**
- `outputId`: (Requis) ID du fichier de sortie Repomix à lire
- `startLine`: (Optionnel) Numéro de ligne de début (basé sur 1, inclusif). Si non spécifié, lit depuis le début.
- `endLine`: (Optionnel) Numéro de ligne de fin (basé sur 1, inclusif). Si non spécifié, lit jusqu'à la fin.

**Fonctionnalités:**
- Conçu spécifiquement pour les environnements basés sur le web ou les applications en bac à sable
- Récupère le contenu des sorties générées précédemment en utilisant leur ID
- Fournit un accès sécurisé à la base de code packagée sans nécessiter d'accès au système de fichiers
- Prend en charge la lecture partielle pour les gros fichiers

**Exemple:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "startLine": 100,
  "endLine": 200
}
```

### grep_repomix_output

Cet outil recherche des motifs dans un fichier de sortie Repomix en utilisant une fonctionnalité similaire à grep avec la syntaxe JavaScript RegExp. Il retourne les lignes correspondantes avec des lignes de contexte optionnelles autour des correspondances.

**Paramètres:**
- `outputId`: (Requis) ID du fichier de sortie Repomix à rechercher
- `pattern`: (Requis) Motif de recherche (syntaxe d'expression régulière JavaScript RegExp)
- `contextLines`: (Optionnel, par défaut: 0) Nombre de lignes de contexte à afficher avant et après chaque correspondance. Remplacé par beforeLines/afterLines si spécifié.
- `beforeLines`: (Optionnel) Nombre de lignes de contexte à afficher avant chaque correspondance (comme grep -B). Priorité sur contextLines.
- `afterLines`: (Optionnel) Nombre de lignes de contexte à afficher après chaque correspondance (comme grep -A). Priorité sur contextLines.
- `ignoreCase`: (Optionnel, par défaut: false) Effectue une correspondance insensible à la casse

**Fonctionnalités:**
- Utilise la syntaxe JavaScript RegExp pour une correspondance de motifs puissante
- Prend en charge les lignes de contexte pour une meilleure compréhension des correspondances
- Permet un contrôle séparé des lignes de contexte avant/après
- Options de recherche sensible et insensible à la casse

**Exemple:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "pattern": "function\\s+\\w+\\(",
  "contextLines": 3,
  "ignoreCase": false
}
```

### file_system_read_file et file_system_read_directory

Le serveur MCP de Repomix fournit deux outils système de fichiers qui permettent aux assistants IA d'interagir en toute sécurité avec le système de fichiers local:

1. `file_system_read_file`
  - Lit le contenu des fichiers du système de fichiers local en utilisant des chemins absolus
  - Inclut une validation de sécurité intégrée pour détecter et prévenir l'accès aux fichiers contenant des informations sensibles
  - Implémente la validation de sécurité avec [Secretlint](https://github.com/secretlint/secretlint)
  - Empêche l'accès aux fichiers contenant des informations sensibles (clés API, mots de passe, secrets)
  - Valide les chemins absolus pour prévenir les attaques par traversée de répertoire
  - Renvoie des messages d'erreur clairs pour les chemins invalides et les problèmes de sécurité

2. `file_system_read_directory`
  - Liste le contenu d'un répertoire en utilisant un chemin absolu
  - Renvoie une liste formatée montrant les fichiers et sous-répertoires avec des indicateurs clairs
  - Affiche les fichiers et répertoires avec des indicateurs clairs (`[FILE]` ou `[DIR]`)
  - Fournit une traversée sécurisée des répertoires avec une gestion appropriée des erreurs
  - Valide les chemins et s'assure qu'ils sont absolus
  - Utile pour explorer la structure du projet et comprendre l'organisation de la base de code

Les deux outils intègrent des mesures de sécurité robustes:
- Validation des chemins absolus pour prévenir les attaques par traversée de répertoire
- Vérifications des permissions pour assurer des droits d'accès appropriés
- Intégration avec Secretlint pour la détection d'informations sensibles
- Messages d'erreur clairs pour un meilleur débogage et une meilleure sensibilisation à la sécurité

**Exemple:**
```typescript
// Lecture d'un fichier
const fileContent = await tools.file_system_read_file({
  path: '/absolute/path/to/file.txt'
});

// Liste du contenu d'un répertoire
const dirContent = await tools.file_system_read_directory({
  path: '/absolute/path/to/directory'
});
```

Ces outils sont particulièrement utiles lorsque les assistants IA doivent:
- Analyser des fichiers spécifiques dans la base de code
- Naviguer dans les structures de répertoires
- Vérifier l'existence et l'accessibilité des fichiers
- Assurer des opérations sécurisées sur le système de fichiers

## Avantages de l'utilisation de Repomix comme serveur MCP

L'utilisation de Repomix comme serveur MCP offre plusieurs avantages:

1. **Intégration directe**: Les assistants IA peuvent analyser directement votre base de code sans préparation manuelle des fichiers.
2. **Flux de travail efficace**: Simplifie le processus d'analyse du code en éliminant le besoin de générer et de télécharger manuellement des fichiers.
3. **Sortie cohérente**: Garantit que l'assistant IA reçoit la base de code dans un format cohérent et optimisé.
4. **Fonctionnalités avancées**: Exploite toutes les fonctionnalités de Repomix comme la compression de code, le comptage de tokens et les vérifications de sécurité.

Une fois configuré, votre assistant IA peut utiliser directement les capacités de Repomix pour analyser les bases de code, rendant les flux de travail d'analyse de code plus efficaces.
</file>

<file path="website/client/src/fr/guide/output.md">
# Formats de sortie

Repomix prend en charge trois formats de sortie:
- XML (par défaut)
- Markdown
- Texte brut

## Format XML

```bash
repomix --style xml
```

Le format XML est optimisé pour le traitement par l'IA:

```xml
Ce fichier est une représentation fusionnée de toute la base de code...
<file_summary>
(Métadonnées et instructions pour l'IA)
</file_summary>
<directory_structure>
src/
  index.ts
  utils/
    helper.ts
</directory_structure>
<files>
<file path="src/index.ts">
// Contenu du fichier ici
</file>
</files>
```

::: tip Pourquoi XML?
Les balises XML aident les modèles d'IA comme Claude à analyser le contenu plus précisément. La [Documentation de Claude](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags) recommande d'utiliser des balises XML pour les prompts structurés.
:::

## Format Markdown

```bash
repomix --style markdown
```

Le Markdown offre un formatage lisible:

```markdown
Ce fichier est une représentation fusionnée de toute la base de code...
# Résumé du fichier
(Métadonnées et instructions pour l'IA)
# Structure des répertoires
```
src/
index.ts
utils/
helper.ts
```
# Fichiers
## Fichier: src/index.ts
```typescript
// Contenu du fichier ici
```
```

## Utilisation avec les modèles d'IA

Chaque format fonctionne bien avec les modèles d'IA, mais considérez:
- Utilisez XML pour Claude (meilleure précision d'analyse)
- Utilisez Markdown pour une meilleure lisibilité générale
- Utilisez le texte brut pour la simplicité et une compatibilité universelle

## Personnalisation

Définissez le format par défaut dans `repomix.config.json`:

```json
{
  "output": {
    "style": "xml",
    "filePath": "output.xml"
  }
}
```

## Format texte brut

```bash
repomix --style plain
```

Structure de sortie:

```text
Ce fichier est une représentation fusionnée de toute la base de code...
================
Résumé du fichier
================
(Métadonnées et instructions pour l'IA)
================
Structure des répertoires
================
src/
  index.ts
  utils/
    helper.ts
================
Fichiers
================
================
Fichier: src/index.ts
================
// Contenu du fichier ici
```
</file>

<file path="website/client/src/fr/guide/prompt-examples.md">
# Exemples de prompts

## Revue de code

### Revue d'architecture
```
Analysez l'architecture de cette base de code:
1. Évaluez la structure globale et les motifs de conception
2. Identifiez les problèmes architecturaux potentiels
3. Suggérez des améliorations pour la scalabilité
4. Notez les zones qui suivent les meilleures pratiques
Concentrez-vous sur la maintenabilité et la modularité.
```

### Revue de sécurité
```
Effectuez une revue de sécurité de cette base de code:
1. Identifiez les vulnérabilités potentielles
2. Vérifiez les anti-patterns courants de sécurité
3. Examinez la gestion des erreurs et la validation des entrées
4. Évaluez la sécurité des dépendances
Fournissez des exemples spécifiques et des étapes de correction.
```

### Revue de performance
```
Examinez la base de code pour les performances:
1. Identifiez les goulots d'étranglement
2. Vérifiez l'utilisation des ressources
3. Examinez l'efficacité algorithmique
4. Évaluez les stratégies de mise en cache
Incluez des recommandations d'optimisation spécifiques.
```

## Génération de documentation

### Documentation d'API
```
Générez une documentation complète de l'API:
1. Listez et décrivez tous les points d'accès publics
2. Documentez les formats de requête/réponse
3. Incluez des exemples d'utilisation
4. Notez les limitations ou contraintes
```

### Guide du développeur
```
Créez un guide du développeur couvrant:
1. Instructions de configuration
2. Aperçu de la structure du projet
3. Flux de travail de développement
4. Approche de test
5. Étapes courantes de dépannage
```

### Documentation d'architecture
```
Documentez l'architecture du système:
1. Vue d'ensemble de haut niveau
2. Interactions entre composants
3. Diagrammes de flux de données
4. Décisions de conception et justification
5. Contraintes et limitations du système
```

## Analyse et amélioration

### Analyse des dépendances
```
Analysez les dépendances du projet:
1. Identifiez les packages obsolètes
2. Vérifiez les vulnérabilités de sécurité
3. Suggérez des packages alternatifs
4. Examinez les modèles d'utilisation des dépendances
Incluez des recommandations spécifiques de mise à niveau.
```

### Couverture de tests
```
Examinez la couverture des tests:
1. Identifiez les composants non testés
2. Suggérez des cas de test supplémentaires
3. Examinez la qualité des tests
4. Recommandez des stratégies de test
```

### Qualité du code
```
Évaluez la qualité du code et suggérez des améliorations:
1. Examinez les conventions de nommage
2. Vérifiez l'organisation du code
3. Évaluez la gestion des erreurs
4. Examinez les pratiques de commentaires
Fournissez des exemples spécifiques de modèles bons et problématiques.
```

## Conseils pour de meilleurs résultats

1. **Soyez spécifique**: Incluez des objectifs clairs et des critères d'évaluation
2. **Établissez le contexte**: Spécifiez votre rôle et le niveau d'expertise requis
3. **Format de demande**: Définissez comment vous souhaitez structurer la réponse
4. **Priorisez**: Indiquez quels aspects sont les plus importants

## Notes spécifiques aux modèles

### Claude
- Utilisez le format de sortie XML
- Placez les instructions importantes à la fin
- Spécifiez la structure de réponse

### ChatGPT
- Utilisez le format Markdown
- Divisez les grandes bases de code en sections
- Incluez des prompts de rôle système

### Gemini
- Fonctionne avec tous les formats
- Concentrez-vous sur des domaines spécifiques par demande
- Utilisez une analyse étape par étape
</file>

<file path="website/client/src/fr/guide/remote-repository-processing.md">
# Traitement des dépôts distants

## Utilisation de base

Traiter des dépôts publics:
```bash
# En utilisant l'URL complète
repomix --remote https://github.com/user/repo
# En utilisant le format abrégé GitHub
repomix --remote user/repo
```

## Sélection de branche et de commit

```bash
# Branche spécifique
repomix --remote user/repo --remote-branch main
# Tag
repomix --remote user/repo --remote-branch v1.0.0
# Hash de commit
repomix --remote user/repo --remote-branch 935b695
```

## Prérequis

- Git doit être installé
- Connexion Internet
- Accès en lecture au dépôt

## Contrôle de la sortie

```bash
# Emplacement de sortie personnalisé
repomix --remote user/repo -o custom-output.xml
# Avec format XML
repomix --remote user/repo --style xml
# Supprimer les commentaires
repomix --remote user/repo --remove-comments
```

## Utilisation avec Docker

```bash
# Traiter et sortir dans le répertoire courant
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo
# Sortie vers un répertoire spécifique
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo
```

## Problèmes courants

### Problèmes d'accès
- Assurez-vous que le dépôt est public
- Vérifiez l'installation de Git
- Vérifiez la connexion Internet

### Dépôts volumineux
- Utilisez `--include` pour sélectionner des chemins spécifiques
- Activez `--remove-comments`
- Traitez les branches séparément
</file>

<file path="website/client/src/fr/guide/security.md">
# Sécurité

## Fonctionnalité de vérification de sécurité

Repomix utilise [Secretlint](https://github.com/secretlint/secretlint) pour détecter les informations sensibles dans vos fichiers:
- Clés d'API
- Jetons d'accès
- Identifiants
- Clés privées
- Variables d'environnement

## Configuration

Les vérifications de sécurité sont activées par défaut.

Désactivation via CLI:
```bash
repomix --no-security-check
```

Ou dans `repomix.config.json`:
```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

## Mesures de sécurité

1. **Exclusion des fichiers binaires**: Les fichiers binaires ne sont pas inclus dans la sortie
2. **Compatible avec Git**: Respecte les motifs `.gitignore`
3. **Détection automatisée**: Analyse les problèmes de sécurité courants:
    - Identifiants AWS
    - Chaînes de connexion aux bases de données
    - Jetons d'authentification
    - Clés privées

## Lorsque la vérification de sécurité trouve des problèmes

Exemple de sortie:
```bash
🔍 Vérification de sécurité:
────────────────────────────
2 fichier(s) suspect(s) détecté(s) et exclu(s):
1. config/credentials.json
  - Clé d'accès AWS trouvée
2. .env.local
  - Mot de passe de base de données trouvé
```

## Meilleures pratiques

1. Toujours examiner la sortie avant de la partager
2. Utiliser `.repomixignore` pour les chemins sensibles
3. Garder les vérifications de sécurité activées
4. Supprimer les fichiers sensibles du dépôt

## Signalement des problèmes de sécurité

Vous avez trouvé une vulnérabilité de sécurité? Veuillez:
1. Ne pas ouvrir un ticket public
2. Envoyer un email à: koukun0120@gmail.com
3. Ou utiliser les [Avis de sécurité GitHub](https://github.com/yamadashy/repomix/security/advisories/new)
</file>

<file path="website/client/src/fr/guide/usage.md">
# Utilisation de base

## Démarrage rapide

Empaquetez tout votre dépôt:

```bash
repomix
```

## Cas d'utilisation courants

### Empaqueter des répertoires spécifiques

```bash
repomix path/to/directory
```

### Inclure des fichiers spécifiques

Utilisez des [motifs glob](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):

```bash
repomix --include "src/**/*.ts,**/*.md"
```

### Exclure des fichiers

```bash
repomix --ignore "**/*.log,tmp/"
```

### Dépôts distants

```bash
# En utilisant l'URL GitHub
repomix --remote https://github.com/user/repo
# En utilisant le format abrégé
repomix --remote user/repo
# Branche/tag/commit spécifique
repomix --remote user/repo --remote-branch main
repomix --remote user/repo --remote-branch 935b695
```

### Entrée de liste de fichiers (stdin)

Passez les chemins de fichiers via stdin pour une flexibilité ultime:

```bash
# En utilisant la commande find
find src -name "*.ts" -type f | repomix --stdin

# En utilisant git pour obtenir les fichiers suivis
git ls-files "*.ts" | repomix --stdin

# En utilisant ls avec des motifs glob
ls src/**/*.ts | repomix --stdin

# À partir d'un fichier contenant des chemins de fichiers
cat file-list.txt | repomix --stdin

# Entrée directe avec echo
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```

L'option `--stdin` vous permet de transmettre une liste de chemins de fichiers à Repomix, offrant une flexibilité ultime dans la sélection des fichiers à empaqueter.

> [!NOTE]
> Lors de l'utilisation de `--stdin`, les chemins de fichiers peuvent être relatifs ou absolus, et Repomix gèrera automatiquement la résolution des chemins et la déduplication.

### Compression de code

```bash
repomix --compress
# Vous pouvez également l'utiliser avec des dépôts distants:
repomix --remote yamadashy/repomix --compress
```

## Formats de sortie

### XML (Par défaut)

```bash
repomix --style xml
```

### Markdown

```bash
repomix --style markdown
```

### Texte brut

```bash
repomix --style plain
```

## Options supplémentaires

### Supprimer les commentaires

```bash
repomix --remove-comments
```

### Afficher les numéros de ligne

```bash
repomix --output-show-line-numbers
```

### Copier dans le presse-papiers

```bash
repomix --copy
```

### Désactiver la vérification de sécurité

```bash
repomix --no-security-check
```

## Configuration

Initialiser le fichier de configuration:

```bash
repomix --init
```

Consultez le [Guide de configuration](/fr/guide/configuration) pour les options détaillées.
</file>

<file path="website/client/src/fr/index.md">
---
layout: home
title: Repomix
titleTemplate: Empaquetez votre code dans des formats adaptés à l'IA
aside: false
editLink: false

features:
  - icon: 🤖
    title: Optimisé pour l'IA
    details: Formate votre base de code d'une manière facilement compréhensible et traitable par l'IA.
  - icon: ⚙️
    title: Compatible avec Git
    details: Respecte automatiquement vos fichiers .gitignore.
  - icon: 🛡️
    title: Axé sur la sécurité
    details: Intègre Secretlint pour des vérifications de sécurité robustes afin de détecter et prévenir l'inclusion d'informations sensibles.
  - icon: 📊
    title: Comptage de tokens
    details: Fournit le nombre de tokens pour chaque fichier et l'ensemble du dépôt, utile pour les limites de contexte des LLM.

---

<script setup>
import YouTubeVideo from '../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../utils/videos'
</script>

<div class="cli-section">

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## 🏆 Nomination aux Open Source Awards

Nous sommes honorés ! Repomix a été nominé dans la catégorie **Powered by AI** aux [JSNation Open Source Awards 2025](https://osawards.com/javascript/).

Cela n'aurait pas été possible sans vous tous qui utilisez et soutenez Repomix. Merci !

Si Repomix vous a aidé à analyser ou empaqueter des bases de code pour les outils d'IA, nous vous serions reconnaissants de voter pour nous dans la catégorie **Powered by AI**.

## Qu'est-ce que Repomix ?

Repomix est un outil puissant qui package votre base de code entière en un seul fichier compatible avec l'IA. Que vous travailliez sur des revues de code, du refactoring ou que vous ayez besoin d'assistance IA pour votre projet, Repomix facilite le partage de tout le contexte de votre dépôt avec les outils d'IA.

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

## Démarrage rapide

Une fois que vous avez généré un fichier compressé (`repomix-output.xml`) avec Repomix, vous pouvez l'envoyer à un assistant IA (comme ChatGPT, Claude) avec une instruction comme :

```
Ce fichier contient tous les fichiers du dépôt combinés en un seul.
Je souhaite refactoriser le code, veuillez donc d'abord l'examiner.
```

L'IA analysera votre base de code complète et fournira des informations détaillées :

![Utilisation de Repomix 1](/images/docs/repomix-file-usage-1.png)

Lors de la discussion de modifications spécifiques, l'IA peut vous aider à générer du code. Avec des fonctionnalités comme les Artefacts de Claude, vous pouvez même recevoir plusieurs fichiers interdépendants :

![Utilisation de Repomix 2](/images/docs/repomix-file-usage-2.png)

Bon codage ! 🚀

## Utilisation de l'outil CLI {#using-the-cli-tool}

Repomix peut être utilisé comme un outil en ligne de commande, offrant des fonctionnalités puissantes et des options de personnalisation.

**L'outil CLI peut accéder aux dépôts privés** car il utilise votre Git installé localement.

### Démarrage rapide

Vous pouvez essayer Repomix instantanément dans votre répertoire de projet sans installation :

```bash
npx repomix
```

Ou l'installer globalement pour une utilisation répétée :

```bash
# Installation avec npm
npm install -g repomix

# Ou avec yarn
yarn global add repomix

# Ou avec bun
bun add -g repomix

# Ou avec Homebrew (macOS/Linux)
brew install repomix

# Puis exécuter dans n'importe quel répertoire de projet
repomix
```

C'est tout ! Repomix générera un fichier `repomix-output.xml` dans votre répertoire actuel, contenant l'intégralité de votre dépôt dans un format adapté à l'IA.

### Utilisation

Pour empaqueter tout votre dépôt :

```bash
repomix
```

Pour empaqueter un répertoire spécifique :

```bash
repomix path/to/directory
```

Pour empaqueter des fichiers ou répertoires spécifiques en utilisant des [motifs glob](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax) :

```bash
repomix --include "src/**/*.ts,**/*.md"
```

Pour exclure des fichiers ou répertoires spécifiques :

```bash
repomix --ignore "**/*.log,tmp/"
```

Pour empaqueter un dépôt distant :
```bash
# Utilisation du format abrégé
npx repomix --remote yamadashy/repomix

# Utilisation de l'URL complète (prend en charge les branches et les chemins spécifiques)
npx repomix --remote https://github.com/yamadashy/repomix
npx repomix --remote https://github.com/yamadashy/repomix/tree/main

# Utilisation de l'URL d'un commit
npx repomix --remote https://github.com/yamadashy/repomix/commit/836abcd7335137228ad77feb28655d85712680f1
```

Pour initialiser un nouveau fichier de configuration (`repomix.config.json`) :

```bash
repomix --init
```

Une fois que vous avez généré le fichier compressé, vous pouvez l'utiliser avec des outils d'IA générative comme Claude, ChatGPT et Gemini.

#### Utilisation avec Docker

Vous pouvez également exécuter Repomix avec Docker 🐳  
C'est utile si vous souhaitez exécuter Repomix dans un environnement isolé ou préférez utiliser des conteneurs.

Utilisation de base (répertoire courant) :

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

Pour empaqueter un répertoire spécifique :
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

Traiter un dépôt distant et sortir vers un répertoire `output` :

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### Formats de sortie

Choisissez votre format de sortie préféré :

```bash
# Format XML (par défaut)
repomix --style xml

# Format Markdown
repomix --style markdown

# Format texte brut
repomix --style plain
```

### Personnalisation

Créez un `repomix.config.json` pour des paramètres persistants :

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

## Guide des Utilisateurs Avancés

Repomix offre des fonctionnalités puissantes pour les cas d'usage avancés. Voici quelques guides essentiels pour les utilisateurs avancés :

- **[Serveur MCP](./guide/mcp-server)** - Intégration du Model Context Protocol pour les assistants IA
- **[GitHub Actions](./guide/github-actions)** - Automatisez l'empaquetage des bases de code dans les workflows CI/CD
- **[Compression de Code](./guide/code-compress)** - Compression intelligente basée sur Tree-sitter (~70% de réduction de tokens)
- **[Utiliser comme Bibliothèque](./guide/development/using-repomix-as-a-library)** - Intégrez Repomix dans vos applications Node.js
- **[Instructions Personnalisées](./guide/custom-instructions)** - Ajoutez des prompts et instructions personnalisés aux sorties
- **[Fonctionnalités de Sécurité](./guide/security)** - Intégration Secretlint intégrée et vérifications de sécurité
- **[Meilleures Pratiques](./guide/tips/best-practices)** - Optimisez vos workflows IA avec des stratégies éprouvées

### Plus d'exemples
::: tip Besoin de plus d'aide ? 💡
Consultez notre [guide](./guide/) pour des instructions détaillées, ou visitez notre [dépôt GitHub](https://github.com/yamadashy/repomix) pour plus d'exemples et le code source.
:::

</div>
</file>

<file path="website/client/src/hi/guide/development/index.md">
# Repomix में योगदान

Repomix एक ओपन सोर्स प्रोजेक्ट है और हम योगदान का स्वागत करते हैं! यह गाइड आपको Repomix के विकास में शामिल होने के लिए आवश्यक जानकारी प्रदान करेगी।

## विकास परिवेश सेटअप

### आवश्यकताएँ

- Node.js (v18 या उच्चतर)
- npm, yarn, या pnpm
- Git

### रिपॉजिटरी क्लोन करना

```bash
git clone https://github.com/yamadashy/repomix.git
cd repomix
```

### निर्भरताएँ इंस्टॉल करना

```bash
# npm का उपयोग करके
npm install

# या yarn का उपयोग करके
yarn

# या pnpm का उपयोग करके
pnpm install
```

### विकास सर्वर चलाना

```bash
# npm का उपयोग करके
npm run dev

# या yarn का उपयोग करके
yarn dev

# या pnpm का उपयोग करके
pnpm dev
```

## प्रोजेक्ट संरचना

Repomix प्रोजेक्ट निम्नलिखित प्रमुख डायरेक्टरी में संगठित है:

- `src/`: मुख्य सोर्स कोड
  - `cli/`: कमांड लाइन इंटरफेस कोड
  - `core/`: कोर फंक्शनैलिटी
  - `utils/`: उपयोगिता फंक्शन
- `test/`: टेस्ट फाइलें
- `website/`: दस्तावेज़ीकरण वेबसाइट
- `scripts/`: बिल्ड और विकास स्क्रिप्ट

## टेस्टिंग

Repomix में व्यापक टेस्ट सूट है। टेस्ट चलाने के लिए:

```bash
# सभी टेस्ट चलाएँ
npm test

# या विशिष्ट टेस्ट चलाएँ
npm test -- -g "specific test name"
```

## बिल्डिंग

प्रोडक्शन बिल्ड बनाने के लिए:

```bash
npm run build
```

बिल्ड आउटपुट `dist/` डायरेक्टरी में जनरेट होगा।

## लिंटिंग और फॉर्मेटिंग

Repomix ESLint और Prettier का उपयोग करता है। कोड लिंट करने के लिए:

```bash
npm run lint
```

कोड फॉर्मेट करने के लिए:

```bash
npm run format
```

## पुल रिक्वेस्ट प्रक्रिया

1. अपना फीचर ब्रांच बनाएँ (`git checkout -b feature/amazing-feature`)
2. अपने परिवर्तन कमिट करें (`git commit -m 'Add amazing feature'`)
3. अपना ब्रांच पुश करें (`git push origin feature/amazing-feature`)
4. GitHub पर एक पुल रिक्वेस्ट खोलें

## रिलीज प्रक्रिया

Repomix सेमांटिक वर्जनिंग का पालन करता है। रिलीज प्रक्रिया स्वचालित है और GitHub Actions के माध्यम से संचालित होती है।

## दस्तावेज़ीकरण

दस्तावेज़ीकरण वेबसाइट VitePress का उपयोग करती है और `website/` डायरेक्टरी में स्थित है। दस्तावेज़ीकरण विकास सर्वर चलाने के लिए:

```bash
cd website
npm install
npm run dev
```

## अगला क्या है?

- [Repomix को लाइब्रेरी के रूप में उपयोग](using-repomix-as-a-library.md) के बारे में जानें
- [AI-सहायक विकास टिप्स](../tips/best-practices.md) का अन्वेषण करें
</file>

<file path="website/client/src/hi/guide/development/using-repomix-as-a-library.md">
# Repomix को लाइब्रेरी के रूप में उपयोग करना

Repomix को एक स्टैंडअलोन CLI टूल के रूप में उपयोग करने के अलावा, आप इसे अपने JavaScript या TypeScript प्रोजेक्ट में एक लाइब्रेरी के रूप में भी उपयोग कर सकते हैं।

## इंस्टॉलेशन

अपने प्रोजेक्ट में Repomix को लाइब्रेरी के रूप में इंस्टॉल करें:

```bash
# npm के साथ
npm install repomix

# yarn के साथ
yarn add repomix

# pnpm के साथ
pnpm add repomix
```

## बुनियादी उपयोग

Repomix को अपने कोड में इम्पोर्ट करें और उपयोग करें:

```typescript
import { processRepository } from 'repomix';

async function main() {
  const result = await processRepository({
    path: './path/to/repository',
    outputStyle: 'xml',
    outputFile: 'output.xml',
  });

  console.log(`Processed ${result.fileCount} files with ${result.tokenCount} tokens`);
}

main().catch(console.error);
```

## विकल्प

Repomix API निम्नलिखित विकल्पों का समर्थन करता है:

```typescript
interface RepomixOptions {
  // रिपॉजिटरी पथ या URL
  path?: string;
  remote?: string;
  remoteBranch?: string;

  // आउटपुट विकल्प
  outputStyle?: 'xml' | 'markdown' | 'plain';
  outputFile?: string;

  // फिल्टरिंग विकल्प
  include?: string | string[];
  ignore?: string | string[];

  // प्रोसेसिंग विकल्प
  removeComments?: boolean;
  compress?: boolean;

  // सुरक्षा विकल्प
  securityCheck?: boolean;

  // टोकन काउंटिंग विकल्प
  tokenCounter?: 'gpt-4' | 'gpt-3.5-turbo' | 'claude' | 'llama' | 'gemini';
}
```

## उदाहरण

### लोकल रिपॉजिटरी प्रोसेसिंग

```typescript
import { processRepository } from 'repomix';

async function processLocalRepo() {
  const result = await processRepository({
    path: './my-project',
    outputStyle: 'markdown',
    outputFile: 'output.md',
    include: ['src/**/*.ts', 'docs/**/*.md'],
    ignore: ['**/*.test.ts', '**/node_modules/**'],
    removeComments: true,
    compress: true,
  });

  return result;
}
```

### रिमोट रिपॉजिटरी प्रोसेसिंग

```typescript
import { processRepository } from 'repomix';

async function processRemoteRepo() {
  const result = await processRepository({
    remote: 'https://github.com/user/repo',
    remoteBranch: 'main',
    outputStyle: 'xml',
    outputFile: 'output.xml',
  });

  return result;
}
```

### आउटपुट स्ट्रिंग के रूप में प्राप्त करना

```typescript
import { processRepository } from 'repomix';

async function getOutputAsString() {
  const result = await processRepository({
    path: './my-project',
    outputStyle: 'markdown',
    // outputFile को छोड़ दें
  });

  // आउटपुट स्ट्रिंग के रूप में वापस आता है
  console.log(result.output);
  
  return result.output;
}
```

## एडवांस्ड उपयोग

### कस्टम टोकन काउंटर

```typescript
import { processRepository, createTokenCounter } from 'repomix';

async function useCustomTokenCounter() {
  // कस्टम टोकन काउंटर फंक्शन
  const myTokenCounter = createTokenCounter('gpt-4');
  
  const result = await processRepository({
    path: './my-project',
    tokenCounter: myTokenCounter,
  });
  
  console.log(`Total tokens: ${result.tokenCount}`);
}
```

### प्रोग्रेस कॉलबैक

```typescript
import { processRepository } from 'repomix';

async function withProgressCallback() {
  const result = await processRepository({
    path: './my-project',
    onProgress: (info) => {
      console.log(`Processing: ${info.currentFile} (${info.processedFiles}/${info.totalFiles})`);
    },
  });
  
  return result;
}
```

### एरर हैंडलिंग

```typescript
import { processRepository } from 'repomix';

async function withErrorHandling() {
  try {
    const result = await processRepository({
      path: './non-existent-path',
    });
    
    return result;
  } catch (error) {
    console.error('Repomix प्रोसेसिंग एरर:', error.message);
    // एरर हैंडलिंग लॉजिक
  }
}
```

## वेब एप्लिकेशन में उपयोग

Repomix को वेब एप्लिकेशन में भी उपयोग किया जा सकता है, लेकिन कुछ सीमाएं हैं:

```typescript
import { processContent } from 'repomix';

async function processInBrowser() {
  // फाइल कंटेंट का एक ऑब्जेक्ट
  const files = {
    'src/index.ts': 'console.log("Hello, world!");',
    'README.md': '# My Project\n\nThis is a sample project.',
  };
  
  const result = await processContent({
    files,
    outputStyle: 'markdown',
  });
  
  return result.output;
}
```

## अगला क्या है?

- [विकास गाइड](index.md) पढ़ें
- [AI-सहायक विकास टिप्स](../tips/best-practices.md) का अन्वेषण करें
- [कमांड लाइन विकल्पों](../command-line-options.md) के बारे में अधिक जानें
</file>

<file path="website/client/src/hi/guide/tips/best-practices.md">
# AI-सहायक विकास टिप्स

Repomix के साथ AI मॉडल का उपयोग करके अपने विकास प्रक्रिया को अधिकतम करने के लिए यहां कुछ सर्वोत्तम प्रथाएं दी गई हैं।

## प्रभावी प्रॉम्प्ट लिखना

### स्पष्ट निर्देश दें

AI मॉडल को स्पष्ट और विशिष्ट निर्देश दें:

```
इस रिपॉजिटरी का विश्लेषण करें और निम्नलिखित पर ध्यान केंद्रित करें:
1. कोड संरचना और आर्किटेक्चर
2. संभावित प्रदर्शन बॉटलनेक
3. सुरक्षा कमजोरियां
```

### संदर्भ प्रदान करें

AI को आपके प्रोजेक्ट के बारे में अधिक जानकारी दें:

```
यह एक Node.js बैकएंड API है जो MongoDB का उपयोग करता है और AWS पर होस्ट किया गया है। 
मुझे प्रमाणीकरण प्रणाली में सुधार करने की आवश्यकता है।
```

### विशिष्ट प्रश्न पूछें

सामान्य प्रश्नों के बजाय विशिष्ट प्रश्न पूछें:

```
इस कोड में JWT प्रमाणीकरण कैसे लागू किया गया है और क्या कोई सुरक्षा समस्याएं हैं?
```

## AI के साथ कोड समीक्षा

### समीक्षा के लिए फोकस क्षेत्र निर्दिष्ट करें

AI को बताएं कि आप किन पहलुओं पर ध्यान केंद्रित करना चाहते हैं:

```
कृपया इस कोड की समीक्षा करें, विशेष रूप से:
- प्रदर्शन अनुकूलन
- त्रुटि हैंडलिंग
- कोड पठनीयता
```

### परिवर्तनों का संदर्भ प्रदान करें

बड़े परिवर्तनों के लिए, संदर्भ प्रदान करें:

```
मैंने अभी-अभी हमारी डेटाबेस एक्सेस लेयर को पुनर्लिखित किया है। 
पुराना कोड सिंगल कनेक्शन का उपयोग करता था, नया कोड कनेक्शन पूलिंग का उपयोग करता है।
```

### प्रतिक्रिया पर कार्रवाई करें

AI की प्रतिक्रिया पर कार्रवाई करें और फिर से समीक्षा के लिए अपडेट किए गए कोड को भेजें:

```
मैंने आपके सुझावों के आधार पर परिवर्तन किए हैं। 
कृपया अपडेट किए गए कोड की समीक्षा करें और देखें कि क्या अभी भी कोई समस्याएं हैं।
```

## कोड जनरेशन और रिफैक्टरिंग

### स्पष्ट आवश्यकताएं प्रदान करें

कोड जनरेशन के लिए स्पष्ट आवश्यकताएं प्रदान करें:

```
कृपया एक REST API एंडपॉइंट बनाएं जो:
1. POST अनुरोधों को स्वीकार करता है
2. JSON बॉडी से उपयोगकर्ता डेटा को पार्स करता है
3. MongoDB में डेटा सहेजता है
4. उचित त्रुटि हैंडलिंग प्रदान करता है
```

### मौजूदा कोड शैली का पालन करें

AI को मौजूदा कोड शैली का पालन करने के लिए कहें:

```
कृपया इस फंक्शन को रिफैक्टर करें, लेकिन प्रोजेक्ट की मौजूदा कोडिंग शैली और पैटर्न का पालन करें।
```

### छोटे टुकड़ों में काम करें

बड़े परिवर्तनों को छोटे, प्रबंधनीय टुकड़ों में विभाजित करें:

```
मुझे इस पूरे मॉड्यूल को रिफैक्टर करने की आवश्यकता है। 
आइए पहले डेटा एक्सेस लेयर पर ध्यान केंद्रित करें, फिर बिजनेस लॉजिक पर जाएंगे।
```

## डिबगिंग और समस्या निवारण

### संपूर्ण त्रुटि संदेश प्रदान करें

त्रुटि संदेश और स्टैक ट्रेस का पूरा विवरण प्रदान करें:

```
मैं निम्नलिखित त्रुटि का सामना कर रहा हूं:
TypeError: Cannot read property 'id' of undefined
    at UserService.findById (/src/services/user.service.ts:45:23)
    at async UserController.getUser (/src/controllers/user.controller.ts:32:18)
```

### संदर्भ और पुनरुत्पादन चरण प्रदान करें

समस्या का संदर्भ और पुनरुत्पादन चरण प्रदान करें:

```
यह त्रुटि केवल तब होती है जब उपयोगकर्ता एक विशिष्ट API एंडपॉइंट पर GET अनुरोध भेजता है और क्वेरी पैरामीटर में 'filter' पैरामीटर शामिल होता है।
```

### एक समय में एक परिवर्तन करें

डिबगिंग के दौरान एक समय में एक परिवर्तन करें:

```
मैंने पहले सुझाव को लागू किया है और त्रुटि अभी भी हो रही है। 
क्या हम अगले समाधान पर आगे बढ़ सकते हैं?
```

## प्रोजेक्ट दस्तावेज़ीकरण

### AI से दस्तावेज़ीकरण जनरेट करें

AI का उपयोग दस्तावेज़ीकरण जनरेट करने के लिए करें:

```
कृपया इस कोड के लिए JSDoc टिप्पणियां जनरेट करें, जिसमें पैरामीटर, रिटर्न वैल्यू और उदाहरण शामिल हों।
```

### दस्तावेज़ीकरण अपडेट करें

कोड परिवर्तनों के साथ दस्तावेज़ीकरण अपडेट करें:

```
मैंने इस API में कुछ नए पैरामीटर जोड़े हैं। कृपया README.md फाइल अपडेट करें ताकि इन परिवर्तनों को दर्शाया जा सके।
```

### उपयोगकर्ता गाइड बनाएं

AI का उपयोग उपयोगकर्ता गाइड बनाने के लिए करें:

```
कृपया इस CLI टूल के लिए एक उपयोगकर्ता गाइड बनाएं, जिसमें इंस्टॉलेशन, कॉन्फिगरेशन और सामान्य उपयोग के उदाहरण शामिल हों।
```

## सामान्य सर्वोत्तम प्रथाएं

### Repomix आउटपुट को नियमित रूप से अपडेट करें

जैसे-जैसे आपका कोडबेस विकसित होता है, Repomix आउटपुट को अपडेट करें:

```bash
# प्रत्येक स्प्रिंट के अंत में या महत्वपूर्ण परिवर्तनों के बाद चलाएं
repomix --output-file latest-codebase.xml
```

### AI प्रतिक्रिया को सत्यापित करें

AI द्वारा जनरेट किए गए कोड को हमेशा सत्यापित करें:

1. **कोड समीक्षा**: AI द्वारा जनरेट किए गए कोड की मैन्युअल समीक्षा करें
2. **टेस्टिंग**: सभी नए कोड के लिए टेस्ट लिखें
3. **सुरक्षा**: संवेदनशील कार्यों के लिए सुरक्षा जांच करें

### टीम के साथ ज्ञान साझा करें

AI के साथ अपने अनुभवों को टीम के साथ साझा करें:

1. **प्रभावी प्रॉम्प्ट साझा करें**: अच्छे परिणाम देने वाले प्रॉम्प्ट साझा करें
2. **वर्कफ़्लो दस्तावेज़ीकरण**: AI-सहायक विकास वर्कफ़्लो का दस्तावेज़ीकरण करें
3. **प्रशिक्षण सत्र**: टीम के लिए AI उपकरणों पर प्रशिक्षण सत्र आयोजित करें

## अगला क्या है?

- [Repomix में योगदान](../development/index.md) के बारे में जानें
- [Repomix को लाइब्रेरी के रूप में उपयोग](../development/using-repomix-as-a-library.md) का अन्वेषण करें
- [प्रॉम्प्ट उदाहरण](../prompt-examples.md) देखें
</file>

<file path="website/client/src/hi/guide/code-compress.md">
# कोड कम्प्रेशन

Repomix का कोड कम्प्रेशन फीचर आपके कोडबेस को संक्षिप्त करने में मदद करता है, जिससे AI मॉडल के लिए टोकन उपयोग कम हो जाता है और बड़े कोडबेस को संभालना आसान हो जाता है।

## कोड कम्प्रेशन क्या है?

कोड कम्प्रेशन एक प्रक्रिया है जिसमें कोड के महत्वपूर्ण हिस्सों को बनाए रखते हुए कार्यान्वयन विवरण हटा दिए जाते हैं। यह फंक्शन और क्लास सिग्नेचर, इंटरफेस परिभाषाओं और महत्वपूर्ण लॉजिक पर ध्यान केंद्रित करता है।

## कोड कम्प्रेशन का उपयोग कैसे करें

कोड कम्प्रेशन सक्षम करने के लिए, `--compress` फ्लैग का उपयोग करें:

```bash
repomix --compress
```

## कॉन्फिगरेशन फाइल में कोड कम्प्रेशन

आप अपने `repomix.config.json` में भी कोड कम्प्रेशन को कॉन्फिगर कर सकते हैं:

```json
{
  "output": {
    "compress": true
  }
}
```

## कोड कम्प्रेशन कैसे काम करता है

कोड कम्प्रेशन निम्नलिखित तरीके से काम करता है:

1. **फंक्शन सिग्नेचर बनाए रखना**: फंक्शन के नाम, पैरामीटर और रिटर्न टाइप बनाए रखे जाते हैं
2. **कार्यान्वयन विवरण हटाना**: फंक्शन बॉडी को संक्षिप्त किया जाता है
3. **क्लास संरचना बनाए रखना**: क्लास परिभाषाएं, प्रॉपर्टी और मेथड सिग्नेचर बनाए रखे जाते हैं
4. **इंटरफेस और टाइप परिभाषाएं बनाए रखना**: टाइप सिस्टम जानकारी बनाए रखी जाती है

## उदाहरण

### कम्प्रेशन से पहले

```typescript
/**
 * उपयोगकर्ता प्रमाणीकरण सेवा
 */
class AuthService {
  private userRepository: UserRepository;
  private tokenService: TokenService;
  
  constructor(userRepo: UserRepository, tokenSvc: TokenService) {
    this.userRepository = userRepo;
    this.tokenService = tokenSvc;
  }
  
  /**
   * उपयोगकर्ता को प्रमाणित करता है और एक्सेस टोकन वापस करता है
   */
  async authenticate(username: string, password: string): Promise<string> {
    const user = await this.userRepository.findByUsername(username);
    
    if (!user) {
      throw new Error('उपयोगकर्ता नहीं मिला');
    }
    
    const isValid = await bcrypt.compare(password, user.passwordHash);
    
    if (!isValid) {
      throw new Error('अमान्य क्रेडेंशियल');
    }
    
    const token = this.tokenService.generateToken({
      userId: user.id,
      role: user.role,
      permissions: user.permissions
    });
    
    await this.userRepository.updateLastLogin(user.id);
    
    return token;
  }
  
  // अन्य मेथड्स...
}
```

### कम्प्रेशन के बाद

```typescript
/**
 * उपयोगकर्ता प्रमाणीकरण सेवा
 */
class AuthService {
  private userRepository: UserRepository;
  private tokenService: TokenService;
  
  constructor(userRepo: UserRepository, tokenSvc: TokenService) {
    // कार्यान्वयन संक्षिप्त किया गया
  }
  
  /**
   * उपयोगकर्ता को प्रमाणित करता है और एक्सेस टोकन वापस करता है
   */
  async authenticate(username: string, password: string): Promise<string> {
    // कार्यान्वयन संक्षिप्त किया गया
  }
  
  // अन्य मेथड्स...
}
```

## कोड कम्प्रेशन के लाभ

1. **टोकन बचत**: AI मॉडल के लिए टोकन उपयोग कम करें
2. **बड़े कोडबेस**: बड़े कोडबेस को AI मॉडल की कॉन्टेक्स्ट विंडो में फिट करें
3. **संरचनात्मक समझ**: कोड की संरचना पर ध्यान केंद्रित करें, कार्यान्वयन विवरण पर नहीं
4. **संवेदनशील जानकारी**: कार्यान्वयन विवरण में छिपी संवेदनशील जानकारी को हटाएं

## सावधानियां

कोड कम्प्रेशन का उपयोग करते समय कुछ बातों का ध्यान रखें:

1. **कार्यान्वयन विवरण**: कम्प्रेशन कार्यान्वयन विवरण हटा देता है, जो कभी-कभी महत्वपूर्ण हो सकते हैं
2. **बग खोजना**: कम्प्रेस्ड कोड में बग खोजना कठिन हो सकता है
3. **AI समझ**: कुछ मामलों में, AI को कार्यान्वयन विवरण की आवश्यकता हो सकती है

## अगला क्या है?

- [टिप्पणी हटाने](comment-removal.md) के बारे में जानें
- [आउटपुट फॉर्मेट](output.md) का अन्वेषण करें
- [कमांड लाइन विकल्पों](command-line-options.md) के बारे में अधिक जानें
</file>

<file path="website/client/src/hi/guide/command-line-options.md">
# कमांड लाइन विकल्प

Repomix कई कमांड लाइन विकल्प प्रदान करता है जो आपको अपने कोडबेस को प्रोसेस करने के तरीके को अनुकूलित करने की अनुमति देते हैं।

## बुनियादी विकल्प

### वर्जन दिखाना

```bash
repomix --version
```

वर्तमान इंस्टॉल किए गए Repomix का वर्जन दिखाता है।

### मदद दिखाना

```bash
repomix --help
```

उपलब्ध कमांड लाइन विकल्पों की सूची दिखाता है।

## आउटपुट विकल्प

### आउटपुट फाइल

```bash
repomix --output-file <filename>
```

आउटपुट फाइल का नाम निर्दिष्ट करता है। डिफॉल्ट: `repomix-output.xml`

### आउटपुट स्टाइल

```bash
repomix --style <style>
```

आउटपुट फॉर्मेट निर्दिष्ट करता है। विकल्प: `xml`, `markdown`, या `plain`। डिफॉल्ट: `xml`

### स्टैंडर्ड आउटपुट

```bash
repomix --stdout
```

आउटपुट को फाइल के बजाय स्टैंडर्ड आउटपुट (stdout) पर भेजता है।

## फिल्टरिंग विकल्प

### फाइलों को शामिल करना

```bash
repomix --include <patterns>
```

शामिल करने के लिए [ग्लोब पैटर्न](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax) निर्दिष्ट करता है। कई पैटर्न को अल्पविराम से अलग किया जा सकता है।

उदाहरण:
```bash
repomix --include "src/**/*.ts,**/*.md"
```

### फाइलों को बाहर रखना

```bash
repomix --ignore <patterns>
```

बाहर रखने के लिए [ग्लोब पैटर्न](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax) निर्दिष्ट करता है। कई पैटर्न को अल्पविराम से अलग किया जा सकता है।

उदाहरण:
```bash
repomix --ignore "**/*.log,tmp/"
```

### Stdin से फ़ाइल पथ

```bash
repomix --stdin
```

फ़ाइलों को स्वचालित रूप से खोजने के बजाय stdin से फ़ाइल पथ पढ़ता है।

## रिमोट रिपॉजिटरी प्रोसेसिंग

### रिमोट रिपॉजिटरी

```bash
repomix --remote <repository>
```

प्रोसेस करने के लिए रिमोट GitHub रिपॉजिटरी निर्दिष्ट करता है।

उदाहरण:
```bash
repomix --remote yamadashy/repomix
```

### रिमोट ब्रांच

```bash
repomix --remote-branch <branch>
```

प्रोसेस करने के लिए रिमोट रिपॉजिटरी का ब्रांच या कमिट हैश निर्दिष्ट करता है।

उदाहरण:
```bash
repomix --remote yamadashy/repomix --remote-branch main
repomix --remote yamadashy/repomix --remote-branch 935b695
```

## कॉन्फिगरेशन विकल्प

### कॉन्फिगरेशन फाइल

```bash
repomix --config <path>
```

कस्टम कॉन्फिगरेशन फाइल का पथ निर्दिष्ट करता है। डिफॉल्ट: `repomix.config.json`

### कॉन्फिगरेशन फाइल इनिशियलाइज़ करना

```bash
repomix --init
```

वर्तमान डायरेक्टरी में एक डिफॉल्ट कॉन्फिगरेशन फाइल बनाता है।

## सुरक्षा विकल्प

### सुरक्षा जांच

```bash
repomix --no-security-check
```

सुरक्षा जांच को अक्षम करता है। डिफॉल्ट रूप से, Repomix संवेदनशील जानकारी के लिए फाइलों की जांच करता है।

## प्रोसेसिंग विकल्प

### टिप्पणियां हटाना

```bash
repomix --remove-comments
```

आउटपुट से कोड टिप्पणियां हटाता है।

### कोड कम्प्रेशन

```bash
repomix --compress
```

कोड को संक्षिप्त करता है, जिससे टोकन उपयोग कम हो जाता है।

## टोकन काउंटिंग विकल्प

### टोकन काउंटर

```bash
repomix --token-counter <model>
```

टोकन काउंटिंग के लिए उपयोग किए जाने वाले मॉडल को निर्दिष्ट करता है। विकल्प: `gpt-4`, `gpt-3.5-turbo`, `claude`, `llama`, `gemini`। डिफॉल्ट: `gpt-4`

## उदाहरण

### बुनियादी उपयोग

```bash
repomix
```

वर्तमान डायरेक्टरी को प्रोसेस करता है और `repomix-output.xml` फाइल बनाता है।

### कस्टम आउटपुट

```bash
repomix --style markdown --output-file docs/codebase.md
```

वर्तमान डायरेक्टरी को प्रोसेस करता है और मार्कडाउन फॉर्मेट में `docs/codebase.md` फाइल बनाता है।

### विशिष्ट फाइलों को प्रोसेस करना

```bash
repomix --include "src/**/*.ts" --ignore "**/*.test.ts"
```

केवल `src` डायरेक्टरी में TypeScript फाइलों को प्रोसेस करता है, टेस्ट फाइलों को छोड़कर।

### रिमोट रिपॉजिटरी प्रोसेसिंग

```bash
repomix --remote yamadashy/repomix --style markdown
```

GitHub से `yamadashy/repomix` रिपॉजिटरी को प्रोसेस करता है और मार्कडाउन फॉर्मेट में आउटपुट बनाता है।

### टोकन उपयोग को कम करना

```bash
repomix --remove-comments --compress
```

टिप्पणियां हटाकर और कोड को संक्षिप्त करके टोकन उपयोग को कम करता है।

### Stdin का उपयोग करके फ़ाइल सूची

```bash
find src -name "*.ts" -type f | repomix --stdin
git ls-files "*.js" | repomix --stdin
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```

## अगला क्या है?

- [कॉन्फिगरेशन विकल्पों](configuration.md) के बारे में अधिक जानें
- [आउटपुट फॉर्मेट](output.md) का अन्वेषण करें
- [सुरक्षा सुविधाओं](security.md) के बारे में जानें
</file>

<file path="website/client/src/hi/guide/comment-removal.md">
# टिप्पणी हटाना

Repomix आपको आउटपुट से कोड टिप्पणियां हटाने की अनुमति देता है। यह सुविधा टोकन उपयोग को कम करने और AI मॉडल के लिए आउटपुट को अधिक संक्षिप्त बनाने में मदद कर सकती है।

## टिप्पणियां हटाने का उपयोग

टिप्पणियां हटाने के लिए, `--remove-comments` विकल्प का उपयोग करें:

```bash
repomix --remove-comments
```

आप इसे अन्य विकल्पों के साथ संयोजित कर सकते हैं:

```bash
repomix --remove-comments --style markdown --output-file output.md
```

## कॉन्फिगरेशन फाइल में टिप्पणियां हटाना

आप अपने `repomix.config.json` में टिप्पणियां हटाने को कॉन्फिगर कर सकते हैं:

```json
{
  "processing": {
    "removeComments": true
  }
}
```

## समर्थित टिप्पणी प्रकार

Repomix निम्नलिखित प्रकार की टिप्पणियों को हटा सकता है:

### सिंगल-लाइन टिप्पणियां

```javascript
// यह एक सिंगल-लाइन टिप्पणी है
const x = 5; // लाइन के अंत में टिप्पणी
```

### मल्टी-लाइन टिप्पणियां

```javascript
/*
 * यह एक मल्टी-लाइन टिप्पणी है
 * जो कई लाइनों पर फैली हुई है
 */
const y = 10;
```

### डॉक्यूमेंटेशन टिप्पणियां

```javascript
/**
 * एक फंक्शन जो दो संख्याओं को जोड़ता है
 * @param {number} a - पहली संख्या
 * @param {number} b - दूसरी संख्या
 * @returns {number} - दोनों संख्याओं का योग
 */
function add(a, b) {
  return a + b;
}
```

### HTML/XML टिप्पणियां

```html
<!-- यह एक HTML टिप्पणी है -->
<div>कंटेंट</div>
```

### पायथन टिप्पणियां

```python
# यह एक पायथन टिप्पणी है
x = 5  # लाइन के अंत में टिप्पणी

"""
यह एक मल्टी-लाइन
पायथन डॉकस्ट्रिंग है
"""
```

## टिप्पणियां हटाने के लाभ

टिप्पणियां हटाने के कई लाभ हैं:

1. **टोकन उपयोग कम करना**: टिप्पणियां हटाकर, आप AI मॉडल के लिए आवश्यक टोकन की संख्या कम कर सकते हैं
2. **शोर कम करना**: टिप्पणियां हटाकर, आप AI मॉडल के लिए आउटपुट को अधिक संक्षिप्त और केंद्रित बना सकते हैं
3. **संवेदनशील जानकारी हटाना**: टिप्पणियां अक्सर संवेदनशील जानकारी या व्यक्तिगत नोट्स शामिल कर सकती हैं

## टिप्पणियां हटाने के नुकसान

टिप्पणियां हटाने के कुछ नुकसान भी हैं:

1. **संदर्भ का नुकसान**: टिप्पणियां अक्सर कोड के बारे में महत्वपूर्ण संदर्भ या स्पष्टीकरण प्रदान करती हैं
2. **डॉक्यूमेंटेशन का नुकसान**: डॉक्यूमेंटेशन टिप्पणियां फंक्शन, पैरामीटर और रिटर्न वैल्यू के बारे में महत्वपूर्ण जानकारी प्रदान करती हैं
3. **कोड समझने में कठिनाई**: टिप्पणियों के बिना, AI मॉडल को कोड का उद्देश्य समझने में कठिनाई हो सकती है

## कब टिप्पणियां हटाएं

निम्नलिखित परिस्थितियों में टिप्पणियां हटाना उपयोगी हो सकता है:

1. **टोकन सीमाओं से निपटना**: जब आप AI मॉडल की टोकन सीमाओं से निपट रहे हों
2. **केवल कोड पर ध्यान केंद्रित करना**: जब आप चाहते हैं कि AI मॉडल केवल कोड पर ध्यान केंद्रित करे
3. **संवेदनशील जानकारी हटाना**: जब टिप्पणियों में संवेदनशील जानकारी शामिल हो

## कब टिप्पणियां न हटाएं

निम्नलिखित परिस्थितियों में टिप्पणियां बनाए रखना बेहतर हो सकता है:

1. **जटिल कोड**: जब कोड जटिल हो और टिप्पणियां महत्वपूर्ण स्पष्टीकरण प्रदान करती हों
2. **API डॉक्यूमेंटेशन**: जब टिप्पणियां API डॉक्यूमेंटेशन के लिए महत्वपूर्ण हों
3. **कोड समझना**: जब आप चाहते हैं कि AI मॉडल कोड के उद्देश्य और कार्यप्रणाली को समझे

## उदाहरण

### टिप्पणियों के साथ कोड

```javascript
/**
 * उपयोगकर्ता को प्रमाणित करता है
 * @param {string} username - उपयोगकर्ता का नाम
 * @param {string} password - उपयोगकर्ता का पासवर्ड
 * @returns {boolean} - प्रमाणीकरण सफल था या नहीं
 */
function authenticateUser(username, password) {
  // डेटाबेस से उपयोगकर्ता प्राप्त करें
  const user = getUserFromDatabase(username);
  
  // यदि उपयोगकर्ता नहीं मिला, तो false लौटाएं
  if (!user) {
    return false;
  }
  
  // पासवर्ड की जांच करें
  return checkPassword(user, password);
}
```

### टिप्पणियों के बिना कोड

```javascript
function authenticateUser(username, password) {
  const user = getUserFromDatabase(username);
  
  if (!user) {
    return false;
  }
  
  return checkPassword(user, password);
}
```

## अगला क्या है?

- [कोड कम्प्रेशन](code-compress.md) के बारे में जानें
- [कमांड लाइन विकल्पों](command-line-options.md) का अन्वेषण करें
- [कॉन्फिगरेशन विकल्पों](configuration.md) के बारे में अधिक जानें
</file>

<file path="website/client/src/hi/guide/configuration.md">
# कॉन्फिगरेशन

Repomix को `repomix.config.json` फाइल के माध्यम से कॉन्फिगर किया जा सकता है। यह फाइल आपको अपने प्रोजेक्ट के लिए डिफॉल्ट विकल्प सेट करने की अनुमति देती है।

## कॉन्फिगरेशन फाइल बनाना

आप निम्न कमांड के साथ एक डिफॉल्ट कॉन्फिगरेशन फाइल बना सकते हैं:

```bash
repomix --init
```

यह आपके वर्तमान डायरेक्टरी में एक `repomix.config.json` फाइल बनाएगा।

## कॉन्फिगरेशन विकल्प

`repomix.config.json` फाइल में निम्नलिखित विकल्प शामिल हो सकते हैं:

```json
{
  "include": ["src/**/*.ts", "**/*.md"],
  "ignore": ["**/node_modules/**", "**/*.test.ts"],
  "output": {
    "style": "xml",
    "file": "repomix-output.xml"
  },
  "processing": {
    "removeComments": false,
    "compress": false
  },
  "security": {
    "check": true
  },
  "tokenCounter": "gpt-4"
}
```

### फिल्टरिंग विकल्प

#### `include`

शामिल करने के लिए [ग्लोब पैटर्न](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax) की एक सूची। यदि निर्दिष्ट नहीं है, तो सभी फाइलें शामिल की जाएंगी (कुछ डिफॉल्ट अपवादों के साथ)।

```json
{
  "include": ["src/**/*.ts", "**/*.md"]
}
```

#### `ignore`

बाहर रखने के लिए [ग्लोब पैटर्न](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax) की एक सूची। यह `include` पैटर्न के बाद लागू होता है।

```json
{
  "ignore": ["**/node_modules/**", "**/*.test.ts"]
}
```

### आउटपुट विकल्प

#### `output.style`

आउटपुट फॉर्मेट निर्दिष्ट करता है। विकल्प: `xml`, `markdown`, या `plain`। डिफॉल्ट: `xml`

```json
{
  "output": {
    "style": "markdown"
  }
}
```

#### `output.file`

आउटपुट फाइल का नाम निर्दिष्ट करता है। डिफॉल्ट: `repomix-output.xml`, `repomix-output.md`, या `repomix-output.txt` (चुने गए स्टाइल के आधार पर)

```json
{
  "output": {
    "file": "docs/codebase.md"
  }
}
```

### प्रोसेसिंग विकल्प

#### `processing.removeComments`

यदि `true` है, तो आउटपुट से कोड टिप्पणियां हटा दी जाएंगी। डिफॉल्ट: `false`

```json
{
  "processing": {
    "removeComments": true
  }
}
```

#### `processing.compress`

यदि `true` है, तो कोड को संक्षिप्त किया जाएगा, जिससे टोकन उपयोग कम हो जाएगा। डिफॉल्ट: `false`

```json
{
  "processing": {
    "compress": true
  }
}
```

### सुरक्षा विकल्प

#### `security.check`

यदि `true` है, तो Repomix संवेदनशील जानकारी के लिए फाइलों की जांच करेगा। डिफॉल्ट: `true`

```json
{
  "security": {
    "check": false
  }
}
```

### टोकन काउंटिंग विकल्प

#### `tokenCounter`

टोकन काउंटिंग के लिए उपयोग किए जाने वाले मॉडल को निर्दिष्ट करता है। विकल्प: `gpt-4`, `gpt-3.5-turbo`, `claude`, `llama`, `gemini`। डिफॉल्ट: `gpt-4`

```json
{
  "tokenCounter": "claude"
}
```

## कस्टम कॉन्फिगरेशन फाइल का उपयोग

आप `--config` विकल्प के साथ एक कस्टम कॉन्फिगरेशन फाइल का पथ निर्दिष्ट कर सकते हैं:

```bash
repomix --config ./configs/my-repomix-config.json
```

## कमांड लाइन विकल्प और कॉन्फिगरेशन फाइल

कमांड लाइन विकल्प कॉन्फिगरेशन फाइल में निर्दिष्ट विकल्पों को ओवरराइड करते हैं। उदाहरण के लिए, यदि आपकी कॉन्फिगरेशन फाइल में `"style": "xml"` है, लेकिन आप `--style markdown` कमांड लाइन विकल्प का उपयोग करते हैं, तो आउटपुट मार्कडाउन फॉर्मेट में होगा।

## कॉन्फिगरेशन उदाहरण

### बुनियादी कॉन्फिगरेशन

```json
{
  "include": ["src/**/*.ts", "**/*.md"],
  "ignore": ["**/node_modules/**", "**/*.test.ts"],
  "output": {
    "style": "markdown",
    "file": "docs/codebase.md"
  }
}
```

### टोकन उपयोग को कम करने के लिए कॉन्फिगरेशन

```json
{
  "processing": {
    "removeComments": true,
    "compress": true
  },
  "tokenCounter": "gpt-4"
}
```

### विकास प्रोजेक्ट के लिए कॉन्फिगरेशन

```json
{
  "include": ["src/**/*.ts"],
  "ignore": ["**/*.test.ts", "**/dist/**"],
  "output": {
    "style": "xml",
    "file": "docs/api-reference.xml"
  },
  "processing": {
    "removeComments": false,
    "compress": false
  }
}
```

### दस्तावेज़ीकरण प्रोजेक्ट के लिए कॉन्फिगरेशन

```json
{
  "include": ["**/*.md", "docs/**/*"],
  "ignore": ["**/node_modules/**"],
  "output": {
    "style": "markdown",
    "file": "docs/documentation.md"
  }
}
```

## अगला क्या है?

- [कमांड लाइन विकल्पों](command-line-options.md) के बारे में अधिक जानें
- [आउटपुट फॉर्मेट](output.md) का अन्वेषण करें
- [कस्टम निर्देशों](custom-instructions.md) के बारे में जानें
</file>

<file path="website/client/src/hi/guide/custom-instructions.md">
# कस्टम निर्देश

Repomix आपको अपने आउटपुट में कस्टम निर्देश शामिल करने की अनुमति देता है। ये निर्देश AI मॉडल को आपके कोडबेस के साथ कैसे इंटरैक्ट करना है, इसके बारे में मार्गदर्शन प्रदान करते हैं।

## कस्टम निर्देश क्या हैं?

कस्टम निर्देश आपके कोडबेस के बारे में अतिरिक्त जानकारी या AI मॉडल के लिए विशिष्ट निर्देश हैं। इनका उपयोग निम्नलिखित के लिए किया जा सकता है:

1. **कोडबेस का संदर्भ प्रदान करना**: प्रोजेक्ट संरचना, आर्किटेक्चर, या महत्वपूर्ण फाइलों के बारे में जानकारी
2. **विशिष्ट निर्देश देना**: AI मॉडल को विशिष्ट कार्यों या विश्लेषण पर ध्यान केंद्रित करने के लिए निर्देश देना
3. **संदर्भ जोड़ना**: प्रोजेक्ट के बारे में अतिरिक्त जानकारी या संदर्भ प्रदान करना

## कस्टम निर्देश जोड़ना

कस्टम निर्देश जोड़ने के दो तरीके हैं:

### 1. कमांड लाइन विकल्प

`--instructions` विकल्प का उपयोग करके कस्टम निर्देश फाइल निर्दिष्ट करें:

```bash
repomix --instructions ./instructions.md
```

### 2. कॉन्फिगरेशन फाइल

अपने `repomix.config.json` में `instructions` फील्ड का उपयोग करें:

```json
{
  "instructions": "./instructions.md"
}
```

## कस्टम निर्देश फॉर्मेट

कस्टम निर्देश फाइलें मार्कडाउन फॉर्मेट में होनी चाहिए। वे आपके आउटपुट फाइल के शीर्ष पर जोड़ी जाएंगी।

### उदाहरण कस्टम निर्देश फाइल

```markdown
# प्रोजेक्ट निर्देश

यह एक Node.js बैकएंड API है जो MongoDB का उपयोग करता है। प्रोजेक्ट की संरचना निम्नानुसार है:

- `src/controllers/`: API एंडपॉइंट हैंडलर्स
- `src/models/`: MongoDB मॉडल्स
- `src/services/`: बिजनेस लॉजिक
- `src/utils/`: उपयोगिता फंक्शन्स

## विश्लेषण के लिए निर्देश

कृपया निम्नलिखित पर ध्यान केंद्रित करें:

1. कोड गुणवत्ता और शैली
2. संभावित प्रदर्शन बॉटलनेक
3. सुरक्षा समस्याएं
4. त्रुटि हैंडलिंग

## महत्वपूर्ण नोट्स

- यह प्रोजेक्ट TypeScript का उपयोग करता है
- हम Express.js फ्रेमवर्क का उपयोग करते हैं
- हम Jest का उपयोग टेस्टिंग के लिए करते हैं
```

## प्रभावी कस्टम निर्देश के लिए टिप्स

### 1. प्रोजेक्ट संदर्भ प्रदान करें

AI मॉडल को आपके प्रोजेक्ट के बारे में महत्वपूर्ण जानकारी प्रदान करें:

```markdown
# प्रोजेक्ट संदर्भ

यह एक React फ्रंटएंड एप्लिकेशन है जो Redux का उपयोग स्टेट मैनेजमेंट के लिए करती है। 
हम Tailwind CSS का उपयोग स्टाइलिंग के लिए करते हैं।
```

### 2. विशिष्ट विश्लेषण क्षेत्र निर्दिष्ट करें

AI मॉडल को बताएं कि आप किन पहलुओं पर ध्यान केंद्रित करना चाहते हैं:

```markdown
# विश्लेषण फोकस

कृपया निम्नलिखित पर ध्यान केंद्रित करें:
1. कंपोनेंट पुन: उपयोग और संरचना
2. प्रदर्शन अनुकूलन के अवसर
3. एक्सेसिबिलिटी समस्याएं
```

### 3. प्रोजेक्ट-विशिष्ट शब्दावली शामिल करें

महत्वपूर्ण शब्दावली या प्रोजेक्ट-विशिष्ट शब्दों को परिभाषित करें:

```markdown
# प्रोजेक्ट शब्दावली

- **Workspace**: एक उपयोगकर्ता का निजी कार्य क्षेत्र
- **Collection**: संबंधित दस्तावेज़ों का एक समूह
- **Template**: पूर्व-परिभाषित दस्तावेज़ संरचना
```

### 4. कोडिंग मानक और दिशानिर्देश शामिल करें

अपने कोडिंग मानकों और दिशानिर्देशों को शामिल करें:

```markdown
# कोडिंग मानक

- हम Airbnb JavaScript स्टाइल गाइड का पालन करते हैं
- सभी कंपोनेंट फंक्शनल कंपोनेंट होने चाहिए
- हम camelCase का उपयोग वेरिएबल और फंक्शन नामों के लिए करते हैं
- हम PascalCase का उपयोग कंपोनेंट नामों के लिए करते हैं
```

### 5. उदाहरण और संदर्भ शामिल करें

उदाहरण या संदर्भ शामिल करें जो AI मॉडल को मदद कर सकते हैं:

```markdown
# उदाहरण और संदर्भ

## API एंडपॉइंट उदाहरण

```json
GET /api/users
{
  "users": [
    { "id": 1, "name": "John Doe" },
    { "id": 2, "name": "Jane Smith" }
  ]
}
```

## डेटाबेस स्कीमा संदर्भ

User स्कीमा में निम्नलिखित फील्ड्स हैं:
- id: UUID
- name: String
- email: String
- createdAt: Date
```

## कस्टम निर्देशों के साथ आउटपुट

जब आप कस्टम निर्देशों के साथ Repomix का उपयोग करते हैं, तो आउटपुट फाइल में आपके निर्देश शीर्ष पर शामिल होंगे:

### XML आउटपुट

```xml
<!--
# प्रोजेक्ट निर्देश

यह एक Node.js बैकएंड API है...
-->

<repository>
  <file path="src/index.ts" type="typescript">
    // फाइल सामग्री
  </file>
  <!-- अन्य फाइलें -->
</repository>
```

### मार्कडाउन आउटपुट

```markdown
# प्रोजेक्ट निर्देश

यह एक Node.js बैकएंड API है...

---

# Repository

## src/index.ts
```typescript
// फाइल सामग्री
```

<!-- अन्य फाइलें -->
```

## अगला क्या है?

- [कमांड लाइन विकल्पों](command-line-options.md) के बारे में अधिक जानें
- [कॉन्फिगरेशन विकल्पों](configuration.md) का अन्वेषण करें
- [प्रॉम्प्ट उदाहरणों](prompt-examples.md) को देखें
</file>

<file path="website/client/src/hi/guide/github-actions.md">
# GitHub Actions

Repomix को GitHub Actions के साथ एकीकृत किया जा सकता है ताकि रिपॉजिटरी को स्वचालित रूप से प्रोसेस किया जा सके और AI-फ्रेंडली आउटपुट जनरेट किया जा सके। यह आपको CI/CD पाइपलाइन के हिस्से के रूप में Repomix का उपयोग करने की अनुमति देता है।

## बुनियादी उपयोग

यहां GitHub Actions में Repomix का उपयोग करने के लिए एक बुनियादी वर्कफ़्लो कॉन्फिगरेशन है:

```yaml
name: Repomix

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  repomix:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Run Repomix
        run: npx repomix --output-file repomix-output.xml
      
      - name: Upload Repomix Output
        uses: actions/upload-artifact@v3
        with:
          name: repomix-output
          path: repomix-output.xml
```

यह वर्कफ़्लो मुख्य ब्रांच पर हर पुश या पुल रिक्वेस्ट पर चलता है, रिपॉजिटरी को प्रोसेस करता है और `repomix-output.xml` फाइल जनरेट करता है, फिर इसे आर्टिफैक्ट के रूप में अपलोड करता है।

## उन्नत कॉन्फिगरेशन

अधिक उन्नत कॉन्फिगरेशन के लिए, आप निम्न विकल्पों को जोड़ सकते हैं:

```yaml
name: Repomix Advanced

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 0 * * 1'  # हर सोमवार को चलाएं
  
jobs:
  repomix:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Run Repomix
        run: |
          npx repomix \
            --style markdown \
            --output-file repomix-output.md \
            --include "src/**/*.ts,docs/**/*.md" \
            --ignore "**/*.test.ts,**/node_modules/**" \
            --remove-comments \
            --compress
      
      - name: Upload Repomix Output
        uses: actions/upload-artifact@v3
        with:
          name: repomix-output
          path: repomix-output.md
      
      - name: Create GitHub Release
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: softprops/action-gh-release@v1
        with:
          files: repomix-output.md
          name: Repomix Output ${{ github.sha }}
          tag_name: repomix-${{ github.sha }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

इस उन्नत कॉन्फिगरेशन में, हम निम्न कार्य कर रहे हैं:

1. शेड्यूल्ड रन जोड़ना (हर सोमवार)
2. अधिक Repomix विकल्पों का उपयोग करना
3. मुख्य ब्रांच पर पुश होने पर GitHub रिलीज बनाना

## एनवायरनमेंट वेरिएबल्स और सीक्रेट्स

संवेदनशील जानकारी के साथ काम करते समय, आप GitHub सीक्रेट्स का उपयोग कर सकते हैं:

```yaml
- name: Run Repomix with Auth
  run: npx repomix --remote user/private-repo
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

## मैट्रिक्स बिल्ड

कई कॉन्फिगरेशन के साथ Repomix चलाने के लिए, आप मैट्रिक्स बिल्ड का उपयोग कर सकते हैं:

```yaml
jobs:
  repomix:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        output-style: [xml, markdown, plain]
        node-version: [16, 18, 20]
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
      
      - name: Run Repomix
        run: npx repomix --style ${{ matrix.output-style }} --output-file repomix-output.${{ matrix.output-style }}
      
      - name: Upload Repomix Output
        uses: actions/upload-artifact@v3
        with:
          name: repomix-output-${{ matrix.output-style }}-node${{ matrix.node-version }}
          path: repomix-output.${{ matrix.output-style }}
```

## पुल रिक्वेस्ट कमेंट्स

आप Repomix आउटपुट को पुल रिक्वेस्ट पर कमेंट के रूप में भी जोड़ सकते हैं:

```yaml
- name: Run Repomix
  run: npx repomix --style markdown --output-file repomix-output.md

- name: Comment on PR
  if: github.event_name == 'pull_request'
  uses: actions/github-script@v6
  with:
    github-token: ${{ secrets.GITHUB_TOKEN }}
    script: |
      const fs = require('fs');
      const output = fs.readFileSync('repomix-output.md', 'utf8');
      const summary = output.split('\n').slice(0, 20).join('\n') + '\n\n[Full output attached as artifact]';
      
      github.rest.issues.createComment({
        issue_number: context.issue.number,
        owner: context.repo.owner,
        repo: context.repo.repo,
        body: summary
      });
```

## अगला क्या है?

- [कमांड लाइन विकल्पों](command-line-options.md) के बारे में अधिक जानें
- [कॉन्फिगरेशन विकल्पों](configuration.md) का अन्वेषण करें
- [रिमोट रिपॉजिटरी प्रोसेसिंग](remote-repository-processing.md) के बारे में जानें
</file>

<file path="website/client/src/hi/guide/index.md">
# Repomix के साथ शुरुआत करना

<script setup>
import HomeBadges from '../../../components/HomeBadges.vue'
import YouTubeVideo from '../../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../../utils/videos'
</script>

Repomix एक ऐसा टूल है जो आपके पूरे रिपॉजिटरी को एक एकल, AI-फ्रेंडली फाइल में पैक करता है। यह आपके कोडबेस को ChatGPT, DeepSeek, Perplexity, Gemini, Gemma, Llama, Grok और अन्य जैसे लार्ज लैंग्वेज मॉडल (LLMs) को फीड करने में मदद करने के लिए डिज़ाइन किया गया है।

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

<HomeBadges />

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## त्वरित शुरुआत

अपने प्रोजेक्ट डायरेक्टरी में यह कमांड चलाएं:

```bash
npx repomix
```

बस इतना ही! आपको एक `repomix-output.xml` फाइल मिलेगी जिसमें आपका पूरा रिपॉजिटरी AI-फ्रेंडली फॉर्मेट में होगा।

फिर आप इस फाइल को इस तरह के प्रॉम्प्ट के साथ एक AI असिस्टेंट को भेज सकते हैं:

```
इस फाइल में रिपॉजिटरी की सभी फाइलें एक में संयोजित हैं।
मैं कोड को रिफैक्टर करना चाहता हूं, इसलिए कृपया पहले इसकी समीक्षा करें।
```

AI आपके पूरे कोडबेस का विश्लेषण करेगा और व्यापक अंतर्दृष्टि प्रदान करेगा:

![Repomix File Usage 1](/images/docs/repomix-file-usage-1.png)

विशिष्ट परिवर्तनों पर चर्चा करते समय, AI कोड जनरेट करने में मदद कर सकता है। Claude के आर्टिफैक्ट्स जैसी सुविधाओं के साथ, आप कई परस्पर निर्भर फाइलें भी प्राप्त कर सकते हैं:

![Repomix File Usage 2](/images/docs/repomix-file-usage-2.png)

हैप्पी कोडिंग! 🚀

## मुख्य विशेषताएं

- **AI-अनुकूलित आउटपुट**: आपके कोडबेस को आसान AI प्रोसेसिंग के लिए फॉर्मेट करता है
- **टोकन काउंटिंग**: LLM कॉन्टेक्स्ट सीमाओं के लिए टोकन उपयोग को ट्रैक करता है
- **Git-जागरूक**: आपकी `.gitignore` और `.git/info/exclude` फाइलों का सम्मान करता है
- **सुरक्षा-केंद्रित**: संवेदनशील जानकारी का पता लगाता है
- **कई आउटपुट फॉर्मेट**: प्लेन टेक्स्ट, XML, या मार्कडाउन के बीच चुनें

## आगे क्या है?

- [इंस्टॉलेशन गाइड](installation.md): Repomix इंस्टॉल करने के विभिन्न तरीके
- [उपयोग गाइड](usage.md): बुनियादी और उन्नत सुविधाओं के बारे में जानें
- [कॉन्फिगरेशन](configuration.md): अपनी आवश्यकताओं के लिए Repomix को अनुकूलित करें
- [सुरक्षा सुविधाएं](security.md): सुरक्षा जांच के बारे में जानें

## समुदाय

हमारे [Discord समुदाय](https://discord.gg/wNYzTwZFku) में शामिल हों:
- Repomix के साथ मदद प्राप्त करना
- अपने अनुभव साझा करना
- नई सुविधाओं का सुझाव देना
- अन्य उपयोगकर्ताओं से जुड़ना

## सहायता

बग मिला या मदद चाहिए?
- [GitHub पर एक इश्यू खोलें](https://github.com/yamadashy/repomix/issues)
- हमारे Discord सर्वर में शामिल हों
- [दस्तावेज़ीकरण](https://repomix.com) देखें
</file>

<file path="website/client/src/hi/guide/installation.md">
# इंस्टॉलेशन

Repomix को कई तरीकों से इंस्टॉल किया जा सकता है। अपनी आवश्यकताओं के अनुसार सबसे उपयुक्त विधि चुनें।

## npx के साथ बिना इंस्टॉलेशन के उपयोग

आप Repomix को बिना इंस्टॉल किए तुरंत उपयोग कर सकते हैं:

```bash
npx repomix
```

यह विधि तब उपयोगी होती है जब आप Repomix को आजमाना चाहते हैं या इसे केवल एक बार उपयोग करना चाहते हैं।

## ग्लोबल इंस्टॉलेशन

### npm के साथ

```bash
npm install -g repomix
```

### yarn के साथ

```bash
yarn global add repomix
```

### pnpm के साथ

```bash
pnpm add -g repomix
```

### Bun

```bash
bun add -g repomix
```

### Homebrew के साथ (macOS और Linux)

```bash
brew install repomix
```

## प्रोजेक्ट-स्पेसिफिक इंस्टॉलेशन

आप Repomix को अपने प्रोजेक्ट की डिपेंडेंसी के रूप में भी इंस्टॉल कर सकते हैं:

### npm के साथ

```bash
npm install --save-dev repomix
```

### yarn के साथ

```bash
yarn add --dev repomix
```

### pnpm के साथ

```bash
pnpm add -D repomix
```

## Docker के साथ उपयोग

Repomix को Docker कंटेनर के रूप में भी चलाया जा सकता है:

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

## ब्राउज़र एक्सटेंशन

किसी भी GitHub रिपॉजिटरी से Repomix तक तुरंत पहुंच प्राप्त करें! हमारा ब्राउज़र एक्सटेंशन GitHub रिपॉजिटरी पेजों पर एक सुविधाजनक "Repomix" बटन जोड़ता है।

![Repomix Browser Extension](/images/docs/browser-extension.png)

### इंस्टॉलेशन
- Chrome एक्सटेंशन: [Repomix - Chrome Web Store](https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa)
- Firefox ऐड-ऑन: [Repomix - Firefox Add-ons](https://addons.mozilla.org/firefox/addon/repomix/)

### विशेषताएं
- किसी भी GitHub रिपॉजिटरी के लिए वन-क्लिक Repomix पहुंच
- और भी रोमांचक सुविधाएं जल्द ही आ रही हैं!

## GitHub Actions के साथ उपयोग

Repomix को GitHub Actions में एक एक्शन के रूप में भी उपयोग किया जा सकता है। अधिक जानकारी के लिए [GitHub Actions गाइड](github-actions.md) देखें।

## सत्यापन

इंस्टॉलेशन सत्यापित करने के लिए, निम्न कमांड चलाएं:

```bash
repomix --version
```

यह Repomix का वर्तमान वर्जन प्रदर्शित करेगा।

## अगला क्या है?

- [बुनियादी उपयोग](usage.md) के साथ शुरू करें
- [कॉन्फिगरेशन विकल्पों](configuration.md) के बारे में जानें
- [कमांड लाइन विकल्पों](command-line-options.md) का अन्वेषण करें
</file>

<file path="website/client/src/hi/guide/mcp-server.md">
# MCP सर्वर

Repomix [Model Context Protocol (MCP)](https://modelcontextprotocol.io) का समर्थन करता है, जो AI असिस्टेंट्स को आपके कोडबेस के साथ सीधे इंटरैक्ट करने की अनुमति देता है। जब MCP सर्वर के रूप में चलाया जाता है, तो Repomix ऐसे टूल्स प्रदान करता है जो AI असिस्टेंट्स को मैन्युअल फ़ाइल तैयारी की आवश्यकता के बिना विश्लेषण के लिए स्थानीय या रिमोट रिपॉजिटरी को पैकेज करने की अनुमति देते हैं।

> [!NOTE]  
> यह एक प्रयोगात्मक सुविधा है जिसे हम उपयोगकर्ता फीडबैक और वास्तविक-जगत के उपयोग के आधार पर सक्रिय रूप से सुधारेंगे

## Repomix को MCP सर्वर के रूप में चलाना

Repomix को MCP सर्वर के रूप में चलाने के लिए, `--mcp` फ्लैग का उपयोग करें:

```bash
repomix --mcp
```

यह Repomix को MCP सर्वर मोड में शुरू करता है, इसे Model Context Protocol का समर्थन करने वाले AI असिस्टेंट्स के लिए उपलब्ध बनाता है।

## MCP सर्वर कॉन्फ़िगरेशन

Claude जैसे AI असिस्टेंट्स के साथ Repomix को MCP सर्वर के रूप में उपयोग करने के लिए, आपको MCP सेटिंग्स कॉन्फ़िगर करनी होंगी:

### VS Code के लिए

आप निम्नलिखित तरीकों में से एक का उपयोग करके VS Code में Repomix MCP सर्वर इंस्टॉल कर सकते हैं:

1. **इंस्टॉलेशन बैज का उपयोग करके:**

  [![Install in VS Code](https://img.shields.io/badge/VS_Code-VS_Code?style=flat-square&label=Install%20Server&color=0098FF)](vscode:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)<br>
  [![Install in VS Code Insiders](https://img.shields.io/badge/VS_Code_Insiders-VS_Code_Insiders?style=flat-square&label=Install%20Server&color=24bfa5)](vscode-insiders:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)

2. **कमांड लाइन का उपयोग करके:**

  ```bash
  code --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

  VS Code Insiders के लिए:
  ```bash
  code-insiders --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

### Cline (VS Code एक्सटेंशन) के लिए

`cline_mcp_settings.json` फ़ाइल को संपादित करें:

```json
{
  "mcpServers": {
    "repomix": {
      "command": "npx",
      "args": [
        "-y",
        "repomix",
        "--mcp"
      ]
    }
  }
}
```

### Cursor के लिए

Cursor में, `Cursor Settings` > `MCP` > `+ Add new global MCP server` से एक नया MCP सर्वर जोड़ें, जो Cline के समान कॉन्फ़िगरेशन के साथ हो।

### Claude Desktop के लिए

`claude_desktop_config.json` फ़ाइल को Cline के समान कॉन्फ़िगरेशन के साथ संपादित करें।

### Claude Code के लिए

[Claude Code](https://docs.anthropic.com/en/docs/claude-code/overview) में Repomix को MCP सर्वर के रूप में कॉन्फ़िगर करने के लिए, निम्नलिखित कमांड का उपयोग करें:

```bash
claude mcp add repomix -- npx -y repomix --mcp
```

### npx के बजाय Docker का उपयोग करना

npx का उपयोग करने के बजाय, आप Repomix को MCP सर्वर के रूप में चलाने के लिए Docker का उपयोग कर सकते हैं:

```json
{
  "mcpServers": {
    "repomix-docker": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "ghcr.io/yamadashy/repomix",
        "--mcp"
      ]
    }
  }
}
```

## उपलब्ध MCP टूल्स

जब MCP सर्वर के रूप में चलाया जाता है, तो Repomix निम्नलिखित टूल्स प्रदान करता है:

### pack_codebase

यह टूल स्थानीय कोड डायरेक्टरी को AI विश्लेषण के लिए XML फ़ाइल में पैकेज करता है। यह कोडबेस संरचना का विश्लेषण करता है, प्रासंगिक कोड सामग्री निकालता है, और मेट्रिक्स, फ़ाइल ट्री, और फॉर्मेटेड कोड सामग्री सहित एक व्यापक रिपोर्ट जेनरेट करता है।

**पैरामीटर:**
- `directory`: (आवश्यक) पैकेज करने के लिए डायरेक्टरी का पूर्ण पथ
- `compress`: (वैकल्पिक, डिफ़ॉल्ट: false) इम्प्लीमेंटेशन विवरण हटाते समय आवश्यक कोड हस्ताक्षर और संरचना निकालने के लिए Tree-sitter संपीड़न सक्षम करता है। सिमेंटिक अर्थ संरक्षित रखते हुए टोकन उपयोग को ~70% कम करता है। आमतौर पर आवश्यक नहीं क्योंकि grep_repomix_output वृद्धिशील सामग्री पुनर्प्राप्ति की अनुमति देता है। केवल तब उपयोग करें जब आपको विशेष रूप से बड़े रिपॉजिटरी के लिए पूरी कोडबेस सामग्री की आवश्यकता हो।
- `includePatterns`: (वैकल्पिक) fast-glob पैटर्न का उपयोग करके शामिल करने के लिए फ़ाइलें निर्दिष्ट करता है। कई पैटर्न को कॉमा से अलग किया जा सकता है (जैसे: "**/*.{js,ts}", "src/**,docs/**")। केवल मैचिंग फ़ाइलें प्रोसेस की जाएंगी।
- `ignorePatterns`: (वैकल्पिक) fast-glob पैटर्न का उपयोग करके बाहर करने के लिए अतिरिक्त फ़ाइलें निर्दिष्ट करता है। कई पैटर्न को कॉमा से अलग किया जा सकता है (जैसे: "test/**,*.spec.js", "node_modules/**,dist/**")। ये पैटर्न .gitignore और बिल्ट-इन एक्सक्लूज़न को पूरक करते हैं।
- `topFilesLength`: (वैकल्पिक, डिफ़ॉल्ट: 10) कोडबेस विश्लेषण के लिए मेट्रिक्स सारांश में दिखाने के लिए आकार के अनुसार सबसे बड़ी फ़ाइलों की संख्या।

**उदाहरण:**
```json
{
  "directory": "/path/to/your/project",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### pack_remote_repository

यह टूल GitHub रिपॉजिटरी को fetch, clone और AI विश्लेषण के लिए XML फ़ाइल में पैकेज करता है। यह स्वचालित रूप से रिमोट रिपॉजिटरी को clone करता है, इसकी संरचना का विश्लेषण करता है, और एक व्यापक रिपोर्ट जेनरेट करता है।

**पैरामीटर:**
- `remote`: (आवश्यक) GitHub रिपॉजिटरी URL या user/repo फॉर्मेट (जैसे: "yamadashy/repomix", "https://github.com/user/repo", या "https://github.com/user/repo/tree/branch")
- `compress`: (वैकल्पिक, डिफ़ॉल्ट: false) इम्प्लीमेंटेशन विवरण हटाते समय आवश्यक कोड हस्ताक्षर और संरचना निकालने के लिए Tree-sitter संपीड़न सक्षम करता है। सिमेंटिक अर्थ संरक्षित रखते हुए टोकन उपयोग को ~70% कम करता है। आमतौर पर आवश्यक नहीं क्योंकि grep_repomix_output वृद्धिशील सामग्री पुनर्प्राप्ति की अनुमति देता है। केवल तब उपयोग करें जब आपको विशेष रूप से बड़े रिपॉजिटरी के लिए पूरी कोडबेस सामग्री की आवश्यकता हो।
- `includePatterns`: (वैकल्पिक) fast-glob पैटर्न का उपयोग करके शामिल करने के लिए फ़ाइलें निर्दिष्ट करता है। कई पैटर्न को कॉमा से अलग किया जा सकता है (जैसे: "**/*.{js,ts}", "src/**,docs/**")। केवल मैचिंग फ़ाइलें प्रोसेस की जाएंगी।
- `ignorePatterns`: (वैकल्पिक) fast-glob पैटर्न का उपयोग करके बाहर करने के लिए अतिरिक्त फ़ाइलें निर्दिष्ट करता है। कई पैटर्न को कॉमा से अलग किया जा सकता है (जैसे: "test/**,*.spec.js", "node_modules/**,dist/**")। ये पैटर्न .gitignore और बिल्ट-इन एक्सक्लूज़न को पूरक करते हैं।
- `topFilesLength`: (वैकल्पिक, डिफ़ॉल्ट: 10) कोडबेस विश्लेषण के लिए मेट्रिक्स सारांश में दिखाने के लिए आकार के अनुसार सबसे बड़ी फ़ाइलों की संख्या।

**उदाहरण:**
```json
{
  "remote": "yamadashy/repomix",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### read_repomix_output

यह टूल Repomix द्वारा जेनरेट की गई आउटपुट फ़ाइल की सामग्री पढ़ता है। बड़ी फ़ाइलों के लिए लाइन रेंज स्पेसिफिकेशन के साथ आंशिक पढ़ने का समर्थन करता है। यह टूल उन वातावरणों के लिए डिज़ाइन किया गया है जहाँ प्रत्यक्ष फ़ाइल सिस्टम पहुंच सीमित है।

**पैरामीटर:**
- `outputId`: (आवश्यक) पढ़ने के लिए Repomix आउटपुट फ़ाइल की ID
- `startLine`: (वैकल्पिक) शुरुआती लाइन नंबर (1-आधारित, समावेशी)। यदि निर्दिष्ट नहीं है, तो शुरुआत से पढ़ता है।
- `endLine`: (वैकल्पिक) अंतिम लाइन नंबर (1-आधारित, समावेशी)। यदि निर्दिष्ट नहीं है, तो अंत तक पढ़ता है।

**विशेषताएं:**
- विशेष रूप से वेब-आधारित वातावरण या सैंडबॉक्स एप्लिकेशन के लिए डिज़ाइन किया गया
- उनकी ID का उपयोग करके पहले से जेनरेट किए गए आउटपुट की सामग्री पुनर्प्राप्त करता है
- फ़ाइल सिस्टम पहुंच की आवश्यकता के बिना पैकेज्ड कोडबेस तक सुरक्षित पहुंच प्रदान करता है
- बड़ी फ़ाइलों के लिए आंशिक पढ़ने का समर्थन करता है

**उदाहरण:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "startLine": 100,
  "endLine": 200
}
```

### grep_repomix_output

यह टूल JavaScript RegExp सिंटैक्स के साथ grep-जैसी कार्यक्षमता का उपयोग करके Repomix आउटपुट फ़ाइल में पैटर्न खोजता है। मैचों के आसपास वैकल्पिक संदर्भ लाइनों के साथ मैचिंग लाइनें वापस करता है।

**पैरामीटर:**
- `outputId`: (आवश्यक) खोजने के लिए Repomix आउटपुट फ़ाइल की ID
- `pattern`: (आवश्यक) खोज पैटर्न (JavaScript RegExp नियमित अभिव्यक्ति सिंटैक्स)
- `contextLines`: (वैकल्पिक, डिफ़ॉल्ट: 0) प्रत्येक मैच से पहले और बाद में दिखाने के लिए संदर्भ लाइनों की संख्या। beforeLines/afterLines निर्दिष्ट होने पर इसे ओवरराइड किया जाता है।
- `beforeLines`: (वैकल्पिक) प्रत्येक मैच से पहले दिखाने के लिए संदर्भ लाइनों की संख्या (grep -B की तरह)। contextLines पर प्राथमिकता लेता है।
- `afterLines`: (वैकल्पिक) प्रत्येक मैच के बाद दिखाने के लिए संदर्भ लाइनों की संख्या (grep -A की तरह)। contextLines पर प्राथमिकता लेता है।
- `ignoreCase`: (वैकल्पिक, डिफ़ॉल्ट: false) केस-इनसेंसिटिव मैचिंग करता है

**विशेषताएं:**
- शक्तिशाली पैटर्न मैचिंग के लिए JavaScript RegExp सिंटैक्स का उपयोग करता है
- मैचों की बेहतर समझ के लिए संदर्भ लाइनों का समर्थन करता है
- पहले/बाद की संदर्भ लाइनों का अलग नियंत्रण की अनुमति देता है
- केस-सेंसिटिव और केस-इनसेंसिटिव खोज विकल्प

**उदाहरण:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "pattern": "function\\s+\\w+\\(",
  "contextLines": 3,
  "ignoreCase": false
}
```

### file_system_read_file और file_system_read_directory

Repomix का MCP सर्वर दो फ़ाइल सिस्टम टूल्स प्रदान करता है जो AI असिस्टेंट्स को स्थानीय फ़ाइल सिस्टम के साथ सुरक्षित रूप से इंटरैक्ट करने की अनुमति देते हैं:

1. `file_system_read_file`
  - पूर्ण पथों का उपयोग करके स्थानीय फ़ाइल सिस्टम से फ़ाइल सामग्री पढ़ता है
  - संवेदनशील जानकारी वाली फ़ाइलों तक पहुंच का पता लगाने और रोकने के लिए बिल्ट-इन सुरक्षा सत्यापन शामिल करता है
  - [Secretlint](https://github.com/secretlint/secretlint) का उपयोग करके सुरक्षा सत्यापन लागू करता है
  - संवेदनशील जानकारी (API कीज़, पासवर्ड, सीक्रेट्स) वाली फ़ाइलों तक पहुंच को रोकता है
  - डायरेक्टरी ट्रैवर्सल हमलों को रोकने के लिए पूर्ण पथों को सत्यापित करता है
  - अमान्य पथों और सुरक्षा समस्याओं के लिए स्पष्ट त्रुटि संदेश वापस करता है

2. `file_system_read_directory`
  - पूर्ण पथ का उपयोग करके डायरेक्टरी की सामग्री सूचीबद्ध करता है
  - स्पष्ट संकेतकों के साथ फ़ाइलें और उप-डायरेक्टरी दिखाने वाली एक फॉर्मेटेड सूची वापस करता है
  - स्पष्ट संकेतकों (`[FILE]` या `[DIR]`) के साथ फ़ाइलें और डायरेक्टरी दिखाता है
  - उचित त्रुटि हैंडलिंग के साथ सुरक्षित डायरेक्टरी नेवीगेशन प्रदान करता है
  - पथों को सत्यापित करता है और सुनिश्चित करता है कि वे पूर्ण हैं
  - प्रोजेक्ट संरचना का अन्वेषण और कोडबेस संगठन की समझ के लिए उपयोगी

दोनों टूल्स मजबूत सुरक्षा उपाय शामिल करते हैं:
- डायरेक्टरी ट्रैवर्सल हमलों को रोकने के लिए पूर्ण पथ सत्यापन
- उचित पहुंच अधिकार सुनिश्चित करने के लिए अनुमति जांच
- संवेदनशील जानकारी का पता लगाने के लिए Secretlint के साथ एकीकरण
- बेहतर डीबगिंग और सुरक्षा जागरूकता के लिए स्पष्ट त्रुटि संदेश

**उदाहरण:**
```typescript
// फ़ाइल पढ़ना
const fileContent = await tools.file_system_read_file({
  path: '/absolute/path/to/file.txt'
});

// डायरेक्टरी सामग्री सूचीबद्ध करना
const dirContent = await tools.file_system_read_directory({
  path: '/absolute/path/to/directory'
});
```

ये टूल्स विशेष रूप से उपयोगी हैं जब AI असिस्टेंट्स को निम्नलिखित की आवश्यकता होती है:
- कोडबेस में विशिष्ट फ़ाइलों का विश्लेषण करना
- डायरेक्टरी संरचनाओं को नेविगेट करना
- फ़ाइलों की उपस्थिति और पहुंच की पुष्टि करना
- सुरक्षित फ़ाइल सिस्टम ऑपरेशन सुनिश्चित करना

## Repomix को MCP सर्वर के रूप में उपयोग करने के लाभ

Repomix को MCP सर्वर के रूप में उपयोग करने से कई फायदे मिलते हैं:

1. **प्रत्यक्ष एकीकरण**: AI असिस्टेंट्स मैन्युअल फ़ाइल तैयारी के बिना आपके कोडबेस का सीधे विश्लेषण कर सकते हैं।
2. **कुशल वर्कफ़्लो**: मैन्युअल रूप से फ़ाइलें जेनरेट और अपलोड करने की आवश्यकता को समाप्त करके कोड विश्लेषण प्रक्रिया को सुव्यवस्थित करता है।
3. **सुसंगत आउटपुट**: सुनिश्चित करता है कि AI असिस्टेंट को एक सुसंगत, अनुकूलित प्रारूप में कोडबेस प्राप्त होता है।
4. **उन्नत सुविधाएं**: कोड संपीड़न, टोकन गिनती, और सुरक्षा जांच जैसी Repomix की सभी सुविधाओं का लाभ उठाता है।

एक बार कॉन्फ़िगर होने के बाद, आपका AI असिस्टेंट कोडबेस का विश्लेषण करने के लिए Repomix की क्षमताओं का सीधे उपयोग कर सकता है, जिससे कोड विश्लेषण वर्कफ़्लो अधिक कुशल हो जाते हैं।
</file>

<file path="website/client/src/hi/guide/output.md">
# आउटपुट फॉर्मेट

Repomix तीन आउटपुट फॉर्मेट का समर्थन करता है: XML, मार्कडाउन और प्लेन टेक्स्ट। प्रत्येक फॉर्मेट के अपने फायदे हैं और विभिन्न उपयोग मामलों के लिए अनुकूलित हैं।

## आउटपुट फॉर्मेट विकल्प

आप `--style` विकल्प का उपयोग करके आउटपुट फॉर्मेट निर्दिष्ट कर सकते हैं:

```bash
# XML फॉर्मेट (डिफॉल्ट)
repomix --style xml

# मार्कडाउन फॉर्मेट
repomix --style markdown

# प्लेन टेक्स्ट फॉर्मेट
repomix --style plain
```

## XML फॉर्मेट

XML फॉर्मेट AI मॉडल के साथ उपयोग के लिए अनुशंसित फॉर्मेट है। यह फाइल पथ, फाइल प्रकार और कोड संरचना के बारे में स्पष्ट मेटाडेटा प्रदान करता है।

```bash
repomix --style xml
```

उदाहरण आउटपुट:

```xml
<repository>
  <file path="src/index.ts" type="typescript">
    import { processRepository } from './core';
    
    export function main() {
      processRepository('./my-repo');
    }
  </file>
  <file path="src/core.ts" type="typescript">
    export function processRepository(path: string) {
      // कार्यान्वयन विवरण
    }
  </file>
</repository>
```

XML फॉर्मेट के लाभ:

1. **स्पष्ट संरचना**: फाइलों और उनके संबंधों की स्पष्ट संरचना
2. **मेटाडेटा**: फाइल पथ और प्रकार जैसे मेटाडेटा शामिल
3. **AI पार्सिंग**: AI मॉडल द्वारा आसानी से पार्स किया जा सकता है
4. **संदर्भ संरक्षण**: फाइल संदर्भ और संरचना संरक्षित रहती है

## मार्कडाउन फॉर्मेट

मार्कडाउन फॉर्मेट मानव पठनीयता और AI प्रोसेसिंग के बीच एक संतुलन प्रदान करता है। यह GitHub और अन्य मार्कडाउन व्यूअर में अच्छी तरह से प्रदर्शित होता है।

```bash
repomix --style markdown
```

उदाहरण आउटपुट:

```markdown
# Repository

## src/index.ts
```typescript
import { processRepository } from './core';

export function main() {
  processRepository('./my-repo');
}
```

## src/core.ts
```typescript
export function processRepository(path: string) {
  // कार्यान्वयन विवरण
}
```
```

मार्कडाउन फॉर्मेट के लाभ:

1. **पठनीयता**: मानव पाठकों के लिए अधिक पठनीय
2. **प्रदर्शन**: GitHub और अन्य मार्कडाउन व्यूअर में अच्छी तरह से प्रदर्शित होता है
3. **सिंटैक्स हाइलाइटिंग**: कोड ब्लॉक में सिंटैक्स हाइलाइटिंग का समर्थन
4. **संपादन योग्यता**: आसानी से संपादित किया जा सकता है

## प्लेन टेक्स्ट फॉर्मेट

प्लेन टेक्स्ट फॉर्मेट सबसे सरल आउटपुट विकल्प है। यह फाइल पथ और सामग्री को बिना किसी विशेष फॉर्मेटिंग के प्रस्तुत करता है।

```bash
repomix --style plain
```

उदाहरण आउटपुट:

```
--- src/index.ts ---
import { processRepository } from './core';

export function main() {
  processRepository('./my-repo');
}

--- src/core.ts ---
export function processRepository(path: string) {
  // कार्यान्वयन विवरण
}
```

प्लेन टेक्स्ट फॉर्मेट के लाभ:

1. **सादगी**: कोई विशेष फॉर्मेटिंग नहीं
2. **संगतता**: सभी टेक्स्ट एडिटर और टूल के साथ संगत
3. **आकार**: आमतौर पर सबसे छोटा फाइल आकार

## डिफॉल्ट आउटपुट फॉर्मेट सेट करना

आप अपने `repomix.config.json` में डिफॉल्ट आउटपुट फॉर्मेट सेट कर सकते हैं:

```json
{
  "output": {
    "style": "markdown"
  }
}
```

## आउटपुट फाइल नाम

आप `--output-file` विकल्प का उपयोग करके आउटपुट फाइल का नाम निर्दिष्ट कर सकते हैं:

```bash
repomix --output-file my-repo-code.xml
```

डिफॉल्ट फाइल नाम `repomix-output.xml`, `repomix-output.md`, या `repomix-output.txt` है, जो चुने गए आउटपुट फॉर्मेट पर निर्भर करता है।

## AI मॉडल के साथ आउटपुट का उपयोग

### XML के साथ

XML फॉर्मेट AI मॉडल के साथ उपयोग के लिए अनुशंसित है। यह फाइल संरचना और संदर्भ को संरक्षित करता है, जिससे AI को कोडबेस को बेहतर ढंग से समझने में मदद मिलती है।

```
इस XML फाइल में मेरे रिपॉजिटरी की सभी फाइलें हैं। कृपया इसकी समीक्षा करें और सुधार के लिए सुझाव दें।
```

### मार्कडाउन के साथ

मार्कडाउन फॉर्मेट मानव पठनीयता और AI प्रोसेसिंग के बीच एक अच्छा संतुलन प्रदान करता है।

```
इस मार्कडाउन फाइल में मेरे रिपॉजिटरी की सभी फाइलें हैं। कृपया इसकी समीक्षा करें और सुधार के लिए सुझाव दें।
```

### प्लेन टेक्स्ट के साथ

प्लेन टेक्स्ट फॉर्मेट सबसे सरल है लेकिन फाइल संरचना और संदर्भ के बारे में कम जानकारी प्रदान करता है।

```
इस टेक्स्ट फाइल में मेरे रिपॉजिटरी की सभी फाइलें हैं। कृपया इसकी समीक्षा करें और सुधार के लिए सुझाव दें।
```

## अगला क्या है?

- [कमांड लाइन विकल्पों](command-line-options.md) के बारे में अधिक जानें
- [कॉन्फिगरेशन विकल्पों](configuration.md) का अन्वेषण करें
- [सुरक्षा सुविधाओं](security.md) के बारे में जानें
</file>

<file path="website/client/src/hi/guide/prompt-examples.md">
# प्रॉम्प्ट उदाहरण

Repomix द्वारा जनरेट की गई फाइल का उपयोग करके AI मॉडल के साथ प्रभावी ढंग से संवाद करने के लिए यहां कुछ प्रॉम्प्ट उदाहरण दिए गए हैं।

## कोड समीक्षा प्रॉम्प्ट

### सामान्य कोड समीक्षा

```
इस फाइल में मेरे रिपॉजिटरी की सभी फाइलें हैं। कृपया इसकी समीक्षा करें और निम्नलिखित पर ध्यान केंद्रित करें:
1. कोड गुणवत्ता और शैली
2. संभावित बग और समस्याएं
3. प्रदर्शन अनुकूलन के अवसर
4. सुरक्षा समस्याएं
```

### आर्किटेक्चर समीक्षा

```
इस फाइल में मेरे रिपॉजिटरी की सभी फाइलें हैं। कृपया इसकी आर्किटेक्चर की समीक्षा करें और निम्नलिखित पर ध्यान केंद्रित करें:
1. कोड संगठन और संरचना
2. डिजाइन पैटर्न का उपयोग
3. मॉड्यूल और कंपोनेंट के बीच संबंध
4. स्केलेबिलिटी और मेंटेनेबिलिटी
```

### सुरक्षा समीक्षा

```
इस फाइल में मेरे रिपॉजिटरी की सभी फाइलें हैं। कृपया इसकी सुरक्षा समीक्षा करें और निम्नलिखित पर ध्यान केंद्रित करें:
1. संभावित सुरक्षा कमजोरियां
2. संवेदनशील जानकारी का एक्सपोज़र
3. इनपुट वैलिडेशन समस्याएं
4. प्रमाणीकरण और प्राधिकरण समस्याएं
```

### प्रदर्शन समीक्षा

```
इस फाइल में मेरे रिपॉजिटरी की सभी फाइलें हैं। कृपया इसकी प्रदर्शन समीक्षा करें और निम्नलिखित पर ध्यान केंद्रित करें:
1. प्रदर्शन बॉटलनेक
2. मेमोरी लीक
3. अनुकूलन के अवसर
4. एल्गोरिदम दक्षता
```

## दस्तावेज़ीकरण प्रॉम्प्ट

### API दस्तावेज़ीकरण

```
इस फाइल में मेरे रिपॉजिटरी की सभी फाइलें हैं। कृपया मेरे API के लिए व्यापक दस्तावेज़ीकरण जनरेट करें, जिसमें शामिल हों:
1. प्रत्येक एंडपॉइंट का विवरण
2. अनुरोध और प्रतिक्रिया फॉर्मेट
3. प्रमाणीकरण आवश्यकताएं
4. त्रुटि कोड और उनके अर्थ
```

### डेवलपर गाइड

```
इस फाइल में मेरे रिपॉजिटरी की सभी फाइलें हैं। कृपया नए डेवलपर्स के लिए एक गाइड जनरेट करें, जिसमें शामिल हों:
1. प्रोजेक्ट संरचना का अवलोकन
2. सेटअप और इंस्टॉलेशन निर्देश
3. विकास वर्कफ़्लो
4. कोडिंग मानक और दिशानिर्देश
```

## विश्लेषण और सुधार प्रॉम्प्ट

### कोड रिफैक्टरिंग

```
इस फाइल में मेरे रिपॉजिटरी की सभी फाइलें हैं। कृपया निम्नलिखित मॉड्यूल को रिफैक्टर करने के लिए सुझाव दें: [मॉड्यूल नाम]
मुझे निम्नलिखित पर ध्यान केंद्रित करने की आवश्यकता है:
1. कोड पठनीयता में सुधार
2. डुप्लिकेशन को कम करना
3. मेंटेनेबिलिटी बढ़ाना
4. मौजूदा फंक्शनैलिटी को बनाए रखना
```

### बग फिक्स

```
इस फाइल में मेरे रिपॉजिटरी की सभी फाइलें हैं। मैं निम्नलिखित बग का सामना कर रहा हूं: [बग विवरण]
कृपया:
1. बग का कारण पहचानें
2. समाधान प्रदान करें
3. समान समस्याओं को रोकने के लिए सुझाव दें
```

### नई सुविधा कार्यान्वयन

```
इस फाइल में मेरे रिपॉजिटरी की सभी फाइलें हैं। मैं निम्नलिखित नई सुविधा जोड़ना चाहता हूं: [सुविधा विवरण]
कृपया:
1. कार्यान्वयन योजना प्रदान करें
2. आवश्यक परिवर्तनों का विवरण दें
3. संभावित चुनौतियों और उनके समाधान का उल्लेख करें
```

## प्रभावी प्रॉम्प्ट के लिए टिप्स

1. **स्पष्ट और विशिष्ट रहें**: अपने प्रॉम्प्ट में अपनी आवश्यकताओं को स्पष्ट रूप से परिभाषित करें।
2. **संदर्भ प्रदान करें**: AI को आपके प्रोजेक्ट के बारे में पृष्ठभूमि जानकारी दें।
3. **प्राथमिकताएं निर्धारित करें**: सबसे महत्वपूर्ण पहलुओं को पहले रखें।
4. **उदाहरण शामिल करें**: जहां उपयुक्त हो, उदाहरण प्रदान करें।
5. **फॉलो-अप प्रश्न पूछें**: पहली प्रतिक्रिया के बाद, अधिक विशिष्ट जानकारी के लिए फॉलो-अप प्रश्न पूछें।

## मॉडल-विशिष्ट नोट्स

### Claude के लिए

Claude आर्टिफैक्ट्स का समर्थन करता है, जिससे आप एक साथ कई फाइलें प्राप्त कर सकते हैं:

```
इस फाइल में मेरे रिपॉजिटरी की सभी फाइलें हैं। कृपया निम्नलिखित फाइलों को अपडेट करें ताकि [सुविधा विवरण] जोड़ा जा सके। कृपया अपडेट की गई फाइलों को आर्टिफैक्ट्स के रूप में वापस करें।
```

### ChatGPT के लिए

ChatGPT के साथ, फाइल अपलोड और कोड इंटरप्रिटर का उपयोग करें:

```
मैंने अपने रिपॉजिटरी की फाइल अपलोड की है। कृपया कोड इंटरप्रिटर का उपयोग करके इसका विश्लेषण करें और [अनुरोध विवरण] प्रदान करें।
```

### Gemini के लिए

Gemini के साथ, कोड ब्लॉक का उपयोग करके प्रतिक्रिया को संरचित करने के लिए कहें:

```
इस फाइल में मेरे रिपॉजिटरी की सभी फाइलें हैं। कृपया [अनुरोध विवरण] प्रदान करें और अपनी प्रतिक्रिया को कोड ब्लॉक में संरचित करें ताकि मैं इसे आसानी से कॉपी कर सकूं।
```

## अगला क्या है?

- [आउटपुट फॉर्मेट](output.md) के बारे में जानें
- [कमांड लाइन विकल्पों](command-line-options.md) का अन्वेषण करें
- [कॉन्फिगरेशन विकल्पों](configuration.md) के बारे में अधिक जानें
</file>

<file path="website/client/src/hi/guide/remote-repository-processing.md">
# रिमोट रिपॉजिटरी प्रोसेसिंग

Repomix आपको GitHub जैसे प्लेटफॉर्म पर होस्ट किए गए रिमोट रिपॉजिटरी को प्रोसेस करने की अनुमति देता है। यह सुविधा उपयोगी है जब आप अपने लोकल मशीन पर रिपॉजिटरी को क्लोन किए बिना कोडबेस का विश्लेषण करना चाहते हैं।

## रिमोट रिपॉजिटरी प्रोसेस करना

रिमोट रिपॉजिटरी प्रोसेस करने के लिए, `--remote` विकल्प का उपयोग करें:

```bash
repomix --remote <username>/<repository>
```

उदाहरण:

```bash
repomix --remote yamadashy/repomix
```

यह GitHub से `yamadashy/repomix` रिपॉजिटरी को डाउनलोड करेगा और प्रोसेस करेगा।

## विशिष्ट ब्रांच या कमिट प्रोसेस करना

डिफॉल्ट रूप से, Repomix रिपॉजिटरी के डिफॉल्ट ब्रांच (आमतौर पर `main` या `master`) को प्रोसेस करेगा। विशिष्ट ब्रांच या कमिट प्रोसेस करने के लिए, `--remote-branch` विकल्प का उपयोग करें:

```bash
repomix --remote <username>/<repository> --remote-branch <branch-or-commit>
```

उदाहरण:

```bash
# विशिष्ट ब्रांच प्रोसेस करना
repomix --remote yamadashy/repomix --remote-branch develop

# विशिष्ट कमिट प्रोसेस करना
repomix --remote yamadashy/repomix --remote-branch 935b695
```

## आउटपुट विकल्प

रिमोट रिपॉजिटरी प्रोसेस करते समय, आप अन्य Repomix विकल्पों का उपयोग कर सकते हैं, जैसे आउटपुट स्टाइल और फिल्टरिंग:

```bash
repomix --remote yamadashy/repomix --style markdown --output-file output.md
```

```bash
repomix --remote yamadashy/repomix --include "src/**/*.ts" --ignore "**/*.test.ts"
```

## प्राइवेट रिपॉजिटरी

Repomix CLI टूल आपके लोकल Git क्रेडेंशियल्स का उपयोग करता है, इसलिए यदि आपके पास प्राइवेट रिपॉजिटरी तक पहुंच है, तो आप उन्हें भी प्रोसेस कर सकते हैं:

```bash
repomix --remote your-org/private-repo
```

## रिमोट प्रोसेसिंग के लाभ

रिमोट रिपॉजिटरी प्रोसेसिंग के कई लाभ हैं:

1. **डिस्क स्पेस बचाना**: आपको अपने लोकल मशीन पर रिपॉजिटरी को क्लोन करने की आवश्यकता नहीं है
2. **समय बचाना**: बड़े रिपॉजिटरी को क्लोन करने में समय लग सकता है
3. **सुविधा**: आपको Git इंस्टॉल करने या सेटअप करने की आवश्यकता नहीं है
4. **एक्सप्लोरेशन**: नए प्रोजेक्ट्स या ओपन सोर्स रिपॉजिटरी का त्वरित विश्लेषण

## रिमोट प्रोसेसिंग सीमाएं

रिमोट रिपॉजिटरी प्रोसेसिंग की कुछ सीमाएं हैं:

1. **नेटवर्क निर्भरता**: आपको इंटरनेट कनेक्शन की आवश्यकता है
2. **डाउनलोड समय**: बड़े रिपॉजिटरी को डाउनलोड करने में समय लग सकता है
3. **API सीमाएं**: GitHub API सीमाओं के अधीन है
4. **Git इतिहास**: वर्तमान में, Repomix केवल निर्दिष्ट ब्रांच या कमिट के स्नैपशॉट को प्रोसेस करता है, न कि पूरे Git इतिहास को

## उदाहरण उपयोग

### ओपन सोर्स प्रोजेक्ट का विश्लेषण

```bash
repomix --remote facebook/react --include "packages/react/**/*.js" --style markdown --output-file react-analysis.md
```

### विशिष्ट ब्रांच का विश्लेषण

```bash
repomix --remote tensorflow/tensorflow --remote-branch r2.9 --include "tensorflow/python/**/*.py" --output-file tensorflow-python-api.xml
```

### कमिट के बीच तुलना

आप विभिन्न कमिट्स के बीच तुलना करने के लिए Repomix का उपयोग कर सकते हैं:

```bash
# पहले कमिट को प्रोसेस करें
repomix --remote user/repo --remote-branch commit1 --output-file output1.xml

# दूसरे कमिट को प्रोसेस करें
repomix --remote user/repo --remote-branch commit2 --output-file output2.xml

# फिर आप दोनों आउटपुट फाइलों को AI मॉडल के साथ उपयोग कर सकते हैं
```

## अगला क्या है?

- [कमांड लाइन विकल्पों](command-line-options.md) के बारे में अधिक जानें
- [कॉन्फिगरेशन विकल्पों](configuration.md) का अन्वेषण करें
- [आउटपुट फॉर्मेट](output.md) के बारे में जानें
</file>

<file path="website/client/src/hi/guide/security.md">
# सुरक्षा

Repomix में एक अंतर्निहित सुरक्षा जांच प्रणाली है जो आपके कोडबेस में संवेदनशील जानकारी का पता लगाती है और आपको AI मॉडल के साथ साझा करने से पहले उन्हें हटाने या संशोधित करने की अनुमति देती है।

## सुरक्षा जांच कैसे काम करती है

जब आप Repomix चलाते हैं, तो यह आपके कोडबेस में निम्नलिखित प्रकार की संवेदनशील जानकारी की जांच करता है:

1. **API कुंजियां और टोकन**: AWS कुंजियां, GitHub टोकन, आदि
2. **क्रेडेंशियल**: पासवर्ड, प्रमाणीकरण टोकन
3. **प्राइवेट कुंजियां**: SSH कुंजियां, प्राइवेट कुंजियां
4. **कॉन्फिगरेशन फाइलें**: .env फाइलें, कॉन्फिगरेशन फाइलें जिनमें संवेदनशील जानकारी हो सकती है

## सुरक्षा जांच का उपयोग

सुरक्षा जांच डिफॉल्ट रूप से सक्षम है। आप इसे अक्षम कर सकते हैं, लेकिन यह अनुशंसित नहीं है:

```bash
repomix --no-security-check
```

## कॉन्फिगरेशन फाइल में सुरक्षा जांच

आप अपने `repomix.config.json` में भी सुरक्षा जांच को कॉन्फिगर कर सकते हैं:

```json
{
  "security": {
    "enabled": true
  }
}
```

## सुरक्षा चेतावनियां

जब Repomix संवेदनशील जानकारी का पता लगाता है, तो यह आपको चेतावनी देगा और आपको विकल्प प्रदान करेगा:

1. **फाइल को छोड़ें**: संवेदनशील फाइल को आउटपुट से बाहर रखें
2. **संवेदनशील जानकारी को संशोधित करें**: संवेदनशील जानकारी को `[REDACTED]` से बदलें
3. **जारी रखें**: चेतावनी को अनदेखा करें और जारी रखें (अनुशंसित नहीं)

## सुरक्षा सर्वोत्तम प्रथाएं

Repomix का उपयोग करते समय सुरक्षा सर्वोत्तम प्रथाओं का पालन करें:

1. **सुरक्षा जांच सक्षम रखें**: सुरक्षा जांच को हमेशा सक्षम रखें
2. **.env फाइलें**: .env फाइलों को .gitignore में जोड़ें
3. **संवेदनशील फाइलें**: संवेदनशील फाइलों को `--ignore` विकल्प के साथ बाहर रखें
4. **कोड समीक्षा**: AI के साथ साझा करने से पहले आउटपुट की समीक्षा करें
5. **सीक्रेट मैनेजमेंट**: सीक्रेट मैनेजमेंट टूल का उपयोग करें जैसे AWS Secrets Manager या HashiCorp Vault

## सुरक्षा जांच सीमाएं

Repomix की सुरक्षा जांच व्यापक है, लेकिन इसकी कुछ सीमाएं हैं:

1. **पैटर्न मैचिंग**: यह पैटर्न मैचिंग पर निर्भर करता है और सभी संवेदनशील जानकारी का पता नहीं लगा सकता है
2. **एन्क्रिप्टेड सीक्रेट**: यह एन्क्रिप्टेड सीक्रेट का पता नहीं लगा सकता है
3. **कस्टम फॉर्मेट**: यह कस्टम फॉर्मेट में संवेदनशील जानकारी का पता नहीं लगा सकता है

## अगला क्या है?

- [कमांड लाइन विकल्प](command-line-options.md) के बारे में अधिक जानें
- [कॉन्फिगरेशन विकल्पों](configuration.md) का अन्वेषण करें
- [कस्टम निर्देशों](custom-instructions.md) के बारे में जानें
</file>

<file path="website/client/src/hi/guide/usage.md">
# बुनियादी उपयोग

Repomix का उपयोग करना आसान है। यहां बताया गया है कि आप अपने कोडबेस को AI-फ्रेंडली फॉर्मेट में पैक करने के लिए इसका उपयोग कैसे कर सकते हैं।

## बुनियादी कमांड

अपने प्रोजेक्ट डायरेक्टरी में, बस निम्न कमांड चलाएं:

```bash
repomix
```

यह आपके वर्तमान डायरेक्टरी में एक `repomix-output.xml` फाइल जनरेट करेगा, जिसमें आपका पूरा रिपॉजिटरी AI-फ्रेंडली XML फॉर्मेट में होगा।

## विशिष्ट डायरेक्टरी को पैक करना

आप एक विशिष्ट डायरेक्टरी को पैक कर सकते हैं:

```bash
repomix path/to/directory
```

## विशिष्ट फाइलों को शामिल करना

आप [ग्लोब पैटर्न](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax) का उपयोग करके विशिष्ट फाइलों या डायरेक्टरी को शामिल कर सकते हैं:

```bash
repomix --include "src/**/*.ts,**/*.md"
```

## फाइलों को बाहर रखना

आप विशिष्ट फाइलों या डायरेक्टरी को बाहर रख सकते हैं:

```bash
repomix --ignore "**/*.log,tmp/"
```

## आउटपुट फॉर्मेट

आप विभिन्न आउटपुट फॉर्मेट में से चुन सकते हैं:

```bash
# XML फॉर्मेट (डिफॉल्ट)
repomix --style xml

# मार्कडाउन फॉर्मेट
repomix --style markdown

# प्लेन टेक्स्ट फॉर्मेट
repomix --style plain
```

## आउटपुट फाइल का नाम बदलना

आप आउटपुट फाइल का नाम बदल सकते हैं:

```bash
repomix --output-file custom-name.xml
```

## कॉन्फिगरेशन फाइल का उपयोग

आप एक कॉन्फिगरेशन फाइल बना सकते हैं जिसमें आपकी सभी सेटिंग्स हों:

```bash
repomix --init
```

यह आपके वर्तमान डायरेक्टरी में एक `repomix.config.json` फाइल बनाएगा। आप इसे अपनी आवश्यकताओं के अनुसार संपादित कर सकते हैं।

## रिमोट रिपॉजिटरी को पैक करना

आप GitHub रिपॉजिटरी को सीधे पैक कर सकते हैं:

```bash
# शॉर्टहैंड फॉर्मेट का उपयोग करके
npx repomix --remote yamadashy/repomix

# पूर्ण URL का उपयोग करके
npx repomix --remote https://github.com/yamadashy/repomix
```

## फ़ाइल सूची इनपुट (stdin)

अधिकतम लचीलेपन के लिए stdin के माध्यम से फ़ाइल पथ पास करें:

```bash
# find कमांड का उपयोग करके
find src -name "*.ts" -type f | repomix --stdin

# git का उपयोग करके ट्रैक्ड फ़ाइलें प्राप्त करने के लिए
git ls-files "*.ts" | repomix --stdin

# glob पैटर्न के साथ ls का उपयोग करके
ls src/**/*.ts | repomix --stdin

# फ़ाइल पथ वाली फ़ाइल से
cat file-list.txt | repomix --stdin

# echo के साथ प्रत्यक्ष इनपुट
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```

`--stdin` विकल्प आपको फ़ाइल पथों की सूची को Repomix में पाइप करने की अनुमति देता है, जो आपको पैक करने के लिए फ़ाइलों का चयन करने में अधिकतम लचीलापन प्रदान करता है।

> [!NOTE]
> `--stdin` का उपयोग करते समय, फ़ाइल पथ सापेक्ष या पूर्ण हो सकते हैं, और Repomix स्वचालित रूप से पथ रिज़ॉल्यूशन और डुप्लिकेशन हैंडलिंग करेगा।

## AI के साथ आउटपुट का उपयोग

एक बार जब आपके पास पैक्ड फाइल है, तो आप इसे ChatGPT, Claude, या अन्य LLM के साथ उपयोग कर सकते हैं। बस फाइल को अपलोड करें और अपने प्रॉम्प्ट में इसका उल्लेख करें:

```
इस फाइल में मेरे रिपॉजिटरी की सभी फाइलें हैं। कृपया इसकी समीक्षा करें और मुझे बताएं कि क्या सुधार किए जा सकते हैं।
```

## अगला क्या है?

- [कमांड लाइन विकल्पों](command-line-options.md) के बारे में अधिक जानें
- [कॉन्फिगरेशन](configuration.md) के साथ Repomix को अनुकूलित करें
- [सुरक्षा सुविधाओं](security.md) के बारे में जानें
</file>

<file path="website/client/src/hi/index.md">
---
layout: home
title: Repomix
titleTemplate: अपने कोडबेस को AI-फ्रेंडली फॉर्मेट में पैकेज करें
aside: false
editLink: false

features:
  - icon: 🤖
    title: AI-अनुकूलित
    details: आपके कोडबेस को ऐसे प्रारूप में प्रस्तुत करता है जिसे AI आसानी से समझ और प्रोसेस कर सके।

  - icon: ⚙️
    title: Git-जागरूक
    details: स्वचालित रूप से आपकी .gitignore फाइलों का सम्मान करता है।

  - icon: 🛡️
    title: सुरक्षा-केंद्रित
    details: संवेदनशील जानकारी का पता लगाने और उसे शामिल करने से रोकने के लिए मजबूत सुरक्षा जांच के लिए Secretlint को शामिल करता है।

  - icon: 📊
    title: टोकन काउंटिंग
    details: प्रत्येक फाइल और पूरे रिपॉजिटरी के लिए टोकन काउंट प्रदान करता है, जो LLM कॉन्टेक्स्ट सीमाओं के लिए उपयोगी है।

---

<script setup>
import YouTubeVideo from '../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../utils/videos'
</script>

<div class="cli-section">

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## 🏆 ओपन सोर्स अवार्ड्स नामांकन

हमें सम्मान मिला है! Repomix को [JSNation Open Source Awards 2025](https://osawards.com/javascript/) के **Powered by AI** श्रेणी में नामांकित किया गया है।

यह आप सभी के Repomix का उपयोग करने और समर्थन करने के बिना संभव नहीं होता। धन्यवाद!

अगर Repomix ने आपको AI टूल्स के लिए कोडबेस का विश्लेषण या पैकेजिंग करने में मदद की है, तो हम **Powered by AI** श्रेणी में आपके वोट के लिए आभारी होंगे।

## Repomix क्या है?

Repomix एक शक्तिशाली टूल है जो आपके पूरे कोडबेस को एक AI-फ्रेंडली फाइल में पैकेज करता है। चाहे आप कोड रिव्यू, रिफैक्टरिंग पर काम कर रहे हों या अपने प्रोजेक्ट के लिए AI सहायता की आवश्यकता हो, Repomix आपके पूरे रिपॉजिटरी कॉन्टेक्स्ट को AI टूल्स के साथ साझा करना आसान बनाता है।

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

## त्वरित शुरुआत

एक बार जब आप Repomix का उपयोग करके एक पैक्ड फाइल (`repomix-output.xml`) जनरेट कर लेते हैं, तो आप इसे एक AI असिस्टेंट (जैसे ChatGPT, Claude) को इस तरह के प्रॉम्प्ट के साथ भेज सकते हैं:

```
इस फाइल में रिपॉजिटरी की सभी फाइलें एक में संयोजित हैं।
मैं कोड को रिफैक्टर करना चाहता हूं, इसलिए कृपया पहले इसकी समीक्षा करें।
```

AI आपके पूरे कोडबेस का विश्लेषण करेगा और व्यापक अंतर्दृष्टि प्रदान करेगा:

![Repomix File Usage 1](/images/docs/repomix-file-usage-1.png)

विशिष्ट परिवर्तनों पर चर्चा करते समय, AI कोड जनरेट करने में मदद कर सकता है। Claude के आर्टिफैक्ट्स जैसी सुविधाओं के साथ, आप कई परस्पर निर्भर फाइलें भी प्राप्त कर सकते हैं:

![Repomix File Usage 2](/images/docs/repomix-file-usage-2.png)

हैप्पी कोडिंग! 🚀


## CLI टूल का उपयोग {#using-the-cli-tool}

Repomix को कमांड-लाइन टूल के रूप में उपयोग किया जा सकता है, जो शक्तिशाली सुविधाएँ और अनुकूलन विकल्प प्रदान करता है।

**CLI टूल प्राइवेट रिपॉजिटरी तक पहुंच सकता है** क्योंकि यह आपके स्थानीय रूप से इंस्टॉल किए गए git का उपयोग करता है।

### त्वरित शुरुआत

आप Repomix को अपने प्रोजेक्ट डायरेक्टरी में बिना इंस्टॉलेशन के तुरंत आजमा सकते हैं:

```bash
npx repomix
```

या बार-बार उपयोग के लिए ग्लोबली इंस्टॉल करें:

```bash
# npm का उपयोग करके इंस्टॉल करें
npm install -g repomix

# या yarn के साथ
yarn global add repomix

# या bun के साथ
bun add -g repomix

# या Homebrew के साथ (macOS/Linux)
brew install repomix

# फिर किसी भी प्रोजेक्ट डायरेक्टरी में चलाएं
repomix
```

बस इतना ही! Repomix आपकी वर्तमान डायरेक्टरी में एक `repomix-output.xml` फाइल जनरेट करेगा, जिसमें आपका पूरा रिपॉजिटरी AI-फ्रेंडली फॉर्मेट में होगा।



### उपयोग

अपने पूरे रिपॉजिटरी को पैक करने के लिए:

```bash
repomix
```

किसी विशिष्ट डायरेक्टरी को पैक करने के लिए:

```bash
repomix path/to/directory
```

[ग्लोब पैटर्न](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax) का उपयोग करके विशिष्ट फाइलों या डायरेक्टरी को पैक करने के लिए:

```bash
repomix --include "src/**/*.ts,**/*.md"
```

विशिष्ट फाइलों या डायरेक्टरी को बाहर रखने के लिए:

```bash
repomix --ignore "**/*.log,tmp/"
```

रिमोट रिपॉजिटरी को पैक करने के लिए:
```bash
# शॉर्टहैंड फॉर्मेट का उपयोग करके
npx repomix --remote yamadashy/repomix

# पूर्ण URL का उपयोग करके (ब्रांच और विशिष्ट पाथ का समर्थन करता है)
npx repomix --remote https://github.com/yamadashy/repomix
npx repomix --remote https://github.com/yamadashy/repomix/tree/main

# कमिट के URL का उपयोग करके
npx repomix --remote https://github.com/yamadashy/repomix/commit/836abcd7335137228ad77feb28655d85712680f1
```

एक नई कॉन्फिगरेशन फाइल (`repomix.config.json`) को इनिशियलाइज़ करने के लिए:

```bash
repomix --init
```

एक बार जब आप पैक्ड फाइल जनरेट कर लेते हैं, तो आप इसे Claude, ChatGPT और Gemini जैसे जनरेटिव AI टूल के साथ उपयोग कर सकते हैं।

#### Docker उपयोग

आप Docker 🐳 का उपयोग करके भी Repomix चला सकते हैं  
यह उपयोगी है यदि आप Repomix को एक अलग वातावरण में चलाना चाहते हैं या कंटेनर का उपयोग करना पसंद करते हैं।

बेसिक उपयोग (वर्तमान डायरेक्टरी):

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

किसी विशिष्ट डायरेक्टरी को पैक करने के लिए:
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

रिमोट रिपॉजिटरी को प्रोसेस करें और `output` डायरेक्टरी में आउटपुट करें:

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### आउटपुट फॉर्मेट

अपना पसंदीदा आउटपुट फॉर्मेट चुनें:

```bash
# XML फॉर्मेट (डिफॉल्ट)
repomix --style xml

# मार्कडाउन फॉर्मेट
repomix --style markdown

# प्लेन टेक्स्ट फॉर्मेट
repomix --style plain
```

### अनुकूलन

स्थायी सेटिंग्स के लिए `repomix.config.json` बनाएं:

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

## पावर यूज़र गाइड

Repomix उन्नत उपयोग के मामलों के लिए शक्तिशाली सुविधाएं प्रदान करता है। पावर यूज़र्स के लिए कुछ आवश्यक गाइड यहां हैं:

- **[MCP सर्वर](./guide/mcp-server)** - AI असिस्टेंट के लिए Model Context Protocol एकीकरण
- **[GitHub Actions](./guide/github-actions)** - CI/CD वर्कफ़्लो में कोडबेस पैकेजिंग को स्वचालित करें
- **[कोड कंप्रेशन](./guide/code-compress)** - Tree-sitter आधारित इंटेलिजेंट कंप्रेशन (~70% टोकन कमी)
- **[लाइब्रेरी के रूप में उपयोग](./guide/development/using-repomix-as-a-library)** - अपने Node.js एप्लिकेशन में Repomix को एकीकृत करें
- **[कस्टम निर्देश](./guide/custom-instructions)** - आउटपुट में कस्टम प्रॉम्प्ट और निर्देश जोड़ें
- **[सुरक्षा सुविधाएं](./guide/security)** - अंतर्निहित Secretlint एकीकरण और सुरक्षा जांच
- **[सर्वोत्तम प्रथाएं](./guide/tips/best-practices)** - सिद्ध रणनीतियों के साथ अपने AI वर्कफ़्लो को अनुकूलित करें

### अधिक उदाहरण
::: tip अधिक मदद चाहिए? 💡
हमारे व्यापक दस्तावेज़ीकरण को [गाइड](/hi/guide/) में देखें या अधिक उदाहरणों और सोर्स कोड के लिए [GitHub रिपॉजिटरी](https://github.com/yamadashy/repomix) का अन्वेषण करें।
:::

</div>
</file>

<file path="website/client/src/id/guide/development/index.md">
# Berkontribusi ke Repomix


Kami sangat menghargai kontribusi dari komunitas! Halaman ini memberikan panduan tentang cara berkontribusi ke proyek Repomix.

## Memulai

### Prasyarat

Untuk berkontribusi ke Repomix, Anda akan memerlukan:

- [Node.js](https://nodejs.org/) (versi 18 atau lebih baru)
- [Git](https://git-scm.com/)
- Editor kode (kami merekomendasikan [Visual Studio Code](https://code.visualstudio.com/))

### Mengkloning Repositori

```bash
# Kloning repositori
git clone https://github.com/yamadashy/repomix.git

# Masuk ke direktori
cd repomix

# Instal dependensi
npm install
```

## Struktur Proyek

Repositori Repomix diorganisir sebagai berikut:

```
repomix/
├── src/              # Kode sumber utama
├── test/             # File pengujian
├── website/          # Situs web dokumentasi
├── .github/          # Alur kerja GitHub Actions
├── package.json      # Konfigurasi proyek
└── README.md         # Dokumentasi utama
```

## Alur Kerja Pengembangan

1. **Buat Cabang**: Selalu buat cabang baru untuk pekerjaan Anda
   ```bash
   git checkout -b fitur/nama-fitur-anda
   ```

2. **Buat Perubahan**: Implementasikan perubahan Anda

3. **Jalankan Pengujian**: Pastikan semua pengujian lulus
   ```bash
   npm test
   ```

4. **Lint Kode Anda**: Pastikan kode Anda mengikuti pedoman gaya
   ```bash
   npm run lint
   ```

5. **Commit Perubahan Anda**: Gunakan pesan commit yang deskriptif
   ```bash
   git commit -m "feat: Tambahkan fitur baru X"
   ```

6. **Push ke GitHub**: Push cabang Anda ke GitHub
   ```bash
   git push origin fitur/nama-fitur-anda
   ```

7. **Buat Pull Request**: Buka pull request di GitHub

## Konvensi Commit

Kami mengikuti [Conventional Commits](https://www.conventionalcommits.org/) untuk pesan commit:

- `feat`: Fitur baru
- `fix`: Perbaikan bug
- `docs`: Perubahan dokumentasi
- `style`: Perubahan format (tidak memengaruhi kode)
- `refactor`: Refaktor kode
- `test`: Menambahkan atau memperbaiki pengujian
- `chore`: Perubahan pada proses build atau alat

## Pengujian

Kami menggunakan [Jest](https://jestjs.io/) untuk pengujian. Untuk menjalankan pengujian:

```bash
# Jalankan semua pengujian
npm test

# Jalankan pengujian dengan cakupan
npm run test:coverage

# Jalankan pengujian dalam mode watch
npm run test:watch
```

## Dokumentasi

Dokumentasi adalah bagian penting dari proyek. Jika Anda menambahkan fitur baru atau mengubah perilaku yang ada, pastikan untuk memperbarui dokumentasi yang relevan.

Situs web dokumentasi terletak di direktori `website/` dan dibangun menggunakan [VitePress](https://vitepress.dev/).

```bash
# Jalankan server pengembangan dokumentasi
cd website/client
npm run docs:dev
```

## Pedoman Kontribusi

- **Kode Berkualitas Tinggi**: Tulis kode yang bersih, terdokumentasi dengan baik, dan dapat diuji
- **Pengujian**: Tambahkan pengujian untuk kode baru
- **Dokumentasi**: Perbarui dokumentasi untuk mencerminkan perubahan Anda
- **Kompatibilitas**: Pastikan perubahan Anda kompatibel dengan semua platform yang didukung
- **Ukuran PR**: Buat pull request yang kecil dan terfokus

## Mendapatkan Bantuan

Jika Anda memiliki pertanyaan atau memerlukan bantuan:

- [Buka masalah](https://github.com/yamadashy/repomix/issues) di GitHub
- Bergabunglah dengan [server Discord](https://discord.gg/wNYzTwZFku) kami
- Tanyakan di [Diskusi GitHub](https://github.com/yamadashy/repomix/discussions)

Terima kasih atas kontribusi Anda ke Repomix!
</file>

<file path="website/client/src/id/guide/development/using-repomix-as-a-library.md">
# Menggunakan Repomix sebagai Library


Selain sebagai alat command-line, Repomix juga dapat digunakan sebagai library dalam proyek JavaScript atau TypeScript Anda. Ini memungkinkan Anda untuk mengintegrasikan fungsionalitas Repomix langsung ke dalam aplikasi Anda.

## Instalasi

Untuk menggunakan Repomix sebagai library, instal sebagai dependensi:

```bash
npm install repomix
```

## Penggunaan Dasar

Berikut adalah contoh dasar cara menggunakan Repomix sebagai library:

```typescript
import { Repomix } from 'repomix';

async function main() {
  // Inisialisasi instance Repomix
  const repomix = new Repomix();

  // Mengemas direktori saat ini
  const result = await repomix.pack({
    path: process.cwd(),
    output: {
      style: 'xml',
      filePath: 'output.xml',
    },
  });

  console.log(`Berhasil mengemas ${result.stats.files} file`);
  console.log(`Total token: ${result.stats.tokens}`);
}

main().catch(console.error);
```

## Opsi Konfigurasi

Anda dapat meneruskan berbagai opsi ke metode `pack()`:

```typescript
import { Repomix } from 'repomix';

async function main() {
  const repomix = new Repomix();

  const result = await repomix.pack({
    // Jalur ke direktori atau file untuk dikemas
    path: './src',

    // Opsi output
    output: {
      style: 'markdown',
      filePath: 'output.md',
      removeComments: true,
      showLineNumbers: true,
      topFilesLength: 10,
      copyToClipboard: false,
      compress: false,
    },

    // Opsi pengabaian
    ignore: {
      customPatterns: ['**/*.test.ts', 'node_modules/**'],
      respectGitignore: true,
    },

    // Opsi keamanan
    security: {
      enabled: true,
    },
  });

  console.log(result);
}

main().catch(console.error);
```

## Mengakses Hasil

Objek hasil berisi informasi tentang proses pengemasan:

```typescript
import { Repomix } from 'repomix';

async function main() {
  const repomix = new Repomix();
  const result = await repomix.pack({ path: './src' });

  // Mengakses statistik
  console.log(`Total file: ${result.stats.files}`);
  console.log(`Total baris: ${result.stats.lines}`);
  console.log(`Total token: ${result.stats.tokens}`);

  // Mengakses konten output
  console.log(result.content);

  // Mengakses informasi file
  result.fileInfos.forEach((fileInfo) => {
    console.log(`File: ${fileInfo.path}`);
    console.log(`Bahasa: ${fileInfo.language}`);
    console.log(`Token: ${fileInfo.tokens}`);
  });
}

main().catch(console.error);
```

## Kasus Penggunaan

Menggunakan Repomix sebagai library sangat berguna untuk:

### Integrasi dengan Alat Pengembangan

Integrasikan Repomix ke dalam alat pengembangan kustom Anda:

```typescript
import { Repomix } from 'repomix';
import { analyzeCode } from './ai-analyzer';

async function analyzeProject(projectPath) {
  const repomix = new Repomix();
  const result = await repomix.pack({ path: projectPath });
  
  // Kirim output Repomix ke layanan analisis AI
  const analysis = await analyzeCode(result.content);
  
  return analysis;
}
```

### Pemrosesan Batch

Proses beberapa repositori atau direktori secara berurutan:

```typescript
import { Repomix } from 'repomix';
import fs from 'fs/promises';
import path from 'path';

async function processProjects(projectsDir) {
  const repomix = new Repomix();
  const projects = await fs.readdir(projectsDir);
  
  for (const project of projects) {
    const projectPath = path.join(projectsDir, project);
    const stats = await fs.stat(projectPath);
    
    if (stats.isDirectory()) {
      console.log(`Processing ${project}...`);
      const result = await repomix.pack({ 
        path: projectPath,
        output: {
          filePath: `${project}-output.xml`
        }
      });
      console.log(`Completed ${project}: ${result.stats.files} files, ${result.stats.tokens} tokens`);
    }
  }
}
```

### Integrasi Web

Integrasikan Repomix ke dalam aplikasi web:

```typescript
import express from 'express';
import { Repomix } from 'repomix';
import multer from 'multer';
import path from 'path';
import fs from 'fs/promises';

const app = express();
const upload = multer({ dest: 'uploads/' });

app.post('/process', upload.single('repo'), async (req, res) => {
  try {
    const repomix = new Repomix();
    const result = await repomix.pack({ 
      path: req.file.path,
      output: {
        style: req.body.style || 'xml'
      }
    });
    
    // Bersihkan file yang diunggah
    await fs.unlink(req.file.path);
    
    res.json({
      stats: result.stats,
      content: result.content
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

## API Reference

### Kelas Repomix

```typescript
class Repomix {
  constructor(options?: RepomixOptions);
  
  async pack(options: PackOptions): Promise<PackResult>;
}
```

### Tipe PackOptions

```typescript
interface PackOptions {
  path?: string;
  output?: OutputOptions;
  ignore?: IgnoreOptions;
  security?: SecurityOptions;
  remote?: RemoteOptions;
}
```

### Tipe PackResult

```typescript
interface PackResult {
  content: string;
  stats: {
    files: number;
    lines: number;
    tokens: number;
  };
  fileInfos: FileInfo[];
}
```

Untuk informasi lebih lanjut tentang API, lihat [kode sumber Repomix](https://github.com/yamadashy/repomix).
</file>

<file path="website/client/src/id/guide/tips/best-practices.md">
# Praktik Terbaik Pengembangan dengan Bantuan AI


Menggunakan AI untuk pengembangan perangkat lunak dapat meningkatkan produktivitas Anda secara signifikan. Berikut adalah beberapa praktik terbaik untuk memaksimalkan manfaat dari Repomix dan alat AI lainnya.

## Persiapan Basis Kode

### Bersihkan Basis Kode Anda

Sebelum mengemas basis kode Anda dengan Repomix:

- Hapus file sementara atau yang tidak diperlukan
- Pastikan `.gitignore` Anda diperbarui
- Pertimbangkan untuk menghapus komentar yang tidak perlu jika Anda ingin mengurangi jumlah token

### Struktur Repositori yang Jelas

Basis kode yang terorganisir dengan baik lebih mudah dipahami oleh AI:

- Gunakan struktur direktori yang konsisten
- Beri nama file dan direktori dengan jelas
- Pisahkan kode berdasarkan fungsi atau domain

## Menulis Prompt yang Efektif

### Berikan Konteks yang Jelas

Saat mengirimkan basis kode Anda ke AI:

- Jelaskan tujuan dan arsitektur proyek
- Sorot teknologi dan kerangka kerja utama yang digunakan
- Jelaskan konvensi penamaan atau pola khusus

### Tentukan Tujuan Anda

Buat permintaan Anda spesifik:

- "Refaktor fungsi X untuk meningkatkan kinerja" lebih baik daripada "Perbaiki kode saya"
- "Identifikasi potensi masalah keamanan dalam penanganan autentikasi" lebih baik daripada "Periksa keamanan"

### Pecah Masalah Kompleks

Untuk masalah yang kompleks:

- Pecah menjadi bagian-bagian yang lebih kecil dan dapat dikelola
- Ajukan pertanyaan secara bertahap
- Bangun pada respons sebelumnya

## Mengoptimalkan Output Repomix

### Pilih Format yang Tepat

Pilih format output berdasarkan kasus penggunaan Anda:

- **XML**: Ideal untuk pemrosesan AI dan analisis terstruktur
- **Markdown**: Bagus untuk dokumentasi dan pembacaan manusia
- **Teks Biasa**: Sederhana dan ringkas

### Gunakan Opsi Kompresi

Untuk basis kode yang besar:

- Aktifkan kompresi kode (`--compress`) untuk mengurangi jumlah token
- Pertimbangkan untuk menghapus komentar (`--remove-comments`) jika tidak penting
- Gunakan `--include` untuk hanya mengemas file yang relevan

### Tambahkan Instruksi Khusus

Gunakan instruksi khusus untuk memberikan konteks tambahan:

```bash
repomix --instructions "Ini adalah aplikasi React yang menggunakan TypeScript dan Redux untuk manajemen state. Fokus pada komponen UI dan logika state."
```

## Bekerja dengan Respons AI

### Verifikasi dan Uji

Selalu verifikasi kode yang dihasilkan AI:

- Periksa kesalahan logika atau sintaksis
- Jalankan pengujian otomatis
- Tinjau keamanan dan praktik terbaik

### Iterasi dan Perbaikan

Pengembangan dengan bantuan AI adalah proses iteratif:

- Mulai dengan permintaan tingkat tinggi
- Perbaiki berdasarkan respons
- Minta klarifikasi atau perbaikan jika diperlukan

### Pelajari dari Interaksi

Setiap interaksi dengan AI adalah kesempatan belajar:

- Perhatikan bagaimana AI mendekati masalah
- Identifikasi pola dan teknik baru
- Terapkan wawasan ke proyek masa depan

## Kasus Penggunaan Lanjutan

### Analisis Kode

Gunakan Repomix dan AI untuk:

- Mengidentifikasi masalah teknis utang
- Menemukan potensi bug atau masalah keamanan
- Memahami basis kode yang kompleks

### Refaktor dan Optimasi

Minta AI untuk membantu dengan:

- Memodernisasi basis kode lama
- Mengoptimalkan kinerja
- Meningkatkan keterbacaan dan pemeliharaan

### Dokumentasi

Hasilkan dokumentasi berkualitas tinggi:

- Dokumentasi API
- Panduan arsitektur
- Komentar kode dan penjelasan

## Kesimpulan

Menggabungkan Repomix dengan alat AI dapat secara signifikan meningkatkan alur kerja pengembangan Anda. Dengan mengikuti praktik terbaik ini, Anda dapat memaksimalkan manfaat dari teknologi ini sambil memastikan kualitas dan keamanan kode Anda.

Ingat bahwa AI adalah alat untuk melengkapi keahlian Anda, bukan menggantinya. Penilaian dan pengalaman Anda sebagai pengembang tetap menjadi aset paling berharga dalam proses pengembangan.
</file>

<file path="website/client/src/id/guide/code-compress.md">
# Kompresi Kode


Kompresi kode adalah fitur yang kuat yang secara cerdas mengekstrak struktur kode esensial sambil menghapus detail implementasi. Ini sangat berguna untuk mengurangi jumlah token sambil mempertahankan informasi struktural penting tentang basis kode Anda.

> [!NOTE]  
> Ini adalah fitur eksperimental yang akan kami tingkatkan secara aktif berdasarkan umpan balik pengguna dan penggunaan dunia nyata

## Penggunaan Dasar

Aktifkan kompresi kode menggunakan flag `--compress`:

```bash
repomix --compress
```

Anda juga dapat menggunakannya dengan repositori jarak jauh:

```bash
repomix --remote user/repo --compress
```

## Cara Kerjanya

Algoritma kompresi memproses kode menggunakan parsing tree-sitter untuk mengekstrak dan mempertahankan elemen struktural esensial sambil menghapus detail implementasi.

Kompresi mempertahankan:
- Tanda tangan fungsi dan metode
- Definisi antarmuka dan tipe
- Struktur dan properti kelas
- Elemen struktural penting

Sambil menghapus:
- Implementasi fungsi dan metode
- Detail logika perulangan dan kondisional
- Deklarasi variabel internal
- Kode spesifik implementasi

### Contoh

Kode TypeScript asli:

```typescript
import { ShoppingItem } from './shopping-item';

/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
  let total = 0;
  for (const item of items) {
    total += item.price * item.quantity;
  }
  return total;
}

// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

Setelah kompresi:

```typescript
import { ShoppingItem } from './shopping-item';
⋮----
/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
⋮----
// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

## Konfigurasi

Anda dapat mengaktifkan kompresi dalam file konfigurasi Anda:

```json
{
  "output": {
    "compress": true
  }
}
```

## Kasus Penggunaan

Kompresi kode sangat berguna ketika:
- Menganalisis struktur dan arsitektur kode
- Mengurangi jumlah token untuk pemrosesan LLM
- Membuat dokumentasi tingkat tinggi
- Memahami pola dan tanda tangan kode
- Berbagi desain API dan antarmuka

## Opsi Terkait

Anda dapat menggabungkan kompresi dengan opsi lain:
- `--remove-comments`: Menghapus komentar kode
- `--remove-empty-lines`: Menghapus baris kosong
- `--output-show-line-numbers`: Menambahkan nomor baris ke output
</file>

<file path="website/client/src/id/guide/command-line-options.md">
# Opsi Baris Perintah


Repomix menyediakan berbagai opsi baris perintah untuk menyesuaikan perilakunya. Berikut adalah daftar lengkap opsi yang tersedia.

## Opsi Dasar

| Opsi | Deskripsi |
|------|-----------|
| `--help`, `-h` | Menampilkan bantuan |
| `--version`, `-v` | Menampilkan versi |
| `--init` | Membuat file konfigurasi baru (`repomix.config.json`) |

## Opsi Output

| Opsi | Deskripsi |
|------|-----------|
| `--output`, `-o` | Menentukan jalur file output |
| `--style`, `-s` | Menentukan format output (`xml`, `markdown`, `plain`) |
| `--no-line-numbers` | Menonaktifkan nomor baris |
| `--remove-comments` | Menghapus komentar dari kode sumber |
| `--top-files` | Menentukan jumlah file teratas yang akan ditampilkan di ringkasan |
| `--copy-to-clipboard` | Menyalin output ke clipboard |

## Opsi Pengabaian

| Opsi | Deskripsi |
|------|-----------|
| `--include` | Pola glob untuk menyertakan file tertentu |
| `--ignore` | Pola glob untuk mengabaikan file tertentu |
| `--stdin` | Membaca jalur file dari stdin alih-alih menemukan file secara otomatis |
| `--no-gitignore` | Mengabaikan file `.gitignore` |

## Opsi Keamanan

| Opsi | Deskripsi |
|------|-----------|
| `--no-security` | Menonaktifkan pemeriksaan keamanan |

## Opsi Repositori Jarak Jauh

| Opsi | Deskripsi |
|------|-----------|
| `--remote`, `-r` | Mengemas repositori GitHub publik |

## Opsi Diff

| Opsi | Deskripsi |
|------|-----------|
| `--diffs` | Mengaktifkan mode diff |
| `--base-branch` | Menentukan cabang dasar untuk perbandingan diff |

## Opsi MCP Server

| Opsi | Deskripsi |
|------|-----------|
| `--mcp` | Memulai server MCP |
| `--mcp-port` | Menentukan port untuk server MCP |

## Contoh Penggunaan

### Mengemas Seluruh Repositori

```bash
repomix
```

### Mengemas dengan Format Markdown

```bash
repomix --style markdown
```

### Mengemas Direktori Tertentu

```bash
repomix path/to/directory
```

### Mengemas File Tertentu

```bash
repomix --include "src/**/*.ts,**/*.md"
```

### Mengecualikan File Tertentu

```bash
repomix --ignore "**/*.log,tmp/"
```

### Mengemas Repositori Jarak Jauh

```bash
repomix --remote yamadashy/repomix
```

### Mengaktifkan Mode Diff

```bash
repomix --diffs --base-branch main
```

### Memulai Server MCP

```bash
repomix --mcp
```

### Menggunakan stdin untuk Daftar File

```bash
find src -name "*.ts" -type f | repomix --stdin
git ls-files "*.js" | repomix --stdin
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```

## Menggunakan Opsi dengan File Konfigurasi

Semua opsi baris perintah dapat juga ditentukan dalam file konfigurasi. Opsi baris perintah akan mengganti pengaturan dalam file konfigurasi.

Untuk informasi lebih lanjut tentang file konfigurasi, lihat [Panduan Konfigurasi](configuration.md).
</file>

<file path="website/client/src/id/guide/comment-removal.md">
# Penghapusan Komentar


Repomix menyediakan opsi untuk menghapus komentar dari kode sumber Anda sebelum mengemas. Ini dapat membantu mengurangi ukuran output dan mengurangi jumlah token yang digunakan oleh model AI.

## Penggunaan Dasar

Untuk menghapus komentar dari output, gunakan flag `--remove-comments`:

```bash
repomix --remove-comments
```

## Konfigurasi

Anda juga dapat mengaktifkan penghapusan komentar dalam file konfigurasi Anda:

```json
{
  "output": {
    "removeComments": true
  }
}
```

## Apa yang Dihapus

Ketika penghapusan komentar diaktifkan, Repomix akan menghapus:

- Komentar baris tunggal (misalnya, `// komentar ini`)
- Komentar multi-baris (misalnya, `/* komentar ini */`)
- Komentar dokumentasi (misalnya, `/** dokumentasi ini */`)

## Pertimbangan

Meskipun menghapus komentar dapat mengurangi jumlah token, perlu diingat bahwa komentar sering berisi informasi berharga tentang kode, seperti:

- Penjelasan tentang algoritma kompleks
- Alasan di balik keputusan implementasi
- Dokumentasi API
- Petunjuk untuk pengembang masa depan

Pertimbangkan dengan hati-hati apakah Anda ingin menghapus komentar berdasarkan kasus penggunaan spesifik Anda.

## Kasus Penggunaan

Penghapusan komentar paling berguna ketika:

- Anda perlu mengurangi jumlah token untuk model AI dengan konteks terbatas
- Komentar dalam kode Anda tidak memberikan nilai tambah yang signifikan
- Anda ingin fokus hanya pada kode yang dapat dieksekusi

Jika komentar Anda berisi informasi penting yang membantu memahami kode, Anda mungkin ingin mempertahankannya.
</file>

<file path="website/client/src/id/guide/configuration.md">
# Konfigurasi


Repomix dapat dikonfigurasi menggunakan file konfigurasi atau opsi baris perintah. File konfigurasi memberikan cara yang lebih terstruktur untuk menyimpan pengaturan Anda.

## File Konfigurasi

Repomix mencari file konfigurasi bernama `repomix.config.json` di direktori saat ini. Anda dapat membuat file konfigurasi baru dengan perintah:

```bash
repomix --init
```

Ini akan membuat file `repomix.config.json` dengan pengaturan default.

## Struktur Konfigurasi

Berikut adalah contoh file konfigurasi dengan semua opsi yang tersedia:

```json
{
  "output": {
    "style": "xml",
    "filePath": "repomix-output.xml",
    "removeComments": false,
    "showLineNumbers": true,
    "topFilesLength": 10,
    "copyToClipboard": false
  },
  "ignore": {
    "customPatterns": [],
    "respectGitignore": true
  },
  "security": {
    "enabled": true,
    "rules": []
  },
  "diffs": {
    "enabled": false,
    "baseBranch": "main"
  }
}
```

## Opsi Konfigurasi

### Output

| Opsi | Tipe | Default | Deskripsi |
|------|------|---------|-----------|
| `style` | string | `"xml"` | Format output. Nilai yang mungkin: `"xml"`, `"markdown"`, `"plain"` |
| `filePath` | string | `"repomix-output.xml"` | Jalur file output |
| `removeComments` | boolean | `false` | Apakah akan menghapus komentar dari kode sumber |
| `showLineNumbers` | boolean | `true` | Apakah akan menampilkan nomor baris |
| `topFilesLength` | number | `10` | Jumlah file teratas yang akan ditampilkan di ringkasan |
| `copyToClipboard` | boolean | `false` | Apakah akan menyalin output ke clipboard |

### Ignore

| Opsi | Tipe | Default | Deskripsi |
|------|------|---------|-----------|
| `customPatterns` | string[] | `[]` | Pola glob kustom untuk mengabaikan file |
| `respectGitignore` | boolean | `true` | Apakah akan menghormati file `.gitignore` |

### Security

| Opsi | Tipe | Default | Deskripsi |
|------|------|---------|-----------|
| `enabled` | boolean | `true` | Apakah akan mengaktifkan pemeriksaan keamanan |
| `rules` | string[] | `[]` | Aturan keamanan kustom |

### Diffs

| Opsi | Tipe | Default | Deskripsi |
|------|------|---------|-----------|
| `enabled` | boolean | `false` | Apakah akan mengaktifkan mode diff |
| `baseBranch` | string | `"main"` | Cabang dasar untuk perbandingan diff |

## Mengganti Konfigurasi dengan Opsi Baris Perintah

Semua pengaturan dalam file konfigurasi dapat diganti dengan opsi baris perintah. Misalnya:

```bash
repomix --style markdown --output custom-output.md --remove-comments
```

Untuk daftar lengkap opsi baris perintah, lihat [Opsi Baris Perintah](command-line-options.md).

## Prioritas Konfigurasi

Repomix menggunakan prioritas berikut untuk konfigurasi:

1. Opsi baris perintah
2. File konfigurasi proyek (`repomix.config.json`)
3. Nilai default

## Konfigurasi Global

Repomix juga mendukung konfigurasi global yang berlaku untuk semua proyek. File konfigurasi global terletak di:

- Windows: `%USERPROFILE%\.repomix\config.json`
- macOS/Linux: `~/.repomix/config.json`

Konfigurasi global memiliki prioritas lebih rendah daripada konfigurasi proyek dan opsi baris perintah.
</file>

<file path="website/client/src/id/guide/custom-instructions.md">
# Instruksi Khusus


Repomix memungkinkan Anda menambahkan instruksi khusus ke output yang dihasilkan. Ini berguna untuk memberikan konteks tambahan atau petunjuk kepada model AI tentang cara memahami atau menggunakan basis kode Anda.

## Penggunaan Dasar

Untuk menambahkan instruksi khusus, gunakan flag `--instructions`:

```bash
repomix --instructions "Ini adalah proyek React yang menggunakan TypeScript. Perhatikan pola komponen yang digunakan."
```

## Menggunakan File Instruksi

Untuk instruksi yang lebih panjang atau kompleks, Anda dapat menyimpannya dalam file dan mereferensikannya:

```bash
repomix --instructions-file path/to/instructions.txt
```

## Konfigurasi

Anda juga dapat menentukan instruksi dalam file konfigurasi Anda:

```json
{
  "output": {
    "instructions": "Ini adalah proyek React yang menggunakan TypeScript. Perhatikan pola komponen yang digunakan."
  }
}
```

Atau menggunakan file instruksi:

```json
{
  "output": {
    "instructionsFile": "path/to/instructions.txt"
  }
}
```

## Praktik Terbaik

Saat menulis instruksi khusus, pertimbangkan hal berikut:

1. **Berikan konteks proyek**: Jelaskan tujuan, arsitektur, dan teknologi utama yang digunakan.
2. **Sorot area penting**: Arahkan perhatian ke bagian kode yang paling relevan.
3. **Jelaskan konvensi**: Jelaskan pola penamaan, struktur, atau konvensi khusus yang digunakan.
4. **Tentukan tujuan**: Jelaskan apa yang Anda harapkan dari model AI (misalnya, refaktor, analisis, dokumentasi).
5. **Berikan contoh**: Jika memungkinkan, berikan contoh jenis respons yang Anda harapkan.

Instruksi yang jelas dan spesifik akan membantu model AI memberikan respons yang lebih berguna dan relevan.
</file>

<file path="website/client/src/id/guide/github-actions.md">
# GitHub Actions


Repomix menyediakan GitHub Action yang memungkinkan Anda mengintegrasikan pembuatan file Repomix ke dalam alur kerja CI/CD Anda. Ini berguna untuk memastikan bahwa file Repomix selalu diperbarui dengan perubahan terbaru pada basis kode Anda.

## Penggunaan Dasar

Untuk menggunakan GitHub Action Repomix, tambahkan file alur kerja berikut ke repositori Anda di `.github/workflows/repomix.yml`:

```yaml
name: Generate Repomix File

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  generate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Generate Repomix File
        uses: yamadashy/repomix-action@v1
        with:
          output-path: './repomix-output.xml'
          
      - name: Upload Repomix File
        uses: actions/upload-artifact@v3
        with:
          name: repomix-output
          path: ./repomix-output.xml
```

## Opsi Konfigurasi

GitHub Action Repomix mendukung semua opsi yang tersedia di CLI. Berikut adalah beberapa opsi yang paling umum:

| Opsi | Deskripsi | Default |
|------|-----------|---------|
| `output-path` | Jalur file output | `./repomix-output.xml` |
| `style` | Format output (`xml`, `markdown`, `plain`) | `xml` |
| `ignore` | Pola glob untuk mengabaikan file | - |
| `include` | Pola glob untuk menyertakan file | - |
| `remove-comments` | Menghapus komentar dari kode sumber | `false` |
| `compress` | Mengaktifkan kompresi kode | `false` |

## Contoh Lanjutan

Berikut adalah contoh alur kerja yang lebih lanjutan dengan beberapa opsi konfigurasi:

```yaml
name: Generate Repomix File

on:
  push:
    branches: [ main ]
  schedule:
    - cron: '0 0 * * 1'  # Setiap hari Senin pukul 00:00 UTC
  workflow_dispatch:

jobs:
  generate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Generate Repomix File
        uses: yamadashy/repomix-action@v1
        with:
          output-path: './docs/repomix-output.md'
          style: 'markdown'
          ignore: 'node_modules/**,*.log,tmp/**'
          remove-comments: 'true'
          compress: 'true'
          
      - name: Commit and Push
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add ./docs/repomix-output.md
          git commit -m "Update Repomix output" || echo "No changes to commit"
          git push
```

## Kasus Penggunaan

GitHub Action Repomix sangat berguna untuk:

- Mempertahankan dokumentasi basis kode yang selalu diperbarui
- Menyediakan snapshot basis kode terbaru untuk tim AI
- Mengotomatiskan pembuatan file Repomix untuk proyek yang sering berubah
- Mengintegrasikan Repomix ke dalam alur kerja pengembangan yang ada
</file>

<file path="website/client/src/id/guide/index.md">
# Memulai dengan Repomix

<script setup>
import HomeBadges from '../../../components/HomeBadges.vue'
import YouTubeVideo from '../../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../../utils/videos'
</script>

Repomix adalah alat yang mengemas seluruh repositori Anda menjadi satu file yang ramah AI. Ini dirancang untuk membantu Anda menyediakan basis kode Anda ke Model Bahasa Besar (LLM) seperti ChatGPT, DeepSeek, Perplexity, Gemini, Gemma, Llama, Grok, dan lainnya.

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

<HomeBadges />

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## Mulai Cepat

Jalankan perintah ini di direktori proyek Anda:

```bash
npx repomix
```

Itu saja! Anda akan menemukan file `repomix-output.xml` yang berisi seluruh repositori Anda dalam format yang ramah AI.

Anda kemudian dapat mengirim file ini ke asisten AI dengan prompt seperti:

```
File ini berisi semua file dalam repositori yang digabungkan menjadi satu.
Saya ingin merefaktor kode, jadi tolong tinjau terlebih dahulu.
```

AI akan menganalisis seluruh basis kode Anda dan memberikan wawasan komprehensif:

![Penggunaan File Repomix 1](/images/docs/repomix-file-usage-1.png)

Ketika mendiskusikan perubahan spesifik, AI dapat membantu menghasilkan kode. Dengan fitur seperti Artifacts dari Claude, Anda bahkan dapat menerima beberapa file yang saling bergantung:

![Penggunaan File Repomix 2](/images/docs/repomix-file-usage-2.png)

Selamat mengkode! 🚀

## Fitur Utama

- **Output Dioptimalkan untuk AI**: Memformat basis kode Anda untuk pemrosesan AI yang mudah
- **Penghitungan Token**: Melacak penggunaan token untuk batas konteks LLM
- **Mengenali Git**: Menghormati file `.gitignore` dan `.git/info/exclude` Anda
- **Fokus pada Keamanan**: Mendeteksi informasi sensitif
- **Beberapa Format Output**: Pilih antara teks biasa, XML, atau Markdown

## Langkah Selanjutnya

- [Panduan Instalasi](installation.md): Berbagai cara untuk menginstal Repomix
- [Panduan Penggunaan](usage.md): Pelajari tentang fitur dasar dan lanjutan
- [Konfigurasi](configuration.md): Kustomisasi Repomix untuk kebutuhan Anda
- [Fitur Keamanan](security.md): Pelajari tentang pemeriksaan keamanan

## Komunitas

Bergabunglah dengan [komunitas Discord](https://discord.gg/wNYzTwZFku) kami untuk:
- Mendapatkan bantuan dengan Repomix
- Berbagi pengalaman Anda
- Menyarankan fitur baru
- Terhubung dengan pengguna lain

## Dukungan

Menemukan bug atau butuh bantuan?
- [Buka masalah di GitHub](https://github.com/yamadashy/repomix/issues)
- Bergabunglah dengan server Discord kami
- Periksa [dokumentasi](https://repomix.com)
</file>

<file path="website/client/src/id/guide/installation.md">
# Instalasi


Repomix dapat diinstal dengan berbagai cara, tergantung pada kebutuhan dan preferensi Anda.

## Menggunakan npx (Tanpa Instalasi)

Cara tercepat untuk mencoba Repomix adalah dengan menggunakan `npx` tanpa instalasi:

```bash
npx repomix
```

Ini akan mengunduh dan menjalankan Repomix secara langsung di direktori proyek Anda.

## Instalasi Global

Untuk penggunaan berulang, Anda dapat menginstal Repomix secara global:

### Menggunakan npm

```bash
npm install -g repomix
```

### Menggunakan yarn

```bash
yarn global add repomix
```

### Menggunakan pnpm

```bash
pnpm add -g repomix
```

### Menggunakan Bun

```bash
bun add -g repomix
```

### Menggunakan Homebrew (macOS/Linux)

```bash
brew install repomix
```

## Menggunakan Docker

Anda juga dapat menjalankan Repomix menggunakan Docker:

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

## Ekstensi Browser

Dapatkan akses instan ke Repomix langsung dari repositori GitHub mana pun! Ekstensi browser kami menambahkan tombol "Repomix" yang nyaman ke halaman repositori GitHub.

![Repomix Browser Extension](/images/docs/browser-extension.png)

### Instalasi
- Ekstensi Chrome: [Repomix - Chrome Web Store](https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa)
- Add-on Firefox: [Repomix - Firefox Add-ons](https://addons.mozilla.org/firefox/addon/repomix/)

### Fitur
- Akses satu klik ke Repomix untuk repositori GitHub mana pun
- Fitur menarik lainnya akan segera hadir!

## Verifikasi Instalasi

Setelah instalasi, Anda dapat memverifikasi bahwa Repomix telah diinstal dengan benar dengan menjalankan:

```bash
repomix --version
```

## Langkah Selanjutnya

Setelah Anda menginstal Repomix, lihat [Panduan Penggunaan](usage.md) untuk mempelajari cara menggunakannya.
</file>

<file path="website/client/src/id/guide/mcp-server.md">
# Server MCP

Repomix mendukung [Model Context Protocol (MCP)](https://modelcontextprotocol.io), memungkinkan asisten AI untuk berinteraksi langsung dengan codebase Anda. Ketika dijalankan sebagai server MCP, Repomix menyediakan tools yang memungkinkan asisten AI untuk mengemas repository lokal atau remote untuk analisis tanpa memerlukan persiapan file manual.

> [!NOTE]  
> Ini adalah fitur eksperimental yang akan kami tingkatkan secara aktif berdasarkan feedback pengguna dan penggunaan dunia nyata

## Menjalankan Repomix sebagai Server MCP

Untuk menjalankan Repomix sebagai server MCP, gunakan flag `--mcp`:

```bash
repomix --mcp
```

Ini memulai Repomix dalam mode server MCP, membuatnya tersedia untuk asisten AI yang mendukung Model Context Protocol.

## Konfigurasi Server MCP

Untuk menggunakan Repomix sebagai server MCP dengan asisten AI seperti Claude, Anda perlu mengkonfigurasi pengaturan MCP:

### Untuk VS Code

Anda dapat menginstal server MCP Repomix di VS Code menggunakan salah satu metode berikut:

1. **Menggunakan badge instalasi:**

  [![Install in VS Code](https://img.shields.io/badge/VS_Code-VS_Code?style=flat-square&label=Install%20Server&color=0098FF)](vscode:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)<br>
  [![Install in VS Code Insiders](https://img.shields.io/badge/VS_Code_Insiders-VS_Code_Insiders?style=flat-square&label=Install%20Server&color=24bfa5)](vscode-insiders:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)

2. **Menggunakan command line:**

  ```bash
  code --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

  Untuk VS Code Insiders:
  ```bash
  code-insiders --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

### Untuk Cline (ekstensi VS Code)

Edit file `cline_mcp_settings.json`:

```json
{
  "mcpServers": {
    "repomix": {
      "command": "npx",
      "args": [
        "-y",
        "repomix",
        "--mcp"
      ]
    }
  }
}
```

### Untuk Cursor

Di Cursor, tambahkan server MCP baru dari `Cursor Settings` > `MCP` > `+ Add new global MCP server` dengan konfigurasi serupa dengan Cline.

### Untuk Claude Desktop

Edit file `claude_desktop_config.json` dengan konfigurasi serupa dengan Cline.

### Untuk Claude Code

Untuk mengkonfigurasi Repomix sebagai server MCP di [Claude Code](https://docs.anthropic.com/en/docs/claude-code/overview), gunakan perintah berikut:

```bash
claude mcp add repomix -- npx -y repomix --mcp
```

### Menggunakan Docker sebagai pengganti npx

Sebagai pengganti menggunakan npx, Anda dapat menggunakan Docker untuk menjalankan Repomix sebagai server MCP:

```json
{
  "mcpServers": {
    "repomix-docker": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "ghcr.io/yamadashy/repomix",
        "--mcp"
      ]
    }
  }
}
```

## Tools MCP yang Tersedia

Ketika dijalankan sebagai server MCP, Repomix menyediakan tools berikut:

### pack_codebase

Tool ini mengemas direktori kode lokal ke dalam file XML untuk analisis AI. Tool ini menganalisis struktur codebase, mengekstrak konten kode yang relevan, dan menghasilkan laporan komprehensif termasuk metrik, pohon file, dan konten kode yang diformat.

**Parameter:**
- `directory`: (Wajib) Path absolut ke direktori yang akan dikemas
- `compress`: (Opsional, default: false) Mengaktifkan kompresi Tree-sitter untuk mengekstrak signature kode esensial dan struktur sambil menghapus detail implementasi. Mengurangi penggunaan token sekitar 70% sambil mempertahankan makna semantik. Umumnya tidak diperlukan karena grep_repomix_output memungkinkan pengambilan konten incremental. Gunakan hanya ketika Anda khusus membutuhkan konten codebase lengkap untuk repository besar.
- `includePatterns`: (Opsional) Menentukan file yang akan disertakan menggunakan pola fast-glob. Beberapa pola dapat dipisahkan dengan koma (contoh: "**/*.{js,ts}", "src/**,docs/**"). Hanya file yang cocok yang akan diproses.
- `ignorePatterns`: (Opsional) Menentukan file tambahan yang akan dikecualikan menggunakan pola fast-glob. Beberapa pola dapat dipisahkan dengan koma (contoh: "test/**,*.spec.js", "node_modules/**,dist/**"). Pola ini melengkapi .gitignore dan eksklusi built-in.
- `topFilesLength`: (Opsional, default: 10) Jumlah file terbesar berdasarkan ukuran untuk ditampilkan dalam ringkasan metrik untuk analisis codebase.

**Contoh:**
```json
{
  "directory": "/path/to/your/project",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### pack_remote_repository

Tool ini mengambil, mengkloning, dan mengemas repository GitHub ke dalam file XML untuk analisis AI. Tool ini secara otomatis mengkloning repository remote, menganalisis strukturnya, dan menghasilkan laporan komprehensif.

**Parameter:**
- `remote`: (Wajib) URL repository GitHub atau format user/repo (contoh: "yamadashy/repomix", "https://github.com/user/repo", atau "https://github.com/user/repo/tree/branch")
- `compress`: (Opsional, default: false) Mengaktifkan kompresi Tree-sitter untuk mengekstrak signature kode esensial dan struktur sambil menghapus detail implementasi. Mengurangi penggunaan token sekitar 70% sambil mempertahankan makna semantik. Umumnya tidak diperlukan karena grep_repomix_output memungkinkan pengambilan konten incremental. Gunakan hanya ketika Anda khusus membutuhkan konten codebase lengkap untuk repository besar.
- `includePatterns`: (Opsional) Menentukan file yang akan disertakan menggunakan pola fast-glob. Beberapa pola dapat dipisahkan dengan koma (contoh: "**/*.{js,ts}", "src/**,docs/**"). Hanya file yang cocok yang akan diproses.
- `ignorePatterns`: (Opsional) Menentukan file tambahan yang akan dikecualikan menggunakan pola fast-glob. Beberapa pola dapat dipisahkan dengan koma (contoh: "test/**,*.spec.js", "node_modules/**,dist/**"). Pola ini melengkapi .gitignore dan eksklusi built-in.
- `topFilesLength`: (Opsional, default: 10) Jumlah file terbesar berdasarkan ukuran untuk ditampilkan dalam ringkasan metrik untuk analisis codebase.

**Contoh:**
```json
{
  "remote": "yamadashy/repomix",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### read_repomix_output

Tool ini membaca konten file output yang dihasilkan oleh Repomix. Mendukung pembacaan parsial dengan spesifikasi rentang baris untuk file besar. Tool ini dirancang untuk lingkungan di mana akses filesystem langsung terbatas.

**Parameter:**
- `outputId`: (Wajib) ID file output Repomix untuk dibaca
- `startLine`: (Opsional) Nomor baris awal (berbasis 1, inklusif). Jika tidak ditentukan, membaca dari awal.
- `endLine`: (Opsional) Nomor baris akhir (berbasis 1, inklusif). Jika tidak ditentukan, membaca hingga akhir.

**Fitur:**
- Dirancang khusus untuk lingkungan berbasis web atau aplikasi sandbox
- Mengambil konten output yang dihasilkan sebelumnya menggunakan ID mereka
- Menyediakan akses aman ke codebase yang dikemas tanpa memerlukan akses filesystem
- Mendukung pembacaan parsial untuk file besar

**Contoh:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "startLine": 100,
  "endLine": 200
}
```

### grep_repomix_output

Tool ini mencari pola dalam file output Repomix menggunakan fungsionalitas mirip grep dengan sintaks JavaScript RegExp. Mengembalikan baris yang cocok dengan baris konteks opsional di sekitar kecocokan.

**Parameter:**
- `outputId`: (Wajib) ID file output Repomix untuk dicari
- `pattern`: (Wajib) Pola pencarian (sintaks regular expression JavaScript RegExp)
- `contextLines`: (Opsional, default: 0) Jumlah baris konteks untuk ditampilkan sebelum dan sesudah setiap kecocokan. Diganti oleh beforeLines/afterLines jika ditentukan.
- `beforeLines`: (Opsional) Jumlah baris konteks untuk ditampilkan sebelum setiap kecocokan (seperti grep -B). Mengambil prioritas atas contextLines.
- `afterLines`: (Opsional) Jumlah baris konteks untuk ditampilkan setelah setiap kecocokan (seperti grep -A). Mengambil prioritas atas contextLines.
- `ignoreCase`: (Opsional, default: false) Melakukan pencocokan case-insensitive

**Fitur:**
- Menggunakan sintaks JavaScript RegExp untuk pencocokan pola yang kuat
- Mendukung baris konteks untuk pemahaman kecocokan yang lebih baik
- Memungkinkan kontrol terpisah dari baris konteks sebelum/sesudah
- Opsi pencarian case-sensitive dan case-insensitive

**Contoh:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "pattern": "function\\s+\\w+\\(",
  "contextLines": 3,
  "ignoreCase": false
}
```

### file_system_read_file dan file_system_read_directory

Server MCP Repomix menyediakan dua tools filesystem yang memungkinkan asisten AI untuk berinteraksi dengan aman dengan filesystem lokal:

1. `file_system_read_file`
  - Membaca konten file dari filesystem lokal menggunakan path absolut
  - Termasuk validasi keamanan built-in untuk mendeteksi dan mencegah akses ke file yang berisi informasi sensitif
  - Mengimplementasikan validasi keamanan menggunakan [Secretlint](https://github.com/secretlint/secretlint)
  - Mencegah akses ke file yang berisi informasi sensitif (API keys, password, secrets)
  - Memvalidasi path absolut untuk mencegah serangan directory traversal
  - Mengembalikan pesan error yang jelas untuk path yang tidak valid dan masalah keamanan

2. `file_system_read_directory`
  - Mendaftar konten direktori menggunakan path absolut
  - Mengembalikan daftar berformat yang menampilkan file dan subdirektori dengan indikator yang jelas
  - Menampilkan file dan direktori dengan indikator yang jelas (`[FILE]` atau `[DIR]`)
  - Menyediakan navigasi direktori yang aman dengan penanganan error yang tepat
  - Memvalidasi path dan memastikan mereka absolut
  - Berguna untuk mengeksplorasi struktur proyek dan memahami organisasi codebase

Kedua tools menggabungkan tindakan keamanan yang kuat:
- Validasi path absolut untuk mencegah serangan directory traversal
- Pemeriksaan izin untuk memastikan hak akses yang tepat
- Integrasi dengan Secretlint untuk deteksi informasi sensitif
- Pesan error yang jelas untuk debugging dan kesadaran keamanan yang lebih baik

**Contoh:**
```typescript
// Membaca file
const fileContent = await tools.file_system_read_file({
  path: '/absolute/path/to/file.txt'
});

// Mendaftar konten direktori
const dirContent = await tools.file_system_read_directory({
  path: '/absolute/path/to/directory'
});
```

Tools ini sangat berguna ketika asisten AI perlu:
- Menganalisis file spesifik dalam codebase
- Menavigasi struktur direktori
- Memverifikasi eksistensi dan aksesibilitas file
- Memastikan operasi filesystem yang aman

## Manfaat Menggunakan Repomix sebagai Server MCP

Menggunakan Repomix sebagai server MCP menawarkan beberapa keuntungan:

1. **Integrasi Langsung**: Asisten AI dapat menganalisis codebase Anda secara langsung tanpa persiapan file manual.
2. **Workflow Efisien**: Merampingkan proses analisis kode dengan menghilangkan kebutuhan untuk menghasilkan dan mengunggah file secara manual.
3. **Output Konsisten**: Memastikan asisten AI menerima codebase dalam format yang konsisten dan dioptimalkan.
4. **Fitur Lanjutan**: Memanfaatkan semua fitur Repomix seperti kompresi kode, penghitungan token, dan pemeriksaan keamanan.

Setelah dikonfigurasi, asisten AI Anda dapat langsung menggunakan kemampuan Repomix untuk menganalisis codebase, membuat workflow analisis kode lebih efisien.
</file>

<file path="website/client/src/id/guide/output.md">
# Format Output


Repomix mendukung beberapa format output untuk memenuhi berbagai kebutuhan. Anda dapat memilih format yang paling sesuai dengan kasus penggunaan Anda.

## Format yang Tersedia

Repomix mendukung tiga format output utama:

1. **XML** (default): Format terstruktur yang ideal untuk pemrosesan AI
2. **Markdown**: Format yang mudah dibaca manusia dengan dukungan sintaks
3. **Teks Biasa**: Format sederhana tanpa markup

## Memilih Format

Anda dapat menentukan format output menggunakan flag `--style`:

```bash
# Format XML (default)
repomix --style xml

# Format Markdown
repomix --style markdown

# Format teks biasa
repomix --style plain
```

## Contoh Output

### Format XML

```xml
<repomix version="1.0.0" timestamp="2023-04-01T12:00:00Z" repo="example-repo">
  <stats>
    <files>10</files>
    <lines>500</lines>
    <tokens>5000</tokens>
  </stats>
  <file path="src/index.js" language="javascript" tokens="120">
    <content>
    // Kode sumber di sini
    </content>
  </file>
  <!-- File lainnya -->
</repomix>
```

### Format Markdown

```markdown
# Repomix Output: example-repo

Generated on: 2023-04-01T12:00:00Z

## Stats
- Files: 10
- Lines: 500
- Tokens: 5000

## Files

### src/index.js (JavaScript, 120 tokens)

```javascript
// Kode sumber di sini
```

<!-- File lainnya -->
```

### Format Teks Biasa

```
Repomix Output: example-repo
Generated on: 2023-04-01T12:00:00Z

Stats:
- Files: 10
- Lines: 500
- Tokens: 5000

Files:

src/index.js (JavaScript, 120 tokens)
------------------------------------
// Kode sumber di sini

// File lainnya
```

## Konfigurasi

Anda dapat menentukan format output dalam file konfigurasi Anda:

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md"
  }
}
```

## Opsi Terkait

Beberapa opsi terkait yang dapat memengaruhi output:

- `--output`, `-o`: Menentukan jalur file output
- `--no-line-numbers`: Menonaktifkan nomor baris
- `--remove-comments`: Menghapus komentar dari kode sumber
- `--top-files`: Menentukan jumlah file teratas yang akan ditampilkan di ringkasan
- `--copy-to-clipboard`: Menyalin output ke clipboard
</file>

<file path="website/client/src/id/guide/prompt-examples.md">
# Contoh Prompt


Setelah Anda menghasilkan file Repomix, Anda perlu memberikan prompt yang efektif ke model AI untuk mendapatkan hasil terbaik. Halaman ini menyediakan beberapa contoh prompt yang dapat Anda gunakan atau adaptasi untuk berbagai kasus penggunaan.

## Prompt Dasar

Berikut adalah prompt dasar yang dapat Anda gunakan dengan file Repomix:

```
File ini berisi seluruh basis kode saya dalam format yang dioptimalkan untuk AI.
Tolong tinjau kode ini dan berikan wawasan tentang arsitektur, pola desain, dan area potensial untuk perbaikan.
```

## Analisis Kode

Untuk analisis kode mendalam:

```
File ini berisi basis kode proyek saya dalam format yang dioptimalkan untuk AI.
Tolong lakukan analisis kode mendalam dengan fokus pada:
1. Arsitektur keseluruhan dan struktur proyek
2. Pola desain dan praktik terbaik yang digunakan
3. Potensi masalah performa atau keamanan
4. Area untuk refaktor atau perbaikan
5. Kualitas kode secara keseluruhan dan keterbacaan
```

## Refaktor Kode

Untuk bantuan dengan refaktor:

```
File ini berisi basis kode proyek saya dalam format yang dioptimalkan untuk AI.
Saya ingin merefaktor [jelaskan komponen atau fitur].
Tolong bantu saya dengan:
1. Mengidentifikasi masalah dalam implementasi saat ini
2. Menyarankan pendekatan refaktor yang lebih bersih
3. Memberikan contoh kode untuk implementasi yang direfaktor
4. Menjelaskan manfaat dari perubahan yang disarankan
```

## Menambahkan Fitur Baru

Untuk bantuan dengan menambahkan fitur baru:

```
File ini berisi basis kode proyek saya dalam format yang dioptimalkan untuk AI.
Saya ingin menambahkan fitur baru: [jelaskan fitur].
Tolong bantu saya dengan:
1. Mengidentifikasi di mana fitur ini harus diintegrasikan
2. Menyarankan pendekatan implementasi
3. Memberikan contoh kode untuk fitur baru
4. Menjelaskan perubahan yang diperlukan ke file yang ada
```

## Debugging

Untuk bantuan dengan debugging:

```
File ini berisi basis kode proyek saya dalam format yang dioptimalkan untuk AI.
Saya mengalami bug berikut: [jelaskan bug].
Perilaku yang diharapkan adalah: [jelaskan perilaku yang diharapkan].
Tolong bantu saya:
1. Mengidentifikasi kemungkinan penyebab bug
2. Menyarankan perbaikan
3. Menjelaskan mengapa bug terjadi
```

## Dokumentasi

Untuk bantuan dengan dokumentasi:

```
File ini berisi basis kode proyek saya dalam format yang dioptimalkan untuk AI.
Tolong bantu saya membuat dokumentasi untuk proyek ini, termasuk:
1. Ikhtisar tingkat tinggi tentang apa yang dilakukan proyek
2. Arsitektur dan komponen utama
3. Alur kerja dan alur data utama
4. Petunjuk pengaturan dan penggunaan
5. API dan fungsi utama
```

## Praktik Terbaik

Untuk hasil terbaik dengan prompt Anda:

1. **Berikan konteks yang jelas**: Jelaskan proyek dan tujuan Anda
2. **Tentukan kebutuhan spesifik**: Apa yang Anda coba capai?
3. **Berikan contoh**: Jika memungkinkan, berikan contoh output yang Anda harapkan
4. **Gunakan instruksi bertahap**: Pecah permintaan kompleks menjadi langkah-langkah yang lebih kecil
5. **Iterasi**: Jika respons pertama tidak ideal, perbaiki prompt Anda dan coba lagi
</file>

<file path="website/client/src/id/guide/remote-repository-processing.md">
# Pemrosesan Repositori Remote


Repomix dapat memproses repositori GitHub publik secara langsung tanpa perlu mengkloning mereka secara lokal terlebih dahulu. Ini sangat berguna untuk menganalisis proyek open source atau berbagi basis kode dengan AI tanpa mengunduh seluruh repositori.

## Penggunaan Dasar

Untuk memproses repositori remote, gunakan flag `--remote`:

```bash
# Menggunakan format singkat
npx repomix --remote yamadashy/repomix

# Menggunakan URL lengkap
npx repomix --remote https://github.com/yamadashy/repomix
```

## Format yang Didukung

Repomix mendukung beberapa format URL dan referensi:

### Format Singkat

```bash
npx repomix --remote pemilik/repo
```

### URL Lengkap

```bash
npx repomix --remote https://github.com/pemilik/repo
```

### Cabang Tertentu

```bash
npx repomix --remote https://github.com/pemilik/repo/tree/nama-cabang
```

### Commit Tertentu

```bash
npx repomix --remote https://github.com/pemilik/repo/commit/hash-commit
```

### Direktori Tertentu

```bash
npx repomix --remote https://github.com/pemilik/repo/tree/main/path/to/directory
```

## Opsi Tambahan

Anda dapat menggabungkan pemrosesan repositori remote dengan opsi Repomix lainnya:

```bash
# Menggunakan format Markdown
npx repomix --remote pemilik/repo --style markdown

# Menghapus komentar
npx repomix --remote pemilik/repo --remove-comments

# Mengabaikan file tertentu
npx repomix --remote pemilik/repo --ignore "*.log,tmp/"
```

## Batasan

Saat memproses repositori remote, perhatikan batasan berikut:

- Hanya repositori GitHub publik yang didukung
- Ukuran repositori yang sangat besar mungkin memerlukan waktu lebih lama untuk diproses
- Beberapa fitur seperti penghormatan terhadap `.gitignore` mungkin berperilaku berbeda dibandingkan dengan repositori lokal

## Kasus Penggunaan

Pemrosesan repositori remote sangat berguna untuk:

- Menganalisis proyek open source tanpa mengkloning seluruh repositori
- Berbagi basis kode dengan AI untuk mendapatkan wawasan cepat
- Memeriksa bagian tertentu dari repositori besar
- Membandingkan implementasi di berbagai proyek
</file>

<file path="website/client/src/id/guide/security.md">
# Keamanan


Repomix dirancang dengan fokus pada keamanan untuk membantu mencegah kebocoran informasi sensitif saat berbagi basis kode Anda dengan AI.

## Pemeriksaan Keamanan

Secara default, Repomix mengintegrasikan [Secretlint](https://github.com/secretlint/secretlint) untuk mendeteksi informasi sensitif dalam basis kode Anda. Ini membantu mencegah kebocoran rahasia seperti kunci API, token, dan kredensial.

Ketika Repomix mendeteksi informasi sensitif, itu akan:

1. Memperingatkan Anda tentang file yang berisi informasi sensitif
2. Mengecualikan file-file tersebut dari output
3. Memberikan detail tentang jenis informasi sensitif yang ditemukan

## Contoh Peringatan Keamanan

```
⚠️ Security check found sensitive information in the following files:
- src/config.js: Contains API key
- .env: Contains multiple secrets

These files have been excluded from the output for security reasons.
```

## Menonaktifkan Pemeriksaan Keamanan

Meskipun tidak disarankan, Anda dapat menonaktifkan pemeriksaan keamanan dengan opsi baris perintah:

```bash
repomix --no-security
```

Atau dalam file konfigurasi:

```json
{
  "security": {
    "enabled": false
  }
}
```

## Aturan Keamanan Kustom

Anda dapat menentukan aturan keamanan kustom dalam file konfigurasi:

```json
{
  "security": {
    "enabled": true,
    "rules": [
      "@secretlint/secretlint-rule-preset-recommend",
      "@secretlint/secretlint-rule-pattern",
      {
        "id": "@secretlint/secretlint-rule-pattern",
        "options": {
          "patterns": [
            {
              "name": "Custom Secret Pattern",
              "pattern": "MY_SECRET_[A-Z0-9]{10}",
              "message": "Found custom secret pattern"
            }
          ]
        }
      }
    ]
  }
}
```

## Praktik Terbaik Keamanan

Saat berbagi basis kode dengan AI, ikuti praktik terbaik ini:

1. **Selalu gunakan pemeriksaan keamanan**: Jangan menonaktifkan fitur keamanan Repomix.
2. **Gunakan file .gitignore**: Tambahkan file sensitif ke `.gitignore` Anda.
3. **Gunakan file .env**: Simpan rahasia dalam file `.env` dan tambahkan ke `.gitignore`.
4. **Periksa output**: Selalu periksa file output sebelum membagikannya untuk memastikan tidak ada informasi sensitif.
5. **Gunakan variabel lingkungan**: Gunakan variabel lingkungan untuk rahasia dalam kode Anda.

## Pelaporan Masalah Keamanan

Jika Anda menemukan masalah keamanan di Repomix, harap laporkan secara bertanggung jawab dengan membuka [issue di GitHub](https://github.com/yamadashy/repomix/issues) atau menghubungi pemelihara secara langsung.
</file>

<file path="website/client/src/id/guide/usage.md">
# Penggunaan Dasar


Repomix dirancang untuk menjadi alat yang mudah digunakan dengan antarmuka command-line yang sederhana. Berikut adalah panduan penggunaan dasar.

## Perintah Dasar

Untuk mengemas seluruh repositori Anda:

```bash
repomix
```

Ini akan menghasilkan file `repomix-output.xml` di direktori saat ini, berisi seluruh repositori Anda dalam format yang ramah AI.

## Mengemas Direktori Tertentu

Untuk mengemas direktori tertentu:

```bash
repomix path/to/directory
```

## Menggunakan Pola Glob

Untuk mengemas file atau direktori tertentu menggunakan [pola glob](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):

```bash
repomix --include "src/**/*.ts,**/*.md"
```

## Mengecualikan File atau Direktori

Untuk mengecualikan file atau direktori tertentu:

```bash
repomix --ignore "**/*.log,tmp/"
```

## Mengemas Repositori Jarak Jauh

Repomix dapat mengemas repositori GitHub publik:

```bash
# Menggunakan format singkat
npx repomix --remote yamadashy/repomix

# Menggunakan URL lengkap (mendukung cabang dan jalur tertentu)
npx repomix --remote https://github.com/yamadashy/repomix
npx repomix --remote https://github.com/yamadashy/repomix/tree/main

# Menggunakan URL commit
npx repomix --remote https://github.com/yamadashy/repomix/commit/836abcd7335137228ad77feb28655d85712680f1
```

## Input Daftar File (stdin)

Masukkan jalur file melalui stdin untuk fleksibilitas maksimum:

```bash
# Menggunakan perintah find
find src -name "*.ts" -type f | repomix --stdin

# Menggunakan git untuk mendapatkan file yang terlacak
git ls-files "*.ts" | repomix --stdin

# Menggunakan ls dengan pola glob
ls src/**/*.ts | repomix --stdin

# Dari file yang berisi jalur file
cat file-list.txt | repomix --stdin

# Input langsung dengan echo
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```

Opsi `--stdin` memungkinkan Anda untuk mem-pipe daftar jalur file ke Repomix, memberikan fleksibilitas maksimum dalam memilih file mana yang akan dikemas.

> [!NOTE]
> Saat menggunakan `--stdin`, jalur file dapat berupa jalur relatif atau absolut, dan Repomix akan menangani resolusi jalur dan deduplikasi secara otomatis.

## Format Output

Pilih format output yang Anda inginkan:

```bash
# Format XML (default)
repomix --style xml

# Format Markdown
repomix --style markdown

# Format teks biasa
repomix --style plain
```

## Konfigurasi

Untuk menginisialisasi file konfigurasi baru (`repomix.config.json`):

```bash
repomix --init
```

Untuk informasi lebih lanjut tentang konfigurasi, lihat [Panduan Konfigurasi](configuration.md).

## Penggunaan Docker

Anda juga dapat menjalankan Repomix menggunakan Docker:

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

Untuk mengemas direktori tertentu:
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

Memproses repositori jarak jauh dan output ke direktori `output`:

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

## Langkah Selanjutnya

Setelah Anda menghasilkan file yang dikemas, Anda dapat menggunakannya dengan alat AI Generatif seperti Claude, ChatGPT, dan Gemini.

Untuk informasi lebih lanjut tentang opsi baris perintah, lihat [Opsi Baris Perintah](command-line-options.md).
</file>

<file path="website/client/src/id/index.md">
---
layout: home
title: Repomix
titleTemplate: Kemas basis kode Anda ke dalam format yang ramah AI
aside: false
editLink: false

features:
  - icon: 🤖
    title: Dioptimalkan untuk AI
    details: Memformat basis kode Anda dengan cara yang mudah dipahami dan diproses oleh AI.

  - icon: ⚙️
    title: Mengenali Git
    details: Secara otomatis menghormati file .gitignore Anda.

  - icon: 🛡️
    title: Fokus pada Keamanan
    details: Mengintegrasikan Secretlint untuk pemeriksaan keamanan yang kuat untuk mendeteksi dan mencegah penyertaan informasi sensitif.

  - icon: 📊
    title: Penghitungan Token
    details: Menyediakan hitungan token untuk setiap file dan seluruh repositori, berguna untuk batas konteks LLM.

---

<script setup>
import YouTubeVideo from '../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../utils/videos'
</script>

<div class="cli-section">

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## 🏆 Nominasi Open Source Awards

Kami merasa terhormat! Repomix telah dinominasikan untuk kategori **Powered by AI** di [JSNation Open Source Awards 2025](https://osawards.com/javascript/).

Ini tidak mungkin terjadi tanpa semua pengguna yang menggunakan dan mendukung Repomix. Terima kasih!

Jika Repomix telah membantu Anda menganalisis atau mengemas basis kode untuk alat AI, kami akan sangat berterima kasih atas suara Anda dalam kategori **Powered by AI**.

## Apa itu Repomix?

Repomix adalah alat yang powerful yang mengemas seluruh codebase Anda ke dalam satu file yang ramah AI. Baik Anda sedang bekerja pada code review, refactoring, atau membutuhkan bantuan AI untuk proyek Anda, Repomix memudahkan berbagi seluruh konteks repository dengan alat AI.

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

## Mulai Cepat

Setelah Anda menghasilkan file yang dikemas (`repomix-output.xml`) menggunakan Repomix, Anda dapat mengirimkannya ke asisten AI (seperti ChatGPT, Claude) dengan prompt seperti:

```
File ini berisi semua file dalam repositori yang digabungkan menjadi satu.
Saya ingin merefaktor kode, jadi tolong tinjau terlebih dahulu.
```

AI akan menganalisis seluruh basis kode Anda dan memberikan wawasan komprehensif:

![Penggunaan File Repomix 1](/images/docs/repomix-file-usage-1.png)

Ketika mendiskusikan perubahan spesifik, AI dapat membantu menghasilkan kode. Dengan fitur seperti Artifacts dari Claude, Anda bahkan dapat menerima beberapa file yang saling bergantung:

![Penggunaan File Repomix 2](/images/docs/repomix-file-usage-2.png)

Selamat mengkode! 🚀


## Menggunakan Alat CLI {#using-the-cli-tool}

Repomix dapat digunakan sebagai alat command-line, menawarkan fitur dan opsi kustomisasi yang kuat.

**Alat CLI dapat mengakses repositori privat** karena menggunakan git yang diinstal secara lokal.

### Mulai Cepat

Anda dapat mencoba Repomix secara instan di direktori proyek Anda tanpa instalasi:

```bash
npx repomix
```

Atau instal secara global untuk penggunaan berulang:

```bash
# Instal dengan npm
npm install -g repomix

# Atau dengan yarn
yarn global add repomix

# Atau dengan bun
bun add -g repomix

# Atau dengan Homebrew (macOS/Linux)
brew install repomix

# Kemudian jalankan di direktori proyek mana pun
repomix
```

Itu saja! Repomix akan menghasilkan file `repomix-output.xml` di direktori Anda saat ini, berisi seluruh repositori Anda dalam format yang ramah AI.



### Penggunaan

Untuk mengemas seluruh repositori Anda:

```bash
repomix
```

Untuk mengemas direktori tertentu:

```bash
repomix path/to/directory
```

Untuk mengemas file atau direktori tertentu menggunakan [pola glob](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):

```bash
repomix --include "src/**/*.ts,**/*.md"
```

Untuk mengecualikan file atau direktori tertentu:

```bash
repomix --ignore "**/*.log,tmp/"
```

Untuk mengemas repositori jarak jauh:
```bash
# Menggunakan format singkat
npx repomix --remote yamadashy/repomix

# Menggunakan URL lengkap (mendukung cabang dan jalur tertentu)
npx repomix --remote https://github.com/yamadashy/repomix
npx repomix --remote https://github.com/yamadashy/repomix/tree/main

# Menggunakan URL commit
npx repomix --remote https://github.com/yamadashy/repomix/commit/836abcd7335137228ad77feb28655d85712680f1
```

Untuk menginisialisasi file konfigurasi baru (`repomix.config.json`):

```bash
repomix --init
```

Setelah Anda menghasilkan file yang dikemas, Anda dapat menggunakannya dengan alat AI Generatif seperti Claude, ChatGPT, dan Gemini.

#### Penggunaan Docker

Anda juga dapat menjalankan Repomix menggunakan Docker 🐳  
Ini berguna jika Anda ingin menjalankan Repomix di lingkungan yang terisolasi atau lebih suka menggunakan kontainer.

Penggunaan dasar (direktori saat ini):

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

Untuk mengemas direktori tertentu:
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

Memproses repositori jarak jauh dan output ke direktori `output`:

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### Format Output

Pilih format output yang Anda inginkan:

```bash
# Format XML (default)
repomix --style xml

# Format Markdown
repomix --style markdown

# Format teks biasa
repomix --style plain
```

### Kustomisasi

Buat `repomix.config.json` untuk pengaturan permanen:

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

## Panduan Pengguna Mahir

Repomix menawarkan fitur-fitur canggih untuk kasus penggunaan lanjutan. Berikut adalah beberapa panduan penting untuk pengguna mahir:

- **[Server MCP](./guide/mcp-server)** - Integrasi Model Context Protocol untuk asisten AI
- **[GitHub Actions](./guide/github-actions)** - Otomatisasi pengemasan codebase dalam alur kerja CI/CD
- **[Kompresi Kode](./guide/code-compress)** - Kompresi cerdas berbasis Tree-sitter (~70% pengurangan token)
- **[Menggunakan sebagai Library](./guide/development/using-repomix-as-a-library)** - Integrasikan Repomix ke dalam aplikasi Node.js Anda
- **[Instruksi Kustom](./guide/custom-instructions)** - Tambahkan prompt dan instruksi kustom ke output
- **[Fitur Keamanan](./guide/security)** - Integrasi Secretlint bawaan dan pemeriksaan keamanan
- **[Best Practices](./guide/tips/best-practices)** - Optimalkan alur kerja AI Anda dengan strategi yang terbukti

### Contoh Lainnya
::: tip Butuh bantuan lebih? 💡
Lihat dokumentasi komprehensif kami di [Panduan](/id/guide/) atau jelajahi [Repositori GitHub](https://github.com/yamadashy/repomix) untuk lebih banyak contoh dan kode sumber.
:::

</div>
</file>

<file path="website/client/src/ja/guide/development/index.md">
# Repomixへの貢献

Repomixにご興味をお持ちいただきありがとうございます！🚀 より良いものにするためのあなたの協力をお待ちしています。このガイドでは、プロジェクトへの貢献を始めるための手順を説明します。

## 貢献の方法

- **リポジトリをスターする**: [リポジトリをスター](https://github.com/yamadashy/repomix)して応援してください！
- **イシューの作成**: バグを見つけた？新機能のアイデアがある？[イシューを作成](https://github.com/yamadashy/repomix/issues)して教えてください。
- **プルリクエストの提出**: 修正や改善点を見つけた？ぜひPRを送ってください！
- **言葉を広める**: SNS、ブログ、または技術コミュニティでRepomixの経験を共有してください。
- **Repomixを使用する**: 実際の使用からのフィードバックが最も貴重です。あなた自身のプロジェクトにRepomixを組み込んでみてください！
- **スポンサーする**: [スポンサーになる](https://github.com/sponsors/yamadashy)ことでRepomixの開発をサポートしてください。

## 開発環境のセットアップ

### 前提条件

- Node.js ≥ 18.0.0
- Git
- npm
- Docker（オプション、ウェブサイトの実行やコンテナ化された開発用）

### ローカル開発

Repomixのローカル開発環境をセットアップするには：

```bash
# リポジトリのクローン
git clone https://github.com/yamadashy/repomix.git
cd repomix

# 依存関係のインストール
npm install

# CLIの実行
npm run repomix
```

### Docker開発

Dockerを使用してRepomixを実行することもできます：

```bash
# イメージのビルド
docker build -t repomix .

# コンテナの実行
docker run -v ./:/app -it --rm repomix
```

### プロジェクト構造

プロジェクトは次のディレクトリに整理されています：

```
src/
├── cli/          # CLI実装
├── config/       # 設定の処理
├── core/         # コア機能
│   ├── file/     # ファイル処理
│   ├── metrics/  # メトリクス計算
│   ├── output/   # 出力生成
│   ├── security/ # セキュリティチェック
├── mcp/          # MCPサーバー統合
└── shared/       # 共有ユーティリティ
tests/            # src/構造を反映したテスト
website/          # ドキュメントウェブサイト
├── client/       # フロントエンド（VitePress）
└── server/       # バックエンドAPI
```

## 開発コマンド

```bash
# CLIを実行
npm run repomix

# テストを実行
npm run test
npm run test-coverage

# コードのリント
npm run lint
```

### テスト

テストには[Vitest](https://vitest.dev/)を使用しています。テストを実行するには：

```bash
# テストの実行
npm run test

# テストカバレッジ
npm run test-coverage

# リント
npm run lint-biome
npm run lint-ts
npm run lint-secretlint
```

## コーディングスタイル

- [Biome](https://biomejs.dev/)を使用してリントとフォーマットを行う
- テスト可能性のために依存性注入を使用
- ファイルは250行以下に保つ
- 新機能には必ずテストを追加

リントとフォーマットには[Biome](https://biomejs.dev/)を使用しています。コードがスタイルガイドに従っていることを確認するために以下を実行してください：

```bash
npm run lint
```

## プルリクエストのガイドライン

プルリクエストを提出する前に、以下を確認してください：

1. コードが全てのテストをパスすること: `npm run test`を実行
2. コードがリント基準に適合していること: `npm run lint`を実行
3. 関連するドキュメントを更新していること
4. 既存のコードスタイルに従っていること

## ウェブサイト開発

Repomixのウェブサイトは[VitePress](https://vitepress.dev/)で構築されています。ローカルでウェブサイトを実行するには：

```bash
# 前提条件: システムにDockerがインストールされていること

# ウェブサイト開発サーバーの起動
npm run website

# ウェブサイトには http://localhost:5173/ でアクセス
```

ドキュメントを更新する場合は、最初に英語版のみを更新する必要があります。他の言語への翻訳はメンテナーが対応します。

## リリースプロセス

メンテナーと貢献者向けのリリースプロセス：

1. バージョンの更新
```bash
npm version patch  # または minor/major
```

2. テストとビルドの実行
```bash
npm run test-coverage
npm run build
```

3. 公開
```bash
npm publish
```

新しいバージョンはメンテナーによって管理されます。リリースが必要だと思われる場合は、イシューを作成して議論してください。

## サポートが必要な場合

- [イシューを作成](https://github.com/yamadashy/repomix/issues)
- [Discordに参加](https://discord.gg/wNYzTwZFku)
</file>

<file path="website/client/src/ja/guide/development/using-repomix-as-a-library.md">
# ライブラリとしての使用

RepomixはCLIツールとしてだけでなく、Node.jsアプリケーションに直接組み込んで機能を利用することもできます。

## インストール

プロジェクトの依存関係としてRepomixをインストールします：

```bash
npm install repomix
```

## 基本的な使い方

Repomixを使用する最も簡単な方法は、コマンドラインインターフェースと同様の機能を提供する`runCli`関数を使用することです：

```javascript
import { runCli, type CliOptions } from 'repomix';

// カスタムオプションで現在のディレクトリを処理
async function packProject() {
  const options = {
    output: 'output.xml',
    style: 'xml',
    compress: true,
    quiet: true
  } as CliOptions;
  
  const result = await runCli(['.'], process.cwd(), options);
  return result.packResult;
}
```

`result.packResult`には、処理されたファイルに関する以下の情報が含まれています：
- `totalFiles`: 処理されたファイル数
- `totalCharacters`: 総文字数
- `totalTokens`: 総トークン数（LLMのコンテキスト制限に役立ちます）
- `fileCharCounts`: ファイルごとの文字数
- `fileTokenCounts`: ファイルごとのトークン数

## リモートリポジトリの処理

リモートリポジトリをクローンして処理することもできます：

```javascript
import { runCli, type CliOptions } from 'repomix';

// GitHubリポジトリをクローンして処理する
async function processRemoteRepo(repoUrl) {
  const options = {
    remote: repoUrl,
    output: 'output.xml',
    compress: true
  } as CliOptions;
  
  return await runCli(['.'], process.cwd(), options);
}
```

## コアコンポーネントの使用

より詳細な制御が必要な場合は、Repomixの低レベルAPIを直接使用できます：

```javascript
import { searchFiles, collectFiles, processFiles, TokenCounter } from 'repomix';

async function analyzeFiles(directory) {
  // ファイルを検索して収集
  const { filePaths } = await searchFiles(directory, { /* 設定 */ });
  const rawFiles = await collectFiles(filePaths, directory);
  const processedFiles = await processFiles(rawFiles, { /* 設定 */ });
  
  // トークンをカウント
  const tokenCounter = new TokenCounter('o200k_base');
  
  // 分析結果を返す
  return processedFiles.map(file => ({
    path: file.path,
    tokens: tokenCounter.countTokens(file.content)
  }));
}
```

## 実世界の例

Repomixウェブサイト（[repomix.com](https://repomix.com)）では、ライブラリとしてRepomixを使用してリモートリポジトリを処理しています。実装は[website/server/src/remoteRepo.ts](https://github.com/yamadashy/repomix/blob/main/website/server/src/remoteRepo.ts)で確認できます。
</file>

<file path="website/client/src/ja/guide/tips/best-practices.md">
# AI支援開発のベストプラクティス：私の経験から

私はまだAIを使用した大規模な開発を経験したわけではありませんが、これまでの経験から学んだことを共有したいと思います。

## 開発の基本アプローチ

AIと共に開発を進める際、一度にすべての機能を実装しようとすると、予期せぬ問題が発生し、プロジェクト全体が行き詰まってしまうことがあります。そのため、コア機能から始めて一つ一つの機能を確実に作り上げていく方法が効果的です。

### 既存コードの重要性

この方法が効果的な理由は、コア機能の実装を通じて、あなたの理想とする設計やコーディングスタイルをコードとして具体化できる点にあります。
プロジェクトのビジョンを最も効果的に伝えるのは、あなたの基準や好みを反映したコードそのものなのです。

コア機能から始めつつ、一つ一つの機能を確実に動く状態にしてから次の機能に進むことで、プロジェクト全体が一貫性を持ち、AIがより適切なコードを生成しやすくなります。

## モジュール分割のアプローチ

また、コードは小さなモジュールに分割することが重要です。私の経験では、行数を250行程度に抑えることで結果的にAIに明確な指示を与えやすくなり、試行錯誤のプロセスも効率的になります。実際にはトークン数のほうが指標として正しいのですが、人間に判断しやすいのは行数なので、ここでは行数としています。

これはフロントエンド、バックエンド、データベースなどの大きな単位の話ではなく、もっと小さな単位、例えば一つの機能の中でもバリデーションやエラーハンドリングなど、個別の機能をモジュールとして分割することが重要です。

もちろん大きな単位で分けるのも重要で、段階的にモジュールを分割しておくことで、指示も明確になり、AIがより適切なコードを生成しやすくなります。AIに限らず人間にも効果的なアプローチですね。


## テストを通じた品質の確保
私はテストも重要だと考えています。
テストは単なる品質保証の手段としてだけでなく、コードの意図を明確に示すドキュメントとしても機能します。AIに新しい機能の実装を依頼する際、既存のテストコードは実装すべき機能の仕様書として働きます。

また、AIが生成したコードの正しさを判断する際、テストは非常に効果的なツールとなります。例えば、あるモジュールの新しい機能をAIに実装してもらう場合、テストケースを先に書いておくことで、生成されたコードが期待通りの動作をするかを客観的に評価できます。これはテスト駆動開発（TDD）の考え方とも親和性が高く、AIとの協業において特に有効です。


## 計画と実装のバランス

大規模な機能を実装する前には、まずAIと計画について話し合うことをお勧めします。要件を整理し、アーキテクチャを検討することで、後の実装がスムーズになります。要件をまずまとめて、別のチャットに移動して実装を進めるのも良いでしょう。
また、AIの出力は必ず人間がレビューし、必要に応じて調整を加えることが重要です。AIの出力の品質は一般的に中程度ですが、それでも一からコードを書くよりも開発速度は向上します。



## まとめ

この方法を実践することで、AIの強みを活かしながら、一貫性のある高品質なコードベースを構築できます。プロジェクトの規模が大きくなっても、各部分が明確に定義され、管理しやすい状態を維持できるでしょう。
</file>

<file path="website/client/src/ja/guide/code-compress.md">
# コード圧縮
コード圧縮は、実装の詳細を省きながら、コードの本質的な構造を抽出する強力な機能です。トークン数を削減しながらコードベースの重要な構造情報を維持したい場合に特に有用です。

> [!NOTE]
> これは実験的な機能であり、ユーザーのフィードバックや実際の使用状況に基づいて積極的に改善を行っています。

## 基本的な使い方

`--compress`フラグを使用してコード圧縮を有効にします：

```bash
repomix --compress
```

リモートリポジトリでも使用できます：

```bash
repomix --remote user/repo --compress
```

## 仕組み

圧縮アルゴリズムは、tree-sitterパーシングを使用してコードを処理し、本質的な構造要素を抽出・保持しながら、実装の詳細を除外します。

圧縮で保持される要素：
- 関数やメソッドのシグネチャ
- インターフェースと型定義
- クラス構造とプロパティ
- 重要な構造的要素

以下の要素は除外されます：
- 関数やメソッドの実装内容
- ループや条件分岐のロジック詳細
- 内部変数の宣言
- 実装固有のコード

### 例

元のTypeScriptコード：

```typescript
import { ShoppingItem } from './shopping-item';

/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
  let total = 0;
  for (const item of items) {
    total += item.price * item.quantity;
  }
  return total;
}

// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

圧縮後：

```typescript
import { ShoppingItem } from './shopping-item';
⋮----
/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
⋮----
// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

## 設定

設定ファイルで圧縮を有効にすることもできます：

```json
{
  "output": {
    "compress": true
  }
}
```

## ユースケース

コード圧縮は以下のような場合に特に有用です：
- コードの構造やアーキテクチャの分析
- LLM処理のためのトークン数削減
- 高レベルなドキュメントの作成
- コードパターンやシグネチャの理解
- APIやインターフェース設計の共有

## 関連オプション

圧縮は以下のオプションと組み合わせることができます：
- `--remove-comments`: コードコメントを削除
- `--remove-empty-lines`: 空行を削除
- `--output-show-line-numbers`: 出力に行番号を追加
</file>

<file path="website/client/src/ja/guide/command-line-options.md">
# コマンドラインオプション

## 基本オプション
- `-v, --version`: バージョンを表示

## 出力オプション
- `-o, --output <file>`: 出力ファイル名（デフォルト: `repomix-output.txt`）
- `--stdout`: ファイルに書き込む代わりに標準出力に出力（`--output`オプションと併用不可）
- `--style <type>`: 出力形式（`plain`、`xml`、`markdown`）（デフォルト: `xml`）
- `--parsable-style`: 選択した形式のスキーマに基づいて解析可能な出力を有効化（デフォルト: `false`）
- `--compress`: 関数やクラスのシグネチャなどの重要な構造を保持しながら、実装の詳細を削除するインテリジェントなコード抽出を実行します。詳細と例については、[コード圧縮ガイド](code-compress)を参照してください。
- `--output-show-line-numbers`: 行番号を追加（デフォルト: `false`）
- `--copy`: クリップボードにコピー（デフォルト: `false`）
- `--no-file-summary`: ファイルサマリーを無効化（デフォルト: `true`）
- `--no-directory-structure`: ディレクトリ構造を無効化（デフォルト: `true`）
- `--no-files`: ファイル内容の出力を無効化（メタデータのみモード）（デフォルト: `true`）
- `--remove-comments`: コメントを削除（デフォルト: `false`）
- `--remove-empty-lines`: 空行を削除（デフォルト: `false`）
- `--header-text <text>`: ファイルヘッダーに含めるカスタムテキスト
- `--instruction-file-path <path>`: 詳細なカスタム指示を含むファイルのパス
- `--include-empty-directories`: 空のディレクトリを出力に含める（デフォルト: `false`）
- `--include-diffs`: Gitの差分を出力に含める（ワークツリーとステージングされた変更が別々に含まれます）（デフォルト: `false`）
- `--no-git-sort-by-changes`: Gitの変更回数によるファイルのソートを無効化（デフォルト: `true`）

## フィルターオプション
- `--include <patterns>`: 含めるパターン（カンマ区切り）
- `-i, --ignore <patterns>`: 除外パターン（カンマ区切り）
- `--stdin`: ファイルを自動的に検出する代わりに、stdinからファイルパスを読み取る
- `--no-gitignore`: .gitignoreファイルの使用を無効化
- `--no-default-patterns`: デフォルトパターンを無効化

## リモートリポジトリオプション
- `--remote <url>`: リモートリポジトリを処理
- `--remote-branch <name>`: リモートブランチ名、タグ、またはコミットハッシュを指定（デフォルトはリポジトリのデフォルトブランチ）

## 設定オプション
- `-c, --config <path>`: カスタム設定ファイルのパス
- `--init`: 設定ファイルを作成
- `--global`: グローバル設定を使用

## セキュリティオプション
- `--no-security-check`: セキュリティチェックを無効化（デフォルト: `true`）

## トークンカウントオプション
- `--token-count-encoding <encoding>`: トークンカウントのエンコーディングを指定（例: `o200k_base`、`cl100k_base`）（デフォルト: `o200k_base`）

## その他のオプション
- `--top-files-len <number>`: 表示するトップファイルの数（デフォルト: `5`）
- `--verbose`: 詳細なログを有効化
- `--quiet`: 標準出力へのすべての出力を無効化

## 使用例

```bash
# 基本的な使用方法
repomix

# カスタム出力
repomix -o output.xml --style xml

# 標準出力への出力
repomix --stdout > custom-output.txt

# 標準出力への出力後、他のコマンドへパイプ（例：simonw/llm）
repomix --stdout | llm "このコードについて説明してください"

# 圧縮を使用したカスタム出力
repomix --compress

# 特定のファイルを処理
repomix --include "src/**/*.ts" --ignore "**/*.test.ts"

# ブランチを指定したリモートリポジトリ
repomix --remote https://github.com/user/repo/tree/main

# コミットを指定したリモートリポジトリ
repomix --remote https://github.com/user/repo/commit/836abcd7335137228ad77feb28655d85712680f1

# ショートハンドを使用したリモートリポジトリ
repomix --remote user/repo

# stdinを使用したファイルリスト
find src -name "*.ts" -type f | repomix --stdin
git ls-files "*.js" | repomix --stdin
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```
</file>

<file path="website/client/src/ja/guide/comment-removal.md">
# ソースコード中のコメント削除

Repomixは、パッケージング時に、ソースコード中のコメントを自動的に削除する機能を提供します。これにより、出力ファイルからノイズを減らし、実際のコードに焦点を当てることができます。

## 使用方法

コメントの削除を有効にするには、`repomix.config.json`で`removeComments`オプションを`true`に設定します。

```json
{
  "output": {
    "removeComments": true
  }
}
```

## サポートされている言語

Repomixは以下を含む多くのプログラミング言語のコメント削除をサポートしています。

- JavaScript/TypeScript (`//`, `/* */`)
- Python (`#`, `"""`, `'''`)
- Java (`//`, `/* */`)
- C/C++ (`//`, `/* */`)
- HTML (`<!-- -->`)
- CSS (`/* */`)
- その他多数の言語

## 使用例と出力例

以下のようなJavaScriptコードがある場合

```javascript
// これは単一行コメントです
function test() {
  /* これは
     複数行コメントです */
  return true;
}
```

コメント削除を有効にすると、出力は以下のようになります。

```javascript
function test() {
  return true;
}
```

## 制限事項

- コメントの削除は、行番号の追加など、他の処理よりも先に行われます。
- JSDocコメントなど、一部のコメントは削除されない場合があります。
</file>

<file path="website/client/src/ja/guide/configuration.md">
# 設定

Repomixは設定ファイル（`repomix.config.json`）またはコマンドラインオプションを使用して設定できます。設定ファイルを使用することで、コードベースの処理と出力方法をカスタマイズできます。

## クイックスタート

プロジェクトディレクトリに設定ファイルを作成します：
```bash
repomix --init
```

これにより、デフォルト設定の`repomix.config.json`ファイルが作成されます。また、ローカル設定が見つからない場合のフォールバックとして使用されるグローバル設定ファイルを作成することもできます：

```bash
repomix --init --global
```

## 設定オプション

| オプション                        | 説明                                                                                                                         | デフォルト値           |
|----------------------------------|------------------------------------------------------------------------------------------------------------------------------|------------------------|
| `input.maxFileSize`              | 処理する最大ファイルサイズ（バイト）。これより大きいファイルはスキップされます。大きなバイナリファイルやデータファイルを除外するのに便利です | `50000000`            |
| `output.filePath`                | 出力ファイル名。XML、Markdown、プレーンテキスト形式をサポートしています                                                      | `"repomix-output.xml"` |
| `output.style`                   | 出力形式（`xml`、`markdown`、`plain`）。各形式はAIツールに応じて異なる利点があります                                        | `"xml"`                |
| `output.parsableStyle`           | 選択したスタイルスキーマに基づいて出力をエスケープするかどうか。より良い解析が可能になりますが、トークン数が増加する可能性があります | `false`                |
| `output.compress`                | Tree-sitterを使用してインテリジェントなコード抽出を実行し、構造を保持しながらトークン数を削減するかどうか                  | `false`                |
| `output.headerText`              | ファイルヘッダーに含めるカスタムテキスト。AIツールにコンテキストや指示を提供するのに便利です                              | `null`                 |
| `output.instructionFilePath`     | AI処理用の詳細なカスタム指示を含むファイルへのパス                                                                          | `null`                 |
| `output.fileSummary`             | ファイル数、サイズ、その他のメトリクスを示す要約セクションを出力の先頭に含めるかどうか                                    | `true`                 |
| `output.directoryStructure`      | 出力にディレクトリ構造を含めるかどうか。AIがプロジェクトの構成を理解するのに役立ちます                                    | `true`                 |
| `output.files`                   | 出力にファイル内容を含めるかどうか。falseに設定すると、構造とメタデータのみが含まれます                                   | `true`                 |
| `output.removeComments`          | サポートされているファイルタイプからコメントを削除するかどうか。ノイズとトークン数を削減できます                          | `false`                |
| `output.removeEmptyLines`        | 出力から空行を削除してトークン数を削減するかどうか                                                                          | `false`                |
| `output.showLineNumbers`         | 各行に行番号を追加するかどうか。コードの特定の部分を参照するのに役立ちます                                                 | `false`                |
| `output.copyToClipboard`         | ファイルの保存に加えて、出力をシステムクリップボードにコピーするかどうか                                                   | `false`                |
| `output.topFilesLength`          | 要約に表示するトップファイルの数。0に設定すると、要約は表示されません                                                       | `5`                    |
| `output.includeEmptyDirectories` | リポジトリ構造に空のディレクトリを含めるかどうか                                                                           | `false`                |
| `output.git.sortByChanges`       | Gitの変更回数でファイルをソートするかどうか。変更が多いファイルが下部に表示されます                                       | `true`                 |
| `output.git.sortByChangesMaxCommits` | Gitの変更を分析する最大コミット数。パフォーマンスのために履歴の深さを制限します                                       | `100`                  |
| `output.git.includeDiffs`        | 出力にGitの差分を含めるかどうか。作業ツリーとステージング済みの変更を別々に表示します                                     | `false`                |
| `include`                        | 含めるファイルのパターン（[globパターン](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)を使用）    | `[]`                   |
| `ignore.useGitignore`            | プロジェクトの`.gitignore`ファイルのパターンを使用するかどうか                                                             | `true`                 |
| `ignore.useDefaultPatterns`      | デフォルトの除外パターン（node_modules、.gitなど）を使用するかどうか                                                       | `true`                 |
| `ignore.customPatterns`          | 追加の除外パターン（[globパターン](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)を使用）          | `[]`                   |
| `security.enableSecurityCheck`   | Secretlintを使用して機密情報を検出するセキュリティチェックを実行するかどうか                                               | `true`                 |
| `tokenCount.encoding`            | OpenAIの[tiktoken](https://github.com/openai/tiktoken)トークナイザーで使用するトークンカウントエンコーディング。GPT-4oの場合は`o200k_base`、GPT-4/3.5の場合は`cl100k_base`を使用。詳細は[tiktoken model.py](https://github.com/openai/tiktoken/blob/main/tiktoken/model.py#L24)を参照 | `"o200k_base"`         |

設定ファイルは[JSON5](https://json5.org/)構文をサポートしており、以下が可能です：
- コメント（単一行および複数行）
- オブジェクトと配列の末尾のカンマ
- 引用符なしのプロパティ名
- より柔軟な文字列構文

## スキーマ検証

設定ファイルに`$schema`プロパティを追加することで、スキーマ検証を有効にできます：

```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "output": {
    "filePath": "repomix-output.md",
    "style": "markdown"
  }
}
```

これにより、JSONスキーマをサポートするエディタでの自動補完と検証が可能になります。

## 設定ファイルの例

以下は完全な設定ファイル（`repomix.config.json`）の例です：

```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 50000000
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "compress": false,
    "headerText": "パッケージ化されたファイルのカスタムヘッダー情報",
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "includeEmptyDirectories": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false
    }
  },
  "include": ["**/*"],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    // パターンは .repomixignore でも指定できます
    "customPatterns": [
      "additional-folder",
      "**/*.log"
    ],
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
```

## 設定ファイルの場所

Repomixは以下の順序で設定ファイルを探します：
1. カレントディレクトリのローカル設定ファイル（`repomix.config.json`）
2. グローバル設定ファイル：
   - Windows: `%LOCALAPPDATA%\Repomix\repomix.config.json`
   - macOS/Linux: `~/.config/repomix/repomix.config.json`

コマンドラインオプションは設定ファイルの設定よりも優先されます。

## 除外パターン

Repomixは複数の方法でファイルの除外を指定できます。パターンは以下の優先順位で処理されます：

1. CLIオプション（`--ignore`）
2. プロジェクトディレクトリの`.repomixignore`ファイル
3. `.gitignore`および`.git/info/exclude`（`ignore.useGitignore`がtrueの場合）
4. デフォルトパターン（`ignore.useDefaultPatterns`がtrueの場合）

`.repomixignore`の例：
```text
# キャッシュディレクトリ
.cache/
tmp/

# ビルド出力
dist/
build/

# ログ
*.log
```

## デフォルトの除外パターン

`ignore.useDefaultPatterns`がtrueの場合、Repomixは以下のような一般的なパターンを自動的に除外します：
```text
node_modules/**
.git/**
coverage/**
dist/**
```

完全なリストは[defaultIgnore.ts](https://github.com/yamadashy/repomix/blob/main/src/config/defaultIgnore.ts)を参照してください。

## 高度な機能

### コード圧縮

`output.compress: true`で有効になるコード圧縮機能は、[Tree-sitter](https://github.com/tree-sitter/tree-sitter)を使用して、実装の詳細を削除しながら本質的なコード構造を抽出します。これにより、重要な構造情報を維持しながらトークン数を削減できます。

主な利点：
- トークン数を大幅に削減
- クラスと関数のシグネチャを保持
- インポートとエクスポートを維持
- 型定義とインターフェースを保持
- 関数本体と実装の詳細を削除

詳細と例については[コード圧縮ガイド](code-compress)をご覧ください。

### Git統合

`output.git`設定では、以下のようなGit対応機能を提供します：

- `sortByChanges`: trueに設定すると、ファイルはGitの変更回数（そのファイルを変更したコミット数）でソートされます。変更が多いファイルが出力の下部に表示されます。これは、より活発に開発されているファイルを優先するのに役立ちます。デフォルト: `true`
- `sortByChangesMaxCommits`: ファイルの変更回数を数える際に分析する最大コミット数。デフォルト: `100`
- `includeDiffs`: trueに設定すると、Git差分を出力に含めます（ワークツリーとステージング済みの変更を別々に含みます）。これにより、リポジトリの保留中の変更を確認できます。デフォルト: `false`

設定例：
```json
{
  "output": {
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": true
    }
  }
}
```

### セキュリティチェック

`security.enableSecurityCheck`が有効な場合、Repomixは[Secretlint](https://github.com/secretlint/secretlint)を使用して、出力に含める前にコードベース内の機密情報を検出します。これにより、以下のような情報の誤った露出を防ぐことができます：

- APIキー
- アクセストークン
- 秘密鍵
- パスワード
- その他の機密情報

### コメントの削除

`output.removeComments`を`true`に設定すると、サポートされているファイルタイプからコメントが削除され、出力サイズを削減し、本質的なコード内容に焦点を当てることができます。これは以下のような場合に特に便利です：

- 大量にドキュメント化されたコードを扱う場合
- トークン数を削減したい場合
- コードの構造とロジックに集中したい場合

サポートされている言語と詳細な例については[コメント削除ガイド](comment-removal)をご覧ください。
</file>

<file path="website/client/src/ja/guide/custom-instructions.md">
# カスタム指示

Repomixでは、出力ファイルに含めるカスタム指示（独自の指示）を提供することができます。これは、AIシステムにプロジェクトの特定のコンテキストや要件を理解させるのに役立ちます。

## 使用方法

カスタム指示を含めるには、リポジトリのルートにマークダウンファイル（例：`repomix-instruction.md`）を作成し、`repomix.config.json`でそのパスを指定します。

```json
{
  "output": {
    "instructionFilePath": "repomix-instruction.md"
  }
}
```

このファイルの内容は出力の「Instruction」セクションに含まれます。

## 使用例

```markdown
# コーディングガイドライン

- Airbnb JavaScript スタイルガイドに従う
- 適切な場合は、ファイルを小さな単位に分割する
- 自明でないロジックにはコメントを追加。すべてのテキストは英語で記述
- すべての新機能には対応するユニットテストを作成する

# 生成内容について

- 特に指定がない限り、すべての内容を省略せずに含める
- 大規模なコードベースを処理しながら、出力の品質を維持する
```

これは出力ファイルで以下のように表示されます。

```xml
<instruction>
# コーディングガイドライン

- Airbnb JavaScript スタイルガイドに従う
- 適切な場合は、ファイルを小さな単位に分割する
- 自明でないロジックにはコメントを追加。すべてのテキストは英語で記述
- すべての新機能には対応するユニットテストを作成する

# 生成内容について

- 特に指定がない限り、すべての内容を省略せずに含める
- 大規模なコードベースを処理しながら、出力の品質を維持する
</instruction>
```

## 注意点

- カスタム指示は出力ファイルの`Instruction`セクションに含まれます。
- カスタム指示は適切な長さに保つことを推奨します。過度に長い指示は逆効果になる場合があります。
- プロジェクト固有のガイドラインや要件に焦点を当てることで、AIがプロジェクトのコンテキストを理解しやすくなり、より効果的な結果が得られます。
</file>

<file path="website/client/src/ja/guide/github-actions.md">
# GitHub ActionsでRepomixを使う

GitHub ActionsワークフローにRepomixを組み込むことで、AI解析用のコードベースパッキングを自動化できます。CIやコードレビュー、LLMツール向けの準備に便利です。

## 基本的な使い方

リポジトリをパックするには、ワークフローYAMLに以下のステップを追加します。

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.xml
```

## 異なる出力形式の使用

`style`パラメータを使用して異なる出力形式を指定できます（デフォルトは`xml`です）：

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.md
    style: markdown
```

## 複数ディレクトリ・圧縮オプション

複数ディレクトリやinclude/excludeパターン、スマート圧縮も指定できます。

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src tests
    include: "**/*.ts,**/*.md"
    ignore: "**/*.test.ts"
    output: repomix-output.xml
    compress: true
```

## 出力ファイルをアーティファクトとしてアップロード

生成したファイルを後続ステップやダウンロード用にアップロードする例です。

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src
    output: repomix-output.xml
    compress: true

- name: Upload Repomix output
  uses: actions/upload-artifact@v4
  with:
    name: repomix-output
    path: repomix-output.xml
```

## Actionの入力パラメータ

| 名前                | 説明                                   | デフォルト         |
|---------------------|----------------------------------------|--------------------|
| `directories`       | パック対象ディレクトリ（空白区切り）    | `.`                |
| `include`           | 含めるファイルのglobパターン（カンマ区切り） | `""`           |
| `ignore`            | 除外するファイルのglobパターン（カンマ区切り） | `""`           |
| `output`            | 出力ファイルパス                        | `repomix-output.xml`      |
| `compress`          | スマート圧縮の有効化                    | `true`             |
| `style`             | 出力スタイル（xml, markdown, plain）      | `xml`             |
| `additional-args`   | repomix CLIへの追加引数                 | `""`           |
| `repomix-version`   | インストールするnpmパッケージのバージョン | `latest`           |

## Actionの出力

| 名前           | 説明                       |
|----------------|----------------------------|
| `output_file`  | 生成された出力ファイルのパス |

## ワークフロー全体例

Repomixを使ったGitHub Actionsワークフローの例です。

```yaml
name: Pack repository with Repomix

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  pack-repo:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Pack repository with Repomix
        uses: yamadashy/repomix/.github/actions/repomix@main
        with:
          output: repomix-output.xml

      - name: Upload Repomix output
        uses: actions/upload-artifact@v4
        with:
          name: repomix-output.xml
          path: repomix-output.xml
          retention-days: 30
```

[完全なワークフロー例](https://github.com/yamadashy/repomix/blob/main/.github/workflows/pack-repository.yml)をご参照ください。
</file>

<file path="website/client/src/ja/guide/index.md">
# Repomixとは

<script setup>
import HomeBadges from '../../../components/HomeBadges.vue'
import YouTubeVideo from '../../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../../utils/videos'
</script>

Repomixは、リポジトリ全体をAIフレンドリーな単一ファイルにパッケージングするツールです。ChatGPT、DeepSeek、Perplexity、Gemini、Gemma、Llama、Grokなどの大規模言語モデル（LLM）にコードベースを提供するために設計されています。

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

<HomeBadges />

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## クイックスタート

プロジェクトディレクトリで以下のコマンドを実行するだけです。

```bash
npx repomix
```

これだけで、`repomix-output.xml`ファイルにAIが理解しやすい形式でリポジトリ全体がまとめられます。

このファイルを以下のようなプロンプトとともにAIアシスタントに送信できます。

```
このファイルはリポジトリ内のすべてのファイルを1つにまとめたものです。
コードのリファクタリングを行いたいので、まずはコードレビューをお願いします。
```

すると、AIはコードベース全体を分析し、包括的な洞察を提供してくれます。

![Repomixの使用例1](/images/docs/repomix-file-usage-1.png)

具体的な変更点を議論する際には、AIはコードの生成をサポートしてくれます。例えば、Claudeのアーティファクト機能などを使用すると、相互に依存する複数のファイルを一度に生成することも可能です。

![Repomixの使用例2](/images/docs/repomix-file-usage-2.png)

良いコーディング体験を！🚀

## 主な機能

- **AI最適化**: コードベースをAIが理解しやすい形式にフォーマット化
- **トークンカウント**: LLMのコンテキスト制限に対応するためのトークン数を計測
- **Git対応**: `.gitignore`および`.git/info/exclude`ファイルを自動的に認識してパッケージング対象から除外
- **セキュリティ重視**: [Secretlint](https://github.com/secretlint/secretlint)を使用した機密情報の検出と保護
- **複数の出力形式**: プレーンテキスト、XML、Markdownの出力形式を選択可能

## 次のステップ

- [インストールガイド](installation.md): Repomixをインストールするにはこちら
- [使用方法](usage.md): 基本的な使い方から高度な使い方まで
- [設定](configuration.md): Repomixをカスタマイズするにはこちら
- [セキュリティ機能](security.md): セキュリティチェックの詳細はこちら

## コミュニティ

[Discordコミュニティ](https://discord.gg/wNYzTwZFku)に参加して、Repomixの使い方について質問したり、経験やノウハウを共有したり、新機能を提案したり、他のユーザーと交流しましょう。

## サポート

バグを見つけた場合や支援が必要な場合は、[GitHubでイシューを作成](https://github.com/yamadashy/repomix/issues)するか、Discordサーバーに参加してください。
</file>

<file path="website/client/src/ja/guide/installation.md">
# インストール

## npx を使用する方法 (インストール不要)

```bash
npx repomix
```

## グローバルインストール

### npm
```bash
npm install -g repomix
```

### Yarn
```bash
yarn global add repomix
```

### Bun
```bash
bun add -g repomix
```

### Homebrew（macOS/Linux）
```bash
brew install repomix
```

## Dockerを使用する方法

以下のコマンドで Docker イメージをプルして実行できます。

```bash
# カレントディレクトリを処理
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix

# 特定のディレクトリを処理
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory

# リモートリポジトリを処理
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote yamadashy/repomix
```

## VSCode 拡張機能

VSCodeでRepomixを直接実行できるコミュニティメンテナンスの[Repomix Runner](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner)拡張機能があります。

機能:
- クリック数回でフォルダをパック
- ファイルまたはコンテンツモードでのコピーが可能
- 出力ファイルの自動クリーンアップ
- repomix.config.jsonと連携

[VSCode マーケットプレイス](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner)からインストールできます。

## ブラウザ拡張機能

GitHubリポジトリから直接Repomixにアクセスできます！Chrome拡張機能がGitHubリポジトリページに便利な「Repomix」ボタンを追加します。

![Repomix Browser Extension](/images/docs/browser-extension.png)

### インストール
- Chrome拡張: [Repomix - Chrome Web Store](https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa)
- Firefox アドオン: [Repomix - Firefox Add-ons](https://addons.mozilla.org/firefox/addon/repomix/)

### 機能
- GitHubリポジトリからワンクリックでRepomixにアクセス
- さらなる機能を開発中です！

## システム要件

- Node.js: 18.0.0 以上
- Git: リモートリポジトリを処理する場合はインストールしてください

## インストールの確認

インストール後、以下のコマンドで Repomix が正常に動作することを確認できます。

```bash
repomix --version
repomix --help
```
</file>

<file path="website/client/src/ja/guide/mcp-server.md">
# MCPサーバー

Repomixは[Model Context Protocol (MCP)](https://modelcontextprotocol.io)をサポートしており、AIアシスタントがコードベースと直接対話できるようになります。MCPサーバーとして実行すると、Repomixはローカルまたはリモートリポジトリを手動でファイル準備することなく、AI分析用にパッケージ化するツールを提供します。

> [!NOTE]  
> これは実験的な機能であり、ユーザーのフィードバックと実際の使用状況に基づいて積極的に改善を進めていきます

## RepomixをMCPサーバーとして実行する

RepomixをMCPサーバーとして実行するには、`--mcp`フラグを使用します：

```bash
repomix --mcp
```

これによりRepomixがMCPサーバーモードで起動し、Model Context ProtocolをサポートするAIアシスタントから利用できるようになります。

## MCPサーバーの設定

RepomixをMCPサーバーとしてClaudeなどのAIアシスタントで使用するには、MCP設定を構成する必要があります：

### VS Code向け

VS CodeにRepomix MCPサーバーをインストールするには、以下のいずれかの方法を使用します：

1. **インストールバッジを使用：**

  [![Install in VS Code](https://img.shields.io/badge/VS_Code-VS_Code?style=flat-square&label=Install%20Server&color=0098FF)](vscode:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)<br>
  [![Install in VS Code Insiders](https://img.shields.io/badge/VS_Code_Insiders-VS_Code_Insiders?style=flat-square&label=Install%20Server&color=24bfa5)](vscode-insiders:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)

2. **コマンドラインを使用：**

  ```bash
  code --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

  VS Code Insiders の場合：
  ```bash
  code-insiders --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

### Cline（VS Code拡張機能）の場合

`cline_mcp_settings.json`ファイルを編集します：

```json
{
  "mcpServers": {
    "repomix": {
      "command": "npx",
      "args": [
        "-y",
        "repomix",
        "--mcp"
      ]
    }
  }
}
```

### Cursorの場合

Cursorでは、`Cursor Settings` > `MCP` > `+ Add new global MCP server`からClineと同様の設定を追加します。

### Claude Desktopの場合

`claude_desktop_config.json`ファイルをClineの設定と同様に編集します。

### Claude Codeの場合

[Claude Code](https://docs.anthropic.com/en/docs/claude-code/overview)でRepomixをMCPサーバーとして設定するには、以下のコマンドを使用します：

```bash
claude mcp add repomix -- npx -y repomix --mcp
```

### npxの代わりにDockerを使用

Dockerを使用してRepomixをMCPサーバーとして実行できます：

```json
{
  "mcpServers": {
    "repomix-docker": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "ghcr.io/yamadashy/repomix",
        "--mcp"
      ]
    }
  }
}
```

## 利用可能なMCPツール

MCPサーバーとして実行すると、Repomixは以下のツールを提供します：

### pack_codebase

このツールはローカルのコードディレクトリをAI分析用のXMLファイルにパッケージ化します。コードベース構造を分析し、関連するコード内容を抽出し、メトリクス、ファイルツリー、フォーマットされたコード内容を含む包括的なレポートを生成します。

**パラメータ：**
- `directory`: (必須) パッケージ化するディレクトリの絶対パス
- `compress`: (オプション、デフォルト: false) 実装の詳細を削除しながら、重要なコードシグネチャと構造を抽出するTree-sitter圧縮を有効にします。セマンティックな意味を保持しながらトークン使用量を約70%削減します。grep_repomix_outputが段階的なコンテンツ取得を可能にするため、通常は不要です。大きなリポジトリのコードベース全体の内容が特に必要な場合のみ使用してください。
- `includePatterns`: (オプション) fast-globパターンを使用して含めるファイルを指定します。複数のパターンはカンマ区切りで指定できます（例："**/*.{js,ts}", "src/**,docs/**"）。マッチするファイルのみが処理されます。
- `ignorePatterns`: (オプション) fast-globパターンを使用して除外する追加ファイルを指定します。複数のパターンはカンマ区切りで指定できます（例："test/**,*.spec.js", "node_modules/**,dist/**"）。これらのパターンは.gitignoreと組み込み除外を補完します。
- `topFilesLength`: (オプション、デフォルト: 10) コードベース分析のメトリクス要約に表示する最大ファイル数（サイズ順）。

**例：**
```json
{
  "directory": "/path/to/your/project",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### pack_remote_repository

このツールはGitHubリポジトリを取得、クローン、パッケージ化してAI分析用のXMLファイルを作成します。リモートリポジトリを自動的にクローンし、その構造を分析し、包括的なレポートを生成します。

**パラメータ：**
- `remote`: (必須) GitHubリポジトリURLまたはuser/repo形式（例："yamadashy/repomix", "https://github.com/user/repo", または "https://github.com/user/repo/tree/branch"）
- `compress`: (オプション、デフォルト: false) 実装の詳細を削除しながら、重要なコードシグネチャと構造を抽出するTree-sitter圧縮を有効にします。セマンティックな意味を保持しながらトークン使用量を約70%削減します。grep_repomix_outputが段階的なコンテンツ取得を可能にするため、通常は不要です。大きなリポジトリのコードベース全体の内容が特に必要な場合のみ使用してください。
- `includePatterns`: (オプション) fast-globパターンを使用して含めるファイルを指定します。複数のパターンはカンマ区切りで指定できます（例："**/*.{js,ts}", "src/**,docs/**"）。マッチするファイルのみが処理されます。
- `ignorePatterns`: (オプション) fast-globパターンを使用して除外する追加ファイルを指定します。複数のパターンはカンマ区切りで指定できます（例："test/**,*.spec.js", "node_modules/**,dist/**"）。これらのパターンは.gitignoreと組み込み除外を補完します。
- `topFilesLength`: (オプション、デフォルト: 10) コードベース分析のメトリクス要約に表示する最大ファイル数（サイズ順）。

**例：**
```json
{
  "remote": "yamadashy/repomix",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### read_repomix_output

このツールはRepomixで生成された出力ファイルの内容を読み込みます。大きなファイルに対する行範囲指定による部分読み込みをサポートします。このツールは直接ファイルシステムアクセスが制限された環境向けに設計されています。

**パラメータ：**
- `outputId`: (必須) 読み込むRepomix出力ファイルのID
- `startLine`: (オプション) 開始行番号（1ベース、包含）。指定しない場合は最初から読み込みます。
- `endLine`: (オプション) 終了行番号（1ベース、包含）。指定しない場合は最後まで読み込みます。

**機能：**
- ウェブベース環境やサンドボックスアプリケーション向けに特別に設計
- IDを使用して以前に生成された出力の内容を取得
- ファイルシステムアクセスを必要とせずにパッケージ化されたコードベースへの安全なアクセスを提供
- 大きなファイルの部分読み込みをサポート

**例：**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "startLine": 100,
  "endLine": 200
}
```

### grep_repomix_output

このツールはJavaScript RegExp構文を使用したgrep風の機能でRepomix出力ファイル内のパターンを検索します。マッチした行の前後にオプションのコンテキスト行を含めて返します。

**パラメータ：**
- `outputId`: (必須) 検索するRepomix出力ファイルのID
- `pattern`: (必須) 検索パターン（JavaScript RegExp正規表現構文）
- `contextLines`: (オプション、デフォルト: 0) 各マッチの前後に表示するコンテキスト行数。beforeLines/afterLinesが指定された場合はそちらが優先されます。
- `beforeLines`: (オプション) 各マッチの前に表示するコンテキスト行数（grep -Bのように）。contextLinesより優先されます。
- `afterLines`: (オプション) 各マッチの後に表示するコンテキスト行数（grep -Aのように）。contextLinesより優先されます。
- `ignoreCase`: (オプション、デフォルト: false) 大文字小文字を区別しないマッチングを実行

**機能：**
- 強力なパターンマッチングのためのJavaScript RegExp構文を使用
- マッチの理解を深めるためのコンテキスト行をサポート
- before/afterコンテキスト行の個別制御が可能
- 大文字小文字を区別する/しない検索オプション

**例：**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "pattern": "function\\s+\\w+\\(",
  "contextLines": 3,
  "ignoreCase": false
}
```

### file_system_read_file と file_system_read_directory

RepomixのMCPサーバーは、AIアシスタントがローカルファイルシステムと安全にやり取りするための2つのファイルシステムツールを提供しています：

1. `file_system_read_file`
  - 絶対パスを使用してローカルファイルシステムからファイルの内容を読み取り
  - 機密情報を含むファイルへのアクセスを検出・防止する組み込みセキュリティ検証を含む
  - [Secretlint](https://github.com/secretlint/secretlint)を使用したセキュリティ検証を実装
  - 機密情報を含むファイル（APIキー、パスワード、シークレット）へのアクセスを防止
  - ディレクトリトラバーサル攻撃を防ぐための絶対パス検証
  - 無効なパスやセキュリティの問題に対する明確なエラーメッセージを返す

2. `file_system_read_directory`
  - 絶対パスを使用してディレクトリの内容を一覧表示
  - ファイルとサブディレクトリを明確な指標で示すフォーマット済みリストを返す
  - ファイルとディレクトリを明確な指標（`[FILE]`または`[DIR]`）で表示
  - 適切なエラー処理による安全なディレクトリ走査を提供
  - パスの検証と絶対パスの確認を実施
  - プロジェクト構造の探索とコードベース組織の理解に有用

両ツールは堅牢なセキュリティ対策を組み込んでいます：
- ディレクトリトラバーサル攻撃を防ぐための絶対パス検証
- 適切なアクセス権を確保するための権限チェック
- 機密情報検出のためのSecretlintとの統合
- デバッグとセキュリティ認識のための明確なエラーメッセージ

**例：**
```typescript
// ファイルの読み取り
const fileContent = await tools.file_system_read_file({
  path: '/absolute/path/to/file.txt'
});

// ディレクトリの内容一覧
const dirContent = await tools.file_system_read_directory({
  path: '/absolute/path/to/directory'
});
```

これらのツールは、AIアシスタントが以下のような操作を必要とする場合に特に有用です：
- コードベース内の特定のファイルを分析
- ディレクトリ構造をナビゲート
- ファイルの存在とアクセス可能性を確認
- 安全なファイルシステム操作を確保

## RepomixをMCPサーバーとして使用する利点

RepomixをMCPサーバーとして使用すると、いくつかの利点があります：

1. **直接統合**: AIアシスタントが手動でファイルを準備することなく、コードベースを直接分析できます。
2. **効率的なワークフロー**: ファイルを手動で生成してアップロードする必要がなくなり、コード分析のプロセスが効率化されます。
3. **一貫した出力**: AIアシスタントが一貫性のある最適化された形式でコードベースを受け取ることができます。
4. **高度な機能**: コード圧縮、トークンカウント、セキュリティチェックなど、Repomixのすべての機能を活用できます。

設定が完了すると、AIアシスタントはRepomixの機能を直接使用してコードベースを分析できるようになり、コード分析ワークフローがより効率的になります。
</file>

<file path="website/client/src/ja/guide/output.md">
# 出力フォーマット

Repomixは3つの出力フォーマットをサポートしています。
- XML（デフォルト）
- Markdown
- プレーンテキスト

## XMLフォーマット

```bash
repomix --style xml
```

XMLフォーマットはAI処理に最適化されています。

```xml
このファイルは、コードベース全体を1つのドキュメントにまとめた表現です...

<file_summary>
（メタデータとAI向けの使用説明）
</file_summary>

<directory_structure>
src/
  index.ts
  utils/
    helper.ts
</directory_structure>

<files>
<file path="src/index.js">
// ファイルの内容がここに表示されます
</file>
</files>

<instruction>
（output.instructionFilePathで指定されたカスタム指示）
</instruction>
```

::: tip なぜXML？
XMLタグはClaudeなどのAIモデルがコンテンツをより正確に解析するのに役立ちます。[Claude公式ドキュメント](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags)では、構造化されたプロンプトにXMLタグを使用することを推奨しています。
:::

## Markdownフォーマット

```bash
repomix --style markdown
```

Markdownは読みやすいフォーマットを提供します。

```markdown
このファイルは、コードベース全体を1つのドキュメントにまとめた表現です...

# ファイルサマリー
（メタデータとAI向けの使用説明）

# ディレクトリ構造
```
src/
index.ts
utils/
helper.ts
```

# ファイル

## File: src/index.ts
```typescript
// ファイルの内容がここに表示されます
```
```

## AIモデルとの使用

各フォーマットはAIモデルで問題なく動作しますが、以下の点を考慮してください。
- XMLはClaude用に最適化（最も正確な解析）
- Markdownは一般的な読みやすさを重視
- プレーンテキストはシンプルさと互換性を重視

## カスタマイズ

`repomix.config.json`でデフォルトのフォーマットを設定
```json
{
  "output": {
    "style": "xml",
    "filePath": "output.xml"
  }
}
```

## プレーンテキストフォーマット

```bash
repomix --style plain
```

出力の構造
```text
このファイルは、コードベース全体を1つのドキュメントにまとめた表現です...

================
ファイルサマリー
================
（メタデータとAI向けの使用説明）

================
ディレクトリ構造
================
src/
  index.ts
  utils/
    helper.ts

================
ファイル
================

================
File: src/index.js
================
// ファイルの内容がここに表示されます

================
File: src/utils.js
================
// ファイルの内容がここに表示されます
```
</file>

<file path="website/client/src/ja/guide/prompt-examples.md">
# プロンプト例

## コードレビュー

### アーキテクチャレビュー
```
このコードベースのアーキテクチャを分析してください。
1. 全体的な構造とパターンを評価
2. アーキテクチャ上の潜在的な問題点を特定
3. スケーラビリティ向上のための改善案を提案
4. ベストプラクティスに従っている部分を指摘

保守性とモジュール性に特に注目してください。
```

### セキュリティレビュー
```
このコードベースのセキュリティレビューを実施してください。
1. 潜在的なセキュリティ脆弱性の特定
2. 一般的なセキュリティアンチパターンのチェック
3. エラー処理と入力バリデーションの確認
4. 依存関係のセキュリティ評価

具体的な例と対策手順を含めてください。
```

### パフォーマンスレビュー
```
パフォーマンスの観点からコードベースをレビューしてください。
1. パフォーマンスのボトルネックを特定
2. リソース使用状況の確認
3. アルゴリズムの効率性の評価
4. キャッシュ戦略の評価

具体的な最適化の推奨事項を含めてください。
```

## ドキュメント生成

### API ドキュメント
```
包括的なAPIドキュメントを生成してください。
1. すべてのパブリックエンドポイントをリストアップし説明
2. リクエスト/レスポンスのフォーマットを文書化
3. 使用例を含める
4. 制限事項や制約を記載
```

### 開発者ガイド
```
以下の内容を含む開発者ガイドを作成してください。
1. セットアップ手順
2. プロジェクト構造の概要
3. 開発ワークフロー
4. テストアプローチ
5. 一般的なトラブルシューティング手順
```

### アーキテクチャドキュメント
```
システムアーキテクチャを文書化してください。
1. 高レベルの概要
2. コンポーネント間の相互作用
3. データフロー図
4. 設計上の決定と根拠
5. システムの制約と制限事項
```

## 分析と改善

### 依存関係の分析
```
プロジェクトの依存関係を分析してください。
1. 古くなったパッケージの特定
2. セキュリティ脆弱性のチェック
3. 代替パッケージの提案
4. 依存関係の使用パターンの確認

具体的なアップグレード推奨事項を含めてください。
```

### テストカバレッジ
```
テストカバレッジを確認してください。
1. テストされていないコンポーネントの特定
2. 追加のテストケースの提案
3. テストの品質の確認
4. テスト戦略の推奨

具体的な改善案を提供してください。
```

### コード品質
```
コード品質を評価し、改善点を提案してください。
1. 命名規則の確認
2. コード構成の確認
3. エラー処理の評価
4. コメントの実践の確認

良いパターンと問題のあるパターンの具体例を提供してください。
```

## より良い結果を得るためのヒント

1. **具体的に**: 明確な目標と評価基準を含める
2. **コンテキストを設定**: あなたの役割と必要な専門知識レベルを指定
3. **レスポンス形式**: 希望する回答の構造を指定
4. **優先順位**: どの側面が最も重要かを示す

## モデル別の注意点

### Claude
- XML出力形式を使用
- 重要な指示を最後に配置
- レスポンス構造を指定

### ChatGPT
- Markdown形式を使用
- 大規模なコードベースはセクションに分割
- システムロールプロンプトを含める

### Gemini
- すべての形式で動作
- 特定の領域に焦点を絞る
- ステップバイステップの分析を使用
</file>

<file path="website/client/src/ja/guide/remote-repository-processing.md">
# リモートリポジトリの処理

## 基本的な使用方法

パブリックリポジトリを処理
```bash
# 完全なURLを使用
repomix --remote https://github.com/user/repo

# GitHubのショートハンド形式を使用
repomix --remote user/repo
```

## ブランチとコミットの選択

```bash
# 特定のブランチ
repomix --remote user/repo --remote-branch main

# タグ
repomix --remote user/repo --remote-branch v1.0.0

# コミットハッシュ
repomix --remote user/repo --remote-branch 935b695
```

## 必要条件

- Gitがインストールされていること
- インターネット接続があること
- リポジトリへの読み取りアクセス権があること

## 出力の制御

```bash
# 出力先のカスタマイズ
repomix --remote user/repo -o custom-output.xml

# XML形式で出力
repomix --remote user/repo --style xml

# コメントを削除
repomix --remote user/repo --remove-comments
```

## Docker使用時

```bash
# カレントディレクトリに出力
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo

# 特定のディレクトリに出力
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo
```

## 一般的な問題

### アクセスの問題
- リポジトリがパブリックであることを確認
- Gitのインストールを確認
- インターネット接続を確認

### 大規模リポジトリの処理
- `--include`で特定のパスを選択
- `--remove-comments`を有効化
- ブランチごとに個別に処理
</file>

<file path="website/client/src/ja/guide/security.md">
# セキュリティ

## セキュリティチェック機能

Repomixは[Secretlint](https://github.com/secretlint/secretlint)を使用して、ファイル内の機密情報を検出します：
- APIキー
- アクセストークン
- 認証情報
- 秘密鍵
- 環境変数

## 設定

セキュリティチェックはデフォルトで有効になっています。

CLIで無効化する場合
```bash
repomix --no-security-check
```

または`repomix.config.json`で
```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

## セキュリティ対策

1. **バイナリファイルの除外**: バイナリファイルは出力に含まれません
2. **Git対応**: `.gitignore`パターンを尊重します
3. **自動検出**: 以下を含む一般的なセキュリティ問題を検出
    - AWSの認証情報
    - データベース接続文字列
    - 認証トークン
    - 秘密鍵

## セキュリティチェックで問題が見つかった場合

出力例
```bash
🔍 Security Check:
──────────────────
2 suspicious file(s) detected and excluded:
1. config/credentials.json
  - Found AWS access key
2. .env.local
  - Found database password
```

## ベストプラクティス

1. 共有する前に必ず出力を確認
2. `.repomixignore`を使用して機密性のあるパスを除外
3. セキュリティチェックを有効に保つ
4. 機密ファイルをリポジトリから削除

## セキュリティ問題の報告

セキュリティ脆弱性を発見した場合は
1. パブリックなイシューは作成しないでください
2. メール: koukun0120@gmail.com
3. または[GitHub Security Advisories](https://github.com/yamadashy/repomix/security/advisories/new)を使用
</file>

<file path="website/client/src/ja/guide/usage.md">
# 基本的な使い方

## クイックスタート

リポジトリ全体をパッケージ化：
```bash
repomix
```

## 一般的な使用例

### 特定のディレクトリをパッケージ化
```bash
repomix path/to/directory
```

### 特定のファイルを含める
[glob パターン](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)を使用：
```bash
repomix --include "src/**/*.ts,**/*.md"
```

### ファイルを除外
```bash
repomix --ignore "**/*.log,tmp/"
```

### リモートリポジトリ
```bash
# GitHub URLを使用
repomix --remote https://github.com/user/repo

# ショートハンドを使用
repomix --remote user/repo

# 特定のブランチ/タグ/コミット
repomix --remote user/repo --remote-branch main
repomix --remote user/repo --remote-branch 935b695
```

### ファイルリスト入力（stdin）

究極の柔軟性でファイルパスをstdin経由で渡します：

```bash
# findコマンドを使用
find src -name "*.ts" -type f | repomix --stdin

# gitを使用してトラッキングされているファイルを取得
git ls-files "*.ts" | repomix --stdin

# globパターンを使用したls
ls src/**/*.ts | repomix --stdin

# ファイルパスが含まれるファイルから
cat file-list.txt | repomix --stdin

# echoで直接入力
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```

`--stdin`オプションを使用すると、Repomixにファイルパスのリストをパイプできるため、どのファイルをパッケージ化するかの選択において究極の柔軟性が得られます。

> [!NOTE]
> `--stdin`を使用する場合、ファイルパスは相対パスまたは絶対パスのどちらでも指定でき、Repomixが自動的にパス解決と重複除去を処理します。

### コード圧縮
```bash
repomix --compress

# リモートリポジトリでも使用可能：
repomix --remote user/repo --compress
```

## 出力形式

### XML（デフォルト）
```bash
repomix --style xml
```

### Markdown
```bash
repomix --style markdown
```

### プレーンテキスト
```bash
repomix --style plain
```

## その他のオプション

### コメントを削除
```bash
repomix --remove-comments
```

### 行番号を表示
```bash
repomix --output-show-line-numbers
```

### クリップボードにコピー
```bash
repomix --copy
```

### セキュリティチェックを無効化
```bash
repomix --no-security-check
```

## 設定

設定ファイルを初期化：
```bash
repomix --init
```

詳細なオプションについては[設定ガイド](/ja/guide/configuration)を参照してください。
</file>

<file path="website/client/src/ja/index.md">
---
layout: home
title: Repomix
titleTemplate: コードベースをAIフレンドリーな形式にパッケージング
aside: false
editLink: false

features:
  - icon: 🤖
    title: AI最適化
    details: コードベースをAIが理解・処理しやすい形式にフォーマット

  - icon: ⚙️
    title: Git対応
    details: .gitignoreファイルを自動的に認識し、適切なファイル除外

  - icon: 🛡️
    title: セキュリティ重視
    details: Secretlintを組み込み、機密情報の検出と除外

  - icon: 📊
    title: トークンカウント
    details: ファイルごとおよびコードベース全体のトークン数を計測し、LLMのコンテキスト制限に対応

---

<script setup>
import YouTubeVideo from '../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../utils/videos'
</script>

<div class="cli-section">

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## 🏆 オープンソースアワードノミネート

光栄です！Repomixが[JSNation Open Source Awards 2025](https://osawards.com/javascript/)の**Powered by AI**カテゴリにノミネートされました。

これは皆様がRepomixを使用し、サポートしてくださったおかげです。ありがとうございます！

RepomixがAIツール向けのコードベース分析やパッケージングにお役に立った場合、**Powered by AI**カテゴリでの投票をお願いいたします。

## Repomixとは？

Repomixは、コードベース全体を単一のAIフレンドリーなファイルにパッケージ化する強力なツールです。コードレビュー、リファクタリング、プロジェクトに関するAIアシスタンスが必要な場合に、リポジトリ全体のコンテキストをAIツールと簡単に共有できます。

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

## クイックスタート

Repomixを使用すると、コードベース全体を1ファイル（`repomix-output.xml`）にできます。

そのまま ChatGPT や Claude などのAIアシスタントに次のようなプロンプトと一緒に送ると、

```
このファイルはコードベース内のファイルを1つにまとめたものです。
コードのリファクタリングを行いたいので、まずはコードレビューをお願いします。
```

全体の内容を理解した上で、リファクタリングなどを進めることができます。

![Repomixの使用例1](/images/docs/repomix-file-usage-1.png)

具体的な内容を提案すると、それに従って良い感じのコードを生成してくれます。Claude だと Artifacts 機能で複数のファイルが出力できるため、依存関係にある複数のコードも一緒に生成できます。

![Repomixの使用例2](/images/docs/repomix-file-usage-2.png)

良いコーディング体験を！🚀

## CLIの使用方法 {#using-the-cli-tool}

Repomixは強力な機能とカスタマイズオプションを提供するコマンドラインツールとして使用できます。

**CLIツールはプライベートリポジトリにアクセスできます**。これはローカルにインストールされたgitを使用するためです。

### クイックスタート

任意のディレクトリで以下のコマンドを実行すると、 `repomix-output.xml` が生成され、それ以降の使い方は同様です。

```bash
npx repomix
```

または、グローバルにインストールして繰り返し使用することもできます。

```bash
# npmを使用してインストール
npm install -g repomix

# または、yarnを使用
yarn global add repomix

# または、bunを使用
bun add -g repomix

# または、Homebrewを使用（macOS/Linux）
brew install repomix

# その後、任意のプロジェクトディレクトリで実行
repomix
```


### CLIの使用方法

カレントディレクトリ全体をまとめる。

```bash
repomix
```

特定のディレクトリをまとめる。

```bash
repomix path/to/directory
```

[glob パターン](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)を使用して特定のファイルやディレクトリを指定。

```bash
repomix --include "src/**/*.ts,**/*.md"
```

特定のファイルやディレクトリを除外。

```bash
repomix --ignore "**/*.log,tmp/"
```

リモートリポジトリをまとめる。

```bash
# ショートハンド形式を使用
npx repomix --remote yamadashy/repomix

# 完全なURL（ブランチや特定のパスをサポート）
npx repomix --remote https://github.com/yamadashy/repomix
npx repomix --remote https://github.com/yamadashy/repomix/tree/main

# コミットのURLを使用
npx repomix --remote https://github.com/yamadashy/repomix/commit/836abcd7335137228ad77feb28655d85712680f1
```

設定ファイル（`repomix.config.json`）の初期化

```bash
repomix --init
```

生成されたファイルは、Claude、ChatGPT、Geminiなどの生成AIツールで使用できます。

### Docker使用方法 🐳

Dockerを使用してRepomixを実行することも可能で、分離された環境でRepomixを実行したい場合に便利です。

基本的な使用方法

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

特定のディレクトリをまとめる
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

リモートリポジトリを処理し、`output`ディレクトリに出力

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### 出力フォーマット

出力フォーマットは3種類あり、`xml`, `markdown`, `plain` を選択できます。
LLMによっては得意・不得意があるので、適切なフォーマットを選択してください。

```bash
# XMLフォーマット（デフォルト）
repomix --style xml

# Markdownフォーマット
repomix --style markdown

# プレーンテキストフォーマット
repomix --style plain
```

### カスタマイズ

フォルダごとの永続的な設定のために`repomix --init`で`repomix.config.json`を作成できます。

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

## パワーユーザーガイド

Repomixは高度な用途向けの強力な機能を提供します。パワーユーザー向けの重要なガイドをご紹介します：

- **[MCPサーバー](./guide/mcp-server)** - AIアシスタント向けModel Context Protocol統合
- **[GitHub Actions](./guide/github-actions)** - CI/CDワークフローでのコードベース自動パッケージング
- **[コード圧縮](./guide/code-compress)** - Tree-sitterベースのインテリジェント圧縮（約70%のトークン削減）
- **[ライブラリとして使用](./guide/development/using-repomix-as-a-library)** - Node.jsアプリケーションへのRepomix統合
- **[カスタム指示](./guide/custom-instructions)** - 出力にカスタムプロンプトと指示を追加
- **[セキュリティ機能](./guide/security)** - 組み込みSecretlint統合と安全性チェック
- **[ベストプラクティス](./guide/tips/best-practices)** - 実証済みの戦略でAIワークフローを最適化

### その他の例
::: tip もっと詳しく知りたい場合は？ 💡
詳しい使い方は[ガイド](./guide/)をご覧ください。コード例やソースコードは[GitHubリポジトリ](https://github.com/yamadashy/repomix)で確認できます。
:::

</div>
</file>

<file path="website/client/src/ko/guide/development/index.md">
# Repomix에 기여하기

Repomix에 관심을 가져주셔서 감사합니다! 🚀 프로젝트를 더 좋게 만들기 위한 여러분의 도움을 환영합니다. 이 가이드는 프로젝트에 기여하는 방법을 안내합니다.

## 기여 방법

- **저장소 스타하기**: [저장소에 스타](https://github.com/yamadashy/repomix)를 눌러 지원해주세요!
- **이슈 생성하기**: 버그를 발견하셨나요? 새로운 기능 아이디어가 있으신가요? [이슈를 생성](https://github.com/yamadashy/repomix/issues)하여 알려주세요.
- **풀 리퀘스트 제출하기**: 수정하거나 개선할 점을 찾으셨나요? PR을 제출해주세요!
- **소문내기**: 소셜 미디어, 블로그 또는 기술 커뮤니티에서 Repomix에 대한 경험을 공유해주세요.
- **Repomix 사용하기**: 실제 사용에서 오는 피드백이 가장 가치 있습니다. 여러분의 프로젝트에 Repomix를 통합해보세요!
- **후원하기**: [후원자가 되어](https://github.com/sponsors/yamadashy) Repomix 개발을 지원해주세요.

## 빠른 시작

```bash
git clone https://github.com/yamadashy/repomix.git
cd repomix
npm install
```

## 개발 명령어

```bash
# CLI 실행
npm run repomix

# 테스트 실행
npm run test
npm run test-coverage

# 코드 린트
npm run lint
```

## 코드 스타일

- 린트 및 포맷팅에 [Biome](https://biomejs.dev/)을 사용합니다.
- 테스트 용이성을 위해 의존성 주입을 사용합니다.
- 파일 길이를 250줄 미만으로 유지합니다.
- 새로운 기능에 대한 테스트를 추가합니다.

## Pull Request 가이드라인

1. 모든 테스트를 실행합니다.
2. 린트 검사를 통과합니다.
3. 문서를 업데이트합니다.
4. 기존 코드 스타일을 따릅니다.

## 개발 환경 설정

### 필수 구성 요소

- Node.js ≥ 18.0.0
- Git
- npm
- Docker (선택 사항, 웹사이트 실행 또는 컨테이너화된 개발용)

### 로컬 개발

Repomix 로컬 개발 환경을 설정하려면:

```bash
# 저장소 복제
git clone https://github.com/yamadashy/repomix.git
cd repomix

# 의존성 설치
npm install

# CLI 실행
npm run repomix
```

### Docker 개발

Docker를 사용하여 Repomix를 실행할 수도 있습니다:

```bash
# 이미지 빌드
docker build -t repomix .

# 컨테이너 실행
docker run -v ./:/app -it --rm repomix
```

### 프로젝트 구조

프로젝트는 다음 디렉토리로 구성되어 있습니다:

```
src/
├── cli/          # CLI 구현
├── config/       # 구성 처리
├── core/         # 핵심 기능
│   ├── file/     # 파일 처리
│   ├── metrics/  # 메트릭스 계산
│   ├── output/   # 출력 생성
│   ├── security/ # 보안 검사
├── mcp/          # MCP 서버 통합
└── shared/       # 공유 유틸리티
tests/            # src/ 구조를 반영한 테스트
website/          # 문서 웹사이트
├── client/       # 프론트엔드 (VitePress)
└── server/       # 백엔드 API
```

## 웹사이트 개발

Repomix 웹사이트는 [VitePress](https://vitepress.dev/)로 구축되었습니다. 로컬에서 웹사이트를 실행하려면:

```bash
# 전제 조건: 시스템에 Docker가 설치되어 있어야 합니다

# 웹사이트 개발 서버 시작
npm run website

# http://localhost:5173/에서 웹사이트에 액세스
```

문서를 업데이트할 때는 먼저 영어 버전만 업데이트하면 됩니다. 다른 언어로의 번역은 메인테이너가 처리합니다.

## 릴리스 프로세스

메인테이너와 기여자를 위한 릴리스 프로세스:

1. 버전 업데이트
```bash
npm version patch  # 또는 minor/major
```

2. 테스트 및 빌드 실행
```bash
npm run test-coverage
npm run build
```

3. 게시
```bash
npm publish
```

새 버전은 메인테이너에 의해 관리됩니다. 릴리스가 필요하다고 생각되면 이슈를 열어 논의하세요.

## 도움이 필요하신가요?

- [이슈 열기](https://github.com/yamadashy/repomix/issues)
- [Discord 참여](https://discord.gg/wNYzTwZFku)
</file>

<file path="website/client/src/ko/guide/development/using-repomix-as-a-library.md">
# Repomix를 라이브러리로 사용하기

Repomix를 CLI 도구로 사용하는 것 외에도 Node.js 애플리케이션에 직접 기능을 통합할 수 있습니다.

## 설치

프로젝트에 Repomix를 의존성으로 설치하세요:

```bash
npm install repomix
```

## 기본 사용법

Repomix를 사용하는 가장 간단한 방법은 명령줄 인터페이스와 동일한 기능을 제공하는 `runCli` 함수를 통해 사용하는 것입니다:

```javascript
import { runCli, type CliOptions } from 'repomix';

// 사용자 정의 옵션으로 현재 디렉토리 처리
async function packProject() {
  const options = {
    output: 'output.xml',
    style: 'xml',
    compress: true,
    quiet: true
  } as CliOptions;
  
  const result = await runCli(['.'], process.cwd(), options);
  return result.packResult;
}
```

`result.packResult`에는 처리된 파일에 대한 다음 정보가 포함됩니다:
- `totalFiles`: 처리된 파일 수
- `totalCharacters`: 총 문자 수
- `totalTokens`: 총 토큰 수(LLM 컨텍스트 제한에 유용)
- `fileCharCounts`: 파일별 문자 수
- `fileTokenCounts`: 파일별 토큰 수

## 원격 저장소 처리

원격 저장소를 클론하고 처리할 수 있습니다:

```javascript
import { runCli, type CliOptions } from 'repomix';

// GitHub 저장소 클론 및 처리
async function processRemoteRepo(repoUrl) {
  const options = {
    remote: repoUrl,
    output: 'output.xml',
    compress: true
  } as CliOptions;
  
  return await runCli(['.'], process.cwd(), options);
}
```

## 핵심 컴포넌트 사용

더 많은 제어를 위해 Repomix의 저수준 API를 직접 사용할 수 있습니다:

```javascript
import { searchFiles, collectFiles, processFiles, TokenCounter } from 'repomix';

async function analyzeFiles(directory) {
  // 파일 찾기 및 수집
  const { filePaths } = await searchFiles(directory, { /* 설정 */ });
  const rawFiles = await collectFiles(filePaths, directory);
  const processedFiles = await processFiles(rawFiles, { /* 설정 */ });
  
  // 토큰 계산
  const tokenCounter = new TokenCounter('o200k_base');
  
  // 분석 결과 반환
  return processedFiles.map(file => ({
    path: file.path,
    tokens: tokenCounter.countTokens(file.content)
  }));
}
```

## 실제 사례

Repomix 웹사이트([repomix.com](https://repomix.com))는 원격 저장소를 처리하기 위해 라이브러리로 Repomix를 사용합니다. [website/server/src/remoteRepo.ts](https://github.com/yamadashy/repomix/blob/main/website/server/src/remoteRepo.ts)에서 구현을 확인할 수 있습니다.
</file>

<file path="website/client/src/ko/guide/tips/best-practices.md">
# AI 지원 개발 모범 사례: 나의 경험으로부터

저는 아직 AI를 사용하여 대규모 프로젝트를 성공적으로 완료하지는 못했지만, 지금까지 개발 과정에서 AI와 함께 작업하면서 배운 점을 공유하고자 합니다.

## 기본 개발 접근 방식

AI와 함께 작업할 때, 모든 기능을 한 번에 구현하려고 하면 예상치 못한 문제와 프로젝트 정체로 이어질 수 있습니다. 그렇기 때문에 핵심 기능부터 시작하여 각 기능을 하나씩 구축하고, 다음 단계로 넘어가기 전에 견고한 구현을 보장하는 것이 더 효과적입니다.

### 기존 코드의 힘

이 접근 방식이 효과적인 이유는 핵심 기능을 구현하면 실제 코드를 통해 이상적인 설계와 코딩 스타일을 구체화할 수 있기 때문입니다. 프로젝트 비전을 전달하는 가장 효과적인 방법은 표준과 선호도를 반영하는 코드를 작성하는 것입니다.

핵심 기능부터 시작하여 각 구성 요소가 제대로 작동하는지 확인한 후 다음 단계로 진행하면 전체 프로젝트의 일관성이 유지되므로 AI가 더 적절한 코드를 생성하기 쉬워집니다.

## 모듈식 접근 방식

코드를 더 작은 모듈로 나누는 것이 중요합니다. 제 경험상, 파일을 약 250줄 정도로 유지하면 AI에게 명확한 지침을 제공하기 쉽고 시행착오 프로세스가 더 효율적입니다. 토큰 수가 더 정확한 지표가 될 수 있지만, 줄 수는 개발자가 작업하기에 더 실용적이므로 이를 지침으로 사용합니다.

이러한 모듈화는 단순히 프런트엔드, 백엔드, 데이터베이스 구성 요소를 분리하는 것뿐만 아니라 훨씬 더 세분화된 수준에서 기능을 분리하는 것입니다. 예를 들어, 단일 기능 내에서 유효성 검사, 오류 처리 및 기타 특정 기능을 별개의 모듈로 분리할 수 있습니다. 물론, 높은 수준의 분리도 중요하며, 이러한 모듈식 접근 방식을 점진적으로 구현하면 명확한 지침을 유지하고 AI가 더 적절한 코드를 생성할 수 있습니다. 이 접근 방식은 AI뿐만 아니라 사람 개발자에게도 효과적입니다.

## 테스트를 통한 품질 보장

저는 AI 지원 개발에서 테스트가 매우 중요하다고 생각합니다. 테스트는 품질 보장 수단일 뿐만 아니라 코드 의도를 명확하게 보여주는 문서 역할도 합니다. AI에게 새로운 기능 구현을 요청할 때, 기존 테스트 코드는 사실상 사양 문서 역할을 합니다.

테스트는 또한 AI가 생성한 코드의 정확성을 검증하는 훌륭한 도구입니다. 예를 들어, AI에게 모듈에 대한 새로운 기능 구현을 요청할 때, 테스트 케이스를 미리 작성하면 생성된 코드가 예상대로 작동하는지 객관적으로 평가할 수 있습니다. 이는 테스트 주도 개발(TDD) 원칙과 잘 부합하며 AI와 협업할 때 특히 효과적입니다.

## 계획과 구현의 균형

대규모 기능을 구현하기 전에 먼저 AI와 계획에 대해 논의하는 것이 좋습니다. 요구 사항을 정리하고 아키텍처를 고려하면 구현이 더 원활해집니다. 좋은 방법은 먼저 요구 사항을 정리한 다음 별도의 대화 세션으로 이동하여 구현 작업을 수행하는 것입니다.

AI의 출력을 사람이 검토하고 필요에 따라 조정하는 것이 중요합니다. AI가 생성한 코드의 품질은 일반적으로 보통 수준이지만, 모든 것을 처음부터 작성하는 것보다 개발 속도를 높여줍니다.

## 결론

이러한 관행을 따르면 AI의 강점을 활용하면서 일관성 있고 고품질의 코드베이스를 구축할 수 있습니다. 프로젝트 규모가 커지더라도 각 구성 요소는 잘 정의되고 관리하기 쉬운 상태로 유지됩니다.
</file>

<file path="website/client/src/ko/guide/code-compress.md">
# 코드 압축

코드 압축은 구현 세부 사항을 제거하면서 필수적인 코드 구조를 지능적으로 추출하는 강력한 기능입니다. 이는 코드베이스의 중요한 구조적 정보를 유지하면서 토큰 수를 줄일 때 특히 유용합니다.

> [!NOTE]
> 이것은 실험적인 기능으로, 사용자 피드백과 실제 사용 사례를 바탕으로 지속적으로 개선될 예정입니다.

## 기본 사용법

`--compress` 플래그를 사용하여 코드 압축을 활성화합니다:

```bash
repomix --compress
```

원격 저장소에서도 사용할 수 있습니다:

```bash
repomix --remote user/repo --compress
```

## 작동 방식

압축 알고리즘은 Tree-sitter 파싱을 사용하여 코드를 처리하고, 구현 세부 사항을 제거하면서 필수적인 구조적 요소를 추출하고 보존합니다.

압축 시 유지되는 요소:
- 함수와 메서드 시그니처
- 인터페이스와 타입 정의
- 클래스 구조와 속성
- 중요한 구조적 요소

제거되는 요소:
- 함수와 메서드 구현
- 반복문과 조건문 로직 세부 사항
- 내부 변수 선언
- 구현 관련 코드

### 예시

원본 TypeScript 코드:

```typescript
import { ShoppingItem } from './shopping-item';

/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
  let total = 0;
  for (const item of items) {
    total += item.price * item.quantity;
  }
  return total;
}

// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

압축 후:

```typescript
import { ShoppingItem } from './shopping-item';
⋮----
/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
⋮----
// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

## 설정

설정 파일에서 압축을 활성화할 수 있습니다:

```json
{
  "output": {
    "compress": true
  }
}
```

## 사용 사례

코드 압축은 다음과 같은 경우에 특히 유용합니다:
- 코드 구조와 아키텍처 분석
- LLM 처리를 위한 토큰 수 감소
- 고수준 문서 작성
- 코드 패턴과 시그니처 이해
- API와 인터페이스 설계 공유

## 관련 옵션

압축은 다음 옵션들과 함께 사용할 수 있습니다:
- `--remove-comments`: 코드 주석 제거
- `--remove-empty-lines`: 빈 줄 제거
- `--output-show-line-numbers`: 출력에 줄 번호 추가
</file>

<file path="website/client/src/ko/guide/command-line-options.md">
# 명령줄 옵션

## 기본 옵션
- `-v, --version`: 버전 표시

## 출력 옵션
- `-o, --output <file>`: 출력 파일 이름 (기본값: `repomix-output.txt`)
- `--stdout`: 파일에 쓰는 대신 표준 출력으로 출력 (`--output` 옵션과 함께 사용 불가)
- `--style <type>`: 출력 스타일 (`plain`, `xml`, `markdown`) (기본값: `xml`)
- `--parsable-style`: 선택한 스타일 스키마에 기반한 파싱 가능한 출력 활성화 (기본값: `false`)
- `--compress`: 함수와 클래스 시그니처에 중점을 두고 구현 세부 사항을 제거하는 지능형 코드 추출을 수행합니다. 자세한 내용과 예제는 [코드 압축 가이드](code-compress)를 참조하세요.
- `--output-show-line-numbers`: 줄 번호 추가 (기본값: `false`)
- `--copy`: 클립보드에 복사 (기본값: `false`)
- `--no-file-summary`: 파일 요약 비활성화 (기본값: `true`)
- `--no-directory-structure`: 디렉토리 구조 비활성화 (기본값: `true`)
- `--no-files`: 파일 내용 출력 비활성화 (메타데이터 전용 모드) (기본값: `true`)
- `--remove-comments`: 주석 제거 (기본값: `false`)
- `--remove-empty-lines`: 빈 줄 제거 (기본값: `false`)
- `--header-text <text>`: 파일 헤더에 포함할 사용자 정의 텍스트
- `--instruction-file-path <path>`: 상세한 사용자 정의 지침이 포함된 파일 경로
- `--include-empty-directories`: 출력에 빈 디렉토리 포함 (기본값: `false`)
- `--include-diffs`: git 차이점을 출력에 포함 (작업 트리 및 스테이지된 변경 사항이 별도로 포함됨) (기본값: `false`)
- `--no-git-sort-by-changes`: git 변경 횟수로 파일 정렬 비활성화 (기본값: `true`)

## 필터 옵션
- `--include <patterns>`: 포함할 패턴 (쉼표로 구분)
- `-i, --ignore <patterns>`: 무시할 패턴 (쉼표로 구분)
- `--stdin`: 파일을 자동으로 검색하는 대신 stdin에서 파일 경로 읽기
- `--no-gitignore`: .gitignore 파일 사용 비활성화
- `--no-default-patterns`: 기본 패턴 비활성화

## 원격 저장소 옵션
- `--remote <url>`: 원격 저장소 처리
- `--remote-branch <name>`: 원격 브랜치 이름, 태그 또는 커밋 해시 지정 (기본값은 저장소의 기본 브랜치)

## 설정 옵션
- `-c, --config <path>`: 사용자 정의 설정 파일 경로
- `--init`: 설정 파일 생성
- `--global`: 전역 설정 사용

## 보안 옵션
- `--no-security-check`: 보안 검사 비활성화 (기본값: `true`)

## 토큰 카운트 옵션
- `--token-count-encoding <encoding>`: 토큰 카운트 인코딩 지정 (예: `o200k_base`, `cl100k_base`) (기본값: `o200k_base`)

## 기타 옵션
- `--top-files-len <number>`: 표시할 상위 파일 수 (기본값: `5`)
- `--verbose`: 상세 로깅 활성화
- `--quiet`: 표준 출력에 대한 모든 출력 비활성화

## 예제

```bash
# 기본 사용법
repomix

# 사용자 정의 출력
repomix -o output.xml --style xml

# 표준 출력으로 출력
repomix --stdout > custom-output.txt

# 표준 출력으로 출력 후 다른 명령으로 파이프 (예: simonw/llm)
repomix --stdout | llm "이 코드가 무엇을 하는지 설명해주세요"

# 압축을 사용한 사용자 정의 출력
repomix --compress

# 특정 파일 처리
repomix --include "src/**/*.ts" --ignore "**/*.test.ts"

# 브랜치를 지정한 원격 저장소
repomix --remote https://github.com/user/repo/tree/main

# 커밋을 지정한 원격 저장소
repomix --remote https://github.com/user/repo/commit/836abcd7335137228ad77feb28655d85712680f1

# 단축형을 사용한 원격 저장소
repomix --remote user/repo

# stdin을 사용한 파일 목록
find src -name "*.ts" -type f | repomix --stdin
git ls-files "*.js" | repomix --stdin
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```
</file>

<file path="website/client/src/ko/guide/comment-removal.md">
# 주석 제거

Repomix는 출력 파일을 생성할 때 코드베이스에서 주석을 자동으로 제거할 수 있습니다. 이를 통해 노이즈를 줄이고 실제 코드에 집중할 수 있습니다.

## 사용법

주석 제거를 활성화하려면 `repomix.config.json`에서 `removeComments` 옵션을 `true`로 설정합니다.

```json
{
  "output": {
    "removeComments": true
  }
}
```

## 지원되는 언어

Repomix는 다음을 포함한 광범위한 프로그래밍 언어에 대한 주석 제거를 지원합니다.

- JavaScript/TypeScript (`//`, `/* */`)
- Python (`#`, `"""`, `'''`)
- Java (`//`, `/* */`)
- C/C++ (`//`, `/* */`)
- HTML (`<!-- -->`)
- CSS (`/* */`)
- 그리고 더 많은 언어들...

## 예시

다음 JavaScript 코드가 주어졌을 때:

```javascript
// 이것은 한 줄 주석입니다
function test() {
  /* 이것은
     여러 줄 주석입니다 */
  return true;
}
```

주석 제거를 활성화하면 출력은 다음과 같습니다.

```javascript
function test() {
  return true;
}
```

## 참고

- 주석 제거는 행 번호 추가와 같은 다른 처리 단계 전에 수행됩니다.
- JSDoc 주석과 같은 일부 주석은 언어 및 컨텍스트에 따라 보존될 수 있습니다.
</file>

<file path="website/client/src/ko/guide/configuration.md">
# 설정

Repomix는 설정 파일(`repomix.config.json`) 또는 명령줄 옵션을 사용하여 설정할 수 있습니다. 설정 파일을 사용하면 코드베이스의 처리 및 출력 방식을 사용자 정의할 수 있습니다.

## 빠른 시작

프로젝트 디렉토리에 설정 파일을 생성합니다:
```bash
repomix --init
```

이렇게 하면 기본 설정이 포함된 `repomix.config.json` 파일이 생성됩니다. 로컬 설정이 없을 때 대체로 사용될 전역 설정 파일을 생성할 수도 있습니다:

```bash
repomix --init --global
```

## 설정 옵션

| 옵션                             | 설명                                                                                                                         | 기본값                 |
|----------------------------------|------------------------------------------------------------------------------------------------------------------------------|------------------------|
| `input.maxFileSize`              | 처리할 최대 파일 크기(바이트). 이 크기를 초과하는 파일은 건너뜁니다. 큰 바이너리 파일이나 데이터 파일을 제외하는 데 유용합니다 | `50000000`            |
| `output.filePath`                | 출력 파일 이름. XML, Markdown, 일반 텍스트 형식을 지원합니다                                                                | `"repomix-output.xml"` |
| `output.style`                   | 출력 스타일(`xml`, `markdown`, `plain`). 각 형식은 다른 AI 도구에 대해 서로 다른 장점이 있습니다                          | `"xml"`                |
| `output.parsableStyle`           | 선택한 스타일 스키마에 따라 출력을 이스케이프할지 여부. 더 나은 구문 분석이 가능하지만 토큰 수가 증가할 수 있습니다      | `false`                |
| `output.compress`                | Tree-sitter를 사용하여 구조를 유지하면서 토큰 수를 줄이기 위해 지능적인 코드 추출을 수행할지 여부                         | `false`                |
| `output.headerText`              | 파일 헤더에 포함할 사용자 정의 텍스트. AI 도구에 컨텍스트나 지침을 제공하는 데 유용합니다                                | `null`                 |
| `output.instructionFilePath`     | AI 처리를 위한 상세한 사용자 정의 지침이 포함된 파일 경로                                                                  | `null`                 |
| `output.fileSummary`             | 출력 시작 부분에 파일 수, 크기 및 기타 메트릭을 보여주는 요약 섹션을 포함할지 여부                                        | `true`                 |
| `output.directoryStructure`      | 출력에 디렉토리 구조를 포함할지 여부. AI가 프로젝트 구성을 이해하는 데 도움이 됩니다                                     | `true`                 |
| `output.files`                   | 출력에 파일 내용을 포함할지 여부. false로 설정하면 구조와 메타데이터만 포함됩니다                                         | `true`                 |
| `output.removeComments`          | 지원되는 파일 유형에서 주석을 제거할지 여부. 노이즈와 토큰 수를 줄일 수 있습니다                                         | `false`                |
| `output.removeEmptyLines`        | 출력에서 빈 줄을 제거하여 토큰 수를 줄일지 여부                                                                            | `false`                |
| `output.showLineNumbers`         | 각 줄에 줄 번호를 추가할지 여부. 코드의 특정 부분을 참조하는 데 도움이 됩니다                                            | `false`                |
| `output.copyToClipboard`         | 파일 저장 외에도 출력을 시스템 클립보드에 복사할지 여부                                                                    | `false`                |
| `output.topFilesLength`          | 요약에 표시할 상위 파일 수. 0으로 설정하면 요약이 표시되지 않습니다                                                        | `5`                    |
| `output.includeEmptyDirectories` | 저장소 구조에 빈 디렉토리를 포함할지 여부                                                                                  | `false`                |
| `output.git.sortByChanges`       | Git 변경 횟수로 파일을 정렬할지 여부. 변경이 많은 파일이 하단에 표시됩니다                                               | `true`                 |
| `output.git.sortByChangesMaxCommits` | Git 변경을 분석할 때 분석할 최대 커밋 수. 성능을 위해 이력 깊이를 제한합니다                                         | `100`                  |
| `output.git.includeDiffs`        | 출력에 Git 차이를 포함할지 여부. 작업 트리와 스테이징된 변경 사항을 별도로 표시합니다                                    | `false`                |
| `include`                        | 포함할 파일 패턴([glob 패턴](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax) 사용)                 | `[]`                   |
| `ignore.useGitignore`            | 프로젝트의 `.gitignore` 파일의 패턴을 사용할지 여부                                                                        | `true`                 |
| `ignore.useDefaultPatterns`      | 기본 무시 패턴(node_modules, .git 등)을 사용할지 여부                                                                     | `true`                 |
| `ignore.customPatterns`          | 추가 무시 패턴([glob 패턴](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax) 사용)                   | `[]`                   |
| `security.enableSecurityCheck`   | Secretlint를 사용하여 민감한 정보를 감지하는 보안 검사를 수행할지 여부                                                    | `true`                 |
| `tokenCount.encoding`            | OpenAI의 [tiktoken](https://github.com/openai/tiktoken) 토크나이저가 사용하는 토큰 카운트 인코딩. GPT-4o는 `o200k_base`, GPT-4/3.5는 `cl100k_base`를 사용. 자세한 내용은 [tiktoken model.py](https://github.com/openai/tiktoken/blob/main/tiktoken/model.py#L24) 참조 | `"o200k_base"`         |

설정 파일은 [JSON5](https://json5.org/) 구문을 지원하며, 다음을 허용합니다:
- 주석(한 줄 및 여러 줄)
- 객체와 배열의 후행 쉼표
- 따옴표 없는 속성 이름
- 더 유연한 문자열 구문

## 스키마 유효성 검사

`$schema` 속성을 추가하여 설정 파일에 대한 스키마 유효성 검사를 활성화할 수 있습니다:

```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "output": {
    "filePath": "repomix-output.md",
    "style": "markdown"
  }
}
```

이렇게 하면 JSON 스키마를 지원하는 편집기에서 자동 완성 및 유효성 검사 기능을 제공합니다.

## 설정 파일 예시

다음은 전체 설정 파일(`repomix.config.json`)의 예시입니다:

```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 50000000
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "compress": false,
    "headerText": "패키지된 파일의 사용자 정의 헤더 정보",
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "includeEmptyDirectories": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false
    }
  },
  "include": ["**/*"],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    // 패턴은 .repomixignore에서도 지정할 수 있습니다
    "customPatterns": [
      "additional-folder",
      "**/*.log"
    ],
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
```

## 설정 파일 위치

Repomix는 다음 순서로 설정 파일을 찾습니다:
1. 현재 디렉토리의 로컬 설정 파일(`repomix.config.json`)
2. 전역 설정 파일:
   - Windows: `%LOCALAPPDATA%\Repomix\repomix.config.json`
   - macOS/Linux: `~/.config/repomix/repomix.config.json`

명령줄 옵션은 설정 파일의 설정보다 우선합니다.

## 무시 패턴

Repomix는 무시할 파일을 지정하는 여러 방법을 제공합니다. 패턴은 다음 우선 순위로 처리됩니다:

1. CLI 옵션(`--ignore`)
2. 프로젝트 디렉토리의 `.repomixignore` 파일
3. `.gitignore` 및 `.git/info/exclude`(`ignore.useGitignore`가 true인 경우)
4. 기본 패턴(`ignore.useDefaultPatterns`가 true인 경우)

`.repomixignore` 예시:
```text
# 캐시 디렉토리
.cache/
tmp/

# 빌드 출력
dist/
build/

# 로그
*.log
```

## 기본 무시 패턴

`ignore.useDefaultPatterns`가 true일 때 Repomix는 다음과 같은 일반적인 패턴을 자동으로 무시합니다:
```text
node_modules/**
.git/**
coverage/**
dist/**
```

전체 목록은 [defaultIgnore.ts](https://github.com/yamadashy/repomix/blob/main/src/config/defaultIgnore.ts)를 참조하세요.

## 고급 기능

### 코드 압축

코드 압축 기능(`output.compress: true`로 활성화)은 [Tree-sitter](https://github.com/tree-sitter/tree-sitter)를 사용하여 구현 세부 사항을 제거하면서 필수 코드 구조를 지능적으로 추출합니다. 이는 중요한 구조 정보를 유지하면서 토큰 수를 줄이는 데 도움이 됩니다.

주요 이점:
- 토큰 수를 크게 줄임
- 클래스와 함수 시그니처 유지
- 임포트와 익스포트 유지
- 타입 정의와 인터페이스 유지
- 함수 본문과 구현 세부 사항 제거

자세한 정보와 예시는 [코드 압축 가이드](code-compress)를 참조하세요.

### Git 통합

`output.git` 설정은 강력한 Git 인식 기능을 제공합니다:

- `sortByChanges`: true로 설정하면 파일이 Git 변경 횟수(해당 파일을 수정한 커밋 수)로 정렬됩니다. 변경이 많은 파일이 출력 하단에 나타납니다. 이는 더 활발하게 개발되는 파일을 우선시하는 데 도움이 됩니다. 기본값: `true`
- `sortByChangesMaxCommits`: 파일 변경 횟수를 계산할 때 분석할 최대 커밋 수. 기본값: `100`
- `includeDiffs`: true로 설정하면 Git 차이를 출력에 포함합니다(작업 트리와 스테이징된 변경 사항을 별도로 포함). 이를 통해 독자는 저장소의 대기 중인 변경 사항을 볼 수 있습니다. 기본값: `false`

설정 예시:
```json
{
  "output": {
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": true
    }
  }
}
```

### 보안 검사

`security.enableSecurityCheck`가 활성화되면 Repomix는 [Secretlint](https://github.com/secretlint/secretlint)를 사용하여 코드베이스를 출력에 포함하기 전에 민감한 정보를 감지합니다. 이는 다음과 같은 정보의 우발적 노출을 방지하는 데 도움이 됩니다:

- API 키
- 액세스 토큰
- 개인 키
- 비밀번호
- 기타 민감한 자격 증명

### 주석 제거

`output.removeComments`를 `true`로 설정하면 지원되는 파일 유형에서 주석이 제거되어 출력 크기를 줄이고 핵심 코드 내용에 집중할 수 있습니다. 이는 다음과 같은 경우에 특히 유용합니다:

- 많은 문서화가 된 코드 처리
- 토큰 수 줄이기 시도
- 코드 구조와 로직에 집중

지원되는 언어와 자세한 예시는 [주석 제거 가이드](comment-removal)를 참조하세요.
</file>

<file path="website/client/src/ko/guide/custom-instructions.md">
# 사용자 정의 지시사항

Repomix는 출력 파일에 포함될 사용자 정의 지시사항을 제공할 수 있게 해줍니다. 이는 AI 시스템이 프로젝트의 특정 맥락이나 요구 사항을 이해하는 데 도움이 됩니다.

## 사용법

사용자 정의 지시사항을 포함하려면 저장소의 루트에 마크다운 파일(예: `repomix-instruction.md`)을 생성하고, `repomix.config.json`에서 해당 파일의 경로를 지정하세요:

```json
{
  "output": {
    "instructionFilePath": "repomix-instruction.md"
  }
}
```

이 파일의 내용은 출력의 "Instruction" 섹션에 포함됩니다.

## 사용 예시

```markdown
# 코딩 지침

- Airbnb JavaScript 스타일 가이드를 따르세요.
- 필요한 경우 파일을 더 작은 단위로 분할하세요.
- 불분명한 로직에는 주석을 추가하세요. 모든 텍스트는 영어로 작성하세요.
- 모든 새로운 기능에 대해 해당 단위 테스트를 작성하세요.

## 생성된 콘텐츠에 대하여

- 특별한 지정이 없는 한, 모든 콘텐츠를 생략 없이 포함하세요.
- 대규모 코드베이스를 처리할 때도 출력 품질을 유지하세요.
```

이는 출력 파일에서 다음과 같이 표시됩니다:

```xml
<instruction>
# 코딩 가이드라인

- Airbnb JavaScript 스타일 가이드를 따릅니다
- 필요한 경우 파일을 작은 단위로 분할합니다
- 명확하지 않은 로직에는 주석을 추가합니다. 모든 텍스트는 영어로 작성합니다
- 모든 새로운 기능에는 해당하는 단위 테스트를 작성합니다

## 생성 내용에 대해

- 특별한 지정이 없는 한, 모든 내용은 축약하지 않고 포함합니다
- 대규모 코드베이스를 처리하면서도 출력의 품질을 유지합니다
</instruction>
```

## 모범 사례

1. **간결하고 명확하게**: 지시사항은 간결하되, 필요한 세부 사항은 모두 포함해야 합니다.
2. **구체적인 예시 제공**: 적절한 경우 코드 예시를 사용하여 설명을 보완합니다.
3. **우선순위 설정**: 가장 중요한 지시사항을 문서 앞부분에 배치하여 강조합니다.
4. **맥락 포함**: 프로젝트의 배경과 중요한 고려사항을 제공하여 AI가 작업을 더 잘 이해하도록 돕습니다.
5. **구조화된 콘텐츠**: 제목과 목록을 사용하여 지시사항을 체계적으로 구성하고 가독성을 높입니다.

## 주의 사항

- 지시사항에 민감한 정보를 포함하지 마세요
- 프로젝트의 변화를 반영하여 정기적으로 지시사항을 업데이트하세요
- 지시사항이 프로젝트의 다른 문서와 일관성을 유지하도록 하세요
- 명확한 계층 구조를 사용하여 콘텐츠를 구성하세요
</file>

<file path="website/client/src/ko/guide/github-actions.md">
# GitHub Actions에서 Repomix 사용하기

GitHub Actions 워크플로우에 Repomix를 통합하면 AI 분석을 위한 코드베이스 패킹을 자동화할 수 있습니다. 이는 CI, 코드 리뷰, LLM 도구 준비 등에 유용합니다.

## 기본 사용법

다음 스텝을 워크플로우 YAML에 추가하여 저장소를 패킹할 수 있습니다.

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.xml
```

## 다양한 출력 형식 사용하기

`style` 매개변수를 사용하여 다양한 출력 형식을 지정할 수 있습니다(기본값은 `xml`):

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.md
    style: markdown
```

## 여러 디렉터리 및 압축 옵션

여러 디렉터리, include/exclude 패턴, 스마트 압축도 지정할 수 있습니다.

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src tests
    include: "**/*.ts,**/*.md"
    ignore: "**/*.test.ts"
    output: repomix-output.txt
    compress: true
```

## 출력 파일을 아티팩트로 업로드

생성된 파일을 후속 스텝이나 다운로드용으로 업로드하는 예시입니다.

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src
    output: repomix-output.xml
    compress: true

- name: Upload Repomix output
  uses: actions/upload-artifact@v4
  with:
    name: repomix-output
    path: repomix-output.xml
```

## Action 입력 파라미터

| 이름                | 설명                                   | 기본값           |
|---------------------|----------------------------------------|------------------|
| `directories`       | 패킹할 디렉터리(공백 구분)             | `.`              |
| `include`           | 포함할 glob 패턴(쉼표 구분)            | `""`           |
| `ignore`            | 제외할 glob 패턴(쉼표 구분)            | `""`           |
| `output`            | 출력 파일 경로                          | `repomix-output.xml`    |
| `style`             | 출력 스타일 (xml, markdown, plain)      | `xml`            |
| `compress`          | 스마트 압축 활성화                      | `true`           |
| `additional-args`   | repomix CLI에 전달할 추가 인자          | `""`           |
| `repomix-version`   | 설치할 npm 패키지 버전                  | `latest`         |

## Action 출력

| 이름           | 설명                   |
|----------------|------------------------|
| `output_file`  | 생성된 출력 파일 경로   |

## 전체 워크플로우 예시

Repomix를 사용하는 GitHub Actions 워크플로우 전체 예시입니다.

```yaml
name: Pack repository with Repomix

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  pack-repo:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Pack repository with Repomix
        uses: yamadashy/repomix/.github/actions/repomix@main
        with:
          output: repomix-output.xml

      - name: Upload Repomix output
        uses: actions/upload-artifact@v4
        with:
          name: repomix-output.xml
          path: repomix-output.xml
          retention-days: 30
```

[전체 워크플로우 예시](https://github.com/yamadashy/repomix/blob/main/.github/workflows/pack-repository.yml)를 확인할 수 있습니다.
</file>

<file path="website/client/src/ko/guide/index.md">
# Repomix 시작하기

<script setup>
import HomeBadges from '../../../components/HomeBadges.vue'
import YouTubeVideo from '../../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../../utils/videos'
</script>

Repomix는 전체 저장소를 AI 친화적인 단일 파일로 패키징하는 도구입니다. ChatGPT, DeepSeek, Perplexity, Gemini, Gemma, Llama, Grok 등의 대규모 언어 모델(LLM)에 코드베이스를 제공하는 데 도움이 되도록 설계되었습니다.

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

<HomeBadges />

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## 빠른 시작

프로젝트 디렉토리에서 다음 명령을 실행하세요.

```bash
npx repomix
```

이게 전부입니다! AI 친화적인 형식으로 전체 저장소를 포함하는 `repomix-output.xml` 파일이 생성됩니다.

그런 다음 이 파일을 다음과 같은 프롬프트와 함께 AI 어시스턴트에 보낼 수 있습니다.

```
이 파일에는 저장소의 모든 파일이 하나로 결합되어 있습니다.
코드를 리팩터링하고 싶으니 먼저 검토해 주세요.
```

AI는 전체 코드베이스를 분석하고 포괄적인 인사이트를 제공합니다.

![Repomix 파일 사용 예시 1](/images/docs/repomix-file-usage-1.png)

특정 변경 사항을 논의할 때 AI가 코드 생성을 도울 수 있습니다. Claude의 Artifacts와 같은 기능을 사용하면 상호 의존적인 여러 파일을 받을 수도 있습니다.

![Repomix 파일 사용 예시 2](/images/docs/repomix-file-usage-2.png)

즐거운 코딩 되세요! 🚀

## 핵심 기능

- **AI 최적화 출력**: AI 처리에 용이한 형식으로 코드베이스를 구성합니다.
- **토큰 계산**: LLM 컨텍스트 제한을 위한 토큰 사용량을 추적합니다.
- **Git 인식**: `.gitignore` 파일과 `.git/info/exclude` 파일을 존중합니다.
- **보안 중심**: 민감한 정보를 탐지합니다.
- **다양한 출력 형식**: 일반 텍스트, XML, Markdown 중에서 선택할 수 있습니다.

## 다음 단계

- [설치 가이드](installation.md): Repomix를 설치하는 다양한 방법
- [사용 가이드](usage.md): 기본 및 고급 기능에 대해 알아보기
- [구성](configuration.md): 필요에 맞게 Repomix를 사용자 정의하기
- [보안 기능](security.md): 보안 검사에 대해 알아보기

## 커뮤니티

[Discord 커뮤니티](https://discord.gg/wNYzTwZFku)에 참여하세요:
- Repomix에 대한 도움 받기
- 경험 공유
- 새로운 기능 제안
- 다른 사용자와 소통

## 지원

버그를 발견했거나 도움이 필요하신가요?
- [GitHub에 이슈 열기](https://github.com/yamadashy/repomix/issues)
- Discord 서버에 참여하기
- [문서 확인하기](https://repomix.com)
</file>

<file path="website/client/src/ko/guide/installation.md">
# 설치

## npx 사용 (설치 불필요)

```bash
npx repomix
```

## 전역 설치

### npm
```bash
npm install -g repomix
```

### Yarn
```bash
yarn global add repomix
```

### Bun
```bash
bun add -g repomix
```

### Homebrew (macOS/Linux)
```bash
brew install repomix
```

## Docker 설치

Docker를 사용하면 환경 설정 문제를 피할 수 있어 가장 편리한 방법 중 하나입니다. 아래와 같이 실행하세요:

```bash
# 현재 디렉토리 처리
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix

# 특정 디렉토리 처리
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory

# 원격 저장소 처리
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote yamadashy/repomix
```

## VSCode 확장 프로그램

커뮤니티에서 관리하는 [Repomix Runner](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner) 확장 프로그램을 통해 VSCode에서 직접 Repomix를 실행할 수 있습니다.

기능:
- 몇 번의 클릭으로 폴더 패키징
- 파일 또는 콘텐츠 모드로 복사
- 출력 파일 자동 정리
- repomix.config.json 지원

[VSCode 마켓플레이스](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner)에서 설치하세요.

## 브라우저 확장 프로그램

GitHub 저장소에서 직접 Repomix에 액세스하세요! Chrome 확장 프로그램이 GitHub 저장소 페이지에 편리한 "Repomix" 버튼을 추가합니다.

![Repomix Browser Extension](/images/docs/browser-extension.png)

### 설치
- Chrome 확장 프로그램: [Repomix - Chrome Web Store](https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa)
- Firefox 애드온: [Repomix - Firefox Add-ons](https://addons.mozilla.org/firefox/addon/repomix/)

### 기능
- GitHub 저장소에서 원클릭으로 Repomix 액세스
- 더 많은 흥미로운 기능이 곧 출시됩니다!

## 시스템 요구 사항

- Node.js: 18.0.0 이상
- Git: 원격 저장소 처리 시 필요

## 설치 확인

설치가 완료된 후, 다음 명령어로 Repomix가 정상적으로 작동하는지 확인하세요:

```bash
repomix --version
repomix --help
```
</file>

<file path="website/client/src/ko/guide/mcp-server.md">
# MCP 서버

Repomix는 [Model Context Protocol (MCP)](https://modelcontextprotocol.io)를 지원하며, AI 어시스턴트가 코드베이스와 직접 상호작용할 수 있게 해줍니다. MCP 서버로 실행하면 Repomix는 AI 어시스턴트가 수동 파일 준비 없이 로컬 또는 원격 저장소를 분석용으로 패키징할 수 있는 도구를 제공합니다.

> [!NOTE]  
> 이것은 실험적인 기능으로, 사용자 피드백과 실제 사용 사례를 바탕으로 지속적으로 개선해 나갈 예정입니다

## Repomix를 MCP 서버로 실행하기

Repomix를 MCP 서버로 실행하려면 `--mcp` 플래그를 사용하세요:

```bash
repomix --mcp
```

이렇게 하면 Repomix가 MCP 서버 모드로 시작되어 Model Context Protocol을 지원하는 AI 어시스턴트에서 사용할 수 있게 됩니다.

## MCP 서버 구성하기

Claude와 같은 AI 어시스턴트와 함께 Repomix를 MCP 서버로 사용하려면 MCP 설정을 구성해야 합니다:

### VS Code의 경우

VS Code에 Repomix MCP 서버를 설치하는 방법은 다음과 같습니다:

1. **설치 배지 사용:**

  [![Install in VS Code](https://img.shields.io/badge/VS_Code-VS_Code?style=flat-square&label=Install%20Server&color=0098FF)](vscode:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)<br>
  [![Install in VS Code Insiders](https://img.shields.io/badge/VS_Code_Insiders-VS_Code_Insiders?style=flat-square&label=Install%20Server&color=24bfa5)](vscode-insiders:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)

2. **명령줄 사용:**

  ```bash
  code --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

  VS Code Insiders의 경우:
  ```bash
  code-insiders --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

### Cline(VS Code 확장)의 경우

`cline_mcp_settings.json` 파일을 편집하세요:

```json
{
  "mcpServers": {
    "repomix": {
      "command": "npx",
      "args": [
        "-y",
        "repomix",
        "--mcp"
      ]
    }
  }
}
```

### Cursor의 경우

Cursor에서는 `Cursor Settings` > `MCP` > `+ Add new global MCP server`에서 Cline과 유사한 설정을 추가하세요.

### Claude Desktop의 경우

Cline의 구성과 유사하게 `claude_desktop_config.json` 파일을 편집하세요.

### Claude Code의 경우

[Claude Code](https://docs.anthropic.com/en/docs/claude-code/overview)에서 Repomix를 MCP 서버로 구성하려면 다음 명령어를 사용하세요:

```bash
claude mcp add repomix -- npx -y repomix --mcp
```

### npx 대신 Docker 사용

npx 대신 Docker를 사용하여 Repomix를 MCP 서버로 실행할 수 있습니다:

```json
{
  "mcpServers": {
    "repomix-docker": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "ghcr.io/yamadashy/repomix",
        "--mcp"
      ]
    }
  }
}
```

## 사용 가능한 MCP 도구

MCP 서버로 실행할 때 Repomix는 다음 도구를 제공합니다:

### pack_codebase

이 도구는 로컬 코드 디렉토리를 AI 분석용 XML 파일로 패키징합니다. 코드베이스 구조를 분석하고 관련 코드 내용을 추출하여 메트릭, 파일 트리, 포맷된 코드 내용을 포함한 포괄적인 보고서를 생성합니다.

**매개변수:**
- `directory`: (필수) 패키징할 디렉토리의 절대 경로
- `compress`: (선택, 기본값: false) 구현 세부사항을 제거하면서 필수 코드 시그니처와 구조를 추출하는 Tree-sitter 압축을 활성화합니다. 의미론적 의미를 유지하면서 토큰 사용량을 ~70% 줄입니다. grep_repomix_output이 점진적 콘텐츠 검색을 가능하게 하므로 일반적으로 필요하지 않습니다. 대형 저장소의 전체 코드베이스 내용이 특별히 필요한 경우에만 사용하세요.
- `includePatterns`: (선택) fast-glob 패턴을 사용하여 포함할 파일을 지정합니다. 여러 패턴은 쉼표로 구분할 수 있습니다(예: "**/*.{js,ts}", "src/**,docs/**"). 일치하는 파일만 처리됩니다.
- `ignorePatterns`: (선택) fast-glob 패턴을 사용하여 제외할 추가 파일을 지정합니다. 여러 패턴은 쉼표로 구분할 수 있습니다(예: "test/**,*.spec.js", "node_modules/**,dist/**"). 이러한 패턴은 .gitignore와 내장 제외를 보완합니다.
- `topFilesLength`: (선택, 기본값: 10) 코드베이스 분석을 위한 메트릭 요약에 표시할 크기별 최대 파일 수입니다.

**예시:**
```json
{
  "directory": "/path/to/your/project",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### pack_remote_repository

이 도구는 GitHub 저장소를 가져와 클론하고 AI 분석용 XML 파일로 패키징합니다. 원격 저장소를 자동으로 클론하고 구조를 분석하여 포괄적인 보고서를 생성합니다.

**매개변수:**
- `remote`: (필수) GitHub 저장소 URL 또는 사용자/저장소 형식(예: "yamadashy/repomix", "https://github.com/user/repo", 또는 "https://github.com/user/repo/tree/branch")
- `compress`: (선택, 기본값: false) 구현 세부사항을 제거하면서 필수 코드 시그니처와 구조를 추출하는 Tree-sitter 압축을 활성화합니다. 의미론적 의미를 유지하면서 토큰 사용량을 ~70% 줄입니다. grep_repomix_output이 점진적 콘텐츠 검색을 가능하게 하므로 일반적으로 필요하지 않습니다. 대형 저장소의 전체 코드베이스 내용이 특별히 필요한 경우에만 사용하세요.
- `includePatterns`: (선택) fast-glob 패턴을 사용하여 포함할 파일을 지정합니다. 여러 패턴은 쉼표로 구분할 수 있습니다(예: "**/*.{js,ts}", "src/**,docs/**"). 일치하는 파일만 처리됩니다.
- `ignorePatterns`: (선택) fast-glob 패턴을 사용하여 제외할 추가 파일을 지정합니다. 여러 패턴은 쉼표로 구분할 수 있습니다(예: "test/**,*.spec.js", "node_modules/**,dist/**"). 이러한 패턴은 .gitignore와 내장 제외를 보완합니다.
- `topFilesLength`: (선택, 기본값: 10) 코드베이스 분석을 위한 메트릭 요약에 표시할 크기별 최대 파일 수입니다.

**예시:**
```json
{
  "remote": "yamadashy/repomix",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### read_repomix_output

이 도구는 Repomix에서 생성된 출력 파일의 내용을 읽습니다. 대용량 파일에 대한 라인 범위 지정을 통한 부분 읽기를 지원합니다. 이 도구는 직접 파일 시스템 접근이 제한된 환경을 위해 설계되었습니다.

**매개변수:**
- `outputId`: (필수) 읽을 Repomix 출력 파일의 ID
- `startLine`: (선택) 시작 라인 번호(1부터 시작, 포함). 지정하지 않으면 처음부터 읽습니다.
- `endLine`: (선택) 끝 라인 번호(1부터 시작, 포함). 지정하지 않으면 끝까지 읽습니다.

**기능:**
- 웹 기반 환경이나 샌드박스 애플리케이션을 위해 특별히 설계됨
- ID를 사용하여 이전에 생성된 출력의 내용을 검색
- 파일 시스템 접근 없이 패키징된 코드베이스에 안전하게 접근 제공
- 대용량 파일의 부분 읽기 지원

**예시:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "startLine": 100,
  "endLine": 200
}
```

### grep_repomix_output

이 도구는 JavaScript RegExp 구문을 사용한 grep 유사 기능으로 Repomix 출력 파일에서 패턴을 검색합니다. 일치하는 라인과 일치 항목 주변의 선택적 컨텍스트 라인을 반환합니다.

**매개변수:**
- `outputId`: (필수) 검색할 Repomix 출력 파일의 ID
- `pattern`: (필수) 검색 패턴(JavaScript RegExp 정규 표현식 구문)
- `contextLines`: (선택, 기본값: 0) 각 일치 항목 전후에 표시할 컨텍스트 라인 수. beforeLines/afterLines가 지정되면 재정의됩니다.
- `beforeLines`: (선택) 각 일치 항목 전에 표시할 컨텍스트 라인 수(grep -B와 같음). contextLines보다 우선합니다.
- `afterLines`: (선택) 각 일치 항목 후에 표시할 컨텍스트 라인 수(grep -A와 같음). contextLines보다 우선합니다.
- `ignoreCase`: (선택, 기본값: false) 대소문자를 구분하지 않는 매칭 수행

**기능:**
- 강력한 패턴 매칭을 위한 JavaScript RegExp 구문 사용
- 일치 항목의 더 나은 이해를 위한 컨텍스트 라인 지원
- 전/후 컨텍스트 라인의 별도 제어 허용
- 대소문자 구분/비구분 검색 옵션

**예시:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "pattern": "function\\s+\\w+\\(",
  "contextLines": 3,
  "ignoreCase": false
}
```

### file_system_read_file 및 file_system_read_directory

Repomix의 MCP 서버는 AI 어시스턴트가 로컬 파일 시스템과 안전하게 상호 작용할 수 있는 두 가지 파일 시스템 도구를 제공합니다:

1. `file_system_read_file`
  - 절대 경로를 사용하여 로컬 파일 시스템에서 파일 내용 읽기
  - 민감한 정보가 포함된 파일에 대한 접근을 감지하고 방지하는 내장 보안 검증 포함
  - [Secretlint](https://github.com/secretlint/secretlint)를 사용한 보안 검증 구현
  - 민감한 정보가 포함된 파일(API 키, 비밀번호, 시크릿)에 대한 접근 방지
  - 디렉토리 순회 공격을 방지하기 위한 절대 경로 검증
  - 잘못된 경로나 보안 문제에 대한 명확한 오류 메시지 반환

2. `file_system_read_directory`
  - 절대 경로를 사용하여 디렉토리의 내용 나열
  - 파일과 하위 디렉토리를 명확한 지표로 표시하는 포맷된 목록 반환
  - 파일과 디렉토리를 명확한 지표(`[FILE]` 또는 `[DIR]`)로 표시
  - 안전한 디렉토리 탐색과 적절한 오류 처리 제공
  - 경로 검증 및 절대 경로 확인
  - 프로젝트 구조 탐색과 코드베이스 조직 이해에 유용

두 도구 모두 강력한 보안 조치를 포함하고 있습니다:
- 디렉토리 순회 공격을 방지하기 위한 절대 경로 검증
- 적절한 접근 권한을 보장하기 위한 권한 검사
- 민감한 정보 감지를 위한 Secretlint 통합
- 디버깅과 보안 인식을 위한 명확한 오류 메시지

**예시:**
```typescript
// 파일 읽기
const fileContent = await tools.file_system_read_file({
  path: '/absolute/path/to/file.txt'
});

// 디렉토리 내용 나열
const dirContent = await tools.file_system_read_directory({
  path: '/absolute/path/to/directory'
});
```

이러한 도구는 AI 어시스턴트가 다음과 같은 작업을 수행해야 할 때 특히 유용합니다:
- 코드베이스의 특정 파일 분석
- 디렉토리 구조 탐색
- 파일 존재 여부 및 접근 가능성 확인
- 안전한 파일 시스템 작업 보장

## Repomix를 MCP 서버로 사용하는 이점

Repomix를 MCP 서버로 사용하면 여러 이점이 있습니다:

1. **직접 통합**: AI 어시스턴트가 수동 파일 준비 없이 코드베이스를 직접 분석할 수 있습니다.
2. **효율적인 워크플로우**: 파일을 수동으로 생성하고 업로드할 필요가 없어 코드 분석 프로세스가 간소화됩니다.
3. **일관된 출력**: AI 어시스턴트가 일관되고 최적화된 형식으로 코드베이스를 받을 수 있습니다.
4. **고급 기능**: 코드 압축, 토큰 카운팅, 보안 검사와 같은 Repomix의 모든 기능을 활용할 수 있습니다.

구성이 완료되면 AI 어시스턴트가 Repomix의 기능을 직접 사용하여 코드베이스를 분석할 수 있어 코드 분석 워크플로우가 더 효율적이 됩니다.
</file>

<file path="website/client/src/ko/guide/output.md">
# 출력 형식

Repomix는 세 가지 출력 형식을 지원합니다:
- XML (기본값)
- Markdown
- 일반 텍스트

## XML 형식

```bash
repomix --style xml
```

XML 형식은 AI 처리에 최적화되어 있습니다:

```xml
이 파일은 전체 코드베이스를 하나의 문서로 통합한 것입니다...

<file_summary>
(메타데이터 및 AI 지시사항)
</file_summary>

<directory_structure>
src/
  index.ts
  utils/
    helper.ts
</directory_structure>

<files>
<file path="src/index.ts">
// 파일 내용
</file>
</files>
```

::: tip XML을 사용하는 이유
XML 태그는 Claude와 같은 AI 모델이 내용을 더 정확하게 파싱하는 데 도움이 됩니다. [Claude 공식 문서](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags)에서는 구조화된 프롬프트에 XML 태그 사용을 권장하고 있습니다.
:::

## Markdown 형식

```bash
repomix --style markdown
```

Markdown은 읽기 쉬운 형식을 제공합니다:

```markdown
이 파일은 전체 코드베이스를 하나의 문서로 통합한 것입니다...

# 파일 요약
(메타데이터 및 AI 지시사항)

# 디렉토리 구조
```
src/
index.ts
utils/
helper.ts
```

# 파일

## File: src/index.ts
```typescript
// 파일 내용
```
```

## AI 모델과의 사용

각 형식은 AI 모델에서 잘 작동하지만, 다음 사항을 고려하세요:
- Claude에는 XML 사용 (가장 정확한 파싱)
- 일반적인 가독성을 위해서는 Markdown
- 단순성과 호환성을 위해서는 일반 텍스트

## 사용자 정의

`repomix.config.json`에서 기본 형식 설정:
```json
{
  "output": {
    "style": "xml",
    "filePath": "output.xml"
  }
}
```

## 일반 텍스트 형식

```bash
repomix --style plain
```

출력 구조:
```text
이 파일은 전체 코드베이스를 하나의 문서로 통합한 것입니다...

================
파일 요약
================
(메타데이터 및 AI 지시사항)

================
디렉토리 구조
================
src/
  index.ts
  utils/
    helper.ts

================
파일
================

================
File: src/index.ts
================
// 파일 내용
```
</file>

<file path="website/client/src/ko/guide/prompt-examples.md">
# 프롬프트 예시

## 코드 리뷰

### 아키텍처 리뷰
```
이 코드베이스의 아키텍처를 분석하세요:
1. 전체 구조와 패턴을 평가
2. 잠재적인 아키텍처 문제 식별
3. 확장성을 위한 개선 사항 제안
4. 모범 사례를 따르는 영역 기록

유지보수성과 모듈성에 중점을 두세요.
```

### 보안 리뷰
```
이 코드베이스의 보안 검토를 수행하세요:
1. 잠재적인 보안 취약점 식별
2. 일반적인 보안 안티패턴 확인
3. 오류 처리 및 입력 유효성 검사 검토
4. 의존성 보안 평가

구체적인 예시와 해결 단계를 제공하세요.
```

### 성능 리뷰
```
코드베이스의 성능을 검토하세요:
1. 성능 병목 현상 식별
2. 리소스 사용량 확인
3. 알고리즘 효율성 검토
4. 캐싱 전략 평가

구체적인 최적화 권장 사항을 포함하세요.
```

## 문서 생성

### API 문서
```
포괄적인 API 문서를 생성하세요:
1. 모든 공개 엔드포인트 나열 및 설명
2. 요청/응답 형식 문서화
3. 사용 예시 포함
4. 제한 사항 기록
```

### 개발자 가이드
```
다음 내용을 포함하는 개발자 가이드를 작성하세요:
1. 설정 지침
2. 프로젝트 구조 개요
3. 개발 워크플로우
4. 테스트 접근 방식
5. 일반적인 문제 해결 단계
```

### 아키텍처 문서
```
시스템 아키텍처를 문서화하세요:
1. 상위 수준 개요
2. 컴포넌트 상호 작용
3. 데이터 흐름 다이어그램
4. 설계 결정 및 근거
5. 시스템 제약 사항 및 한계
```

## 분석 및 개선

### 의존성 분석
```
프로젝트 의존성을 분석하세요:
1. 오래된 패키지 식별
2. 보안 취약점 확인
3. 대체 패키지 제안
4. 의존성 사용 패턴 검토

구체적인 업그레이드 권장 사항을 포함하세요.
```

### 테스트 커버리지
```
테스트 커버리지를 검토하세요:
1. 테스트되지 않은 컴포넌트 식별
2. 추가 테스트 케이스 제안
3. 테스트 품질 검토
4. 테스트 전략 권장
```

### 코드 품질
```
코드 품질을 평가하고 개선 사항을 제안하세요:
1. 명명 규칙 검토
2. 코드 구성 확인
3. 오류 처리 평가
4. 주석 작성 관행 검토

좋은 패턴과 문제가 있는 패턴의 구체적인 예시를 제공하세요.
```

## 더 나은 결과를 위한 팁

1. **구체적으로 작성**: 명확한 목표와 평가 기준을 포함하세요
2. **컨텍스트 설정**: 귀하의 역할과 필요한 전문성 수준을 지정하세요
3. **응답 형식**: 원하는 응답 구조를 정의하세요
4. **우선순위 지정**: 가장 중요한 측면을 표시하세요

## 모델별 참고 사항

### Claude
- XML 출력 형식 사용
- 중요한 지시사항을 마지막에 배치
- 응답 구조 지정

### ChatGPT
- 마크다운 형식 사용
- 큰 코드베이스를 섹션으로 분할
- 시스템 역할 프롬프트 사용

### Gemini
- 모든 형식과 호환
- 요청당 특정 영역에 집중
- 단계별 분석 사용
</file>

<file path="website/client/src/ko/guide/remote-repository-processing.md">
# 원격 저장소 처리

## 기본 사용법

공개 저장소 처리:
```bash
# 전체 URL 사용
repomix --remote https://github.com/user/repo

# GitHub 단축형 사용
repomix --remote user/repo
```

## 브랜치 및 커밋 선택

```bash
# 특정 브랜치
repomix --remote user/repo --remote-branch main

# 태그
repomix --remote user/repo --remote-branch v1.0.0

# 커밋 해시
repomix --remote user/repo --remote-branch 935b695
```

## 요구 사항

- Git이 설치되어 있어야 함
- 인터넷 연결
- 저장소에 대한 읽기 권한

## 출력 제어

```bash
# 사용자 지정 출력 위치
repomix --remote user/repo -o custom-output.xml

# XML 형식 사용
repomix --remote user/repo --style xml

# 주석 제거
repomix --remote user/repo --remove-comments
```

## Docker 사용

```bash
# 현재 디렉토리에서 처리 및 출력
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo

# 특정 디렉토리에 출력
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo
```

## 일반적인 문제

### 접근 문제
- 저장소가 공개되어 있는지 확인
- Git 설치 확인
- 인터넷 연결 확인

### 대용량 저장소
- `--include`를 사용하여 특정 경로 선택
- `--remove-comments` 활성화
- 브랜치별로 개별 처리
</file>

<file path="website/client/src/ko/guide/security.md">
# 보안

## 보안 검사 기능

Repomix는 [Secretlint](https://github.com/secretlint/secretlint)를 사용하여 파일 내의 민감한 정보를 감지합니다:
- API 키
- 액세스 토큰
- 인증 정보
- 개인 키
- 환경 변수

## 설정

보안 검사는 기본적으로 활성화되어 있습니다.

명령행에서 비활성화:
```bash
repomix --no-security-check
```

또는 `repomix.config.json`에서 설정:
```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

## 보안 조치

1. **바이너리 파일 제외**: 출력에 바이너리 파일이 포함되지 않음
2. **Git 인식**: `.gitignore` 패턴을 준수
3. **자동 감지**: 다음과 같은 일반적인 보안 문제를 스캔:
    - AWS 자격 증명
    - 데이터베이스 연결 문자열
    - 인증 토큰
    - 개인 키

## 보안 검사에서 문제가 발견된 경우

출력 예시:
```bash
🔍 Security Check:
──────────────────
2 suspicious file(s) detected and excluded:
1. config/credentials.json
  - Found AWS access key
2. .env.local
  - Found database password
```

## 모범 사례

1. 공유하기 전에 반드시 출력 내용 검토
2. `.repomixignore`를 사용하여 민감한 경로 제외
3. 보안 검사 기능 활성화 유지
4. 저장소에서 민감한 파일 제거

## 보안 문제 보고

보안 취약점을 발견하셨다면:
1. 공개 이슈를 생성하지 마세요
2. 이메일: koukun0120@gmail.com
3. 또는 [GitHub 보안 권고](https://github.com/yamadashy/repomix/security/advisories/new) 사용
</file>

<file path="website/client/src/ko/guide/usage.md">
# 기본 사용법

## 빠른 시작

저장소 전체를 패키징:
```bash
repomix
```

## 일반적인 사용 사례

### 특정 디렉토리 패키징
```bash
repomix path/to/directory
```

### 특정 파일 포함
[glob 패턴](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax) 사용:
```bash
repomix --include "src/**/*.ts,**/*.md"
```

### 파일 제외
```bash
repomix --ignore "**/*.log,tmp/"
```

### 원격 저장소 처리
```bash
# GitHub URL 사용
repomix --remote https://github.com/user/repo

# 단축형 사용
repomix --remote user/repo

# 특정 브랜치/태그/커밋
repomix --remote user/repo --remote-branch main
repomix --remote user/repo --remote-branch 935b695
```

### 파일 목록 입력 (stdin)

최고의 유연성을 위해 stdin을 통해 파일 경로를 전달하세요:

```bash
# find 명령 사용
find src -name "*.ts" -type f | repomix --stdin

# git을 사용하여 추적된 파일 가져오기
git ls-files "*.ts" | repomix --stdin

# glob 패턴과 함께 ls 사용
ls src/**/*.ts | repomix --stdin

# 파일 경로가 포함된 파일에서
cat file-list.txt | repomix --stdin

# echo로 직접 입력
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```

`--stdin` 옵션을 사용하면 파일 경로 목록을 Repomix로 파이프할 수 있어 패킹할 파일 선택에 최고의 유연성을 제공합니다.

> [!NOTE]
> `--stdin`을 사용할 때 파일 경로는 상대 경로 또는 절대 경로가 될 수 있으며, Repomix가 자동으로 경로 해석과 중복 제거를 처리합니다.

### 파일 목록 입력 (stdin)

최대한의 유연성을 위해 stdin을 통해 파일 경로를 전달하세요:

```bash
# find 명령어 사용
find src -name "*.ts" -type f | repomix --stdin

# git을 사용하여 추적된 파일 가져오기
git ls-files "*.ts" | repomix --stdin

# glob 패턴과 함께 ls 사용
ls src/**/*.ts | repomix --stdin

# 파일 경로가 포함된 파일에서
cat file-list.txt | repomix --stdin

# echo를 사용한 직접 입력
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```

`--stdin` 옵션을 사용하면 파일 경로 목록을 Repomix에 파이프할 수 있어 패킹할 파일을 선택하는 데 최대한의 유연성을 제공합니다.

> [!NOTE]
> `--stdin` 사용 시 파일 경로는 상대 경로 또는 절대 경로일 수 있으며, Repomix가 자동으로 경로 해석과 중복 제거를 처리합니다.

## 출력 형식

### XML (기본값)
```bash
repomix --style xml
```

### Markdown
```bash
repomix --style markdown
```

### 일반 텍스트
```bash
repomix --style plain
```

## 추가 옵션

### 주석 제거
```bash
repomix --remove-comments
```

### 행 번호 표시
```bash
repomix --output-show-line-numbers
```

### 클립보드에 복사
```bash
repomix --copy
```

### 보안 검사 비활성화
```bash
repomix --no-security-check
```

## 설정

설정 파일 초기화:
```bash
repomix --init
```

더 자세한 설정 옵션은 [설정 가이드](/ko/guide/configuration)를 참조하세요.
</file>

<file path="website/client/src/ko/index.md">
---
layout: home
title: Repomix
titleTemplate: 코드베이스를 AI 친화적인 형식으로 패키징
aside: false
editLink: false

features:
  - icon: 🤖
    title: AI 최적화
    details: 코드베이스를 AI가 이해하고 처리하기 쉬운 형식으로 변환합니다.

  - icon: ⚙️
    title: Git 인식
    details: .gitignore 파일을 자동으로 인식하고 처리합니다.

  - icon: 🛡️
    title: 보안 중심
    details: Secretlint를 통합하여 민감한 정보를 감지하고 보호합니다.

  - icon: 📊
    title: 토큰 카운팅
    details: LLM 컨텍스트 제한을 위한 파일별 및 전체 토큰 수를 제공합니다.

---

<script setup>
import YouTubeVideo from '../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../utils/videos'
</script>

<div class="cli-section">

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## 🏆 오픈소스 어워드 후보 지명

영광입니다! Repomix가 [JSNation Open Source Awards 2025](https://osawards.com/javascript/)의 **Powered by AI** 카테고리에 후보로 지명되었습니다.

이는 Repomix를 사용하고 지원해 주신 여러분 모두 덕분입니다. 감사합니다!

Repomix가 AI 도구를 위한 코드베이스 분석이나 패키징에 도움이 되었다면, **Powered by AI** 카테고리에서 저희에게 투표해 주시면 감사하겠습니다.

## Repomix란 무엇인가요?

Repomix는 전체 코드베이스를 하나의 AI 친화적 파일로 패키징하는 강력한 도구입니다. 코드 리뷰, 리팩터링 또는 프로젝트에 대한 AI 지원이 필요할 때, 전체 리포지토리 컨텍스트를 AI 도구와 쉽게 공유할 수 있습니다.

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

## 빠른 시작

Repomix를 사용하여 패키지 파일(`repomix-output.xml`)을 생성한 후, 다음과 같은 프롬프트와 함께 AI 어시스턴트(예: ChatGPT, Claude)에게 전송할 수 있습니다:

```
이 파일은 저장소의 모든 파일을 하나로 통합한 것입니다.
코드를 리팩터링하고 싶으니 먼저 검토해 주세요.
```

AI는 전체 코드베이스를 분석하고 포괄적인 인사이트를 제공할 것입니다:

![Repomix 사용 예시 1](/images/docs/repomix-file-usage-1.png)

구체적인 변경 사항을 논의할 때는 AI가 코드 생성을 도와줍니다. Claude의 Artifacts와 같은 기능을 사용하면 상호 의존적인 여러 파일도 한 번에 받을 수 있습니다:

![Repomix 사용 예시 2](/images/docs/repomix-file-usage-2.png)

즐거운 코딩 되세요! 🚀



## CLI 도구 사용하기 {#using-the-cli-tool}

Repomix는 강력한 기능과 사용자 정의 옵션을 제공하는 명령줄 도구로 사용할 수 있습니다.

**CLI 도구는 프라이빗 저장소에 접근할 수 있습니다** 로컬에 설치된 Git을 사용하기 때문입니다.

### 빠른 시작

프로젝트 디렉토리에서 설치 없이 바로 Repomix를 시작할 수 있습니다:

```bash
npx repomix
```

또는 반복 사용을 위해 전역 설치:

```bash
# npm으로 설치
npm install -g repomix

# 또는 yarn으로 설치
yarn global add repomix

# 또는 bun으로 설치
bun add -g repomix

# 또는 Homebrew로 설치 (macOS/Linux)
brew install repomix

# 그런 다음 아무 프로젝트 디렉토리에서 실행
repomix
```

이게 전부입니다! Repomix가 현재 디렉토리에 `repomix-output.xml` 파일을 생성하며, 이 파일에는 AI 친화적인 형식으로 정리된 전체 코드베이스가 포함됩니다.



### 사용법

전체 저장소를 패키징:

```bash
repomix
```

특정 디렉토리를 패키징:

```bash
repomix path/to/directory
```

[glob 패턴](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)을 사용하여 특정 파일이나 디렉토리를 지정:

```bash
repomix --include "src/**/*.ts,**/*.md"
```

특정 파일이나 디렉토리 제외:

```bash
repomix --ignore "**/*.log,tmp/"
```

원격 저장소 처리:
```bash
# 단축형 사용
npx repomix --remote yamadashy/repomix

# 전체 URL 사용 (브랜치 및 특정 경로 지원)
npx repomix --remote https://github.com/yamadashy/repomix
npx repomix --remote https://github.com/yamadashy/repomix/tree/main

# 커밋 URL 사용
npx repomix --remote https://github.com/yamadashy/repomix/commit/836abcd7335137228ad77feb28655d85712680f1
```

새 설정 파일(`repomix.config.json`) 초기화:

```bash
repomix --init
```

생성된 파일은 Claude, ChatGPT, Gemini와 같은 생성형 AI 도구와 함께 사용할 수 있습니다.

#### Docker 사용법

Docker를 사용하여 Repomix를 실행할 수도 있습니다 🐳  
격리된 환경에서 Repomix를 실행하거나 컨테이너를 선호하는 경우에 유용합니다.

기본 사용법(현재 디렉토리):

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

특정 디렉토리를 처리:
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

원격 저장소를 처리하고 `output` 디렉토리에 출력:

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### 출력 형식

선호하는 출력 형식을 선택하세요:

```bash
# XML 형식(기본값)
repomix --style xml

# Markdown 형식
repomix --style markdown

# 일반 텍스트 형식
repomix --style plain
```

### 사용자 정의

`repomix.config.json`을 생성하여 지속적인 설정을 관리할 수 있습니다:

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

## 파워 유저 가이드

Repomix는 고급 사용 사례를 위한 강력한 기능들을 제공합니다. 파워 유저를 위한 필수 가이드들을 소개합니다:

- **[MCP 서버](./guide/mcp-server)** - AI 어시스턴트를 위한 Model Context Protocol 통합
- **[GitHub Actions](./guide/github-actions)** - CI/CD 워크플로우에서 코드베이스 패키징 자동화
- **[코드 압축](./guide/code-compress)** - Tree-sitter 기반 인텔리전트 압축 (~70% 토큰 감소)
- **[라이브러리로 사용하기](./guide/development/using-repomix-as-a-library)** - Node.js 애플리케이션에 Repomix 통합
- **[커스텀 지시사항](./guide/custom-instructions)** - 출력에 커스텀 프롬프트와 지시사항 추가
- **[보안 기능](./guide/security)** - 내장된 Secretlint 통합 및 안전성 검사
- **[모범 사례](./guide/tips/best-practices)** - 검증된 전략으로 AI 워크플로우 최적화

### 더 많은 예제
::: tip 더 자세한 도움이 필요하신가요? 💡
자세한 사용법은 [가이드](./guide/)를 참조하시고, 더 많은 예제와 소스 코드는 [GitHub 저장소](https://github.com/yamadashy/repomix)에서 확인하실 수 있습니다.
:::

</div>
</file>

<file path="website/client/src/pt-br/guide/development/index.md">
# Contribuindo para o Repomix

Obrigado pelo seu interesse no **Repomix**! 🚀 Adoraríamos sua ajuda para torná-lo ainda melhor. Este guia irá ajudá-lo a começar a contribuir para o projeto.

## Como Contribuir

- **Estrelar o Repositório**: Mostre seu apoio [estrelando o repositório](https://github.com/yamadashy/repomix)!
- **Criar uma Issue**: Encontrou um bug? Tem uma ideia para um novo recurso? Informe-nos [criando uma issue](https://github.com/yamadashy/repomix/issues).
- **Enviar um Pull Request**: Encontrou algo para corrigir ou melhorar? Envie um PR!
- **Espalhar a Palavra**: Compartilhe sua experiência com o Repomix nas redes sociais, blogs ou com sua comunidade de tecnologia.
- **Usar o Repomix**: O melhor feedback vem do uso no mundo real, então sinta-se à vontade para integrar o Repomix em seus próprios projetos!
- **Patrocinar**: Apoie o desenvolvimento do Repomix [tornando-se um patrocinador](https://github.com/sponsors/yamadashy).

## Início Rápido

```bash
git clone https://github.com/yamadashy/repomix.git
cd repomix
npm install
```

## Comandos de Desenvolvimento

```bash
# Executar CLI
npm run repomix

# Executar testes
npm run test
npm run test-coverage

# Lintar código
npm run lint
```

## Estilo de Código

- Use [Biome](https://biomejs.dev/) para lintar e formatar
- Injeção de dependência para testabilidade
- Mantenha os arquivos com menos de 250 linhas
- Adicione testes para novos recursos

## Diretrizes para Pull Requests

1. Execute todos os testes
2. Passe nas verificações de lint
3. Atualize a documentação
4. Siga o estilo de código existente

## Configuração de Desenvolvimento

### Pré-requisitos

- Node.js ≥ 18.0.0
- Git
- npm
- Docker (opcional, para executar o website ou desenvolvimento em contêiner)

### Desenvolvimento Local

Para configurar o Repomix para desenvolvimento local:

```bash
# Clonar repositório
git clone https://github.com/yamadashy/repomix.git
cd repomix

# Instalar dependências
npm install

# Executar CLI
npm run repomix
```

### Desenvolvimento com Docker

Você também pode executar o Repomix usando Docker:

```bash
# Construir imagem
docker build -t repomix .

# Executar contêiner
docker run -v ./:/app -it --rm repomix
```

### Estrutura do Projeto

O projeto está organizado nos seguintes diretórios:

```
src/
├── cli/          # Implementação CLI
├── config/       # Manipulação de configuração
├── core/         # Funcionalidade principal
│   ├── file/     # Manipulação de arquivos
│   ├── metrics/  # Cálculo de métricas
│   ├── output/   # Geração de saída
│   ├── security/ # Verificações de segurança
├── mcp/          # Integração com servidor MCP
└── shared/       # Utilitários compartilhados
tests/            # Testes espelhando a estrutura src/
website/          # Website de documentação
├── client/       # Frontend (VitePress)
└── server/       # API Backend
```

## Desenvolvimento do Website

O website do Repomix é construído com [VitePress](https://vitepress.dev/). Para executar o website localmente:

```bash
# Pré-requisitos: Docker deve estar instalado no seu sistema

# Iniciar o servidor de desenvolvimento do website
npm run website

# Acessar o website em http://localhost:5173/
```

Ao atualizar a documentação, você só precisa atualizar primeiro a versão em inglês. Os mantenedores cuidarão das traduções para outros idiomas.

## Processo de Release

Para mantenedores e contribuidores interessados no processo de release:

1. Atualizar versão
```bash
npm version patch  # ou minor/major
```

2. Executar testes e build
```bash
npm run test-coverage
npm run build
```

3. Publicar
```bash
npm publish
```

Novas versões são gerenciadas pelo mantenedor. Se você acha que um lançamento é necessário, abra uma issue para discutir.

## Precisa de Ajuda?

- [Abra uma issue](https://github.com/yamadashy/repomix/issues)
- [Junte-se ao Discord](https://discord.gg/wNYzTwZFku)
</file>

<file path="website/client/src/pt-br/guide/development/using-repomix-as-a-library.md">
# Usando Repomix como Biblioteca

Além de usar o Repomix como ferramenta CLI, você pode integrar suas funcionalidades diretamente em suas aplicações Node.js.

## Instalação

Instale o Repomix como dependência em seu projeto:

```bash
npm install repomix
```

## Uso Básico

A maneira mais simples de usar o Repomix é através da função `runCli`, que proporciona a mesma funcionalidade da interface de linha de comando:

```javascript
import { runCli, type CliOptions } from 'repomix';

// Processar o diretório atual com opções personalizadas
async function packProject() {
  const options = {
    output: 'output.xml',
    style: 'xml',
    compress: true,
    quiet: true
  } as CliOptions;
  
  const result = await runCli(['.'], process.cwd(), options);
  return result.packResult;
}
```

O `result.packResult` contém informações sobre os arquivos processados, incluindo:
- `totalFiles`: Número de arquivos processados
- `totalCharacters`: Contagem total de caracteres
- `totalTokens`: Contagem total de tokens (útil para limites de contexto de LLM)
- `fileCharCounts`: Contagem de caracteres por arquivo
- `fileTokenCounts`: Contagem de tokens por arquivo

## Processamento de Repositórios Remotos

Você pode clonar e processar um repositório remoto:

```javascript
import { runCli, type CliOptions } from 'repomix';

// Clonar e processar um repositório GitHub
async function processRemoteRepo(repoUrl) {
  const options = {
    remote: repoUrl,
    output: 'output.xml',
    compress: true
  } as CliOptions;
  
  return await runCli(['.'], process.cwd(), options);
}
```

## Usando Componentes Principais

Para maior controle, você pode usar as APIs de baixo nível do Repomix diretamente:

```javascript
import { searchFiles, collectFiles, processFiles, TokenCounter } from 'repomix';

async function analyzeFiles(directory) {
  // Encontrar e coletar arquivos
  const { filePaths } = await searchFiles(directory, { /* configuração */ });
  const rawFiles = await collectFiles(filePaths, directory);
  const processedFiles = await processFiles(rawFiles, { /* configuração */ });
  
  // Contar tokens
  const tokenCounter = new TokenCounter('o200k_base');
  
  // Retornar resultados da análise
  return processedFiles.map(file => ({
    path: file.path,
    tokens: tokenCounter.countTokens(file.content)
  }));
}
```

## Exemplo do Mundo Real

O site do Repomix ([repomix.com](https://repomix.com)) usa o Repomix como biblioteca para processar repositórios remotos. Você pode ver a implementação em [website/server/src/remoteRepo.ts](https://github.com/yamadashy/repomix/blob/main/website/server/src/remoteRepo.ts).
</file>

<file path="website/client/src/pt-br/guide/tips/best-practices.md">
# Melhores Práticas para Desenvolvimento com IA: Da Minha Experiência

Embora eu ainda não tenha concluído um grande projeto com IA, gostaria de compartilhar minhas experiências até agora no desenvolvimento com IA.

## Abordagem Básica de Desenvolvimento

Ao trabalhar com IA, tentar implementar todas as funcionalidades de uma vez pode levar a problemas inesperados e estagnação do projeto. Portanto, é mais eficaz começar com a funcionalidade principal e construir cada recurso individualmente, garantindo uma implementação sólida antes de prosseguir.

### O Poder do Código Existente

Essa abordagem é eficaz porque a implementação da funcionalidade principal permite materializar seu design ideal e estilo de codificação através de código real. A maneira mais eficaz de comunicar sua visão do projeto é através de código que reflita seus padrões e preferências.

Começando com funcionalidades principais e garantindo que cada componente funcione corretamente antes de avançar, o projeto inteiro mantém sua consistência, tornando mais fácil para a IA gerar código mais apropriado.

## Abordagem Modular

Dividir o código em módulos menores é crucial. Com base em minha experiência, limitar os arquivos a cerca de 250 linhas de código torna mais fácil dar instruções claras à IA e tornar o processo de tentativa e erro mais eficiente. Embora a contagem de tokens seria uma medida mais precisa, a contagem de linhas é mais prática para desenvolvedores humanos, então usamos isso como diretriz.

Essa modularização não se limita apenas à separação de componentes frontend, backend e banco de dados - trata-se de dividir a funcionalidade em um nível muito mais fino. Por exemplo, dentro de uma única função, você pode separar a validação, tratamento de erros e outras funcionalidades específicas em módulos separados.

## Garantia de Qualidade através de Testes

Considero os testes cruciais no desenvolvimento assistido por IA. Os testes servem não apenas como medidas de garantia de qualidade, mas também como documentação que demonstra claramente as intenções do código. Quando você pede à IA para implementar novos recursos, o código de teste existente serve efetivamente como um documento de especificação.

Os testes também são uma excelente ferramenta para validar a correção do código gerado pela IA. Por exemplo, se você fizer a IA implementar nova funcionalidade para um módulo, escrever casos de teste antecipadamente permite uma avaliação objetiva se o código gerado funciona conforme esperado.

## Equilíbrio entre Planejamento e Implementação

Antes de implementar recursos extensos, recomendo discutir primeiro o plano com a IA. Organizar os requisitos e considerar a arquitetura leva a uma implementação mais suave. Uma boa prática é primeiro compilar os requisitos e depois mudar para uma sessão de chat separada para o trabalho de implementação.

## Conclusão

Seguindo essas práticas, você pode aproveitar os pontos fortes da IA enquanto mantém uma base de código consistente e de alta qualidade. Mesmo à medida que seu projeto cresce, cada componente permanece bem definido e gerenciável.
</file>

<file path="website/client/src/pt-br/guide/code-compress.md">
# Compressão de Código

A compressão de código é um recurso poderoso que extrai estruturas essenciais do código de forma inteligente enquanto remove detalhes de implementação. Isso é particularmente útil para reduzir a contagem de tokens enquanto mantém informações estruturais importantes sobre sua base de código.

> [!NOTE]
> Este é um recurso experimental que estaremos melhorando ativamente com base no feedback dos usuários e no uso no mundo real.

## Uso Básico

Ative a compressão de código usando a flag `--compress`:

```bash
repomix --compress
```

Você também pode usá-la com repositórios remotos:

```bash
repomix --remote user/repo --compress
```

## Como Funciona

O algoritmo de compressão processa o código usando análise Tree-sitter para extrair e preservar elementos estruturais essenciais enquanto remove detalhes de implementação.

A compressão preserva:
- Assinaturas de funções e métodos
- Definições de interfaces e tipos
- Estruturas de classes e propriedades
- Elementos estruturais importantes

Enquanto remove:
- Implementações de funções e métodos
- Detalhes de lógica de loops e condicionais
- Declarações de variáveis internas
- Código específico de implementação

### Exemplo

Código TypeScript original:

```typescript
import { ShoppingItem } from './shopping-item';

/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
  let total = 0;
  for (const item of items) {
    total += item.price * item.quantity;
  }
  return total;
}

// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

Após a compressão:

```typescript
import { ShoppingItem } from './shopping-item';
⋮----
/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
⋮----
// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

## Configuração

Você pode ativar a compressão em seu arquivo de configuração:

```json
{
  "output": {
    "compress": true
  }
}
```

## Casos de Uso

A compressão de código é particularmente útil quando:
- Analisando estrutura e arquitetura do código
- Reduzindo contagem de tokens para processamento LLM
- Criando documentação de alto nível
- Compreendendo padrões e assinaturas de código
- Compartilhando designs de API e interface

## Opções Relacionadas

Você pode combinar a compressão com outras opções:
- `--remove-comments`: Remover comentários do código
- `--remove-empty-lines`: Remover linhas vazias
- `--output-show-line-numbers`: Adicionar números de linha à saída
</file>

<file path="website/client/src/pt-br/guide/command-line-options.md">
# Opções de Linha de Comando

## Opções Básicas
- `-v, --version`: Mostra a versão

## Opções de Saída
- `-o, --output <file>`: Nome do arquivo de saída (padrão: `repomix-output.txt`)
- `--stdout`: Saída para a saída padrão em vez de escrever em um arquivo (não pode ser usado com a opção `--output`)
- `--style <type>`: Estilo de saída (`plain`, `xml`, `markdown`) (padrão: `xml`)
- `--parsable-style`: Habilita saída analisável baseada no esquema do estilo escolhido (padrão: `false`)
- `--compress`: Realiza extração inteligente de código, focando nas assinaturas de funções e classes enquanto remove detalhes de implementação. Para mais detalhes e exemplos, consulte o [Guia de Compressão de Código](code-compress)
- `--output-show-line-numbers`: Adiciona números de linha (padrão: `false`)
- `--copy`: Copia para a área de transferência (padrão: `false`)
- `--no-file-summary`: Desabilita o resumo de arquivos (padrão: `true`)
- `--no-directory-structure`: Desabilita a estrutura de diretórios (padrão: `true`)
- `--no-files`: Desabilita a saída de conteúdo de arquivos (modo somente metadados) (padrão: `true`)
- `--remove-comments`: Remove comentários (padrão: `false`)
- `--remove-empty-lines`: Remove linhas vazias (padrão: `false`)
- `--header-text <text>`: Texto personalizado para incluir no cabeçalho do arquivo
- `--instruction-file-path <path>`: Caminho para um arquivo contendo instruções personalizadas detalhadas
- `--include-empty-directories`: Inclui diretórios vazios na saída (padrão: `false`)
- `--include-diffs`: Inclui diferenças do git na saída (inclui separadamente as alterações da árvore de trabalho e as alterações preparadas) (padrão: `false`)
- `--no-git-sort-by-changes`: Desabilita a ordenação de arquivos por contagem de alterações do git (padrão: `true`)

## Opções de Filtro
- `--include <patterns>`: Padrões para incluir (separados por vírgula)
- `-i, --ignore <patterns>`: Padrões para ignorar (separados por vírgula)
- `--stdin`: Lê caminhos de arquivos do stdin em vez de descobrir arquivos automaticamente
- `--no-gitignore`: Desabilita o uso do arquivo .gitignore
- `--no-default-patterns`: Desabilita padrões padrão

## Opções de Repositório Remoto
- `--remote <url>`: Processa repositório remoto
- `--remote-branch <name>`: Especifica o nome do branch remoto, tag ou hash do commit (padrão é o branch padrão do repositório)

## Opções de Configuração
- `-c, --config <path>`: Caminho do arquivo de configuração personalizado
- `--init`: Cria arquivo de configuração
- `--global`: Usa configuração global

## Opções de Segurança
- `--no-security-check`: Desabilita verificação de segurança (padrão: `true`)

## Opções de Contagem de Tokens
- `--token-count-encoding <encoding>`: Especifica a codificação para contagem de tokens (ex: `o200k_base`, `cl100k_base`) (padrão: `o200k_base`)

## Outras Opções
- `--top-files-len <number>`: Número de arquivos principais para mostrar (padrão: `5`)
- `--verbose`: Habilita log detalhado
- `--quiet`: Desabilita toda saída para stdout

## Exemplos

```bash
# Uso básico
repomix

# Saída personalizada
repomix -o output.xml --style xml

# Saída para a saída padrão
repomix --stdout > custom-output.txt

# Enviar saída para a saída padrão, depois canalizar para outro comando (por exemplo, simonw/llm)
repomix --stdout | llm "Por favor, explique o que este código faz"

# Saída personalizada com compressão
repomix --compress

# Processar arquivos específicos
repomix --include "src/**/*.ts" --ignore "**/*.test.ts"

# Repositório remoto com branch
repomix --remote https://github.com/user/repo/tree/main

# Repositório remoto com commit
repomix --remote https://github.com/user/repo/commit/836abcd7335137228ad77feb28655d85712680f1

# Repositório remoto com formato curto
repomix --remote user/repo

# Usando stdin para lista de arquivos
find src -name "*.ts" -type f | repomix --stdin
git ls-files "*.js" | repomix --stdin
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```
</file>

<file path="website/client/src/pt-br/guide/comment-removal.md">
# Remoção de Comentários

O Repomix pode remover automaticamente os comentários do seu código ao gerar o arquivo de saída. Isso pode ajudar a reduzir o ruído e focar no código real.

## Uso

Para habilitar a remoção de comentários, defina a opção `removeComments` como `true` no seu `repomix.config.json`:

```json
{
  "output": {
    "removeComments": true
  }
}
```

## Linguagens Suportadas

O Repomix suporta a remoção de comentários para uma ampla gama de linguagens de programação, incluindo:

- JavaScript/TypeScript (`//`, `/* */`)
- Python (`#`, `"""`, `'''`)
- Java (`//`, `/* */`)
- C/C++ (`//`, `/* */`)
- HTML (`<!-- -->`)
- CSS (`/* */`)
- E muitas outras...

## Exemplo

Dado o seguinte código JavaScript:

```javascript
// Este é um comentário de linha única
function test() {
  /* Este é um
     comentário de várias linhas */
  return true;
}
```

Com a remoção de comentários habilitada, a saída será:

```javascript
function test() {
  return true;
}
```

## Notas

- A remoção de comentários é realizada antes de outras etapas de processamento, como a adição de números de linha.
- Alguns comentários, como os comentários JSDoc, podem ser preservados dependendo da linguagem e do contexto.
</file>

<file path="website/client/src/pt-br/guide/configuration.md">
# Configuração

O Repomix pode ser configurado usando um arquivo de configuração (`repomix.config.json`) ou opções de linha de comando. O arquivo de configuração permite que você personalize vários aspectos de como seu código-fonte é processado e gerado.

## Início rápido

Crie um arquivo de configuração no diretório do seu projeto:
```bash
repomix --init
```

Isso criará um arquivo `repomix.config.json` com as configurações padrão. Você também pode criar um arquivo de configuração global que será usado como fallback quando nenhuma configuração local for encontrada:

```bash
repomix --init --global
```

## Opções de configuração

| Opção                           | Descrição                                                                                                                  | Padrão                |
|----------------------------------|------------------------------------------------------------------------------------------------------------------------------|------------------------|
| `input.maxFileSize`              | Tamanho máximo do arquivo em bytes para processar. Arquivos maiores serão ignorados. Útil para excluir arquivos binários grandes ou arquivos de dados | `50000000`            |
| `output.filePath`                | Nome do arquivo de saída. Suporta formatos XML, Markdown e texto simples                                                   | `"repomix-output.xml"` |
| `output.style`                   | Estilo de saída (`xml`, `markdown`, `plain`). Cada formato tem suas próprias vantagens para diferentes ferramentas de IA   | `"xml"`                |
| `output.parsableStyle`           | Indica se a saída deve ser escapada de acordo com o esquema de estilo escolhido. Permite melhor análise mas pode aumentar a contagem de tokens | `false`                |
| `output.compress`                | Indica se deve realizar extração inteligente de código usando Tree-sitter para reduzir a contagem de tokens enquanto preserva a estrutura | `false`                |
| `output.headerText`              | Texto personalizado para incluir no cabeçalho do arquivo. Útil para fornecer contexto ou instruções para ferramentas de IA | `null`                 |
| `output.instructionFilePath`     | Caminho para um arquivo contendo instruções personalizadas detalhadas para processamento de IA                            | `null`                 |
| `output.fileSummary`             | Indica se deve incluir uma seção de resumo no início mostrando contagens de arquivos, tamanhos e outras métricas         | `true`                 |
| `output.directoryStructure`      | Indica se deve incluir a estrutura de diretórios na saída. Ajuda a IA a entender a organização do projeto                | `true`                 |
| `output.files`                   | Indica se deve incluir o conteúdo dos arquivos na saída. Defina como false para incluir apenas estrutura e metadados     | `true`                 |
| `output.removeComments`          | Indica se deve remover comentários dos tipos de arquivos suportados. Pode reduzir ruído e contagem de tokens             | `false`                |
| `output.removeEmptyLines`        | Indica se deve remover linhas vazias da saída para reduzir a contagem de tokens                                          | `false`                |
| `output.showLineNumbers`         | Indica se deve adicionar números de linha a cada linha. Útil para referenciar partes específicas do código               | `false`                |
| `output.copyToClipboard`         | Indica se deve copiar a saída para a área de transferência do sistema além de salvar o arquivo                           | `false`                |
| `output.topFilesLength`          | Número de arquivos principais para exibir no resumo. Se definido como 0, nenhum resumo será exibido                      | `5`                    |
| `output.includeEmptyDirectories` | Indica se deve incluir diretórios vazios na estrutura do repositório                                                     | `false`                |
| `output.git.sortByChanges`       | Indica se deve ordenar arquivos por número de alterações git. Arquivos com mais alterações aparecem no final            | `true`                 |
| `output.git.sortByChangesMaxCommits` | Número máximo de commits para analisar ao contar alterações git. Limita a profundidade do histórico por desempenho  | `100`                  |
| `output.git.includeDiffs`        | Indica se deve incluir as diferenças git na saída. Mostra separadamente as alterações da árvore de trabalho e as alterações preparadas | `false`                |
| `include`                        | Padrões de arquivos para incluir usando [padrões glob](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax) | `[]`                   |
| `ignore.useGitignore`            | Indica se deve usar os padrões do arquivo `.gitignore` do projeto                                                        | `true`                 |
| `ignore.useDefaultPatterns`      | Indica se deve usar os padrões de ignorar padrão (node_modules, .git, etc.)                                            | `true`                 |
| `ignore.customPatterns`          | Padrões adicionais para ignorar usando [padrões glob](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax) | `[]`                   |
| `security.enableSecurityCheck`   | Indica se deve realizar verificações de segurança usando Secretlint para detectar informações sensíveis                  | `true`                 |
| `tokenCount.encoding`            | Codificação de contagem de tokens usada pelo tokenizador [tiktoken](https://github.com/openai/tiktoken) da OpenAI. Use `o200k_base` para GPT-4o, `cl100k_base` para GPT-4/3.5. Veja [tiktoken model.py](https://github.com/openai/tiktoken/blob/main/tiktoken/model.py#L24) para mais detalhes. | `"o200k_base"`         |

O arquivo de configuração suporta a sintaxe [JSON5](https://json5.org/), que permite:
- Comentários (tanto de uma linha quanto multilinha)
- Vírgulas finais em objetos e arrays
- Nomes de propriedades sem aspas
- Sintaxe de string mais flexível

## Validação de esquema

Você pode habilitar a validação de esquema para seu arquivo de configuração adicionando a propriedade `$schema`:

```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "output": {
    "filePath": "repomix-output.md",
    "style": "markdown"
  }
}
```

Isso fornece autocompletar e validação em editores que suportam esquema JSON.

## Exemplo de arquivo de configuração

Aqui está um exemplo de um arquivo de configuração completo (`repomix.config.json`):

```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 50000000
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "compress": false,
    "headerText": "Informações de cabeçalho personalizadas para o arquivo empacotado.",
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "includeEmptyDirectories": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false
    }
  },
  "include": ["**/*"],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    // Os padrões também podem ser especificados em .repomixignore
    "customPatterns": [
      "additional-folder",
      "**/*.log"
    ],
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
```

## Locais dos arquivos de configuração

O Repomix procura os arquivos de configuração na seguinte ordem:
1. Arquivo de configuração local (`repomix.config.json`) no diretório atual
2. Arquivo de configuração global:
   - Windows: `%LOCALAPPDATA%\Repomix\repomix.config.json`
   - macOS/Linux: `~/.config/repomix/repomix.config.json`

As opções de linha de comando têm precedência sobre as configurações do arquivo.

## Padrões de ignorar

O Repomix fornece múltiplas formas de especificar quais arquivos devem ser ignorados. Os padrões são processados na seguinte ordem de prioridade:

1. Opções de CLI (`--ignore`)
2. Arquivo `.repomixignore` no diretório do projeto
3. `.gitignore` e `.git/info/exclude` (se `ignore.useGitignore` for verdadeiro)
4. Padrões padrão (se `ignore.useDefaultPatterns` for verdadeiro)

Exemplo de `.repomixignore`:
```text
# Diretórios de cache
.cache/
tmp/

# Saídas de compilação
dist/
build/

# Registros
*.log
```

## Padrões de ignorar padrão

Quando `ignore.useDefaultPatterns` é verdadeiro, o Repomix ignora automaticamente padrões comuns:
```text
node_modules/**
.git/**
coverage/**
dist/**
```

Para a lista completa, veja [defaultIgnore.ts](https://github.com/yamadashy/repomix/blob/main/src/config/defaultIgnore.ts)

## Recursos avançados

### Compressão de código

O recurso de compressão de código, habilitado com `output.compress: true`, usa [Tree-sitter](https://github.com/tree-sitter/tree-sitter) para extrair inteligentemente estruturas de código essenciais enquanto remove detalhes de implementação. Isso ajuda a reduzir a contagem de tokens enquanto mantém informações estruturais importantes.

Benefícios principais:
- Reduz significativamente a contagem de tokens
- Preserva as assinaturas de classes e funções
- Mantém importações e exportações
- Conserva definições de tipos e interfaces
- Remove corpos de funções e detalhes de implementação

Para mais detalhes e exemplos, consulte o [Guia de compressão de código](code-compress).

### Integração com Git

A configuração `output.git` fornece recursos poderosos relacionados ao Git:

- `sortByChanges`: Quando verdadeiro, os arquivos são ordenados por número de alterações Git (commits que modificaram o arquivo). Arquivos com mais alterações aparecem no final da saída. Isso ajuda a priorizar os arquivos mais ativamente desenvolvidos. Padrão: `true`
- `sortByChangesMaxCommits`: O número máximo de commits para analisar ao contar alterações de arquivos. Padrão: `100`
- `includeDiffs`: Quando verdadeiro, inclui as diferenças Git na saída (inclui separadamente as alterações da árvore de trabalho e as alterações preparadas). Isso permite que o leitor veja as alterações pendentes no repositório. Padrão: `false`

Exemplo de configuração:
```json
{
  "output": {
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": true
    }
  }
}
```

### Verificações de segurança

Quando `security.enableSecurityCheck` está habilitado, o Repomix usa [Secretlint](https://github.com/secretlint/secretlint) para detectar informações sensíveis em seu código-fonte antes de incluí-las na saída. Isso ajuda a prevenir a exposição acidental de:

- Chaves de API
- Tokens de acesso
- Chaves privadas
- Senhas
- Outras credenciais sensíveis

### Remoção de comentários

Quando `output.removeComments` é definido como `true`, os comentários são removidos dos tipos de arquivos suportados para reduzir o tamanho da saída e focar no conteúdo essencial do código. Isso pode ser particularmente útil quando:

- Você está trabalhando com código altamente documentado
- Você está tentando reduzir a contagem de tokens
- Você está focando na estrutura e lógica do código

Para os idiomas suportados e exemplos detalhados, consulte o [Guia de remoção de comentários](comment-removal).
</file>

<file path="website/client/src/pt-br/guide/custom-instructions.md">
# Instruções Personalizadas

O Repomix permite que você forneça instruções personalizadas que serão incluídas no arquivo de saída. Isso pode ser útil para adicionar contexto ou diretrizes específicas para sistemas de IA que processam o repositório.

## Uso

Para incluir uma instrução personalizada, crie um arquivo markdown (por exemplo, `repomix-instruction.md`) na raiz do seu repositório. Em seguida, especifique o caminho para este arquivo no seu `repomix.config.json`:

```json
{
  "output": {
    "instructionFilePath": "repomix-instruction.md"
  }
}
```

O conteúdo deste arquivo será incluído na saída sob a seção "Instruction".

## Exemplo

```markdown
# Instruções do Repositório

Este repositório contém o código-fonte da ferramenta Repomix. Por favor, siga estas diretrizes ao analisar o código:

1. Concentre-se na funcionalidade principal no diretório `src/core`.
2. Preste atenção especial às verificações de segurança em `src/core/security`.
3. Ignore quaisquer arquivos no diretório `tests`.
```

Isso resultará na seguinte seção na saída:

```xml
<instruction>
# Instruções do Repositório

Este repositório contém o código-fonte da ferramenta Repomix. Por favor, siga estas diretrizes ao analisar o código:

1. Concentre-se na funcionalidade principal no diretório `src/core`.
2. Preste atenção especial às verificações de segurança em `src/core/security`.
3. Ignore quaisquer arquivos no diretório `tests`.
</instruction>
</file>

<file path="website/client/src/pt-br/guide/github-actions.md">
# Usando o Repomix com GitHub Actions

Você pode automatizar o empacotamento do seu código para análise por IA integrando o Repomix aos seus workflows do GitHub Actions. Isso é útil para integração contínua (CI), revisão de código ou preparação para ferramentas LLM.

## Uso básico

Adicione o seguinte passo ao seu arquivo YAML de workflow para empacotar seu repositório:

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.xml
```

## Usando diferentes formatos de saída

Você pode especificar diferentes formatos de saída usando o parâmetro `style` (o padrão é `xml`):

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.md
    style: markdown
```

## Empacotando múltiplos diretórios com compressão

Você pode especificar múltiplos diretórios, padrões de inclusão/exclusão e ativar a compressão inteligente:

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src tests
    include: "**/*.ts,**/*.md"
    ignore: "**/*.test.ts"
    output: repomix-output.txt
    compress: true
```

## Enviando o arquivo de saída como artefato

Para disponibilizar o arquivo empacotado para etapas posteriores ou para download, envie-o como artefato:

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src
    output: repomix-output.xml
    compress: true

- name: Upload Repomix output
  uses: actions/upload-artifact@v4
  with:
    name: repomix-output
    path: repomix-output.xml
```

## Parâmetros de entrada da Action

| Nome               | Descrição                                   | Padrão            |
|--------------------|---------------------------------------------|-------------------|
| `directories`      | Lista de diretórios a empacotar (separados por espaço) | `.`         |
| `include`          | Padrões glob a incluir (separados por vírgula) | `""`         |
| `ignore`           | Padrões glob a ignorar (separados por vírgula) | `""`         |
| `output`           | Caminho do arquivo de saída                  | `repomix-output.xml`     |
| `style`            | Estilo de saída (xml, markdown, plain)       | `xml`             |
| `compress`         | Ativar compressão inteligente                | `true`            |
| `additional-args`  | Argumentos extras para o repomix CLI         | `""`         |
| `repomix-version`  | Versão do pacote npm a instalar              | `latest`          |

## Saídas da Action

| Nome          | Descrição                        |
|---------------|----------------------------------|
| `output_file` | Caminho do arquivo gerado         |

## Exemplo de workflow completo

Aqui está um exemplo completo de workflow do GitHub Actions usando o Repomix:

```yaml
name: Pack repository with Repomix

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  pack-repo:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Pack repository with Repomix
        uses: yamadashy/repomix/.github/actions/repomix@main
        with:
          output: repomix-output.xml

      - name: Upload Repomix output
        uses: actions/upload-artifact@v4
        with:
          name: repomix-output.xml
          path: repomix-output.xml
          retention-days: 30
```

Veja o [exemplo completo do workflow](https://github.com/yamadashy/repomix/blob/main/.github/workflows/pack-repository.yml).
</file>

<file path="website/client/src/pt-br/guide/index.md">
# Introdução ao Repomix

<script setup>
import HomeBadges from '../../../components/HomeBadges.vue'
import YouTubeVideo from '../../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../../utils/videos'
</script>

O Repomix é uma ferramenta que compacta todo o seu repositório em um único arquivo amigável para IA. Ele foi projetado para ajudá-lo a alimentar seu código-fonte para Modelos de Linguagem Grandes (LLMs) como ChatGPT, DeepSeek, Perplexity, Gemini, Gemma, Llama, Grok e mais.

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

<HomeBadges />

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## Início Rápido

Execute este comando no diretório do seu projeto:

```bash
npx repomix
```

É isso! Você encontrará um arquivo `repomix-output.xml` contendo todo o seu repositório em um formato amigável para IA.

Você pode então enviar este arquivo para um assistente de IA com um prompt como:

```
Este arquivo contém todos os arquivos do repositório combinados em um só.
Eu quero refatorar o código, então, por favor, revise-o primeiro.
```

A IA analisará todo o seu código-fonte e fornecerá insights abrangentes:

![Uso do Arquivo Repomix 1](/images/docs/repomix-file-usage-1.png)

Ao discutir mudanças específicas, a IA pode ajudar a gerar código. Com recursos como o Artifacts do Claude, você pode até receber vários arquivos interdependentes:

![Uso do Arquivo Repomix 2](/images/docs/repomix-file-usage-2.png)

Feliz codificação! 🚀

## Principais Recursos

- **Saída Otimizada para IA**: Formata seu código-fonte para fácil processamento por IA
- **Contagem de Tokens**: Rastreia o uso de tokens para limites de contexto de LLM
- **Consciente do Git**: Respeita seus arquivos `.gitignore` e `.git/info/exclude`
- **Focado em Segurança**: Detecta informações sensíveis
- **Múltiplos Formatos de Saída**: Escolha entre texto simples, XML ou Markdown

## O que vem a seguir?

- [Guia de Instalação](installation.md): Diferentes maneiras de instalar o Repomix
- [Guia de Uso](usage.md): Aprenda sobre recursos básicos e avançados
- [Configuração](configuration.md): Personalize o Repomix para suas necessidades
- [Recursos de Segurança](security.md): Aprenda sobre verificações de segurança

## Comunidade

Junte-se à nossa [comunidade Discord](https://discord.gg/wNYzTwZFku) para:
- Obter ajuda com o Repomix
- Compartilhar suas experiências
- Sugerir novos recursos
- Conectar-se com outros usuários

## Suporte

Encontrou um bug ou precisa de ajuda?
- [Abra um problema no GitHub](https://github.com/yamadashy/repomix/issues)
- Junte-se ao nosso servidor Discord
- Verifique a [documentação](https://repomix.com)
</file>

<file path="website/client/src/pt-br/guide/installation.md">
# Instalação

## Usando npx (Nenhuma Instalação Necessária)

```bash
npx repomix
```

## Instalação Global

### npm
```bash
npm install -g repomix
```

### Yarn
```bash
yarn global add repomix
```

### Bun
```bash
bun add -g repomix
```

### Homebrew (macOS/Linux)
```bash
brew install repomix
```

## Instalação via Docker

Baixe e execute a imagem Docker:

```bash
# Diretório atual
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix

# Diretório específico
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory

# Repositório remoto
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote yamadashy/repomix
```

## Extensão VSCode

Execute o Repomix diretamente no VSCode com a extensão [Repomix Runner](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner) mantida pela comunidade.

Recursos:
- Empacote qualquer pasta com apenas alguns cliques
- Escolha entre modo arquivo ou conteúdo para copiar
- Limpeza automática de arquivos de saída
- Funciona com repomix.config.json

Instale através do [VSCode Marketplace](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner).

## Extensão do Navegador

Obtenha acesso instantâneo ao Repomix diretamente de qualquer repositório GitHub! Nossa extensão do Chrome adiciona um botão "Repomix" conveniente às páginas de repositório do GitHub.

![Repomix Browser Extension](/images/docs/browser-extension.png)

### Instalação
- Extensão do Chrome: [Repomix - Chrome Web Store](https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa)
- Add-on do Firefox: [Repomix - Firefox Add-ons](https://addons.mozilla.org/firefox/addon/repomix/)

### Recursos
- Acesso com um clique ao Repomix para qualquer repositório GitHub
- Mais recursos emocionantes em breve!

## Requisitos de Sistema

- Node.js: ≥ 18.0.0
- Git: Necessário para processamento de repositório remoto

## Verificação

Após a instalação, verifique se o Repomix está funcionando:

```bash
repomix --version
repomix --help
```
</file>

<file path="website/client/src/pt-br/guide/mcp-server.md">
# Servidor MCP

O Repomix suporta o [Model Context Protocol (MCP)](https://modelcontextprotocol.io), permitindo que assistentes de IA interajam diretamente com sua base de código. Quando executado como um servidor MCP, o Repomix fornece ferramentas que permitem aos assistentes de IA empacotar repositórios locais ou remotos para análise sem necessidade de preparação manual de arquivos.

> [!NOTE]  
> Este é um recurso experimental que estaremos melhorando ativamente com base no feedback dos usuários e no uso no mundo real

## Executando o Repomix como um Servidor MCP

Para executar o Repomix como um servidor MCP, use a flag `--mcp`:

```bash
repomix --mcp
```

Isso inicia o Repomix no modo servidor MCP, tornando-o disponível para assistentes de IA que suportam o Model Context Protocol.

## Configurando Servidores MCP

Para usar o Repomix como um servidor MCP com assistentes de IA como o Claude, você precisa configurar as definições do MCP:

### Para VS Code

Você pode instalar o servidor MCP do Repomix no VS Code usando um destes métodos:

1. **Usando o distintivo de instalação:**

  [![Install in VS Code](https://img.shields.io/badge/VS_Code-VS_Code?style=flat-square&label=Install%20Server&color=0098FF)](vscode:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)<br>
  [![Install in VS Code Insiders](https://img.shields.io/badge/VS_Code_Insiders-VS_Code_Insiders?style=flat-square&label=Install%20Server&color=24bfa5)](vscode-insiders:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)

2. **Usando a linha de comando:**

  ```bash
  code --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

  Para VS Code Insiders:
  ```bash
  code-insiders --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

### Para o Cline (extensão do VS Code)

Edite o arquivo `cline_mcp_settings.json`:

```json
{
  "mcpServers": {
    "repomix": {
      "command": "npx",
      "args": [
        "-y",
        "repomix",
        "--mcp"
      ]
    }
  }
}
```

### Para o Cursor

No Cursor, adicione um novo servidor MCP a partir de `Cursor Settings` > `MCP` > `+ Add new global MCP server` com uma configuração similar à do Cline.

### Para o Claude Desktop

Edite o arquivo `claude_desktop_config.json` com uma configuração similar à do Cline.

### Para o Claude Code

Para configurar o Repomix como servidor MCP no [Claude Code](https://docs.anthropic.com/en/docs/claude-code/overview), use o seguinte comando:

```bash
claude mcp add repomix -- npx -y repomix --mcp
```

### Usando Docker em vez de npx

Em vez de usar npx, você pode usar o Docker para executar o Repomix como um servidor MCP:

```json
{
  "mcpServers": {
    "repomix-docker": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "ghcr.io/yamadashy/repomix",
        "--mcp"
      ]
    }
  }
}
```

## Ferramentas MCP Disponíveis

Quando executado como um servidor MCP, o Repomix fornece as seguintes ferramentas:

### pack_codebase

Esta ferramenta empacota um diretório de código local em um arquivo XML para análise de IA. Ela analisa a estrutura da base de código, extrai conteúdo de código relevante e gera um relatório abrangente incluindo métricas, árvore de arquivos e conteúdo de código formatado.

**Parâmetros:**
- `directory`: (Obrigatório) Caminho absoluto para o diretório a ser empacotado
- `compress`: (Opcional, padrão: false) Habilita compressão Tree-sitter para extrair assinaturas de código essenciais e estrutura enquanto remove detalhes de implementação. Reduz o uso de tokens em ~70% mantendo o significado semântico. Geralmente não é necessário já que grep_repomix_output permite recuperação incremental de conteúdo. Use apenas quando você especificamente precisar do conteúdo completo da base de código para repositórios grandes.
- `includePatterns`: (Opcional) Especifica arquivos para incluir usando padrões fast-glob. Múltiplos padrões podem ser separados por vírgula (ex: "**/*.{js,ts}", "src/**,docs/**"). Apenas arquivos correspondentes serão processados.
- `ignorePatterns`: (Opcional) Especifica arquivos adicionais para excluir usando padrões fast-glob. Múltiplos padrões podem ser separados por vírgula (ex: "test/**,*.spec.js", "node_modules/**,dist/**"). Estes padrões complementam .gitignore e exclusões integradas.
- `topFilesLength`: (Opcional, padrão: 10) Número de maiores arquivos por tamanho para exibir no resumo de métricas para análise da base de código.

**Exemplo:**
```json
{
  "directory": "/path/to/your/project",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### pack_remote_repository

Esta ferramenta busca, clona e empacota um repositório GitHub em um arquivo XML para análise de IA. Ela automaticamente clona o repositório remoto, analisa sua estrutura e gera um relatório abrangente.

**Parâmetros:**
- `remote`: (Obrigatório) URL do repositório GitHub ou formato usuário/repo (ex: "yamadashy/repomix", "https://github.com/user/repo", ou "https://github.com/user/repo/tree/branch")
- `compress`: (Opcional, padrão: false) Habilita compressão Tree-sitter para extrair assinaturas de código essenciais e estrutura enquanto remove detalhes de implementação. Reduz o uso de tokens em ~70% mantendo o significado semântico. Geralmente não é necessário já que grep_repomix_output permite recuperação incremental de conteúdo. Use apenas quando você especificamente precisar do conteúdo completo da base de código para repositórios grandes.
- `includePatterns`: (Opcional) Especifica arquivos para incluir usando padrões fast-glob. Múltiplos padrões podem ser separados por vírgula (ex: "**/*.{js,ts}", "src/**,docs/**"). Apenas arquivos correspondentes serão processados.
- `ignorePatterns`: (Opcional) Especifica arquivos adicionais para excluir usando padrões fast-glob. Múltiplos padrões podem ser separados por vírgula (ex: "test/**,*.spec.js", "node_modules/**,dist/**"). Estes padrões complementam .gitignore e exclusões integradas.
- `topFilesLength`: (Opcional, padrão: 10) Número de maiores arquivos por tamanho para exibir no resumo de métricas para análise da base de código.

**Exemplo:**
```json
{
  "remote": "yamadashy/repomix",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### read_repomix_output

Esta ferramenta lê o conteúdo de um arquivo de saída gerado pelo Repomix. Suporta leitura parcial com especificação de intervalo de linhas para arquivos grandes. Esta ferramenta é projetada para ambientes onde o acesso direto ao sistema de arquivos é limitado.

**Parâmetros:**
- `outputId`: (Obrigatório) ID do arquivo de saída do Repomix a ser lido
- `startLine`: (Opcional) Número da linha inicial (baseado em 1, inclusivo). Se não especificado, lê desde o início.
- `endLine`: (Opcional) Número da linha final (baseado em 1, inclusivo). Se não especificado, lê até o final.

**Funcionalidades:**
- Projetado especificamente para ambientes baseados na web ou aplicações em sandbox
- Recupera o conteúdo de saídas geradas anteriormente usando seu ID
- Fornece acesso seguro à base de código empacotada sem requerer acesso ao sistema de arquivos
- Suporta leitura parcial para arquivos grandes

**Exemplo:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "startLine": 100,
  "endLine": 200
}
```

### grep_repomix_output

Esta ferramenta busca padrões em um arquivo de saída do Repomix usando funcionalidade similar ao grep com sintaxe JavaScript RegExp. Retorna linhas correspondentes com linhas de contexto opcionais ao redor das correspondências.

**Parâmetros:**
- `outputId`: (Obrigatório) ID do arquivo de saída do Repomix para buscar
- `pattern`: (Obrigatório) Padrão de busca (sintaxe de expressão regular JavaScript RegExp)
- `contextLines`: (Opcional, padrão: 0) Número de linhas de contexto para mostrar antes e depois de cada correspondência. Sobrescrito por beforeLines/afterLines se especificado.
- `beforeLines`: (Opcional) Número de linhas de contexto para mostrar antes de cada correspondência (como grep -B). Tem precedência sobre contextLines.
- `afterLines`: (Opcional) Número de linhas de contexto para mostrar depois de cada correspondência (como grep -A). Tem precedência sobre contextLines.
- `ignoreCase`: (Opcional, padrão: false) Realizar correspondência insensível a maiúsculas e minúsculas

**Funcionalidades:**
- Usa sintaxe JavaScript RegExp para correspondência de padrões poderosa
- Suporta linhas de contexto para melhor compreensão das correspondências
- Permite controle separado de linhas de contexto antes/depois
- Opções de busca sensível e insensível a maiúsculas e minúsculas

**Exemplo:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "pattern": "function\\s+\\w+\\(",
  "contextLines": 3,
  "ignoreCase": false
}
```

### file_system_read_file e file_system_read_directory

O servidor MCP do Repomix fornece duas ferramentas de sistema de arquivos que permitem que os assistentes de IA interajam com segurança com o sistema de arquivos local:

1. `file_system_read_file`
  - Lê conteúdo de arquivos do sistema de arquivos local usando caminhos absolutos
  - Inclui validação de segurança integrada para detectar e prevenir acesso a arquivos contendo informações sensíveis
  - Implementa validação de segurança usando [Secretlint](https://github.com/secretlint/secretlint)
  - Previne acesso a arquivos contendo informações sensíveis (chaves de API, senhas, segredos)
  - Valida caminhos absolutos para prevenir ataques de travessia de diretórios
  - Retorna mensagens de erro claras para caminhos inválidos e problemas de segurança

2. `file_system_read_directory`
  - Lista conteúdos de um diretório usando um caminho absoluto
  - Retorna uma lista formatada mostrando arquivos e subdiretórios com indicadores claros
  - Mostra arquivos e diretórios com indicadores claros (`[FILE]` ou `[DIR]`)
  - Fornece navegação segura de diretórios com tratamento apropriado de erros
  - Valida caminhos e garante que sejam absolutos
  - Útil para explorar estrutura de projetos e compreender organização da base de código

Ambas as ferramentas incorporam medidas de segurança robustas:
- Validação de caminhos absolutos para prevenir ataques de travessia de diretórios
- Verificações de permissões para garantir direitos de acesso apropriados
- Integração com Secretlint para detecção de informações sensíveis
- Mensagens de erro claras para depuração e consciência de segurança

**Exemplo:**
```typescript
// Ler um arquivo
const fileContent = await tools.file_system_read_file({
  path: '/absolute/path/to/file.txt'
});

// Listar conteúdo do diretório
const dirContent = await tools.file_system_read_directory({
  path: '/absolute/path/to/directory'
});
```

Essas ferramentas são particularmente úteis quando os assistentes de IA precisam:
- Analisar arquivos específicos na base de código
- Navegar estruturas de diretórios
- Verificar existência e acessibilidade de arquivos
- Garantir operações seguras do sistema de arquivos

## Benefícios de Usar o Repomix como um Servidor MCP

Usar o Repomix como um servidor MCP oferece várias vantagens:

1. **Integração Direta**: Assistentes de IA podem analisar sua base de código diretamente sem preparação manual de arquivos.
2. **Fluxo de Trabalho Eficiente**: Otimiza o processo de análise de código eliminando a necessidade de gerar e carregar arquivos manualmente.
3. **Saída Consistente**: Garante que o assistente de IA receba a base de código em um formato consistente e otimizado.
4. **Recursos Avançados**: Aproveita todos os recursos do Repomix como compressão de código, contagem de tokens e verificações de segurança.

Uma vez configurado, seu assistente de IA pode usar diretamente as capacidades do Repomix para analisar bases de código, tornando os fluxos de trabalho de análise de código mais eficientes.
</file>

<file path="website/client/src/pt-br/guide/output.md">
# Formatos de Saída

O Repomix suporta três formatos de saída:
- XML (padrão)
- Markdown
- Texto simples

## Formato XML

```bash
repomix --style xml
```

O formato XML é otimizado para processamento por IA:

::: tip Por que XML?
As tags XML ajudam modelos de IA como o Claude a analisar o conteúdo com mais precisão. A [documentação do Claude](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags) recomenda o uso de tags XML para prompts estruturados.
:::

```xml
Este arquivo é uma representação consolidada de toda a base de código...

<file_summary>
(Metadados e instruções para IA)
</file_summary>

<directory_structure>
src/
  index.ts
  utils/
    helper.ts
</directory_structure>

<files>
<file path="src/index.ts">
// Conteúdo do arquivo aqui
</file>
</files>
```

## Formato Markdown

```bash
repomix --style markdown
```

O Markdown oferece formatação legível:

```markdown
Este arquivo é uma representação consolidada de toda a base de código...

# Resumo do Arquivo
(Metadados e instruções para IA)

# Estrutura de Diretórios
```text
src/
  index.ts
  utils/
    helper.ts
```

# Arquivos

## Arquivo: src/index.ts
```typescript
// Conteúdo do arquivo aqui
```
```

## Uso com Modelos de IA

Cada formato funciona bem com modelos de IA, mas considere:
- Use XML para Claude (melhor precisão de análise)
- Use Markdown para leitura geral
- Use Texto Simples para simplicidade e compatibilidade universal

## Customização

Defina o formato padrão no `repomix.config.json`:
```json
{
  "output": {
    "style": "xml",
    "filePath": "output.xml"
  }
}
```

## Formato de Texto Simples

```bash
repomix --style plain
```

Estrutura de saída:
```text
Este arquivo é uma representação consolidada de toda a base de código...

================
Resumo do Arquivo
================
(Metadados e instruções para IA)

================
Estrutura de Diretórios
================
src/
  index.ts
  utils/
    helper.ts

================
Arquivos
================

================
Arquivo: src/index.ts
================
// Conteúdo do arquivo aqui
```
</file>

<file path="website/client/src/pt-br/guide/prompt-examples.md">
# Exemplos de Prompts

## Revisão de Código

### Revisão de Arquitetura
```
Analise a arquitetura desta base de código:
1. Avalie a estrutura geral e os padrões
2. Identifique possíveis problemas de arquitetura
3. Sugira melhorias para escalabilidade
4. Observe áreas que seguem as melhores práticas

Concentre-se na manutenibilidade e modularidade.
```

### Revisão de Segurança
```
Realize uma revisão de segurança desta base de código:
1. Identifique possíveis vulnerabilidades de segurança
2. Verifique se há antipadrões de segurança comuns
3. Revise o tratamento de erros e a validação de entrada
4. Avalie a segurança das dependências

Forneça exemplos específicos e etapas de correção.
```

### Revisão de Desempenho
```
Revise a base de código para desempenho:
1. Identifique gargalos de desempenho
2. Verifique a utilização de recursos
3. Revise a eficiência algorítmica
4. Avalie as estratégias de cache

Inclua recomendações específicas de otimização.
```

## Geração de Documentação

### Documentação de API
```
Gere documentação abrangente da API:
1. Liste e descreva todos os endpoints públicos
2. Documente os formatos de solicitação/resposta
3. Inclua exemplos de uso
4. Observe quaisquer limitações ou restrições
```

### Guia do Desenvolvedor
```
Crie um guia do desenvolvedor cobrindo:
1. Instruções de configuração
2. Visão geral da estrutura do projeto
3. Fluxo de trabalho de desenvolvimento
4. Abordagem de teste
5. Etapas comuns de solução de problemas
```

### Documentação de Arquitetura
```
Documente a arquitetura do sistema:
1. Visão geral de alto nível
2. Interações de componentes
3. Diagramas de fluxo de dados
4. Decisões de design e justificativa
5. Restrições e limitações do sistema
```

## Análise e Melhoria

### Análise de Dependências
```
Analise as dependências do projeto:
1. Identifique pacotes desatualizados
2. Verifique se há vulnerabilidades de segurança
3. Sugira pacotes alternativos
4. Revise os padrões de uso de dependências

Inclua recomendações específicas de atualização.
```

### Cobertura de Testes
```
Revise a cobertura de testes:
1. Identifique componentes não testados
2. Sugira casos de teste adicionais
3. Revise a qualidade do teste
4. Recomende estratégias de teste
```

### Qualidade do Código
```
Avalie a qualidade do código e sugira melhorias:
1. Revise as convenções de nomenclatura
2. Verifique a organização do código
3. Avalie o tratamento de erros
4. Revise as práticas de comentários

Forneça exemplos específicos de padrões bons e problemáticos.
```

## Dicas para Obter Melhores Resultados

1. **Seja Específico**: Inclua objetivos claros e critérios de avaliação
2. **Defina o Contexto**: Especifique sua função e o nível de especialização necessário
3. **Formato da Solicitação**: Defina como você deseja que a resposta seja estruturada
4. **Priorize**: Indique quais aspectos são mais importantes

## Notas Específicas do Modelo

### Claude
- Use o formato de saída XML
- Coloque instruções importantes no final
- Especifique a estrutura da resposta

### ChatGPT
- Use o formato Markdown
- Divida grandes bases de código em seções
- Inclua prompts de função do sistema

### Gemini
- Funciona com todos os formatos
- Concentre-se em áreas específicas por solicitação
- Use análise passo a passo
</file>

<file path="website/client/src/pt-br/guide/remote-repository-processing.md">
# Processamento de Repositório Remoto

## Uso Básico

Processar repositórios públicos:
```bash
# Usando URL completo
repomix --remote https://github.com/user/repo

# Usando atalho do GitHub
repomix --remote user/repo
```

## Seleção de Branch e Commit

```bash
# Branch específico
repomix --remote user/repo --remote-branch main

# Tag
repomix --remote user/repo --remote-branch v1.0.0

# Hash do commit
repomix --remote user/repo --remote-branch 935b695
```

## Requisitos

- Git deve estar instalado
- Conexão com a internet
- Acesso de leitura ao repositório

## Controle de Saída

```bash
# Local de saída personalizado
repomix --remote user/repo -o custom-output.xml

# Com formato XML
repomix --remote user/repo --style xml

# Remover comentários
repomix --remote user/repo --remove-comments
```

## Uso com Docker

```bash
# Processar e enviar para o diretório atual
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo

# Enviar para um diretório específico
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo
```

## Problemas Comuns

### Problemas de Acesso
- Certifique-se de que o repositório é público
- Verifique a instalação do Git
- Verifique a conexão com a internet

### Repositórios Grandes
- Use `--include` para selecionar caminhos específicos
- Habilite `--remove-comments`
- Processe branches separadamente
</file>

<file path="website/client/src/pt-br/guide/security.md">
# Segurança

## Recurso de Verificação de Segurança

O Repomix usa o [Secretlint](https://github.com/secretlint/secretlint) para detectar informações confidenciais em seus arquivos:
- Chaves de API
- Tokens de acesso
- Credenciais
- Chaves privadas
- Variáveis de ambiente

## Configuração

As verificações de segurança são habilitadas por padrão.

Desativar via CLI:
```bash
repomix --no-security-check
```

Ou em `repomix.config.json`:
```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

## Medidas de Segurança

1. **Exclusão de Arquivos Binários**: Arquivos binários não são incluídos na saída
2. **Compatível com Git**: Respeita os padrões do `.gitignore`
3. **Detecção Automatizada**: Verifica problemas de segurança comuns:
    - Credenciais da AWS
    - Strings de conexão de banco de dados
    - Tokens de autenticação
    - Chaves privadas

## Quando a Verificação de Segurança Encontra Problemas

Exemplo de saída:
```bash
🔍 Verificação de Segurança:
──────────────────
2 arquivo(s) suspeito(s) detectados e excluídos:
1. config/credentials.json
  - Chave de acesso da AWS encontrada
2. .env.local
  - Senha do banco de dados encontrada
```

## Melhores Práticas

1. Sempre revise a saída antes de compartilhar
2. Use `.repomixignore` para caminhos confidenciais
3. Mantenha as verificações de segurança habilitadas
4. Remova arquivos confidenciais do repositório

## Reportando Problemas de Segurança

Encontrou uma vulnerabilidade de segurança? Por favor:
1. Não abra uma issue pública
2. Envie um e-mail para: koukun0120@gmail.com
3. Ou use [Avisos de Segurança do GitHub](https://github.com/yamadashy/repomix/security/advisories/new)
</file>

<file path="website/client/src/pt-br/guide/usage.md">
# Uso Básico

## Início Rápido

Compacte todo o seu repositório:
```bash
repomix
```

## Casos de Uso Comuns

### Compactar Diretórios Específicos
```bash
repomix path/to/directory
```

### Incluir Arquivos Específicos
Use [glob patterns](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):
```bash
repomix --include "src/**/*.ts,**/*.md"
```

### Excluir Arquivos
```bash
repomix --ignore "**/*.log,tmp/"
```

### Repositórios Remotos
```bash
# Usando URL do GitHub
repomix --remote https://github.com/user/repo

# Usando abreviação
repomix --remote user/repo

# Branch/tag/commit específico
repomix --remote user/repo --remote-branch main
repomix --remote user/repo --remote-branch 935b695
```

### Entrada de Lista de Arquivos (stdin)

Passe caminhos de arquivos via stdin para máxima flexibilidade:

```bash
# Usando comando find
find src -name "*.ts" -type f | repomix --stdin

# Usando git para obter arquivos rastreados
git ls-files "*.ts" | repomix --stdin

# Usando ls com padrões glob
ls src/**/*.ts | repomix --stdin

# De um arquivo contendo caminhos de arquivos
cat file-list.txt | repomix --stdin

# Entrada direta com echo
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```

A opção `--stdin` permite que você canalize uma lista de caminhos de arquivos para o Repomix, oferecendo máxima flexibilidade na seleção de quais arquivos compactar.

> [!NOTE]
> Ao usar `--stdin`, os caminhos de arquivos podem ser relativos ou absolutos, e o Repomix tratará automaticamente da resolução de caminhos e deduplicação.

### Entrada de Lista de Arquivos (stdin)

Passe caminhos de arquivos via stdin para máxima flexibilidade:

```bash
# Usando o comando find
find src -name "*.ts" -type f | repomix --stdin

# Usando git para obter arquivos rastreados
git ls-files "*.ts" | repomix --stdin

# Usando ls com padrões glob
ls src/**/*.ts | repomix --stdin

# De um arquivo contendo caminhos de arquivos
cat file-list.txt | repomix --stdin

# Entrada direta com echo
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```

A opção `--stdin` permite canalizar uma lista de caminhos de arquivos para o Repomix, oferecendo máxima flexibilidade na seleção de quais arquivos compactar.

> [!NOTE]
> Ao usar `--stdin`, os caminhos de arquivos podem ser relativos ou absolutos, e o Repomix irá automaticamente lidar com a resolução de caminhos e desduplicação.

## Formatos de Saída

### XML (Padrão)
```bash
repomix --style xml
```

### Markdown
```bash
repomix --style markdown
```

### Texto Simples
```bash
repomix --style plain
```

## Opções Adicionais

### Remover Comentários
```bash
repomix --remove-comments
```

### Mostrar Números de Linha
```bash
repomix --output-show-line-numbers
```

### Copiar para a Área de Transferência
```bash
repomix --copy
```

### Desativar Verificação de Segurança
```bash
repomix --no-security-check
```

## Configuração

Inicializar arquivo de configuração:
```bash
repomix --init
```

Veja o [Guia de Configuração](/pt-br/guide/configuration) para opções detalhadas.
</file>

<file path="website/client/src/pt-br/index.md">
---
layout: home
title: Repomix
titleTemplate: Compacte seu código-fonte em formatos amigáveis para IA
aside: false
editLink: false

features:
  - icon: 🤖
    title: Otimizado para IA
    details: Formata seu código-fonte de uma maneira fácil para a IA entender e processar.

  - icon: ⚙️
    title: Consciente do Git
    details: Respeita automaticamente seus arquivos .gitignore.

  - icon: 🛡️
    title: Focado na Segurança
    details: Incorpora o Secretlint para verificações de segurança robustas para detectar e prevenir a inclusão de informações confidenciais.

  - icon: 📊
    title: Contagem de Tokens
    details: Fornece contagens de tokens para cada arquivo e para todo o repositório, útil para limites de contexto de LLM.

---

<script setup>
import YouTubeVideo from '../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../utils/videos'
</script>

<div class="cli-section">

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## 🏆 Indicação para os Open Source Awards

Estamos honrados! O Repomix foi indicado na categoria **Powered by AI** no [JSNation Open Source Awards 2025](https://osawards.com/javascript/).

Isso não teria sido possível sem todos vocês que usam e apoiam o Repomix. Obrigado!

Se o Repomix ajudou você a analisar ou empacotar bases de código para ferramentas de IA, ficaríamos gratos pelo seu voto na categoria **Powered by AI**.

## O que é o Repomix?

O Repomix é uma ferramenta poderosa que empacota toda a sua base de código em um único arquivo compatível com IA. Seja trabalhando em revisões de código, refatoração ou precisando de assistência de IA para seu projeto, o Repomix facilita o compartilhamento de todo o contexto do seu repositório com ferramentas de IA.

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

## Início Rápido

Depois de gerar um arquivo compactado (`repomix-output.xml`) usando o Repomix, você pode enviá-lo para um assistente de IA (como ChatGPT, Claude) com um prompt como:

```
Este arquivo contém todos os arquivos do repositório combinados em um.
Eu quero refatorar o código, então, por favor, revise-o primeiro.
```

A IA analisará todo o seu código-fonte e fornecerá insights abrangentes:

![Repomix File Usage 1](/images/docs/repomix-file-usage-1.png)

Ao discutir mudanças específicas, a IA pode ajudar a gerar código. Com recursos como o Artifacts do Claude, você pode até receber vários arquivos interdependentes:

![Repomix File Usage 2](/images/docs/repomix-file-usage-2.png)

Feliz codificação! 🚀

## Usando a Ferramenta CLI {#using-the-cli-tool}

O Repomix pode ser usado como uma ferramenta de linha de comando, oferecendo recursos poderosos e opções de personalização.

**A ferramenta CLI pode acessar repositórios privados** pois utiliza o Git instalado localmente.

### Início Rápido

Você pode experimentar o Repomix instantaneamente no diretório do seu projeto sem instalação:

```bash
npx repomix
```

Ou instale globalmente para uso repetido:

```bash
# Instalar com npm
npm install -g repomix

# Ou com yarn
yarn global add repomix

# Ou com bun
bun add -g repomix

# Ou com Homebrew (macOS/Linux)
brew install repomix

# Então execute em qualquer diretório de projeto
repomix
```

É isso! O Repomix irá gerar um arquivo `repomix-output.xml` no seu diretório atual, contendo todo o seu repositório em um formato amigável para IA.

### Uso

Para compactar todo o seu repositório:

```bash
repomix
```

Para compactar um diretório específico:

```bash
repomix path/to/directory
```

Para compactar arquivos ou diretórios específicos usando [glob patterns](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):

```bash
repomix --include "src/**/*.ts,**/*.md"
```

Para excluir arquivos ou diretórios específicos:

```bash
repomix --ignore "**/*.log,tmp/"
```

Para compactar um repositório remoto:
```bash
# Usando formato abreviado
npx repomix --remote yamadashy/repomix

# Usando URL completa (suporta branches e caminhos específicos)
npx repomix --remote https://github.com/yamadashy/repomix
npx repomix --remote https://github.com/yamadashy/repomix/tree/main

# Usando URL do commit
npx repomix --remote https://github.com/yamadashy/repomix/commit/836abcd7335137228ad77feb28655d85712680f1
```

Para inicializar um novo arquivo de configuração (`repomix.config.json`):

```bash
repomix --init
```

Depois de gerar o arquivo compactado, você pode usá-lo com ferramentas de IA Generativa como Claude, ChatGPT e Gemini.

#### Uso do Docker

Você também pode executar o Repomix usando o Docker 🐳
Isso é útil se você quiser executar o Repomix em um ambiente isolado ou preferir usar contêineres.

Uso básico (diretório atual):

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

Para compactar um diretório específico:
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

Processar um repositório remoto e enviar para um diretório `output`:

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### Formatos de Saída

Escolha seu formato de saída preferido:

```bash
# Formato XML (padrão)
repomix --style xml

# Formato Markdown
repomix --style markdown

# Formato de texto simples
repomix --style plain
```

### Customização

Crie um `repomix.config.json` para configurações persistentes:

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

## Guia de Usuários Avançados

O Repomix oferece recursos poderosos para casos de uso avançados. Aqui estão alguns guias essenciais para usuários avançados:

- **[Servidor MCP](./guide/mcp-server)** - Integração do Model Context Protocol para assistentes de IA
- **[GitHub Actions](./guide/github-actions)** - Automatize o empacotamento de código base em workflows de CI/CD
- **[Compressão de Código](./guide/code-compress)** - Compressão inteligente baseada em Tree-sitter (~70% de redução de tokens)
- **[Usar como Biblioteca](./guide/development/using-repomix-as-a-library)** - Integre o Repomix em suas aplicações Node.js
- **[Instruções Personalizadas](./guide/custom-instructions)** - Adicione prompts e instruções personalizadas às saídas
- **[Recursos de Segurança](./guide/security)** - Integração Secretlint incorporada e verificações de segurança
- **[Melhores Práticas](./guide/tips/best-practices)** - Otimize seus workflows de IA com estratégias comprovadas

### Mais Exemplos
::: tip Precisa de mais ajuda? 💡
Consulte nosso [guia](./guide/) para instruções detalhadas, ou visite nosso [repositório GitHub](https://github.com/yamadashy/repomix) para mais exemplos e código-fonte.
:::

</div>
</file>

<file path="website/client/src/public/images/repomix-logo.svg">
<?xml version="1.0" encoding="utf-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="96.259 93.171 300 300" xmlns:bx="https://boxy-svg.com">
  <g id="group-1" transform="matrix(1.160932, 0, 0, 1.160932, 97.635941, 94.725143)" style="">
    <path style="fill-rule: nonzero; fill-opacity: 1; stroke-width: 2; fill: rgb(234, 127, 58);" d="M 128.03 -1.486 L 21.879 65.349 L 21.848 190.25 L 127.979 256.927 L 234.2 190.27 L 234.197 65.463 L 128.03 -1.486 Z M 208.832 70.323 L 127.984 121.129 L 47.173 70.323 L 128.144 19.57 L 208.832 70.323 Z M 39.669 86.367 L 119.188 136.415 L 119.255 230.529 L 39.637 180.386 L 39.669 86.367 Z M 136.896 230.506 L 136.887 136.575 L 216.469 86.192 L 216.417 180.46 L 136.896 230.506 Z M 136.622 230.849"/>
  </g>
</svg>
</file>

<file path="website/client/src/public/schemas/0.3.5/schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "$schema": {
      "type": "string"
    },
    "input": {
      "type": "object",
      "properties": {
        "maxFileSize": {
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "output": {
      "type": "object",
      "properties": {
        "filePath": {
          "type": "string"
        },
        "style": {
          "type": "string",
          "enum": [
            "xml",
            "markdown",
            "plain"
          ]
        },
        "parsableStyle": {
          "type": "boolean"
        },
        "headerText": {
          "type": "string"
        },
        "instructionFilePath": {
          "type": "string"
        },
        "fileSummary": {
          "type": "boolean"
        },
        "directoryStructure": {
          "type": "boolean"
        },
        "files": {
          "type": "boolean"
        },
        "removeComments": {
          "type": "boolean"
        },
        "removeEmptyLines": {
          "type": "boolean"
        },
        "compress": {
          "type": "boolean"
        },
        "topFilesLength": {
          "type": "number"
        },
        "showLineNumbers": {
          "type": "boolean"
        },
        "copyToClipboard": {
          "type": "boolean"
        },
        "includeEmptyDirectories": {
          "type": "boolean"
        },
        "git": {
          "type": "object",
          "properties": {
            "sortByChanges": {
              "type": "boolean"
            },
            "sortByChangesMaxCommits": {
              "type": "number"
            },
            "includeDiffs": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "include": {
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "ignore": {
      "type": "object",
      "properties": {
        "useGitignore": {
          "type": "boolean"
        },
        "useDefaultPatterns": {
          "type": "boolean"
        },
        "customPatterns": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "security": {
      "type": "object",
      "properties": {
        "enableSecurityCheck": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "tokenCount": {
      "type": "object",
      "properties": {
        "encoding": {
          "type": "string"
        }
      },
      "additionalProperties": false
    }
  },
  "additionalProperties": false,
  "title": "Repomix Configuration",
  "description": "Schema for repomix.config.json configuration file"
}
</file>

<file path="website/client/src/public/schemas/latest/schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "$schema": {
      "type": "string"
    },
    "input": {
      "type": "object",
      "properties": {
        "maxFileSize": {
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "output": {
      "type": "object",
      "properties": {
        "filePath": {
          "type": "string"
        },
        "style": {
          "type": "string",
          "enum": [
            "xml",
            "markdown",
            "plain"
          ]
        },
        "parsableStyle": {
          "type": "boolean"
        },
        "headerText": {
          "type": "string"
        },
        "instructionFilePath": {
          "type": "string"
        },
        "fileSummary": {
          "type": "boolean"
        },
        "directoryStructure": {
          "type": "boolean"
        },
        "files": {
          "type": "boolean"
        },
        "removeComments": {
          "type": "boolean"
        },
        "removeEmptyLines": {
          "type": "boolean"
        },
        "compress": {
          "type": "boolean"
        },
        "topFilesLength": {
          "type": "number"
        },
        "showLineNumbers": {
          "type": "boolean"
        },
        "copyToClipboard": {
          "type": "boolean"
        },
        "includeEmptyDirectories": {
          "type": "boolean"
        },
        "git": {
          "type": "object",
          "properties": {
            "sortByChanges": {
              "type": "boolean"
            },
            "sortByChangesMaxCommits": {
              "type": "number"
            },
            "includeDiffs": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "include": {
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "ignore": {
      "type": "object",
      "properties": {
        "useGitignore": {
          "type": "boolean"
        },
        "useDefaultPatterns": {
          "type": "boolean"
        },
        "customPatterns": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "security": {
      "type": "object",
      "properties": {
        "enableSecurityCheck": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "tokenCount": {
      "type": "object",
      "properties": {
        "encoding": {
          "type": "string"
        }
      },
      "additionalProperties": false
    }
  },
  "additionalProperties": false,
  "title": "Repomix Configuration",
  "description": "Schema for repomix.config.json configuration file"
}
</file>

<file path="website/client/src/vi/guide/development/index.md">
# Đóng góp cho Repomix

Repomix là một dự án mã nguồn mở và chúng tôi hoan nghênh đóng góp từ cộng đồng. Trang này cung cấp thông tin về cách bạn có thể đóng góp cho dự án.

## Thiết lập môi trường phát triển

### Yêu cầu

- Node.js (phiên bản 16 trở lên)
- npm hoặc yarn
- Git

### Clone kho lưu trữ

```bash
git clone https://github.com/yamadashy/repomix.git
cd repomix
```

### Cài đặt phụ thuộc

```bash
npm install
```

hoặc nếu bạn sử dụng yarn:

```bash
yarn install
```

### Xây dựng dự án

```bash
npm run build
```

### Chạy các bài kiểm tra

```bash
npm run test
```

### Chạy linter

```bash
npm run lint
```

## Cấu trúc dự án

Dự án Repomix được tổ chức như sau:

```
repomix/
├── src/                  # Mã nguồn chính
│   ├── cli/              # Giao diện dòng lệnh
│   ├── core/             # Chức năng cốt lõi
│   ├── formatters/       # Trình định dạng đầu ra
│   ├── security/         # Kiểm tra bảo mật
│   └── utils/            # Tiện ích
├── test/                 # Bài kiểm tra
├── website/              # Tài liệu trang web
├── .github/              # Cấu hình GitHub
├── package.json          # Cấu hình npm
└── tsconfig.json         # Cấu hình TypeScript
```

## Quy trình đóng góp

### 1. Tạo một vấn đề

Trước khi bắt đầu làm việc trên một tính năng hoặc sửa lỗi, hãy tạo một vấn đề trên GitHub để thảo luận về nó. Điều này giúp đảm bảo rằng công việc của bạn phù hợp với hướng đi của dự án và tránh trùng lặp nỗ lực.

### 2. Fork kho lưu trữ

Fork kho lưu trữ Repomix vào tài khoản GitHub của bạn.

### 3. Tạo một nhánh

Tạo một nhánh mới cho tính năng hoặc sửa lỗi của bạn:

```bash
git checkout -b feature/your-feature-name
```

hoặc

```bash
git checkout -b fix/your-bug-fix
```

### 4. Thực hiện thay đổi của bạn

Thực hiện thay đổi của bạn, tuân theo các quy ước mã của dự án:

- Sử dụng TypeScript cho mã mới
- Tuân theo quy ước đặt tên camelCase cho biến và PascalCase cho lớp
- Viết bài kiểm tra cho mã mới
- Đảm bảo tất cả các bài kiểm tra đều vượt qua
- Cập nhật tài liệu nếu cần

### 5. Commit thay đổi của bạn

```bash
git add .
git commit -m "feat: add new feature" # hoặc "fix: fix some bug"
```

Chúng tôi sử dụng quy ước commit [Conventional Commits](https://www.conventionalcommits.org/).

### 6. Đẩy lên fork của bạn

```bash
git push origin feature/your-feature-name
```

### 7. Tạo một Pull Request

Tạo một Pull Request từ nhánh của bạn đến nhánh `main` của kho lưu trữ Repomix. Trong mô tả Pull Request của bạn:

- Tham chiếu đến vấn đề mà PR giải quyết
- Mô tả thay đổi của bạn
- Mô tả cách kiểm tra thay đổi của bạn
- Thêm ảnh chụp màn hình nếu có thay đổi trực quan

### 8. Xem xét mã

Nhóm Repomix sẽ xem xét PR của bạn và có thể yêu cầu thay đổi. Hãy kiên nhẫn và phản hồi các yêu cầu xem xét một cách kịp thời.

### 9. Hợp nhất

Sau khi PR của bạn được phê duyệt, nó sẽ được hợp nhất vào nhánh chính.

## Hướng dẫn đóng góp

### Mã

- Viết mã rõ ràng và dễ bảo trì
- Bao gồm nhận xét cho mã phức tạp
- Tuân theo các quy ước mã hiện có
- Viết bài kiểm tra cho mã mới
- Đảm bảo tất cả các bài kiểm tra đều vượt qua
- Cập nhật tài liệu nếu cần

### Tài liệu

- Viết tài liệu rõ ràng và ngắn gọn
- Bao gồm ví dụ khi có thể
- Kiểm tra chính tả và ngữ pháp
- Giữ cho tài liệu cập nhật với các thay đổi mã

### Báo cáo lỗi

Khi báo cáo lỗi, hãy bao gồm:

- Phiên bản Repomix bạn đang sử dụng
- Hệ điều hành và phiên bản của bạn
- Các bước để tái tạo lỗi
- Hành vi thực tế và hành vi mong đợi
- Ảnh chụp màn hình hoặc nhật ký nếu có

### Yêu cầu tính năng

Khi yêu cầu tính năng, hãy bao gồm:

- Mô tả rõ ràng về tính năng
- Lý do tại sao tính năng này sẽ có giá trị
- Ví dụ về cách tính năng sẽ được sử dụng
- Bất kỳ tài liệu tham khảo hoặc ví dụ từ các dự án khác

## Phát hành

Repomix tuân theo [Semantic Versioning](https://semver.org/). Các phiên bản được đặt tên theo định dạng `MAJOR.MINOR.PATCH`:

- `MAJOR`: Thay đổi không tương thích với API
- `MINOR`: Thêm chức năng tương thích ngược
- `PATCH`: Sửa lỗi tương thích ngược

## Liên hệ

Nếu bạn có bất kỳ câu hỏi nào về đóng góp cho Repomix, vui lòng:

- [Tham gia Discord của chúng tôi](https://discord.gg/wNYzTwZFku)
- [Mở một vấn đề trên GitHub](https://github.com/yamadashy/repomix/issues)

## Tiếp theo là gì?

- [Sử dụng Repomix như một thư viện](using-repomix-as-a-library.md): Tìm hiểu cách sử dụng Repomix như một thư viện trong dự án của bạn
- [Mẹo phát triển hỗ trợ AI](../tips/best-practices.md): Tìm hiểu về các thực hành tốt nhất cho phát triển hỗ trợ AI
</file>

<file path="website/client/src/vi/guide/development/using-repomix-as-a-library.md">
# Sử dụng Repomix như một thư viện

Ngoài việc sử dụng Repomix như một công cụ dòng lệnh, bạn cũng có thể tích hợp nó trực tiếp vào các ứng dụng JavaScript hoặc TypeScript của mình như một thư viện.

## Cài đặt

Để sử dụng Repomix như một thư viện, trước tiên hãy cài đặt nó như một phụ thuộc:

```bash
# Sử dụng npm
npm install repomix

# Sử dụng yarn
yarn add repomix

# Sử dụng pnpm
pnpm add repomix
```

## Sử dụng cơ bản

Dưới đây là một ví dụ cơ bản về cách sử dụng Repomix trong mã của bạn:

```typescript
import { processRepository } from 'repomix';

async function packMyRepo() {
  try {
    const result = await processRepository({
      path: '/path/to/your/repository',
      output: {
        style: 'xml',
        filePath: 'output.xml',
      },
    });

    console.log('Repository packed successfully!');
    console.log(`Output saved to: ${result.outputPath}`);
    console.log(`Total files: ${result.stats.fileCount}`);
    console.log(`Total tokens: ${result.stats.totalTokens}`);
  } catch (error) {
    console.error('Error packing repository:', error);
  }
}

packMyRepo();
```

## API

### processRepository

Hàm chính để xử lý một kho lưu trữ:

```typescript
async function processRepository(options: RepositoryProcessorOptions): Promise<RepositoryProcessorResult>
```

#### Tùy chọn

Đối tượng `RepositoryProcessorOptions` chấp nhận các tùy chọn sau:

```typescript
interface RepositoryProcessorOptions {
  // Đường dẫn đến kho lưu trữ cục bộ
  path?: string;
  
  // URL của kho lưu trữ từ xa (thay thế cho path)
  remote?: string;
  
  // Cấu hình đầu ra
  output?: {
    // Định dạng đầu ra (xml, markdown, plain)
    style?: 'xml' | 'markdown' | 'plain';
    
    // Đường dẫn tệp đầu ra
    filePath?: string;
    
    // Xóa bình luận khỏi mã nguồn
    removeComments?: boolean;
    
    // Hiển thị số dòng trong đầu ra
    showLineNumbers?: boolean;
    
    // Số lượng tệp hàng đầu để hiển thị trong tóm tắt
    topFilesLength?: number;
    
    // Nội dung hướng dẫn tùy chỉnh
    instructions?: string;
    
    // Đường dẫn đến tệp hướng dẫn
    instructionsPath?: string;
  };
  
  // Cấu hình bỏ qua
  ignore?: {
    // Tôn trọng các tệp .gitignore
    respectGitignore?: boolean;
    
    // Mảng các mẫu glob để bỏ qua
    customPatterns?: string[];
  };
  
  // Cấu hình bảo mật
  security?: {
    // Bật kiểm tra bảo mật
    check?: boolean;
    
    // Đường dẫn đến tệp cấu hình Secretlint
    secretlintConfigPath?: string;
  };
  
  // Cấu hình nâng cao
  advanced?: {
    // Nén mã bằng cách chỉ bao gồm chữ ký hàm
    compressCode?: boolean;
    
    // Bật đếm token
    tokenCount?: boolean;
  };
  
  // Mẫu bao gồm (phân tách bằng dấu phẩy)
  include?: string;
}
```

#### Kết quả

Hàm `processRepository` trả về một Promise giải quyết thành một đối tượng `RepositoryProcessorResult`:

```typescript
interface RepositoryProcessorResult {
  // Đường dẫn đến tệp đầu ra
  outputPath: string;
  
  // Nội dung đầu ra
  output: string;
  
  // Thống kê về kho lưu trữ đã xử lý
  stats: {
    // Số lượng tệp đã xử lý
    fileCount: number;
    
    // Tổng số dòng
    totalLines: number;
    
    // Tổng số token
    totalTokens: number;
    
    // Thông tin về các tệp hàng đầu
    topFiles: Array<{
      path: string;
      lines: number;
      tokens: number;
    }>;
  };
}
```

## Ví dụ nâng cao

### Xử lý kho lưu trữ từ xa

```typescript
import { processRepository } from 'repomix';

async function packRemoteRepo() {
  const result = await processRepository({
    remote: 'https://github.com/yamadashy/repomix',
    output: {
      style: 'markdown',
      filePath: 'repomix-source.md',
    },
  });

  console.log(`Repository packed to: ${result.outputPath}`);
}

packRemoteRepo();
```

### Tùy chọn đầu ra tùy chỉnh

```typescript
import { processRepository } from 'repomix';

async function packWithCustomOptions() {
  const result = await processRepository({
    path: './my-project',
    output: {
      style: 'xml',
      filePath: 'output.xml',
      removeComments: true,
      showLineNumbers: true,
      topFilesLength: 20,
      instructions: 'Đây là codebase của dự án X. Vui lòng tập trung vào...',
    },
    ignore: {
      respectGitignore: true,
      customPatterns: ['*.test.ts', 'docs/**'],
    },
    advanced: {
      compressCode: true,
      tokenCount: true,
    },
  });

  console.log(`Packed ${result.stats.fileCount} files with ${result.stats.totalTokens} tokens`);
}

packWithCustomOptions();
```

### Xử lý đầu ra trong bộ nhớ

```typescript
import { processRepository } from 'repomix';
import * as fs from 'fs';

async function processAndModifyOutput() {
  // Xử lý kho lưu trữ
  const result = await processRepository({
    path: './my-project',
    output: {
      style: 'markdown',
      // Không chỉ định filePath để không ghi vào tệp
    },
  });

  // Sửa đổi đầu ra
  const modifiedOutput = `# Codebase được xử lý bởi ứng dụng tùy chỉnh\n\n${result.output}`;

  // Ghi đầu ra đã sửa đổi vào tệp
  fs.writeFileSync('custom-output.md', modifiedOutput);

  console.log('Custom processing complete!');
}

processAndModifyOutput();
```

### Tích hợp với Express

```typescript
import express from 'express';
import { processRepository } from 'repomix';

const app = express();
app.use(express.json());

app.post('/process', async (req, res) => {
  try {
    const { repoPath, options } = req.body;
    
    const result = await processRepository({
      path: repoPath,
      ...options,
    });
    
    res.json({
      success: true,
      stats: result.stats,
      output: result.output,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message,
    });
  }
});

app.listen(3000, () => {
  console.log('Repomix API server running on port 3000');
});
```

## Xử lý lỗi

Khi sử dụng Repomix như một thư viện, hãy đảm bảo xử lý lỗi đúng cách:

```typescript
import { processRepository } from 'repomix';

async function safelyPackRepo() {
  try {
    const result = await processRepository({
      path: './my-project',
    });
    return result;
  } catch (error) {
    if (error.code === 'SECURITY_ISSUE') {
      console.error('Security issue detected:', error.message);
      // Xử lý vấn đề bảo mật
    } else if (error.code === 'INVALID_PATH') {
      console.error('Invalid repository path:', error.message);
      // Xử lý đường dẫn không hợp lệ
    } else {
      console.error('Unexpected error:', error);
      // Xử lý lỗi khác
    }
    throw error; // Hoặc xử lý lỗi và trả về giá trị mặc định
  }
}
```

## Tiếp theo là gì?

- [Đóng góp cho Repomix](./index.md): Tìm hiểu cách đóng góp cho dự án
- [Mẹo phát triển hỗ trợ AI](../tips/best-practices.md): Tìm hiểu về các thực hành tốt nhất cho phát triển hỗ trợ AI
- [Cấu hình](../configuration.md): Tìm hiểu thêm về các tùy chọn cấu hình
</file>

<file path="website/client/src/vi/guide/tips/best-practices.md">
# Mẹo phát triển hỗ trợ AI

Khi phát triển phần mềm với sự hỗ trợ của AI, có một số thực hành tốt nhất có thể giúp bạn tối đa hóa hiệu quả và chất lượng của quá trình phát triển. Trang này cung cấp các mẹo và hướng dẫn để làm việc hiệu quả với AI khi sử dụng Repomix.

## Chuẩn bị codebase của bạn

### Tổ chức mã

Trước khi đóng gói codebase của bạn với Repomix, hãy xem xét tổ chức nó theo cách giúp AI dễ dàng hiểu:

- **Cấu trúc thư mục rõ ràng**: Sử dụng cấu trúc thư mục có ý nghĩa phản ánh kiến trúc của ứng dụng
- **Tệp README toàn diện**: Bao gồm tổng quan về dự án, hướng dẫn thiết lập và thông tin quan trọng khác
- **Tài liệu mã**: Thêm nhận xét và tài liệu cho các phần phức tạp của mã
- **Quy ước đặt tên nhất quán**: Sử dụng quy ước đặt tên nhất quán trong toàn bộ codebase

### Tối ưu hóa cho AI

- **Loại bỏ mã không sử dụng**: Xóa mã chết hoặc không sử dụng để giảm nhiễu
- **Tách các tệp lớn**: Chia các tệp lớn thành các mô-đun nhỏ hơn, tập trung hơn
- **Giảm thiểu phụ thuộc**: Giảm thiểu phụ thuộc không cần thiết để đơn giản hóa codebase
- **Chuẩn hóa định dạng**: Sử dụng trình định dạng mã để đảm bảo phong cách nhất quán

## Tạo prompt hiệu quả

### Cấu trúc prompt

Khi làm việc với đầu ra Repomix, hãy cấu trúc prompt của bạn để có kết quả tốt nhất:

- **Bắt đầu với bối cảnh**: Cung cấp bối cảnh về dự án và mục tiêu của bạn
- **Chia thành các bước**: Chia các nhiệm vụ phức tạp thành các bước nhỏ hơn, tuần tự
- **Chỉ định định dạng đầu ra**: Nêu rõ cách bạn muốn phản hồi được định dạng
- **Đặt câu hỏi cụ thể**: Tránh các câu hỏi mơ hồ; càng cụ thể càng tốt

### Ví dụ prompt hiệu quả

```
Tệp này chứa codebase của ứng dụng quản lý nhiệm vụ của tôi được đóng gói bởi Repomix.

Bối cảnh: Đây là một ứng dụng React với backend Node.js sử dụng MongoDB.

Tôi muốn cải thiện hiệu suất của ứng dụng, đặc biệt là thời gian tải ban đầu. Vui lòng:

1. Xác định các vấn đề hiệu suất tiềm ẩn trong mã frontend (tập trung vào các thành phần React và quản lý trạng thái)
2. Đề xuất các tối ưu hóa cụ thể với ví dụ mã
3. Đề xuất các thay đổi kiến trúc có thể cải thiện hiệu suất tổng thể

Định dạng phản hồi của bạn như sau:
- Tóm tắt các vấn đề hiệu suất được xác định
- Danh sách các tối ưu hóa được đề xuất với ví dụ trước/sau
- Đề xuất kiến trúc với lý do
```

## Làm việc với phản hồi AI

### Đánh giá phản hồi

Khi nhận phản hồi từ AI dựa trên codebase của bạn:

- **Xác minh tính chính xác**: Kiểm tra phản hồi để đảm bảo nó chính xác và phù hợp với codebase của bạn
- **Hiểu lý do**: Đảm bảo bạn hiểu lý do đằng sau các đề xuất
- **Đánh giá tính khả thi**: Xem xét liệu các đề xuất có thực tế và phù hợp với dự án của bạn không
- **Tìm kiếm các giả định**: Xác định bất kỳ giả định nào mà AI có thể đã đưa ra

### Lặp lại và cải thiện

- **Làm rõ khi cần thiết**: Nếu phản hồi không rõ ràng, hãy yêu cầu làm rõ
- **Cung cấp phản hồi**: Cho AI biết những gì hữu ích và những gì không hữu ích
- **Tinh chỉnh prompt**: Điều chỉnh prompt của bạn dựa trên phản hồi bạn nhận được
- **Chia nhỏ vấn đề**: Nếu phản hồi quá rộng, hãy chia vấn đề thành các phần nhỏ hơn

## Các trường hợp sử dụng phổ biến

### Phân tích mã

Khi sử dụng AI để phân tích codebase:

- Yêu cầu tổng quan cấp cao trước khi đi vào chi tiết
- Tập trung vào các khu vực cụ thể của mối quan tâm
- Yêu cầu xác định các mẫu và chống mẫu
- Yêu cầu đánh giá về khả năng bảo trì và mở rộng

### Tái cấu trúc mã

Khi sử dụng AI để tái cấu trúc mã:

- Giải thích vấn đề với mã hiện tại
- Chỉ định các mục tiêu của tái cấu trúc
- Yêu cầu các bước từng bước để thực hiện tái cấu trúc
- Yêu cầu giải thích về cách tái cấu trúc cải thiện mã

### Gỡ lỗi

Khi sử dụng AI để gỡ lỗi:

- Cung cấp thông báo lỗi đầy đủ
- Mô tả hành vi mong đợi và thực tế
- Bao gồm bối cảnh liên quan (phiên bản, môi trường)
- Yêu cầu các nguyên nhân tiềm ẩn và giải pháp

### Tạo tính năng mới

Khi sử dụng AI để phát triển tính năng mới:

- Mô tả tính năng và mục đích của nó
- Chỉ định cách nó nên tích hợp với mã hiện có
- Yêu cầu thiết kế cấp cao trước khi triển khai
- Yêu cầu các trường hợp kiểm tra để xác minh tính năng

## Tối ưu hóa quy trình phát triển

### Tích hợp AI vào quy trình phát triển

- **Sử dụng AI cho các nhiệm vụ lặp đi lặp lại**: Tự động hóa các nhiệm vụ lặp đi lặp lại như tạo mã soạn sẵn
- **Sử dụng AI cho đánh giá mã**: Yêu cầu AI xem xét mã của bạn để tìm lỗi và cải tiến
- **Sử dụng AI cho tài liệu**: Tạo và duy trì tài liệu với sự trợ giúp của AI
- **Sử dụng AI cho kiểm tra**: Tạo các trường hợp kiểm tra và kịch bản kiểm tra với sự trợ giúp của AI

### Cân bằng đầu vào của AI và con người

- **Xác minh đầu ra của AI**: Luôn xem xét và xác minh đầu ra của AI trước khi tích hợp nó
- **Duy trì kiểm soát sáng tạo**: Sử dụng AI như một công cụ, không phải là người thay thế cho sự sáng tạo của con người
- **Kết hợp chuyên môn của con người**: Kết hợp kiến thức miền và chuyên môn kỹ thuật của bạn với khả năng của AI
- **Lặp lại và cải thiện**: Sử dụng phản hồi từ AI để cải thiện quy trình phát triển của bạn

## Tiếp theo là gì?

- [Đóng góp cho Repomix](../development/index.md): Tìm hiểu cách đóng góp cho dự án
- [Sử dụng Repomix như một thư viện](../development/using-repomix-as-a-library.md): Tìm hiểu cách sử dụng Repomix như một thư viện
- [Sử dụng cơ bản](../usage.md): Quay lại hướng dẫn sử dụng cơ bản
</file>

<file path="website/client/src/vi/guide/code-compress.md">
# Nén mã

Repomix cung cấp tính năng nén mã để giảm kích thước đầu ra bằng cách chỉ bao gồm chữ ký hàm và loại bỏ phần thân hàm. Điều này đặc biệt hữu ích khi làm việc với các codebase lớn và giới hạn token của mô hình ngôn ngữ lớn (LLM).

## Tổng quan

Tính năng nén mã:

- Giữ lại chữ ký hàm, lớp và phương thức
- Loại bỏ phần thân hàm và phương thức
- Duy trì cấu trúc tổng thể của codebase
- Giảm đáng kể số lượng token

Điều này cho phép AI hiểu cấu trúc và API của codebase mà không cần xem xét từng dòng mã triển khai.

## Sử dụng tính năng nén mã

### Thông qua dòng lệnh

Để bật nén mã khi chạy Repomix:

```bash
repomix --compress-code
```

### Thông qua tệp cấu hình

Bạn cũng có thể bật nén mã trong tệp cấu hình `repomix.config.json`:

```json
{
  "advanced": {
    "compressCode": true
  }
}
```

## Ví dụ nén mã

### Mã gốc

```typescript
/**
 * Lớp User đại diện cho người dùng trong hệ thống
 */
class User {
  private name: string;
  private email: string;
  private age: number;

  /**
   * Tạo một người dùng mới
   */
  constructor(name: string, email: string, age: number) {
    this.name = name;
    this.email = email;
    this.age = age;
    console.log(`Người dùng mới được tạo: ${name}`);
  }

  /**
   * Trả về tên người dùng
   */
  getName(): string {
    return this.name;
  }

  /**
   * Trả về email người dùng
   */
  getEmail(): string {
    return this.email;
  }

  /**
   * Trả về tuổi người dùng
   */
  getAge(): number {
    return this.age;
  }

  /**
   * Kiểm tra xem người dùng có phải là người trưởng thành không
   */
  isAdult(): boolean {
    return this.age >= 18;
  }

  /**
   * Cập nhật thông tin người dùng
   */
  updateInfo(name?: string, email?: string, age?: number): void {
    if (name) this.name = name;
    if (email) this.email = email;
    if (age) this.age = age;
    console.log('Thông tin người dùng đã được cập nhật');
  }
}
```

### Mã đã nén

```typescript
/**
 * Lớp User đại diện cho người dùng trong hệ thống
 */
class User {
  private name: string;
  private email: string;
  private age: number;

  /**
   * Tạo một người dùng mới
   */
  constructor(name: string, email: string, age: number) { /* ... */ }

  /**
   * Trả về tên người dùng
   */
  getName(): string { /* ... */ }

  /**
   * Trả về email người dùng
   */
  getEmail(): string { /* ... */ }

  /**
   * Trả về tuổi người dùng
   */
  getAge(): number { /* ... */ }

  /**
   * Kiểm tra xem người dùng có phải là người trưởng thành không
   */
  isAdult(): boolean { /* ... */ }

  /**
   * Cập nhật thông tin người dùng
   */
  updateInfo(name?: string, email?: string, age?: number): void { /* ... */ }
}
```

## Lợi ích của nén mã

### Giảm số lượng token

Nén mã có thể giảm đáng kể số lượng token cần thiết để đại diện cho codebase, cho phép bạn đưa vào nhiều tệp hơn trong cùng một giới hạn token.

### Tập trung vào cấu trúc

Bằng cách chỉ hiển thị chữ ký hàm, AI có thể tập trung vào cấu trúc tổng thể và API của codebase thay vì chi tiết triển khai.

### Phân tích cấp cao

Nén mã rất hữu ích cho các nhiệm vụ phân tích cấp cao như:
- Hiểu cấu trúc dự án
- Xác định mẫu thiết kế
- Phân tích phụ thuộc
- Tạo tài liệu

## Khi nào nên sử dụng nén mã

Nén mã đặc biệt hữu ích trong các trường hợp sau:

- **Codebase lớn**: Khi codebase của bạn quá lớn để phù hợp với giới hạn token của LLM
- **Phân tích cấu trúc**: Khi bạn muốn AI tập trung vào cấu trúc tổng thể thay vì chi tiết triển khai
- **Tạo tài liệu**: Khi bạn muốn tạo tài liệu dựa trên API công khai
- **Hiểu tổng quan**: Khi bạn cần hiểu tổng quan về một codebase lớn

## Khi nào không nên sử dụng nén mã

Nén mã có thể không phù hợp trong các trường hợp sau:

- **Phân tích mã chi tiết**: Khi bạn cần AI phân tích chi tiết triển khai
- **Tìm lỗi**: Khi bạn đang tìm kiếm lỗi trong mã
- **Tối ưu hóa hiệu suất**: Khi bạn muốn AI đề xuất cải tiến hiệu suất
- **Tái cấu trúc mã**: Khi bạn cần AI hiểu đầy đủ logic hiện tại để đề xuất tái cấu trúc

## Kết hợp với các tính năng khác

Nén mã có thể được kết hợp với các tính năng khác của Repomix:

```bash
repomix --compress-code --remove-comments --style markdown
```

Lệnh này sẽ tạo một đầu ra Markdown với mã đã nén và không có bình luận, giảm đáng kể kích thước đầu ra.

## Tiếp theo là gì?

- [Xóa bình luận](comment-removal.md): Tìm hiểu về tính năng xóa bình luận
- [Cấu hình](configuration.md): Tìm hiểu về tệp cấu hình
- [Tùy chọn dòng lệnh](command-line-options.md): Xem tất cả các tùy chọn dòng lệnh có sẵn
</file>

<file path="website/client/src/vi/guide/command-line-options.md">
# Tùy chọn dòng lệnh

Repomix cung cấp nhiều tùy chọn dòng lệnh để tùy chỉnh hành vi của nó. Dưới đây là danh sách đầy đủ các tùy chọn có sẵn.

## Tùy chọn cơ bản

| Tùy chọn | Mô tả |
| --- | --- |
| `--help`, `-h` | Hiển thị thông tin trợ giúp |
| `--version`, `-v` | Hiển thị phiên bản |
| `--init` | Tạo tệp cấu hình mẫu (`repomix.config.json`) |

## Tùy chọn đầu vào

| Tùy chọn | Mô tả |
| --- | --- |
| `--remote <url>` | Xử lý kho lưu trữ từ xa thay vì kho lưu trữ cục bộ |
| `--include <patterns>` | Chỉ bao gồm các tệp khớp với các mẫu được cung cấp (phân tách bằng dấu phẩy) |
| `--ignore <patterns>` | Bỏ qua các tệp khớp với các mẫu được cung cấp (phân tách bằng dấu phẩy) |
| `--stdin` | Đọc đường dẫn tệp từ stdin thay vì tự động khám phá tệp |
| `--no-respect-gitignore` | Không tôn trọng các tệp .gitignore |
| `--config <path>` | Chỉ định đường dẫn đến tệp cấu hình |

## Tùy chọn đầu ra

| Tùy chọn | Mô tả |
| --- | --- |
| `--output-file <path>`, `-o <path>` | Chỉ định tên tệp đầu ra |
| `--style <style>` | Định dạng đầu ra (xml, markdown, plain) |
| `--remove-comments` | Xóa bình luận khỏi mã nguồn |
| `--show-line-numbers` | Hiển thị số dòng trong đầu ra |
| `--top-files-length <number>` | Số lượng tệp hàng đầu để hiển thị trong tóm tắt |

## Tùy chọn bảo mật

| Tùy chọn | Mô tả |
| --- | --- |
| `--no-security-check` | Tắt kiểm tra bảo mật |
| `--secretlint-config <path>` | Chỉ định đường dẫn đến tệp cấu hình Secretlint |

## Tùy chọn nâng cao

| Tùy chọn | Mô tả |
| --- | --- |
| `--compress-code` | Nén mã bằng cách chỉ bao gồm chữ ký hàm |
| `--no-token-count` | Tắt đếm token |
| `--no-color` | Tắt đầu ra màu |
| `--debug` | Bật chế độ gỡ lỗi |

## Ví dụ

### Đóng gói với các tùy chọn cơ bản

```bash
repomix --style markdown --output-file codebase.md
```

### Đóng gói với các mẫu bao gồm và loại trừ

```bash
repomix --include "src/**/*.ts,**/*.md" --ignore "**/*.test.ts,docs/**"
```

### Đóng gói với các tùy chọn nâng cao

```bash
repomix --remove-comments --show-line-numbers --compress-code
```

### Đóng gói kho lưu trữ từ xa

```bash
repomix --remote https://github.com/yamadashy/repomix --style markdown
```

## Sử dụng với tệp cấu hình

Thay vì chỉ định tất cả các tùy chọn trên dòng lệnh, bạn có thể sử dụng tệp cấu hình:

```bash
repomix --config custom-config.json
```

Hoặc chỉ cần đặt một tệp `repomix.config.json` trong thư mục hiện tại.

## Tiếp theo là gì?

- [Cấu hình](configuration.md): Tìm hiểu về tệp cấu hình
- [Sử dụng cơ bản](usage.md): Quay lại hướng dẫn sử dụng cơ bản
- [Xử lý kho lưu trữ từ xa](remote-repository-processing.md): Tìm hiểu thêm về xử lý kho lưu trữ từ xa
</file>

<file path="website/client/src/vi/guide/comment-removal.md">
# Xóa bình luận

Repomix cung cấp tùy chọn để xóa bình luận khỏi mã nguồn trong đầu ra, giúp giảm kích thước đầu ra và tập trung vào mã thực tế.

## Tổng quan

Bình luận trong mã nguồn rất hữu ích cho các nhà phát triển, nhưng chúng có thể:

- Chiếm không gian token quý giá khi làm việc với các mô hình ngôn ngữ lớn (LLMs)
- Chứa thông tin không liên quan hoặc lỗi thời
- Làm phân tâm khỏi cấu trúc mã thực tế

Tính năng xóa bình luận của Repomix giúp giải quyết những vấn đề này bằng cách loại bỏ bình luận khỏi đầu ra.

## Sử dụng tính năng xóa bình luận

### Thông qua dòng lệnh

Để bật xóa bình luận khi chạy Repomix:

```bash
repomix --remove-comments
```

Lệnh này sẽ xóa tất cả các bình luận khỏi mã nguồn trong đầu ra.

### Thông qua tệp cấu hình

Bạn cũng có thể bật xóa bình luận trong tệp cấu hình `repomix.config.json`:

```json
{
  "output": {
    "removeComments": true
  }
}
```

## Các loại bình luận được xóa

Repomix xóa các loại bình luận sau:

### Bình luận dòng đơn

```javascript
// Đây là một bình luận dòng đơn
const x = 5;
```

### Bình luận nhiều dòng

```javascript
/*
 * Đây là một bình luận
 * nhiều dòng
 */
const y = 10;
```

### Bình luận tài liệu

```javascript
/**
 * Hàm này tính tổng hai số
 * @param {number} a - Số thứ nhất
 * @param {number} b - Số thứ hai
 * @returns {number} Tổng của a và b
 */
function add(a, b) {
  return a + b;
}
```

### Bình luận JSX/TSX

```jsx
const element = (
  <div>
    {/* Đây là một bình luận JSX */}
    <p>Hello, world!</p>
  </div>
);
```

### Bình luận HTML

```html
<!-- Đây là một bình luận HTML -->
<div>Hello, world!</div>
```

## Hỗ trợ ngôn ngữ

Tính năng xóa bình luận hỗ trợ nhiều ngôn ngữ lập trình, bao gồm nhưng không giới hạn ở:

- JavaScript/TypeScript
- Python
- Java
- C/C++
- C#
- Go
- Ruby
- PHP
- HTML/CSS
- Rust
- Swift
- Kotlin

## Khi nào nên sử dụng xóa bình luận

Xóa bình luận đặc biệt hữu ích trong các trường hợp sau:

- **Giới hạn token**: Khi bạn cần giảm số lượng token để phù hợp với giới hạn ngữ cảnh của LLM
- **Tập trung vào mã**: Khi bạn muốn AI tập trung vào mã thực tế thay vì bình luận
- **Bình luận lỗi thời**: Khi codebase có bình luận lỗi thời có thể gây nhầm lẫn cho AI
- **Phân tích mã**: Khi bạn muốn AI phân tích cấu trúc mã mà không bị ảnh hưởng bởi bình luận

## Khi nào nên giữ lại bình luận

Trong một số trường hợp, bạn có thể muốn giữ lại bình luận:

- **Tài liệu API**: Khi bình luận chứa thông tin API quan trọng
- **Giải thích thuật toán phức tạp**: Khi bình luận giải thích các thuật toán hoặc logic phức tạp
- **Bối cảnh dự án**: Khi bình luận cung cấp bối cảnh quan trọng về dự án
- **Hướng dẫn sử dụng**: Khi bình luận chứa hướng dẫn sử dụng quan trọng

## Ví dụ so sánh

### Với bình luận

```javascript
/**
 * Lớp User đại diện cho người dùng trong hệ thống
 */
class User {
  /**
   * Tạo một người dùng mới
   * @param {string} name - Tên người dùng
   * @param {string} email - Email người dùng
   */
  constructor(name, email) {
    // Lưu trữ tên người dùng
    this.name = name;
    // Lưu trữ email người dùng
    this.email = email;
  }

  /**
   * Trả về thông tin người dùng dưới dạng chuỗi
   * @returns {string} Thông tin người dùng
   */
  getInfo() {
    // Trả về thông tin người dùng
    return `${this.name} (${this.email})`;
  }
}
```

### Không có bình luận

```javascript
class User {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  getInfo() {
    return `${this.name} (${this.email})`;
  }
}
```

## Tiếp theo là gì?

- [Nén mã](code-compress.md): Tìm hiểu về tính năng nén mã
- [Cấu hình](configuration.md): Tìm hiểu về tệp cấu hình
- [Tùy chọn dòng lệnh](command-line-options.md): Xem tất cả các tùy chọn dòng lệnh có sẵn
</file>

<file path="website/client/src/vi/guide/configuration.md">
# Cấu hình

Repomix có thể được cấu hình thông qua tệp cấu hình JSON, cho phép bạn lưu trữ các tùy chọn và chia sẻ cấu hình giữa các dự án.

## Tạo tệp cấu hình

Để tạo một tệp cấu hình mẫu, hãy chạy:

```bash
repomix --init
```

Lệnh này sẽ tạo một tệp `repomix.config.json` trong thư mục hiện tại với các cài đặt mặc định.

## Vị trí tệp cấu hình

Repomix tìm kiếm tệp cấu hình theo thứ tự sau:

1. Đường dẫn được chỉ định bởi tùy chọn `--config`
2. `repomix.config.json` trong thư mục hiện tại
3. `.repomixrc` trong thư mục hiện tại
4. `.repomixrc.json` trong thư mục hiện tại
5. `.repomixrc.js` trong thư mục hiện tại (phải xuất một đối tượng)

## Cấu trúc cấu hình

Tệp cấu hình có cấu trúc sau:

```json
{
  "output": {
    "style": "xml",
    "filePath": "repomix-output.xml",
    "removeComments": false,
    "showLineNumbers": false,
    "topFilesLength": 10
  },
  "ignore": {
    "respectGitignore": true,
    "customPatterns": []
  },
  "security": {
    "check": true,
    "secretlintConfigPath": null
  },
  "advanced": {
    "compressCode": false,
    "tokenCount": true
  }
}
```

## Tùy chọn cấu hình

### Cấu hình đầu ra

| Tùy chọn | Mô tả | Giá trị mặc định |
| --- | --- | --- |
| `output.style` | Định dạng đầu ra | `"xml"` |
| `output.filePath` | Đường dẫn tệp đầu ra | `"repomix-output.xml"` |
| `output.removeComments` | Xóa bình luận khỏi mã nguồn | `false` |
| `output.showLineNumbers` | Hiển thị số dòng trong đầu ra | `false` |
| `output.topFilesLength` | Số lượng tệp hàng đầu để hiển thị trong tóm tắt | `10` |

### Cấu hình bỏ qua

| Tùy chọn | Mô tả | Giá trị mặc định |
| --- | --- | --- |
| `ignore.respectGitignore` | Tôn trọng các tệp .gitignore | `true` |
| `ignore.customPatterns` | Mảng các mẫu glob để bỏ qua | `[]` |

### Cấu hình bảo mật

| Tùy chọn | Mô tả | Giá trị mặc định |
| --- | --- | --- |
| `security.check` | Bật kiểm tra bảo mật | `true` |
| `security.secretlintConfigPath` | Đường dẫn đến tệp cấu hình Secretlint | `null` |

### Cấu hình nâng cao

| Tùy chọn | Mô tả | Giá trị mặc định |
| --- | --- | --- |
| `advanced.compressCode` | Nén mã bằng cách chỉ bao gồm chữ ký hàm | `false` |
| `advanced.tokenCount` | Bật đếm token | `true` |

## Ví dụ cấu hình

### Cấu hình cơ bản

```json
{
  "output": {
    "style": "markdown",
    "filePath": "codebase.md"
  }
}
```

### Cấu hình với mẫu bỏ qua tùy chỉnh

```json
{
  "output": {
    "style": "xml",
    "filePath": "repomix-output.xml"
  },
  "ignore": {
    "respectGitignore": true,
    "customPatterns": ["*.test.ts", "docs/**", "**/*.log"]
  }
}
```

### Cấu hình đầy đủ

```json
{
  "output": {
    "style": "markdown",
    "filePath": "codebase.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 20
  },
  "ignore": {
    "respectGitignore": true,
    "customPatterns": ["*.test.ts", "docs/**"]
  },
  "security": {
    "check": true,
    "secretlintConfigPath": "./secretlint.config.js"
  },
  "advanced": {
    "compressCode": true,
    "tokenCount": true
  }
}
```

## Ghi đè cấu hình

Các tùy chọn dòng lệnh sẽ ghi đè các cài đặt trong tệp cấu hình. Ví dụ, nếu tệp cấu hình của bạn chỉ định `"style": "xml"` nhưng bạn chạy `repomix --style markdown`, đầu ra sẽ ở định dạng Markdown.

## Sử dụng .repomixignore

Ngoài việc chỉ định các mẫu bỏ qua trong tệp cấu hình, bạn cũng có thể tạo một tệp `.repomixignore` trong thư mục gốc của dự án. Tệp này sử dụng cú pháp tương tự như `.gitignore` và sẽ được sử dụng cùng với bất kỳ mẫu bỏ qua nào được chỉ định trong tệp cấu hình.

## Tiếp theo là gì?

- [Tùy chọn dòng lệnh](command-line-options.md): Xem tất cả các tùy chọn dòng lệnh có sẵn
- [Hướng dẫn tùy chỉnh](custom-instructions.md): Tìm hiểu về hướng dẫn tùy chỉnh
- [Bảo mật](security.md): Tìm hiểu về tính năng bảo mật của Repomix
</file>

<file path="website/client/src/vi/guide/custom-instructions.md">
# Hướng dẫn tùy chỉnh

Repomix cho phép bạn thêm hướng dẫn tùy chỉnh vào đầu ra của mình, giúp hướng dẫn AI về cách hiểu và làm việc với codebase của bạn.

## Tổng quan

Hướng dẫn tùy chỉnh là một cách mạnh mẽ để:

1. Cung cấp ngữ cảnh về dự án của bạn
2. Giải thích các quy ước mã
3. Hướng dẫn AI về các phần quan trọng của codebase
4. Chỉ định các nhiệm vụ cụ thể bạn muốn AI thực hiện

## Thêm hướng dẫn tùy chỉnh

Có hai cách chính để thêm hướng dẫn tùy chỉnh vào đầu ra Repomix:

### 1. Sử dụng tệp hướng dẫn

Cách được khuyến nghị là tạo một tệp hướng dẫn riêng biệt và tham chiếu đến nó khi chạy Repomix:

```bash
repomix --instructions path/to/instructions.md
```

Tệp hướng dẫn có thể ở bất kỳ định dạng nào (Markdown được khuyến nghị cho khả năng đọc), và nội dung của nó sẽ được thêm vào đầu ra.

### 2. Sử dụng tệp cấu hình

Bạn cũng có thể chỉ định hướng dẫn trong tệp cấu hình Repomix:

```json
{
  "output": {
    "style": "xml",
    "filePath": "repomix-output.xml"
  },
  "instructions": {
    "content": "Đây là codebase của dự án X. Vui lòng tập trung vào...",
    "filePath": "path/to/instructions.md"
  }
}
```

Nếu cả `content` và `filePath` đều được chỉ định, `filePath` sẽ được ưu tiên.

## Hướng dẫn tùy chỉnh trong thư mục

Repomix cũng hỗ trợ hướng dẫn tùy chỉnh dựa trên thư mục. Bạn có thể tạo các tệp hướng dẫn trong thư mục `.github/instructions/` của kho lưu trữ của bạn:

- `.github/instructions/base.instructions.md`: Hướng dẫn cơ bản áp dụng cho toàn bộ kho lưu trữ
- `.github/instructions/path/to/dir.instructions.md`: Hướng dẫn cụ thể cho thư mục

Mỗi tệp hướng dẫn có thể bắt đầu bằng front matter YAML để chỉ định phạm vi áp dụng:

```markdown
---
applyTo: '**/*.ts'
---

# Hướng dẫn TypeScript

Các tệp TypeScript trong dự án này tuân theo...
```

Thuộc tính `applyTo` chấp nhận các mẫu glob để chỉ định các tệp mà hướng dẫn áp dụng.

## Ví dụ hướng dẫn tùy chỉnh

Dưới đây là một ví dụ về tệp hướng dẫn tùy chỉnh hiệu quả:

```markdown
# Hướng dẫn dự án Repomix

## Tổng quan dự án
Repomix là một công cụ đóng gói kho lưu trữ mã nguồn thành các định dạng thân thiện với AI. Nó được thiết kế để giúp bạn chia sẻ codebase của mình với các mô hình ngôn ngữ lớn.

## Cấu trúc dự án
- `src/`: Mã nguồn chính
  - `core/`: Chức năng cốt lõi để xử lý kho lưu trữ
  - `formatters/`: Các trình định dạng đầu ra (XML, Markdown, Plain)
  - `utils/`: Tiện ích và trợ giúp

## Quy ước mã
- Chúng tôi sử dụng TypeScript với kiểu nghiêm ngặt
- Chúng tôi tuân theo quy ước đặt tên camelCase cho biến và PascalCase cho lớp
- Các hàm nên có một trách nhiệm duy nhất

## Nhiệm vụ
Vui lòng phân tích codebase và đề xuất cách cải thiện:
1. Xác định các vấn đề hiệu suất tiềm ẩn
2. Đề xuất cải tiến cho khả năng bảo trì
3. Đánh giá khả năng mở rộng của kiến trúc hiện tại

## Lưu ý quan trọng
- Tệp `src/core/processor.ts` chứa logic xử lý chính
- Chúng tôi đang xem xét thêm hỗ trợ cho các định dạng đầu ra mới
```

## Thực hành tốt nhất

Khi tạo hướng dẫn tùy chỉnh:

1. **Bắt đầu với tổng quan**: Cung cấp ngữ cảnh ngắn gọn về dự án
2. **Giải thích cấu trúc**: Phác thảo cấu trúc thư mục và mục đích của chúng
3. **Làm rõ quy ước**: Đề cập đến bất kỳ quy ước mã hoặc mẫu thiết kế nào
4. **Chỉ định nhiệm vụ**: Nêu rõ những gì bạn muốn AI làm
5. **Đánh dấu các khu vực quan trọng**: Hướng dẫn sự chú ý đến các tệp hoặc mô-đun quan trọng
6. **Giữ ngắn gọn**: Tập trung vào thông tin có giá trị nhất

## Tiếp theo là gì?

- [Xử lý kho lưu trữ từ xa](remote-repository-processing.md): Tìm hiểu về xử lý kho lưu trữ từ xa
- [Cấu hình](configuration.md): Tìm hiểu thêm về tùy chọn cấu hình
- [Bảo mật](security.md): Tìm hiểu về tính năng bảo mật của Repomix
</file>

<file path="website/client/src/vi/guide/github-actions.md">
# GitHub Actions

Repomix có thể được tích hợp vào quy trình CI/CD của bạn bằng cách sử dụng GitHub Actions, cho phép bạn tự động đóng gói kho lưu trữ của mình và cung cấp đầu ra cho các bước tiếp theo.

## Tổng quan

Tích hợp Repomix với GitHub Actions cho phép bạn:

- Tự động đóng gói kho lưu trữ của bạn khi có thay đổi
- Lưu trữ đầu ra đã đóng gói dưới dạng artifact
- Sử dụng đầu ra đã đóng gói trong các bước quy trình công việc tiếp theo
- Tích hợp với các công cụ AI trong quy trình CI/CD của bạn

## Sử dụng hành động Repomix

Repomix cung cấp một hành động GitHub chính thức mà bạn có thể sử dụng trong quy trình công việc của mình:

```yaml
name: Repomix

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  pack:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Pack repository
        uses: yamadashy/repomix-action@v1
        with:
          output-file: 'repomix-output.xml'
          style: 'xml'
          remove-comments: false
          show-line-numbers: false

      - name: Upload packed output
        uses: actions/upload-artifact@v3
        with:
          name: repomix-output
          path: repomix-output.xml
```

## Tùy chọn cấu hình

Hành động Repomix hỗ trợ các tùy chọn cấu hình sau:

| Tùy chọn | Mô tả | Mặc định |
| --- | --- | --- |
| `output-file` | Tên tệp đầu ra | `repomix-output.xml` |
| `style` | Định dạng đầu ra (xml, markdown, plain) | `xml` |
| `remove-comments` | Xóa bình luận khỏi mã nguồn | `false` |
| `show-line-numbers` | Hiển thị số dòng trong đầu ra | `false` |
| `include` | Mẫu bao gồm (phân tách bằng dấu phẩy) | |
| `ignore` | Mẫu bỏ qua (phân tách bằng dấu phẩy) | |
| `respect-gitignore` | Tôn trọng các tệp .gitignore | `true` |
| `compress-code` | Nén mã bằng cách chỉ bao gồm chữ ký hàm | `false` |
| `security-check` | Bật kiểm tra bảo mật | `true` |
| `token-count` | Bật đếm token | `true` |

## Ví dụ quy trình công việc

### Đóng gói và tải lên artifact

```yaml
name: Pack Repository

on:
  push:
    branches: [ main ]

jobs:
  pack:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Pack repository
        uses: yamadashy/repomix-action@v1
        with:
          output-file: 'codebase.md'
          style: 'markdown'
          remove-comments: true
          show-line-numbers: true

      - name: Upload packed output
        uses: actions/upload-artifact@v3
        with:
          name: codebase
          path: codebase.md
```

### Đóng gói với các mẫu tùy chỉnh

```yaml
name: Pack Repository

on:
  push:
    branches: [ main ]

jobs:
  pack:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Pack repository
        uses: yamadashy/repomix-action@v1
        with:
          output-file: 'repomix-output.xml'
          include: 'src/**/*.ts,**/*.md'
          ignore: '**/*.test.ts,docs/**'
          compress-code: true
```

### Đóng gói và sử dụng trong bước tiếp theo

```yaml
name: Analyze Repository

on:
  push:
    branches: [ main ]

jobs:
  analyze:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Pack repository
        uses: yamadashy/repomix-action@v1
        with:
          output-file: 'codebase.md'
          style: 'markdown'

      - name: Analyze codebase
        uses: some-ai-analysis-action@v1
        with:
          input-file: 'codebase.md'
```

## Sử dụng Repomix trực tiếp

Nếu bạn muốn sử dụng Repomix trực tiếp trong quy trình công việc của mình thay vì sử dụng hành động chính thức, bạn có thể làm như sau:

```yaml
name: Pack Repository

on:
  push:
    branches: [ main ]

jobs:
  pack:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install Repomix
        run: npm install -g repomix

      - name: Pack repository
        run: repomix --style markdown --output-file codebase.md

      - name: Upload packed output
        uses: actions/upload-artifact@v3
        with:
          name: codebase
          path: codebase.md
```

## Lưu ý bảo mật

Khi sử dụng Repomix trong GitHub Actions, hãy lưu ý những điểm sau:

- Đảm bảo rằng kiểm tra bảo mật được bật để ngăn chặn việc vô tình tiết lộ thông tin nhạy cảm
- Xem xét sử dụng bí mật GitHub cho thông tin nhạy cảm thay vì mã hóa cứng chúng trong mã
- Hãy cẩn thận khi chia sẻ artifact đã đóng gói, vì chúng có thể chứa thông tin nhạy cảm

## Tiếp theo là gì?

- [Tùy chọn dòng lệnh](command-line-options.md): Xem tất cả các tùy chọn dòng lệnh có sẵn
- [Cấu hình](configuration.md): Tìm hiểu về tệp cấu hình
- [Bảo mật](security.md): Tìm hiểu về tính năng bảo mật của Repomix
</file>

<file path="website/client/src/vi/guide/index.md">
# Bắt đầu với Repomix

<script setup>
import HomeBadges from '../../../components/HomeBadges.vue'
import YouTubeVideo from '../../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../../utils/videos'
</script>

Repomix là một công cụ đóng gói toàn bộ kho lưu trữ của bạn thành một tệp duy nhất, thân thiện với AI. Nó được thiết kế để giúp bạn cung cấp codebase cho các Mô hình Ngôn ngữ Lớn (LLMs) như ChatGPT, DeepSeek, Perplexity, Gemini, Gemma, Llama, Grok, và nhiều mô hình khác.

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

<HomeBadges />

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## Bắt đầu nhanh

Chạy lệnh này trong thư mục dự án của bạn:

```bash
npx repomix
```

Vậy là xong! Bạn sẽ tìm thấy một tệp `repomix-output.xml` chứa toàn bộ kho lưu trữ của bạn ở định dạng thân thiện với AI.

Sau đó, bạn có thể gửi tệp này đến trợ lý AI với một prompt như:

```
Tệp này chứa tất cả các tệp trong kho lưu trữ được kết hợp thành một.
Tôi muốn tái cấu trúc mã, vì vậy hãy xem xét nó trước.
```

AI sẽ phân tích toàn bộ codebase của bạn và cung cấp những hiểu biết toàn diện:

![Repomix File Usage 1](/images/docs/repomix-file-usage-1.png)

Khi thảo luận về các thay đổi cụ thể, AI có thể giúp tạo mã. Với các tính năng như Artifacts của Claude, bạn thậm chí có thể nhận được nhiều tệp phụ thuộc lẫn nhau:

![Repomix File Usage 2](/images/docs/repomix-file-usage-2.png)

Chúc bạn code vui vẻ! 🚀

## Tính năng chính

- **Đầu ra được tối ưu hóa cho AI**: Định dạng codebase của bạn để AI dễ dàng xử lý
- **Đếm token**: Theo dõi việc sử dụng token cho giới hạn ngữ cảnh LLM
- **Nhận biết Git**: Tôn trọng các tệp `.gitignore` và `.git/info/exclude` của bạn
- **Tập trung vào bảo mật**: Phát hiện thông tin nhạy cảm
- **Nhiều định dạng đầu ra**: Lựa chọn giữa văn bản thuần túy, XML hoặc Markdown

## Tiếp theo là gì?

- [Hướng dẫn cài đặt](installation.md): Các cách khác nhau để cài đặt Repomix
- [Hướng dẫn sử dụng](usage.md): Tìm hiểu về các tính năng cơ bản và nâng cao
- [Cấu hình](configuration.md): Tùy chỉnh Repomix cho nhu cầu của bạn
- [Tính năng bảo mật](security.md): Tìm hiểu về kiểm tra bảo mật

## Cộng đồng

Tham gia [cộng đồng Discord](https://discord.gg/wNYzTwZFku) của chúng tôi để:
- Nhận trợ giúp với Repomix
- Chia sẻ trải nghiệm của bạn
- Đề xuất tính năng mới
- Kết nối với những người dùng khác

## Hỗ trợ

Tìm thấy lỗi hoặc cần trợ giúp?
- [Mở một vấn đề trên GitHub](https://github.com/yamadashy/repomix/issues)
- Tham gia máy chủ Discord của chúng tôi
- Kiểm tra [tài liệu](https://repomix.com)
</file>

<file path="website/client/src/vi/guide/installation.md">
# Cài đặt

Có nhiều cách để cài đặt và sử dụng Repomix. Chọn phương pháp phù hợp nhất với quy trình làm việc của bạn.

## Sử dụng npx (Không cần cài đặt)

Cách đơn giản nhất để sử dụng Repomix mà không cần cài đặt là thông qua `npx`:

```bash
npx repomix
```

Lệnh này sẽ tải và chạy phiên bản mới nhất của Repomix trực tiếp từ npm.

## Cài đặt toàn cục

Để sử dụng Repomix từ bất kỳ đâu trong hệ thống của bạn, bạn có thể cài đặt nó toàn cục:

### Sử dụng npm

```bash
npm install -g repomix
```

### Sử dụng yarn

```bash
yarn global add repomix
```

### Sử dụng pnpm

```bash
pnpm add -g repomix
```

### Sử dụng Bun

```bash
bun add -g repomix
```

### Sử dụng Homebrew (macOS/Linux)

```bash
brew install repomix
```

Sau khi cài đặt toàn cục, bạn có thể chạy Repomix từ bất kỳ thư mục nào:

```bash
repomix
```

## Cài đặt cục bộ trong dự án

Nếu bạn muốn sử dụng Repomix như một phần của quy trình làm việc dự án của mình, bạn có thể cài đặt nó cục bộ:

### Sử dụng npm

```bash
npm install --save-dev repomix
```

### Sử dụng yarn

```bash
yarn add --dev repomix
```

### Sử dụng pnpm

```bash
pnpm add -D repomix
```

Sau đó, bạn có thể chạy nó thông qua npm scripts trong `package.json` của bạn:

```json
{
  "scripts": {
    "pack-code": "repomix"
  }
}
```

Và chạy nó với:

```bash
npm run pack-code
```

## Sử dụng Docker

Repomix cũng có sẵn dưới dạng hình ảnh Docker, cho phép bạn chạy nó trong một môi trường container:

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

Lệnh này gắn kết thư mục hiện tại của bạn vào container và chạy Repomix trên nó.

## Phần mở rộng trình duyệt

Truy cập Repomix ngay lập tức từ bất kỳ repository GitHub nào! Phần mở rộng trình duyệt của chúng tôi thêm nút "Repomix" tiện lợi vào các trang repository GitHub.

![Repomix Browser Extension](/images/docs/browser-extension.png)

### Cài đặt
- Phần mở rộng Chrome: [Repomix - Chrome Web Store](https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa)
- Add-on Firefox: [Repomix - Firefox Add-ons](https://addons.mozilla.org/firefox/addon/repomix/)

### Tính năng
- Truy cập Repomix chỉ với một cú nhấp chuột từ bất kỳ repository GitHub nào
- Thêm nhiều tính năng thú vị sắp ra mắt!

## Sử dụng GitHub Actions

Repomix có thể được tích hợp vào quy trình CI/CD của bạn bằng cách sử dụng GitHub Actions. Xem [Hướng dẫn GitHub Actions](github-actions.md) để biết thêm chi tiết.

## Xác minh cài đặt

Để xác minh rằng Repomix đã được cài đặt đúng cách, hãy chạy:

```bash
repomix --version
```

Lệnh này sẽ hiển thị phiên bản Repomix hiện được cài đặt.

## Tiếp theo là gì?

- [Sử dụng cơ bản](usage.md): Tìm hiểu cách sử dụng Repomix
- [Cấu hình](configuration.md): Tùy chỉnh Repomix cho nhu cầu của bạn
- [Tùy chọn dòng lệnh](command-line-options.md): Khám phá tất cả các tùy chọn có sẵn
</file>

<file path="website/client/src/vi/guide/mcp-server.md">
# Máy chủ MCP

Repomix hỗ trợ [Model Context Protocol (MCP)](https://modelcontextprotocol.io), cho phép các trợ lý AI tương tác trực tiếp với codebase của bạn. Khi chạy như một máy chủ MCP, Repomix cung cấp các công cụ cho phép các trợ lý AI đóng gói repository cục bộ hoặc từ xa để phân tích mà không cần chuẩn bị file thủ công.

> [!NOTE]  
> Đây là một tính năng thử nghiệm mà chúng tôi sẽ tích cực cải thiện dựa trên phản hồi của người dùng và việc sử dụng thực tế

## Chạy Repomix như một Máy chủ MCP

Để chạy Repomix như một máy chủ MCP, sử dụng flag `--mcp`:

```bash
repomix --mcp
```

Điều này khởi động Repomix ở chế độ máy chủ MCP, làm cho nó có sẵn cho các trợ lý AI hỗ trợ Model Context Protocol.

## Cấu hình Máy chủ MCP

Để sử dụng Repomix như một máy chủ MCP với các trợ lý AI như Claude, bạn cần cấu hình các thiết lập MCP:

### Cho VS Code

Bạn có thể cài đặt máy chủ MCP Repomix trong VS Code bằng một trong các phương pháp sau:

1. **Sử dụng huy hiệu cài đặt:**

  [![Install in VS Code](https://img.shields.io/badge/VS_Code-VS_Code?style=flat-square&label=Install%20Server&color=0098FF)](vscode:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)<br>
  [![Install in VS Code Insiders](https://img.shields.io/badge/VS_Code_Insiders-VS_Code_Insiders?style=flat-square&label=Install%20Server&color=24bfa5)](vscode-insiders:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)

2. **Sử dụng dòng lệnh:**

  ```bash
  code --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

  Cho VS Code Insiders:
  ```bash
  code-insiders --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

### Cho Cline (phần mở rộng VS Code)

Chỉnh sửa file `cline_mcp_settings.json`:

```json
{
  "mcpServers": {
    "repomix": {
      "command": "npx",
      "args": [
        "-y",
        "repomix",
        "--mcp"
      ]
    }
  }
}
```

### Cho Cursor

Trong Cursor, thêm một máy chủ MCP mới từ `Cursor Settings` > `MCP` > `+ Add new global MCP server` với cấu hình tương tự như Cline.

### Cho Claude Desktop

Chỉnh sửa file `claude_desktop_config.json` với cấu hình tương tự như Cline.

### Cho Claude Code

Để cấu hình Repomix như máy chủ MCP trong [Claude Code](https://docs.anthropic.com/en/docs/claude-code/overview), sử dụng lệnh sau:

```bash
claude mcp add repomix -- npx -y repomix --mcp
```

### Sử dụng Docker thay vì npx

Thay vì sử dụng npx, bạn có thể sử dụng Docker để chạy Repomix như một máy chủ MCP:

```json
{
  "mcpServers": {
    "repomix-docker": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "ghcr.io/yamadashy/repomix",
        "--mcp"
      ]
    }
  }
}
```

## Các công cụ MCP có sẵn

Khi chạy như một máy chủ MCP, Repomix cung cấp các công cụ sau:

### pack_codebase

Công cụ này đóng gói một thư mục code cục bộ thành một file XML để phân tích AI. Nó phân tích cấu trúc codebase, trích xuất nội dung code liên quan và tạo ra một báo cáo toàn diện bao gồm metrics, cây file và nội dung code được định dạng.

**Tham số:**
- `directory`: (Bắt buộc) Đường dẫn tuyệt đối đến thư mục cần đóng gói
- `compress`: (Tùy chọn, mặc định: false) Kích hoạt nén Tree-sitter để trích xuất các chữ ký code cần thiết và cấu trúc trong khi loại bỏ các chi tiết triển khai. Giảm việc sử dụng token khoảng 70% trong khi vẫn bảo toàn ý nghĩa ngữ nghĩa. Thường không cần thiết vì grep_repomix_output cho phép truy xuất nội dung tăng dần. Chỉ sử dụng khi bạn đặc biệt cần toàn bộ nội dung codebase cho các repository lớn.
- `includePatterns`: (Tùy chọn) Chỉ định các file để bao gồm sử dụng các pattern fast-glob. Nhiều pattern có thể được tách bằng dấu phẩy (ví dụ: "**/*.{js,ts}", "src/**,docs/**"). Chỉ các file khớp sẽ được xử lý.
- `ignorePatterns`: (Tùy chọn) Chỉ định các file bổ sung để loại trừ sử dụng các pattern fast-glob. Nhiều pattern có thể được tách bằng dấu phẩy (ví dụ: "test/**,*.spec.js", "node_modules/**,dist/**"). Các pattern này bổ sung cho .gitignore và loại trừ tích hợp.
- `topFilesLength`: (Tùy chọn, mặc định: 10) Số lượng file lớn nhất theo kích thước để hiển thị trong tóm tắt metrics cho phân tích codebase.

**Ví dụ:**
```json
{
  "directory": "/path/to/your/project",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### pack_remote_repository

Công cụ này lấy, clone và đóng gói một repository GitHub thành một file XML để phân tích AI. Nó tự động clone repository từ xa, phân tích cấu trúc của nó và tạo ra một báo cáo toàn diện.

**Tham số:**
- `remote`: (Bắt buộc) URL repository GitHub hoặc định dạng user/repo (ví dụ: "yamadashy/repomix", "https://github.com/user/repo", hoặc "https://github.com/user/repo/tree/branch")
- `compress`: (Tùy chọn, mặc định: false) Kích hoạt nén Tree-sitter để trích xuất các chữ ký code cần thiết và cấu trúc trong khi loại bỏ các chi tiết triển khai. Giảm việc sử dụng token khoảng 70% trong khi vẫn bảo toàn ý nghĩa ngữ nghĩa. Thường không cần thiết vì grep_repomix_output cho phép truy xuất nội dung tăng dần. Chỉ sử dụng khi bạn đặc biệt cần toàn bộ nội dung codebase cho các repository lớn.
- `includePatterns`: (Tùy chọn) Chỉ định các file để bao gồm sử dụng các pattern fast-glob. Nhiều pattern có thể được tách bằng dấu phẩy (ví dụ: "**/*.{js,ts}", "src/**,docs/**"). Chỉ các file khớp sẽ được xử lý.
- `ignorePatterns`: (Tùy chọn) Chỉ định các file bổ sung để loại trừ sử dụng các pattern fast-glob. Nhiều pattern có thể được tách bằng dấu phẩy (ví dụ: "test/**,*.spec.js", "node_modules/**,dist/**"). Các pattern này bổ sung cho .gitignore và loại trừ tích hợp.
- `topFilesLength`: (Tùy chọn, mặc định: 10) Số lượng file lớn nhất theo kích thước để hiển thị trong tóm tắt metrics cho phân tích codebase.

**Ví dụ:**
```json
{
  "remote": "yamadashy/repomix",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### read_repomix_output

Công cụ này đọc nội dung của một file đầu ra được tạo bởi Repomix. Hỗ trợ đọc một phần với chỉ định phạm vi dòng cho các file lớn. Công cụ này được thiết kế cho các môi trường mà việc truy cập hệ thống file trực tiếp bị hạn chế.

**Tham số:**
- `outputId`: (Bắt buộc) ID của file đầu ra Repomix cần đọc
- `startLine`: (Tùy chọn) Số dòng bắt đầu (bắt đầu từ 1, bao gồm). Nếu không chỉ định, đọc từ đầu.
- `endLine`: (Tùy chọn) Số dòng kết thúc (bắt đầu từ 1, bao gồm). Nếu không chỉ định, đọc đến cuối.

**Tính năng:**
- Được thiết kế đặc biệt cho các môi trường dựa trên web hoặc ứng dụng sandbox
- Truy xuất nội dung của các đầu ra được tạo trước đó bằng ID của chúng
- Cung cấp truy cập an toàn đến codebase được đóng gói mà không cần truy cập hệ thống file
- Hỗ trợ đọc một phần cho các file lớn

**Ví dụ:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "startLine": 100,
  "endLine": 200
}
```

### grep_repomix_output

Công cụ này tìm kiếm các pattern trong một file đầu ra Repomix sử dụng chức năng giống grep với cú pháp JavaScript RegExp. Trả về các dòng khớp với các dòng ngữ cảnh tùy chọn xung quanh các kết quả khớp.

**Tham số:**
- `outputId`: (Bắt buộc) ID của file đầu ra Repomix cần tìm kiếm
- `pattern`: (Bắt buộc) Pattern tìm kiếm (cú pháp biểu thức chính quy JavaScript RegExp)
- `contextLines`: (Tùy chọn, mặc định: 0) Số dòng ngữ cảnh để hiển thị trước và sau mỗi kết quả khớp. Bị ghi đè bởi beforeLines/afterLines nếu được chỉ định.
- `beforeLines`: (Tùy chọn) Số dòng ngữ cảnh để hiển thị trước mỗi kết quả khớp (như grep -B). Ưu tiên hơn contextLines.
- `afterLines`: (Tùy chọn) Số dòng ngữ cảnh để hiển thị sau mỗi kết quả khớp (như grep -A). Ưu tiên hơn contextLines.
- `ignoreCase`: (Tùy chọn, mặc định: false) Thực hiện khớp không phân biệt chữ hoa chữ thường

**Tính năng:**
- Sử dụng cú pháp JavaScript RegExp cho khớp pattern mạnh mẽ
- Hỗ trợ các dòng ngữ cảnh để hiểu rõ hơn về các kết quả khớp
- Cho phép điều khiển riêng biệt các dòng ngữ cảnh trước/sau
- Tùy chọn tìm kiếm phân biệt và không phân biệt chữ hoa chữ thường

**Ví dụ:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "pattern": "function\\s+\\w+\\(",
  "contextLines": 3,
  "ignoreCase": false
}
```

### file_system_read_file và file_system_read_directory

Máy chủ MCP của Repomix cung cấp hai công cụ hệ thống file cho phép các trợ lý AI tương tác an toàn với hệ thống file cục bộ:

1. `file_system_read_file`
  - Đọc nội dung file từ hệ thống file cục bộ sử dụng đường dẫn tuyệt đối
  - Bao gồm xác thực bảo mật tích hợp để phát hiện và ngăn chặn truy cập đến các file chứa thông tin nhạy cảm
  - Triển khai xác thực bảo mật sử dụng [Secretlint](https://github.com/secretlint/secretlint)
  - Ngăn chặn truy cập đến các file chứa thông tin nhạy cảm (khóa API, mật khẩu, bí mật)
  - Xác thực đường dẫn tuyệt đối để ngăn chặn các cuộc tấn công directory traversal
  - Trả về thông báo lỗi rõ ràng cho các đường dẫn không hợp lệ và vấn đề bảo mật

2. `file_system_read_directory`
  - Liệt kê nội dung của một thư mục sử dụng đường dẫn tuyệt đối
  - Trả về một danh sách được định dạng hiển thị các file và thư mục con với các chỉ báo rõ ràng
  - Hiển thị file và thư mục với các chỉ báo rõ ràng (`[FILE]` hoặc `[DIR]`)
  - Cung cấp điều hướng thư mục an toàn với xử lý lỗi thích hợp
  - Xác thực đường dẫn và đảm bảo chúng là tuyệt đối
  - Hữu ích cho việc khám phá cấu trúc dự án và hiểu tổ chức codebase

Cả hai công cụ đều kết hợp các biện pháp bảo mật mạnh mẽ:
- Xác thực đường dẫn tuyệt đối để ngăn chặn các cuộc tấn công directory traversal
- Kiểm tra quyền để đảm bảo quyền truy cập thích hợp
- Tích hợp với Secretlint để phát hiện thông tin nhạy cảm
- Thông báo lỗi rõ ràng để debug tốt hơn và nhận thức bảo mật

**Ví dụ:**
```typescript
// Đọc một file
const fileContent = await tools.file_system_read_file({
  path: '/absolute/path/to/file.txt'
});

// Liệt kê nội dung thư mục
const dirContent = await tools.file_system_read_directory({
  path: '/absolute/path/to/directory'
});
```

Các công cụ này đặc biệt hữu ích khi các trợ lý AI cần:
- Phân tích các file cụ thể trong codebase
- Điều hướng cấu trúc thư mục
- Xác minh sự tồn tại và khả năng truy cập của file
- Đảm bảo các hoạt động hệ thống file an toàn

## Lợi ích của việc sử dụng Repomix như một Máy chủ MCP

Sử dụng Repomix như một máy chủ MCP mang lại nhiều lợi thế:

1. **Tích hợp trực tiếp**: Các trợ lý AI có thể phân tích codebase của bạn trực tiếp mà không cần chuẩn bị file thủ công.
2. **Luồng công việc hiệu quả**: Tối ưu hóa quy trình phân tích code bằng cách loại bỏ nhu cầu tạo và tải lên file thủ công.
3. **Đầu ra nhất quán**: Đảm bảo rằng trợ lý AI nhận được codebase ở định dạng nhất quán, được tối ưu hóa.
4. **Các tính năng nâng cao**: Tận dụng tất cả các tính năng của Repomix như nén code, đếm token và kiểm tra bảo mật.

Một khi được cấu hình, trợ lý AI của bạn có thể sử dụng trực tiếp các khả năng của Repomix để phân tích codebase, làm cho luồng công việc phân tích code hiệu quả hơn.
</file>

<file path="website/client/src/vi/guide/output.md">
# Định dạng đầu ra

Repomix hỗ trợ nhiều định dạng đầu ra khác nhau để đáp ứng các nhu cầu khác nhau. Mỗi định dạng có ưu điểm riêng và phù hợp với các trường hợp sử dụng khác nhau.

## Định dạng có sẵn

Repomix hỗ trợ ba định dạng đầu ra chính:

1. **XML** (mặc định)
2. **Markdown**
3. **Văn bản thuần túy**

Bạn có thể chỉ định định dạng đầu ra bằng cách sử dụng tùy chọn `--style`:

```bash
# XML (mặc định)
repomix --style xml

# Markdown
repomix --style markdown

# Văn bản thuần túy
repomix --style plain
```

## Định dạng XML

Định dạng XML là định dạng mặc định và được khuyến nghị cho hầu hết các trường hợp sử dụng. Nó cung cấp cấu trúc rõ ràng và dễ dàng cho AI phân tích.

Ví dụ về đầu ra XML:

```xml
<repository name="repomix" path="/path/to/repomix">
  <stats>
    <file_count>42</file_count>
    <total_lines>1234</total_lines>
    <total_tokens>5678</total_tokens>
  </stats>
  <top_files>
    <file path="src/index.ts" lines="100" tokens="450" />
    <file path="src/utils.ts" lines="80" tokens="320" />
    <!-- ... -->
  </top_files>
  <files>
    <file path="src/index.ts" language="typescript">
      import { processRepository } from './core';
      // Nội dung tệp...
    </file>
    <file path="src/utils.ts" language="typescript">
      export function formatOutput(data) {
        // Nội dung tệp...
      }
    </file>
    <!-- ... -->
  </files>
</repository>
```

Định dạng XML đặc biệt hữu ích cho:
- Cung cấp cấu trúc rõ ràng cho AI
- Bao gồm siêu dữ liệu về mỗi tệp (ngôn ngữ, số dòng, số token)
- Phân tích tự động bởi các công cụ

## Định dạng Markdown

Định dạng Markdown cung cấp đầu ra dễ đọc hơn cho con người, đồng thời vẫn duy trì cấu trúc đủ tốt cho AI.

Ví dụ về đầu ra Markdown:

```markdown
# Repository: repomix

## Stats
- File count: 42
- Total lines: 1234
- Total tokens: 5678

## Top Files
1. src/index.ts (100 lines, 450 tokens)
2. src/utils.ts (80 lines, 320 tokens)
...

## Files

### src/index.ts (typescript)
```typescript
import { processRepository } from './core';
// Nội dung tệp...
```

### src/utils.ts (typescript)
```typescript
export function formatOutput(data) {
  // Nội dung tệp...
}
```
...
```

Định dạng Markdown đặc biệt hữu ích cho:
- Đọc và xem xét bởi con người
- Chia sẻ codebase trong các tài liệu hoặc wiki
- Sử dụng với các công cụ hỗ trợ Markdown

## Định dạng văn bản thuần túy

Định dạng văn bản thuần túy cung cấp đầu ra đơn giản nhất, không có định dạng đặc biệt.

Ví dụ về đầu ra văn bản thuần túy:

```
Repository: repomix

Stats:
File count: 42
Total lines: 1234
Total tokens: 5678

Top Files:
1. src/index.ts (100 lines, 450 tokens)
2. src/utils.ts (80 lines, 320 tokens)
...

Files:

File: src/index.ts (typescript)
import { processRepository } from './core';
// Nội dung tệp...

File: src/utils.ts (typescript)
export function formatOutput(data) {
  // Nội dung tệp...
}
...
```

Định dạng văn bản thuần túy đặc biệt hữu ích cho:
- Tương thích tối đa với các công cụ khác nhau
- Trường hợp khi định dạng không quan trọng
- Sử dụng với các công cụ AI cũ hơn có thể gặp khó khăn với XML hoặc Markdown

## Tùy chọn định dạng bổ sung

Ngoài việc chọn định dạng đầu ra, Repomix cũng cung cấp các tùy chọn bổ sung để tùy chỉnh đầu ra:

### Xóa bình luận

Để xóa bình luận khỏi mã nguồn trong đầu ra:

```bash
repomix --remove-comments
```

Điều này có thể hữu ích để giảm kích thước đầu ra và tập trung vào mã thực tế.

### Hiển thị số dòng

Để bao gồm số dòng trong đầu ra:

```bash
repomix --show-line-numbers
```

Điều này giúp dễ dàng tham khảo các dòng cụ thể khi thảo luận về mã với AI.

### Số lượng tệp hàng đầu

Để chỉ định số lượng tệp hàng đầu để hiển thị trong tóm tắt:

```bash
repomix --top-files-length 20
```

Mặc định là 10 tệp.

## Tên tệp đầu ra tùy chỉnh

Để chỉ định tên tệp đầu ra:

```bash
repomix --output-file my-codebase.xml
```

Mặc định, Repomix sẽ tạo:
- `repomix-output.xml` cho định dạng XML
- `repomix-output.md` cho định dạng Markdown
- `repomix-output.txt` cho định dạng văn bản thuần túy

## Tiếp theo là gì?

- [Tùy chọn dòng lệnh](command-line-options.md): Xem tất cả các tùy chọn dòng lệnh có sẵn
- [Cấu hình](configuration.md): Tìm hiểu về tệp cấu hình
- [Xóa bình luận](comment-removal.md): Tìm hiểu thêm về tính năng xóa bình luận
</file>

<file path="website/client/src/vi/guide/prompt-examples.md">
# Ví dụ Prompt

Khi sử dụng Repomix để đóng gói codebase của bạn, việc tạo prompt hiệu quả cho AI là rất quan trọng để có được kết quả tốt nhất. Trang này cung cấp các ví dụ prompt để sử dụng với đầu ra Repomix.

## Prompt cơ bản

Dưới đây là một prompt cơ bản để bắt đầu:

```
Tệp này chứa toàn bộ codebase của dự án của tôi được đóng gói bởi Repomix. Vui lòng phân tích codebase và cung cấp tổng quan về cấu trúc và chức năng của nó.
```

## Phân tích codebase

Để có phân tích codebase chi tiết:

```
Tệp này chứa toàn bộ codebase của dự án của tôi được đóng gói bởi Repomix. Vui lòng:

1. Phân tích cấu trúc tổng thể của dự án
2. Xác định các mô-đun chính và mối quan hệ giữa chúng
3. Giải thích luồng dữ liệu và luồng điều khiển
4. Xác định các mẫu thiết kế được sử dụng
5. Đánh giá khả năng bảo trì và mở rộng của codebase
```

## Tìm lỗi

Để tìm lỗi tiềm ẩn:

```
Tệp này chứa toàn bộ codebase của dự án của tôi được đóng gói bởi Repomix. Tôi đang gặp phải [mô tả vấn đề]. Vui lòng:

1. Phân tích codebase để tìm lỗi tiềm ẩn
2. Xác định các vấn đề hiệu suất có thể có
3. Kiểm tra các lỗ hổng bảo mật
4. Đề xuất sửa chữa cho bất kỳ vấn đề nào bạn tìm thấy
```

## Tái cấu trúc mã

Để tái cấu trúc codebase:

```
Tệp này chứa toàn bộ codebase của dự án của tôi được đóng gói bởi Repomix. Tôi muốn tái cấu trúc nó để cải thiện khả năng bảo trì và mở rộng. Vui lòng:

1. Xác định các khu vực cần tái cấu trúc
2. Đề xuất các thay đổi cụ thể để cải thiện cấu trúc mã
3. Cung cấp ví dụ về mã đã tái cấu trúc cho các phần quan trọng
4. Giải thích lợi ích của các thay đổi được đề xuất
```

## Thêm tính năng mới

Để thêm tính năng mới:

```
Tệp này chứa toàn bộ codebase của dự án của tôi được đóng gói bởi Repomix. Tôi muốn thêm tính năng sau: [mô tả tính năng]. Vui lòng:

1. Phân tích codebase để xác định nơi tính năng mới nên được tích hợp
2. Đề xuất các thay đổi cần thiết để triển khai tính năng
3. Cung cấp mã mẫu cho tính năng mới
4. Giải thích cách tính năng mới tương tác với mã hiện có
```

## Tạo tài liệu

Để tạo tài liệu:

```
Tệp này chứa toàn bộ codebase của dự án của tôi được đóng gói bởi Repomix. Tôi cần tạo tài liệu toàn diện. Vui lòng:

1. Tạo tổng quan về dự án
2. Tạo tài liệu API cho các mô-đun chính
3. Giải thích cách sử dụng các tính năng chính
4. Cung cấp ví dụ sử dụng cho các trường hợp sử dụng phổ biến
5. Tạo hướng dẫn cài đặt và cấu hình
```

## Đánh giá mã

Để đánh giá chất lượng mã:

```
Tệp này chứa toàn bộ codebase của dự án của tôi được đóng gói bởi Repomix. Vui lòng đánh giá chất lượng mã và cung cấp phản hồi về:

1. Khả năng đọc và khả năng bảo trì
2. Hiệu suất và tối ưu hóa
3. Tuân thủ các thực hành tốt nhất
4. Bảo mật và xử lý lỗi
5. Khả năng kiểm tra và khả năng mở rộng
```

## Chuyển đổi mã

Để chuyển đổi mã từ một ngôn ngữ hoặc framework sang ngôn ngữ hoặc framework khác:

```
Tệp này chứa toàn bộ codebase của dự án của tôi được đóng gói bởi Repomix. Nó hiện được viết bằng [ngôn ngữ/framework hiện tại]. Tôi muốn chuyển đổi nó sang [ngôn ngữ/framework mới]. Vui lòng:

1. Phân tích codebase hiện tại
2. Cung cấp kế hoạch chuyển đổi
3. Chuyển đổi các mô-đun chính sang [ngôn ngữ/framework mới]
4. Giải thích bất kỳ thay đổi kiến trúc nào cần thiết
```

## Tối ưu hóa hiệu suất

Để tối ưu hóa hiệu suất:

```
Tệp này chứa toàn bộ codebase của dự án của tôi được đóng gói bởi Repomix. Tôi đang gặp phải vấn đề hiệu suất, đặc biệt là với [mô tả vấn đề]. Vui lòng:

1. Xác định các điểm nghẽn hiệu suất tiềm ẩn
2. Đề xuất tối ưu hóa cụ thể
3. Cung cấp mã đã tối ưu hóa cho các phần quan trọng
4. Đề xuất các thay đổi kiến trúc để cải thiện hiệu suất tổng thể
```

## Tích hợp với công nghệ khác

Để tích hợp với công nghệ khác:

```
Tệp này chứa toàn bộ codebase của dự án của tôi được đóng gói bởi Repomix. Tôi muốn tích hợp nó với [công nghệ]. Vui lòng:

1. Phân tích codebase để xác định điểm tích hợp tốt nhất
2. Đề xuất các thay đổi cần thiết để tích hợp với [công nghệ]
3. Cung cấp mã mẫu cho tích hợp
4. Giải thích bất kỳ thay đổi cấu hình hoặc phụ thuộc nào cần thiết
```

## Tùy chỉnh prompt

Khi tùy chỉnh prompt của bạn, hãy xem xét bao gồm:

1. **Bối cảnh dự án**: Cung cấp thông tin về mục đích và phạm vi của dự án
2. **Yêu cầu cụ thể**: Nêu rõ những gì bạn cần từ AI
3. **Định dạng đầu ra**: Chỉ định cách bạn muốn thông tin được trình bày
4. **Giới hạn**: Đề cập đến bất kỳ ràng buộc hoặc giới hạn nào
5. **Ưu tiên**: Làm rõ các khía cạnh quan trọng nhất đối với bạn

## Tiếp theo là gì?

- [Sử dụng cơ bản](usage.md): Tìm hiểu cách sử dụng Repomix
- [Định dạng đầu ra](output.md): Tìm hiểu về các định dạng đầu ra khác nhau
- [Hướng dẫn tùy chỉnh](custom-instructions.md): Tìm hiểu về hướng dẫn tùy chỉnh
</file>

<file path="website/client/src/vi/guide/remote-repository-processing.md">
# Xử lý kho lưu trữ từ xa

Repomix có thể xử lý các kho lưu trữ từ xa mà không cần clone chúng cục bộ, giúp bạn dễ dàng đóng gói và phân tích các dự án mã nguồn mở.

## Tổng quan

Tính năng xử lý kho lưu trữ từ xa cho phép bạn:

- Đóng gói các kho lưu trữ GitHub công khai
- Chỉ định nhánh, thẻ hoặc commit cụ thể
- Xử lý các đường dẫn cụ thể trong kho lưu trữ
- Phân tích các dự án mã nguồn mở mà không cần clone chúng

## Cú pháp cơ bản

Để xử lý một kho lưu trữ từ xa, sử dụng tùy chọn `--remote`:

```bash
repomix --remote <url_or_shorthand>
```

## Định dạng URL được hỗ trợ

Repomix hỗ trợ nhiều định dạng URL khác nhau:

### Định dạng rút gọn

```bash
repomix --remote owner/repo
```

Ví dụ:

```bash
repomix --remote yamadashy/repomix
```

### URL đầy đủ

```bash
repomix --remote https://github.com/owner/repo
```

Ví dụ:

```bash
repomix --remote https://github.com/yamadashy/repomix
```

### URL nhánh cụ thể

```bash
repomix --remote https://github.com/owner/repo/tree/branch
```

Ví dụ:

```bash
repomix --remote https://github.com/yamadashy/repomix/tree/main
```

### Chỉ định commit cụ thể

Để xử lý một commit cụ thể, sử dụng tùy chọn `--remote-branch` với mã hash commit:

```bash
repomix --remote owner/repo --remote-branch commit_hash
```

Ví dụ:

```bash
repomix --remote yamadashy/repomix --remote-branch 836abcd7335137228ad77feb28655d85712680f1
```

### URL đường dẫn cụ thể

```bash
repomix --remote https://github.com/owner/repo/tree/branch/path/to/directory
```

Ví dụ:

```bash
repomix --remote https://github.com/yamadashy/repomix/tree/main/src
```

## Ví dụ sử dụng

### Đóng gói kho lưu trữ từ xa với định dạng mặc định

```bash
repomix --remote yamadashy/repomix
```

### Đóng gói kho lưu trữ từ xa với định dạng Markdown

```bash
repomix --remote yamadashy/repomix --style markdown
```

### Đóng gói một nhánh cụ thể

```bash
repomix --remote https://github.com/yamadashy/repomix/tree/develop
```

### Đóng gói một thư mục cụ thể trong kho lưu trữ

```bash
repomix --remote https://github.com/yamadashy/repomix/tree/main/src
```

### Đóng gói một commit cụ thể

```bash
repomix --remote yamadashy/repomix --remote-branch 836abcd7335137228ad77feb28655d85712680f1
```

## Giới hạn và lưu ý

Khi sử dụng tính năng xử lý kho lưu trữ từ xa, hãy lưu ý những điểm sau:

- **Chỉ hỗ trợ kho lưu trữ công khai**: Tính năng này chỉ hoạt động với các kho lưu trữ GitHub công khai.
- **Giới hạn kích thước**: Các kho lưu trữ rất lớn có thể gặp vấn đề do giới hạn API GitHub.
- **Không có hỗ trợ .gitignore**: Khi xử lý kho lưu trữ từ xa, Repomix không thể tôn trọng các tệp .gitignore vì nó không có quyền truy cập vào cấu hình Git cục bộ.
- **Giới hạn API**: Có thể áp dụng giới hạn tốc độ API GitHub.

## Sử dụng với Docker

Bạn cũng có thể xử lý các kho lưu trữ từ xa bằng cách sử dụng hình ảnh Docker của Repomix:

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote yamadashy/repomix
```

Lệnh này sẽ đóng gói kho lưu trữ từ xa và lưu đầu ra vào thư mục `output` cục bộ của bạn.

## Tiếp theo là gì?

- [Tùy chọn dòng lệnh](command-line-options.md): Xem tất cả các tùy chọn dòng lệnh có sẵn
- [Cấu hình](configuration.md): Tìm hiểu về tệp cấu hình
- [GitHub Actions](github-actions.md): Tìm hiểu về tích hợp GitHub Actions
</file>

<file path="website/client/src/vi/guide/security.md">
# Bảo mật

Repomix tích hợp các tính năng bảo mật mạnh mẽ để giúp ngăn chặn việc vô tình tiết lộ thông tin nhạy cảm khi chia sẻ codebase của bạn với các mô hình ngôn ngữ lớn (LLMs).

## Tổng quan

Khi đóng gói codebase để chia sẻ với AI, có nguy cơ vô tình bao gồm thông tin nhạy cảm như:

- Khóa API
- Mật khẩu
- Khóa bí mật
- Token truy cập
- Thông tin xác thực cơ sở dữ liệu
- Thông tin cá nhân

Repomix giúp giảm thiểu rủi ro này bằng cách tích hợp [Secretlint](https://github.com/secretlint/secretlint), một công cụ phát hiện bí mật trong mã.

## Kiểm tra bảo mật tự động

Theo mặc định, Repomix thực hiện kiểm tra bảo mật trên tất cả các tệp trước khi đưa chúng vào đầu ra. Nếu phát hiện thông tin nhạy cảm, Repomix sẽ:

1. Hiển thị cảnh báo
2. Cung cấp thông tin về vị trí của thông tin nhạy cảm
3. Cho bạn tùy chọn để tiếp tục hoặc hủy bỏ quá trình

## Sử dụng kiểm tra bảo mật

### Bật kiểm tra bảo mật (mặc định)

Kiểm tra bảo mật được bật theo mặc định. Không cần thực hiện bất kỳ hành động nào để sử dụng tính năng này.

### Tắt kiểm tra bảo mật

Nếu bạn muốn tắt kiểm tra bảo mật (không được khuyến nghị), bạn có thể sử dụng tùy chọn `--no-security-check`:

```bash
repomix --no-security-check
```

Hoặc trong tệp cấu hình:

```json
{
  "security": {
    "check": false
  }
}
```

### Cấu hình Secretlint tùy chỉnh

Bạn có thể cung cấp cấu hình Secretlint tùy chỉnh để điều chỉnh các quy tắc phát hiện:

```bash
repomix --secretlint-config path/to/secretlint.config.js
```

Hoặc trong tệp cấu hình:

```json
{
  "security": {
    "secretlintConfigPath": "./secretlint.config.js"
  }
}
```

## Các loại bí mật được phát hiện

Repomix có thể phát hiện nhiều loại thông tin nhạy cảm, bao gồm:

- **Khóa API**: AWS, Google Cloud, Azure, GitHub, Stripe, v.v.
- **Mật khẩu**: Mật khẩu được mã hóa cứng trong mã
- **Khóa bí mật**: Khóa SSH, khóa JWT, v.v.
- **Token truy cập**: OAuth, token truy cập cá nhân, v.v.
- **Thông tin xác thực cơ sở dữ liệu**: Chuỗi kết nối, thông tin đăng nhập, v.v.
- **Thông tin cá nhân**: Số điện thoại, địa chỉ email, v.v.

## Thực hành tốt nhất về bảo mật

Ngoài việc sử dụng kiểm tra bảo mật của Repomix, hãy xem xét các thực hành tốt nhất sau:

### 1. Sử dụng biến môi trường

Lưu trữ thông tin nhạy cảm trong biến môi trường thay vì mã hóa cứng chúng trong mã:

```javascript
// Không tốt
const apiKey = "sk_live_1234567890abcdef";

// Tốt
const apiKey = process.env.API_KEY;
```

### 2. Sử dụng tệp .env

Lưu trữ biến môi trường trong tệp `.env` và đảm bảo tệp này được thêm vào `.gitignore`:

```
# .env
API_KEY=sk_live_1234567890abcdef
DATABASE_URL=postgres://user:password@localhost/db
```

### 3. Sử dụng quản lý bí mật

Xem xét sử dụng dịch vụ quản lý bí mật như:
- AWS Secrets Manager
- Google Secret Manager
- HashiCorp Vault
- Azure Key Vault

### 4. Xem lại đầu ra

Luôn xem lại đầu ra của Repomix trước khi chia sẻ nó với AI để đảm bảo không có thông tin nhạy cảm nào bị lọt qua.

### 5. Sử dụng tệp .repomixignore

Thêm các tệp có thể chứa thông tin nhạy cảm vào tệp `.repomixignore`:

```
# .repomixignore
.env
config/secrets.yml
credentials/
```

## Xử lý cảnh báo bảo mật

Khi Repomix phát hiện thông tin nhạy cảm, bạn có một số tùy chọn:

1. **Sửa vấn đề**: Xóa hoặc thay thế thông tin nhạy cảm trong mã nguồn
2. **Bỏ qua tệp**: Thêm tệp có vấn đề vào `.repomixignore`
3. **Tiếp tục với rủi ro**: Tiếp tục quá trình đóng gói (không được khuyến nghị)
4. **Tùy chỉnh quy tắc**: Điều chỉnh cấu hình Secretlint để giảm cảnh báo sai

## Tiếp theo là gì?

- [Cấu hình](configuration.md): Tìm hiểu về tệp cấu hình
- [Tùy chọn dòng lệnh](command-line-options.md): Xem tất cả các tùy chọn dòng lệnh có sẵn
- [Máy chủ MCP](mcp-server.md): Tìm hiểu về tính năng máy chủ MCP
</file>

<file path="website/client/src/vi/guide/usage.md">
# Sử dụng cơ bản

Repomix được thiết kế để dễ sử dụng với các tùy chọn mặc định hợp lý, đồng thời cung cấp khả năng tùy chỉnh mạnh mẽ cho các trường hợp sử dụng nâng cao.

## Đóng gói kho lưu trữ cục bộ

### Đóng gói toàn bộ kho lưu trữ

Để đóng gói toàn bộ kho lưu trữ hiện tại của bạn, chỉ cần chạy Repomix trong thư mục gốc của dự án:

```bash
repomix
```

Lệnh này sẽ tạo một tệp `repomix-output.xml` trong thư mục hiện tại, chứa toàn bộ codebase của bạn ở định dạng XML.

### Đóng gói một thư mục cụ thể

Để đóng gói một thư mục cụ thể thay vì toàn bộ kho lưu trữ:

```bash
repomix path/to/directory
```

### Đóng gói các tệp cụ thể

Bạn có thể chỉ định các tệp hoặc mẫu cụ thể để đóng gói bằng cách sử dụng tùy chọn `--include`:

```bash
repomix --include "src/**/*.ts,**/*.md"
```

Điều này sẽ đóng gói tất cả các tệp TypeScript trong thư mục `src` và tất cả các tệp Markdown trong toàn bộ dự án.

## Đóng gói kho lưu trữ từ xa

Repomix có thể đóng gói các kho lưu trữ từ xa mà không cần clone chúng cục bộ:

```bash
# Sử dụng định dạng rút gọn
repomix --remote yamadashy/repomix

# Sử dụng URL đầy đủ
repomix --remote https://github.com/yamadashy/repomix

# Chỉ định nhánh
repomix --remote https://github.com/yamadashy/repomix/tree/main

# Sử dụng URL của commit
repomix --remote https://github.com/yamadashy/repomix/commit/836abcd7335137228ad77feb28655d85712680f1
```

## Nhập danh sách tệp (stdin)

Truyền đường dẫn tệp qua stdin để có tính linh hoạt tối đa:

```bash
# Sử dụng lệnh find
find src -name "*.ts" -type f | repomix --stdin

# Sử dụng git để lấy các tệp được theo dõi
git ls-files "*.ts" | repomix --stdin

# Sử dụng ls với các mẫu glob
ls src/**/*.ts | repomix --stdin

# Từ một tệp chứa đường dẫn tệp
cat file-list.txt | repomix --stdin

# Nhập trực tiếp với echo
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```

Tùy chọn `--stdin` cho phép bạn truyền danh sách đường dẫn tệp tới Repomix, mang lại tính linh hoạt tối đa trong việc chọn tệp nào để đóng gói.

> [!NOTE]
> Khi sử dụng `--stdin`, đường dẫn tệp có thể là tương đối hoặc tuyệt đối, và Repomix sẽ tự động xử lý việc phân giải đường dẫn và loại bỏ trùng lặp.

## Tùy chọn đầu ra

### Định dạng đầu ra

Repomix hỗ trợ nhiều định dạng đầu ra:

```bash
# XML (mặc định)
repomix --style xml

# Markdown
repomix --style markdown

# Văn bản thuần túy
repomix --style plain
```

### Tên tệp đầu ra tùy chỉnh

Để chỉ định tên tệp đầu ra:

```bash
repomix --output-file my-codebase.xml
```

### Xóa bình luận

Để xóa bình luận khỏi mã nguồn trong đầu ra:

```bash
repomix --remove-comments
```

### Hiển thị số dòng

Để bao gồm số dòng trong đầu ra:

```bash
repomix --show-line-numbers
```

## Bỏ qua tệp và thư mục

### Sử dụng .gitignore

Theo mặc định, Repomix tôn trọng các tệp `.gitignore` của bạn. Để ghi đè hành vi này:

```bash
repomix --no-respect-gitignore
```

### Mẫu bỏ qua tùy chỉnh

Để chỉ định các mẫu bỏ qua bổ sung:

```bash
repomix --ignore "**/*.log,tmp/,**/*.min.js"
```

### Sử dụng .repomixignore

Bạn cũng có thể tạo một tệp `.repomixignore` trong thư mục gốc của dự án để chỉ định các mẫu bỏ qua cụ thể cho Repomix.

## Tùy chọn nâng cao

### Nén mã

Để nén mã bằng cách chỉ bao gồm chữ ký hàm và loại bỏ phần thân:

```bash
repomix --compress-code
```

### Kiểm tra bảo mật

Để tắt kiểm tra bảo mật:

```bash
repomix --no-security-check
```

### Đếm token

Để tắt đếm token:

```bash
repomix --no-token-count
```

## Sử dụng tệp cấu hình

Để tạo một tệp cấu hình mẫu:

```bash
repomix --init
```

Điều này sẽ tạo một tệp `repomix.config.json` mà bạn có thể chỉnh sửa để tùy chỉnh hành vi của Repomix.

Ví dụ về tệp cấu hình:

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

## Sử dụng với AI

Sau khi tạo tệp đầu ra, bạn có thể tải nó lên các công cụ AI như:

- ChatGPT
- Claude
- Gemini
- Perplexity
- Phind
- Và các LLM khác

Khi tải lên tệp, bạn có thể sử dụng một prompt như:

```
Tệp này chứa toàn bộ codebase của tôi. Tôi muốn bạn:
1. Phân tích cấu trúc tổng thể
2. Xác định các mẫu thiết kế được sử dụng
3. Đề xuất cải tiến
```

## Tiếp theo là gì?

- [Tùy chọn dòng lệnh](command-line-options.md): Danh sách đầy đủ các tùy chọn dòng lệnh
- [Cấu hình](configuration.md): Tùy chỉnh Repomix thông qua tệp cấu hình
- [Xử lý kho lưu trữ từ xa](remote-repository-processing.md): Thông tin chi tiết về xử lý kho lưu trữ từ xa
</file>

<file path="website/client/src/vi/index.md">
---
layout: home
title: Repomix
titleTemplate: Đóng gói codebase của bạn thành các định dạng thân thiện với AI
aside: false
editLink: false

features:
  - icon: 🤖
    title: Tối ưu hóa cho AI
    details: Định dạng codebase của bạn theo cách dễ dàng cho AI hiểu và xử lý.

  - icon: ⚙️
    title: Nhận biết Git
    details: Tự động tôn trọng các tệp .gitignore của bạn.

  - icon: 🛡️
    title: Tập trung vào bảo mật
    details: Tích hợp Secretlint để kiểm tra bảo mật mạnh mẽ nhằm phát hiện và ngăn chặn việc đưa thông tin nhạy cảm vào.

  - icon: 📊
    title: Đếm token
    details: Cung cấp số lượng token cho mỗi tệp và toàn bộ kho lưu trữ, hữu ích cho giới hạn ngữ cảnh LLM.

---

<script setup>
import YouTubeVideo from '../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../utils/videos'
</script>

<div class="cli-section">

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## 🏆 Đề cử Giải thưởng Mã nguồn Mở

Chúng tôi rất vinh dự! Repomix đã được đề cử cho hạng mục **Powered by AI** tại [JSNation Open Source Awards 2025](https://osawards.com/javascript/).

Điều này không thể thực hiện được nếu không có tất cả các bạn sử dụng và hỗ trợ Repomix. Xin cảm ơn!

Nếu Repomix đã giúp bạn phân tích hoặc đóng gói codebase cho các công cụ AI, chúng tôi sẽ rất biết ơn nếu bạn bỏ phiếu cho chúng tôi trong hạng mục **Powered by AI**.

## Repomix là gì?

Repomix là một công cụ mạnh mẽ giúp đóng gói toàn bộ codebase của bạn thành một file thân thiện với AI. Dù bạn đang làm việc với code review, refactoring hay cần hỗ trợ AI cho dự án của mình, Repomix giúp bạn dễ dàng chia sẻ toàn bộ ngữ cảnh repository với các công cụ AI.

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

## Bắt đầu nhanh

Sau khi bạn đã tạo một tệp đóng gói (`repomix-output.xml`) bằng Repomix, bạn có thể gửi nó đến trợ lý AI (như ChatGPT, Claude) với một prompt như:

```
Tệp này chứa tất cả các tệp trong kho lưu trữ được kết hợp thành một.
Tôi muốn tái cấu trúc mã, vì vậy hãy xem xét nó trước.
```

AI sẽ phân tích toàn bộ codebase của bạn và cung cấp những hiểu biết toàn diện:

![Repomix File Usage 1](/images/docs/repomix-file-usage-1.png)

Khi thảo luận về các thay đổi cụ thể, AI có thể giúp tạo mã. Với các tính năng như Artifacts của Claude, bạn thậm chí có thể nhận được nhiều tệp phụ thuộc lẫn nhau:

![Repomix File Usage 2](/images/docs/repomix-file-usage-2.png)

Chúc bạn code vui vẻ! 🚀


## Sử dụng công cụ CLI {#using-the-cli-tool}

Repomix có thể được sử dụng như một công cụ dòng lệnh, cung cấp các tính năng mạnh mẽ và tùy chọn tùy chỉnh.

**Công cụ CLI có thể truy cập các kho lưu trữ riêng tư** vì nó sử dụng git được cài đặt cục bộ của bạn.

### Bắt đầu nhanh

Bạn có thể thử Repomix ngay lập tức trong thư mục dự án của bạn mà không cần cài đặt:

```bash
npx repomix
```

Hoặc cài đặt toàn cục để sử dụng nhiều lần:

```bash
# Cài đặt với npm
npm install -g repomix

# Hoặc với yarn
yarn global add repomix

# Hoặc với bun
bun add -g repomix

# Hoặc với Homebrew (macOS/Linux)
brew install repomix

# Sau đó chạy trong bất kỳ thư mục dự án nào
repomix
```

Vậy là xong! Repomix sẽ tạo một tệp `repomix-output.xml` trong thư mục hiện tại của bạn, chứa toàn bộ kho lưu trữ của bạn ở định dạng thân thiện với AI.



### Cách sử dụng

Để đóng gói toàn bộ kho lưu trữ của bạn:

```bash
repomix
```

Để đóng gói một thư mục cụ thể:

```bash
repomix path/to/directory
```

Để đóng gói các tệp hoặc thư mục cụ thể bằng cách sử dụng [mẫu glob](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):

```bash
repomix --include "src/**/*.ts,**/*.md"
```

Để loại trừ các tệp hoặc thư mục cụ thể:

```bash
repomix --ignore "**/*.log,tmp/"
```

Để đóng gói một kho lưu trữ từ xa:
```bash
# Sử dụng định dạng rút gọn
npx repomix --remote yamadashy/repomix

# Sử dụng URL đầy đủ (hỗ trợ nhánh và đường dẫn cụ thể)
npx repomix --remote https://github.com/yamadashy/repomix
npx repomix --remote https://github.com/yamadashy/repomix/tree/main

# Sử dụng commit cụ thể với --remote-branch
npx repomix --remote yamadashy/repomix --remote-branch 836abcd7335137228ad77feb28655d85712680f1
```

Để khởi tạo một tệp cấu hình mới (`repomix.config.json`):

```bash
repomix --init
```

Sau khi bạn đã tạo tệp đóng gói, bạn có thể sử dụng nó với các công cụ AI Tạo sinh như Claude, ChatGPT và Gemini.

#### Sử dụng Docker

Bạn cũng có thể chạy Repomix bằng Docker 🐳  
Điều này hữu ích nếu bạn muốn chạy Repomix trong môi trường biệt lập hoặc thích sử dụng container.

Cách sử dụng cơ bản (thư mục hiện tại):

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

Để đóng gói một thư mục cụ thể:
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

Xử lý một kho lưu trữ từ xa và xuất ra thư mục `output`:

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### Định dạng đầu ra

Chọn định dạng đầu ra ưa thích của bạn:

```bash
# Định dạng XML (mặc định)
repomix --style xml

# Định dạng Markdown
repomix --style markdown

# Định dạng văn bản thuần túy
repomix --style plain
```

### Tùy chỉnh

Tạo một `repomix.config.json` cho các cài đặt cố định:

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

## Hướng Dẫn Người Dùng Chuyên Nghiệp

Repomix cung cấp các tính năng mạnh mẽ cho các trường hợp sử dụng nâng cao. Dưới đây là một số hướng dẫn thiết yếu cho người dùng chuyên nghiệp:

- **[Máy chủ MCP](./guide/mcp-server)** - Tích hợp Model Context Protocol cho trợ lý AI
- **[GitHub Actions](./guide/github-actions)** - Tự động hóa đóng gói codebase trong quy trình CI/CD
- **[Nén Mã](./guide/code-compress)** - Nén thông minh dựa trên Tree-sitter (~70% giảm token)
- **[Sử dụng như Thư viện](./guide/development/using-repomix-as-a-library)** - Tích hợp Repomix vào ứng dụng Node.js của bạn
- **[Hướng dẫn Tùy chỉnh](./guide/custom-instructions)** - Thêm prompt và hướng dẫn tùy chỉnh vào đầu ra
- **[Tính năng Bảo mật](./guide/security)** - Tích hợp Secretlint tích hợp sẵn và kiểm tra an toàn
- **[Thực hành Tốt nhất](./guide/tips/best-practices)** - Tối ưu hóa quy trình AI của bạn với các chiến lược đã được chứng minh

### Thêm ví dụ
::: tip Cần thêm trợ giúp? 💡
Hãy xem tài liệu toàn diện của chúng tôi trong [Hướng dẫn](/vi/guide/) hoặc khám phá [Kho lưu trữ GitHub](https://github.com/yamadashy/repomix) để biết thêm ví dụ và mã nguồn.
:::

</div>
</file>

<file path="website/client/src/zh-cn/guide/development/index.md">
# 参与 Repomix 开发

感谢您对 **Repomix** 的兴趣！🚀 我们非常欢迎您的帮助，让它变得更好。本指南将帮助您开始为项目做贡献。

## 如何贡献

- **为仓库加星**: 通过[为仓库加星](https://github.com/yamadashy/repomix)来表示您的支持！
- **创建问题**: 发现了bug？有新功能的想法？通过[创建问题](https://github.com/yamadashy/repomix/issues)让我们知道。
- **提交拉取请求**: 找到了可以修复或改进的地方？提交PR吧！
- **传播消息**: 在社交媒体、博客或技术社区中分享您使用Repomix的经验。
- **使用Repomix**: 最有价值的反馈来自实际使用，请随时将Repomix集成到您自己的项目中！
- **赞助**: 通过[成为赞助者](https://github.com/sponsors/yamadashy)来支持Repomix的开发。

## 快速开始

```bash
git clone https://github.com/yamadashy/repomix.git
cd repomix
npm install
```

## 开发命令

```bash
# 运行 CLI
npm run repomix

# 运行测试
npm run test
npm run test-coverage

# 代码检查
npm run lint
```

## 代码风格

- 使用 [Biome](https://biomejs.dev/) 进行代码检查和格式化
- 使用依赖注入以提高可测试性
- 保持文件不超过 250 行
- 为新功能添加测试用例

## Pull Request 提交指南

1. 运行所有测试
2. 通过代码检查
3. 更新文档
4. 遵循现有代码风格

## 开发环境搭建

### 前提条件

- Node.js ≥ 18.0.0
- Git
- npm
- Docker（可选，用于运行网站或容器化开发）

### 本地开发

要为Repomix设置本地开发环境：

```bash
# 克隆仓库
git clone https://github.com/yamadashy/repomix.git
cd repomix

# 安装依赖
npm install

# 运行CLI
npm run repomix
```

### Docker开发

您也可以使用Docker运行Repomix：

```bash
# 构建镜像
docker build -t repomix .

# 运行容器
docker run -v ./:/app -it --rm repomix
```

### 项目结构

项目组织为以下目录：

```
src/
├── cli/          # CLI实现
├── config/       # 配置处理
├── core/         # 核心功能
│   ├── file/     # 文件处理
│   ├── metrics/  # 指标计算
│   ├── output/   # 输出生成
│   ├── security/ # 安全检查
├── mcp/          # MCP服务器集成
└── shared/       # 共享工具
tests/            # 反映src/结构的测试
website/          # 文档网站
├── client/       # 前端（VitePress）
└── server/       # 后端API
```

## 网站开发

Repomix网站使用[VitePress](https://vitepress.dev/)构建。要在本地运行网站：

```bash
# 先决条件：系统上必须安装Docker

# 启动网站开发服务器
npm run website

# 在http://localhost:5173/访问网站
```

更新文档时，您只需先更新英文版本。维护者将处理其他语言的翻译。

## 发布流程

对于维护者和有兴趣的贡献者的发布流程：

1. 更新版本
```bash
npm version patch  # 或minor/major
```

2. 运行测试和构建
```bash
npm run test-coverage
npm run build
```

3. 发布
```bash
npm publish
```

新版本由维护者管理。如果您认为需要发布，请打开一个Issue进行讨论。

## 需要帮助？

- [提交 Issue](https://github.com/yamadashy/repomix/issues)
- [加入 Discord](https://discord.gg/wNYzTwZFku)
</file>

<file path="website/client/src/zh-cn/guide/development/using-repomix-as-a-library.md">
# 作为库使用 Repomix

除了作为 CLI 工具使用 Repomix 外，您还可以将其功能直接集成到 Node.js 应用程序中。

## 安装

在您的项目中安装 Repomix 作为依赖项：

```bash
npm install repomix
```

## 基本用法

使用 Repomix 最简单的方法是通过 `runCli` 函数，它提供与命令行界面相同的功能：

```javascript
import { runCli, type CliOptions } from 'repomix';

// 使用自定义选项处理当前目录
async function packProject() {
  const options = {
    output: 'output.xml',
    style: 'xml',
    compress: true,
    quiet: true
  } as CliOptions;
  
  const result = await runCli(['.'], process.cwd(), options);
  return result.packResult;
}
```

`result.packResult` 包含有关处理文件的信息，包括：
- `totalFiles`：处理的文件数量
- `totalCharacters`：总字符数
- `totalTokens`：总令牌数（对 LLM 上下文限制有用）
- `fileCharCounts`：每个文件的字符数
- `fileTokenCounts`：每个文件的令牌数

## 处理远程仓库

您可以克隆并处理远程仓库：

```javascript
import { runCli, type CliOptions } from 'repomix';

// 克隆并处理 GitHub 仓库
async function processRemoteRepo(repoUrl) {
  const options = {
    remote: repoUrl,
    output: 'output.xml',
    compress: true
  } as CliOptions;
  
  return await runCli(['.'], process.cwd(), options);
}
```

## 使用核心组件

要获得更多控制，您可以直接使用 Repomix 的低级 API：

```javascript
import { searchFiles, collectFiles, processFiles, TokenCounter } from 'repomix';

async function analyzeFiles(directory) {
  // 查找并收集文件
  const { filePaths } = await searchFiles(directory, { /* 配置 */ });
  const rawFiles = await collectFiles(filePaths, directory);
  const processedFiles = await processFiles(rawFiles, { /* 配置 */ });
  
  // 计算令牌
  const tokenCounter = new TokenCounter('o200k_base');
  
  // 返回分析结果
  return processedFiles.map(file => ({
    path: file.path,
    tokens: tokenCounter.countTokens(file.content)
  }));
}
```

## 实际示例

Repomix 网站（[repomix.com](https://repomix.com)）使用 Repomix 作为库来处理远程仓库。您可以在 [website/server/src/remoteRepo.ts](https://github.com/yamadashy/repomix/blob/main/website/server/src/remoteRepo.ts) 中查看实现。
</file>

<file path="website/client/src/zh-cn/guide/tips/best-practices.md">
# AI 辅助开发最佳实践：从实践经验谈起

虽然我还没有完成一个大型的 AI 辅助开发项目，但我想分享一下到目前为止从与 AI 合作开发中学到的经验。

## 基本开发方法

在与 AI 合作时，试图一次性实现所有功能可能会导致意外问题和项目停滞。因此，从核心功能开始，一步一步稳扎稳打地构建每个功能是更有效的方法。

### 现有代码的重要性

这种方法之所以有效，是因为通过核心功能的实现，你可以将你理想中的设计和编码风格具体化为实际代码。向 AI 传达项目愿景的最有效方式就是通过反映你的标准和偏好的代码本身。

从核心功能开始，确保每个功能在进入下一个功能之前都能正常工作，这样整个项目就能保持一致性，使 AI 更容易生成更合适的代码。

## 模块化方法

将代码分解成更小的模块至关重要。根据经验，将文件限制在 250 行左右的代码使得向 AI 提供清晰的指示更容易，并使试错过程更有效。虽然令牌计数会是更准确的指标，但对人类开发者来说，行数更容易判断，所以我们使用行数作为参考。

这不仅仅是关于前端、后端和数据库等大单元的分离，而是关于更精细层面的功能划分。例如，在一个功能内部，也要将验证、错误处理等具体功能分离成独立模块。

当然，大单元的分离也很重要，逐步实施模块化方法不仅让指令更清晰，也让 AI 能生成更合适的代码。这种方法不仅对 AI，对人类开发者来说也是有效的。

## 通过测试确保质量

我认为测试在 AI 辅助开发中尤为重要。测试不仅作为质量保证手段，还作为清晰展示代码意图的文档。当要求 AI 实现新功能时，现有的测试代码有效地充当了规范文档。

测试也是验证 AI 生成代码正确性的绝佳工具。例如，当让 AI 为某个模块实现新功能时，预先编写测试用例可以客观评估生成的代码是否符合预期。这与测试驱动开发（TDD）的理念高度契合，在与 AI 协作时特别有效。

## 规划与实现的平衡

在实现大规模功能之前，建议先与 AI 讨论计划。整理需求并考虑架构可以使后续实现更顺畅。先整理需求，然后在新的对话中进行实现是个好方法。

此外，AI 的输出必须经过人工审查，并在必要时进行调整。虽然 AI 输出的质量通常处于中等水平，但与从头开始编写代码相比，仍然可以提高开发速度。

## 结语

通过实践这些方法，你可以充分发挥 AI 的优势，同时构建一个连贯的、高质量的代码库。即使项目规模增长，每个部分都能保持清晰定义和易于管理的状态。
</file>

<file path="website/client/src/zh-cn/guide/code-compress.md">
# 代码压缩
代码压缩是一个强大的功能，它能够在移除实现细节的同时智能提取关键代码结构。在需要减少令牌数量的同时保持代码库的重要结构信息时，这个功能特别有用。

> [!NOTE]
> 这是一个实验性功能，我们将根据用户反馈和实际使用情况积极改进。

## 基本用法

使用 `--compress` 标志启用代码压缩：

```bash
repomix --compress
```

也可以在远程仓库中使用：

```bash
repomix --remote user/repo --compress
```

## 工作原理

压缩算法使用 Tree-sitter 解析处理代码，提取并保留基本结构元素，同时移除实现细节。

压缩会保留：
- 函数和方法签名
- 接口和类型定义
- 类结构和属性
- 重要的结构元素

同时会移除：
- 函数和方法实现
- 循环和条件逻辑细节
- 内部变量声明
- 具体实现代码

### 示例

原始 TypeScript 代码：

```typescript
import { ShoppingItem } from './shopping-item';

/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
  let total = 0;
  for (const item of items) {
    total += item.price * item.quantity;
  }
  return total;
}

// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

压缩后：

```typescript
import { ShoppingItem } from './shopping-item';
⋮----
/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
⋮----
// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

## 配置

你可以在配置文件中启用压缩：

```json
{
  "output": {
    "compress": true
  }
}
```

## 使用场景

代码压缩在以下情况特别有用：
- 分析代码结构和架构
- 减少用于 LLM 处理的令牌数量
- 创建高层次文档
- 理解代码模式和签名
- 共享 API 和接口设计

## 相关选项

你可以将压缩与其他选项结合使用：
- `--remove-comments`: 移除代码注释
- `--remove-empty-lines`: 移除空行
- `--output-show-line-numbers`: 在输出中添加行号
</file>

<file path="website/client/src/zh-cn/guide/command-line-options.md">
# 命令行选项

## 基本选项
- `-v, --version`: 显示版本

## 输出选项
- `-o, --output <file>`: 输出文件名（默认：`repomix-output.txt`）
- `--stdout`: 输出到标准输出而不是写入文件（不能与`--output`选项一起使用）
- `--style <type>`: 输出样式（`plain`、`xml`、`markdown`）（默认：`xml`）
- `--parsable-style`: 启用基于所选样式模式的可解析输出（默认：`false`）
- `--compress`: 执行智能代码提取，专注于函数和类的签名，同时删除实现细节。有关详细信息和示例，请参阅[代码压缩指南](code-compress)。
- `--output-show-line-numbers`: 添加行号（默认：`false`）
- `--copy`: 复制到剪贴板（默认：`false`）
- `--no-file-summary`: 禁用文件摘要（默认：`true`）
- `--no-directory-structure`: 禁用目录结构（默认：`true`）
- `--no-files`: 禁用文件内容输出（仅元数据模式）（默认：`true`）
- `--remove-comments`: 移除注释（默认：`false`）
- `--remove-empty-lines`: 移除空行（默认：`false`）
- `--header-text <text>`: 文件头部包含的自定义文本
- `--instruction-file-path <path>`: 包含详细自定义指令的文件路径
- `--include-empty-directories`: 在输出中包含空目录（默认：`false`）
- `--include-diffs`: 在输出中包含 git 差异（包括工作树和已暂存的变更，它们将分开显示）（默认：`false`）
- `--no-git-sort-by-changes`: 禁用按 git 变更计数排序文件（默认：`true`）

## 过滤选项
- `--include <patterns>`: 包含模式（逗号分隔）
- `-i, --ignore <patterns>`: 忽略模式（逗号分隔）
- `--stdin`: 从 stdin 读取文件路径而不是自动发现文件
- `--no-gitignore`: 禁用 .gitignore 文件
- `--no-default-patterns`: 禁用默认模式

## 远程仓库选项
- `--remote <url>`: 处理远程仓库
- `--remote-branch <name>`: 指定远程分支名称、标签或提交哈希（默认为仓库的默认分支）

## 配置选项
- `-c, --config <path>`: 自定义配置文件路径
- `--init`: 创建配置文件
- `--global`: 使用全局配置

## 安全选项
- `--no-security-check`: 禁用安全检查（默认：`true`）

## 令牌计数选项
- `--token-count-encoding <encoding>`: 指定令牌计数编码（如 `o200k_base`、`cl100k_base`）（默认：`o200k_base`）

## 其他选项
- `--top-files-len <number>`: 显示的顶部文件数量（默认：`5`）
- `--verbose`: 启用详细日志
- `--quiet`: 禁止所有标准输出

## 示例

```bash
# 基本用法
repomix

# 自定义输出
repomix -o output.xml --style xml

# 输出到标准输出
repomix --stdout > custom-output.txt

# 将输出发送到标准输出，然后通过管道传递到另一个命令（例如：simonw/llm）
repomix --stdout | llm "请解释这段代码的功能"

# 使用压缩的自定义输出
repomix --compress

# 处理特定文件
repomix --include "src/**/*.ts" --ignore "**/*.test.ts"

# 带分支的远程仓库
repomix --remote https://github.com/user/repo/tree/main

# 带提交的远程仓库
repomix --remote https://github.com/user/repo/commit/836abcd7335137228ad77feb28655d85712680f1

# 使用简写的远程仓库
repomix --remote user/repo

# 使用 stdin 的文件列表
find src -name "*.ts" -type f | repomix --stdin
git ls-files "*.js" | repomix --stdin
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```
</file>

<file path="website/client/src/zh-cn/guide/comment-removal.md">
# 注释移除

Repomix 可以在生成输出文件时自动移除代码中的注释。这有助于减少干扰，让代码更加简洁。

## 使用方法

要启用注释移除，在 `repomix.config.json` 中将 `removeComments` 选项设置为 `true`：

```json
{
  "output": {
    "removeComments": true
  }
}
```

## 支持的语言

Repomix 支持移除多种编程语言的注释，包括：

- JavaScript/TypeScript (`//`, `/* */`)
- Python (`#`, `"""`, `'''`)
- Java (`//`, `/* */`)
- C/C++ (`//`, `/* */`)
- HTML (`<!-- -->`)
- CSS (`/* */`)
- 以及更多语言...

## 示例

以下是 JavaScript 代码示例：

```javascript
// 这是单行注释
function test() {
  /* 这是
     多行注释 */
  return true;
}
```

启用注释移除后，输出将变为：

```javascript
function test() {
  return true;
}
```

## 注意事项

- 注释移除在其他处理步骤（如行号添加）之前执行
- 某些注释，例如 JSDoc 注释，可能会根据语言和上下文保留
- 如果你需要保留某些重要注释，请考虑使用其他方式记录这些信息，例如使用自定义指令

## 建议用法

1. **选择性使用**：
  - 对于需要向 AI 展示实现细节的代码，保留注释
  - 对于主要关注代码结构的分析，移除注释

2. **配合其他功能**：
  - 与 `--remove-empty-lines` 选项组合使用，获得更简洁的输出
  - 使用自定义指令提供额外的上下文信息

3. **性能考虑**：
  - 移除注释可以减少输出文件大小
  - 对于大型代码库特别有用
</file>

<file path="website/client/src/zh-cn/guide/configuration.md">
# 配置

Repomix可以通过配置文件（`repomix.config.json`）或命令行选项进行配置。配置文件允许您自定义代码库的处理和输出方式。

## 快速开始

在项目目录中创建配置文件：
```bash
repomix --init
```

这将创建一个带有默认设置的`repomix.config.json`文件。您还可以创建一个全局配置文件，在找不到本地配置时将使用它作为后备：

```bash
repomix --init --global
```

## 配置选项

| 选项                             | 说明                                                                                                                         | 默认值                 |
|----------------------------------|------------------------------------------------------------------------------------------------------------------------------|------------------------|
| `input.maxFileSize`              | 要处理的最大文件大小（字节）。超过此大小的文件将被跳过。用于排除大型二进制文件或数据文件                                  | `50000000`            |
| `output.filePath`                | 输出文件名。支持XML、Markdown和纯文本格式                                                                                   | `"repomix-output.xml"` |
| `output.style`                   | 输出样式（`xml`、`markdown`、`plain`）。每种格式对不同的AI工具都有其优势                                                   | `"xml"`                |
| `output.parsableStyle`           | 是否根据所选样式模式转义输出。可以提供更好的解析，但可能会增加令牌数量                                                    | `false`                |
| `output.compress`                | 是否使用Tree-sitter执行智能代码提取，在保持结构的同时减少令牌数量                                                         | `false`                |
| `output.headerText`              | 要包含在文件头部的自定义文本。对于为AI工具提供上下文或指令很有用                                                          | `null`                 |
| `output.instructionFilePath`     | 包含用于AI处理的详细自定义指令的文件路径                                                                                   | `null`                 |
| `output.fileSummary`             | 是否在输出开头包含显示文件计数、大小和其他指标的摘要部分                                                                   | `true`                 |
| `output.directoryStructure`      | 是否在输出中包含目录结构。帮助AI理解项目组织                                                                               | `true`                 |
| `output.files`                   | 是否在输出中包含文件内容。设置为false时只包含结构和元数据                                                                  | `true`                 |
| `output.removeComments`          | 是否从支持的文件类型中删除注释。可以减少噪音和令牌数量                                                                    | `false`                |
| `output.removeEmptyLines`        | 是否从输出中删除空行以减少令牌数量                                                                                         | `false`                |
| `output.showLineNumbers`         | 是否为每行添加行号。有助于引用代码的特定部分                                                                               | `false`                |
| `output.copyToClipboard`         | 是否除了保存文件外还将输出复制到系统剪贴板                                                                                 | `false`                |
| `output.topFilesLength`          | 在摘要中显示的顶部文件数量。如果设置为0，则不显示摘要                                                                      | `5`                    |
| `output.includeEmptyDirectories` | 是否在仓库结构中包含空目录                                                                                                 | `false`                |
| `output.git.sortByChanges`       | 是否按Git更改次数对文件进行排序。更改较多的文件显示在底部                                                                 | `true`                 |
| `output.git.sortByChangesMaxCommits` | 分析Git更改时要分析的最大提交数。限制历史深度以提高性能                                                               | `100`                  |
| `output.git.includeDiffs`        | 是否在输出中包含Git差异。分别显示工作树和暂存区的更改                                                                     | `false`                |
| `include`                        | 要包含的文件模式（使用[glob模式](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)）                 | `[]`                   |
| `ignore.useGitignore`            | 是否使用项目的`.gitignore`文件中的模式                                                                                     | `true`                 |
| `ignore.useDefaultPatterns`      | 是否使用默认忽略模式（node_modules、.git等）                                                                              | `true`                 |
| `ignore.customPatterns`          | 额外的忽略模式（使用[glob模式](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)）                   | `[]`                   |
| `security.enableSecurityCheck`   | 是否使用Secretlint执行安全检查以检测敏感信息                                                                              | `true`                 |
| `tokenCount.encoding`            | OpenAI的[tiktoken](https://github.com/openai/tiktoken)分词器使用的令牌计数编码。GPT-4o使用`o200k_base`，GPT-4/3.5使用`cl100k_base`。详见[tiktoken model.py](https://github.com/openai/tiktoken/blob/main/tiktoken/model.py#L24) | `"o200k_base"`         |

配置文件支持[JSON5](https://json5.org/)语法，允许：
- 注释（单行和多行）
- 对象和数组中的尾随逗号
- 无引号属性名
- 更灵活的字符串语法

## 模式验证

您可以通过添加`$schema`属性为配置文件启用模式验证：

```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "output": {
    "filePath": "repomix-output.md",
    "style": "markdown"
  }
}
```

这在支持JSON模式的编辑器中提供自动完成和验证功能。

## 配置文件示例

以下是完整配置文件（`repomix.config.json`）的示例：

```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 50000000
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "compress": false,
    "headerText": "打包文件的自定义头部信息",
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "includeEmptyDirectories": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false
    }
  },
  "include": ["**/*"],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    // 模式也可以在 .repomixignore 中指定
    "customPatterns": [
      "additional-folder",
      "**/*.log"
    ],
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
```

## 配置文件位置

Repomix按以下顺序查找配置文件：
1. 当前目录中的本地配置文件（`repomix.config.json`）
2. 全局配置文件：
   - Windows：`%LOCALAPPDATA%\Repomix\repomix.config.json`
   - macOS/Linux：`~/.config/repomix/repomix.config.json`

命令行选项优先于配置文件设置。

## 忽略模式

Repomix提供多种方式来指定要忽略的文件。模式按以下优先顺序处理：

1. CLI选项（`--ignore`）
2. 项目目录中的`.repomixignore`文件
3. `.gitignore`和`.git/info/exclude`（如果`ignore.useGitignore`为true）
4. 默认模式（如果`ignore.useDefaultPatterns`为true）

`.repomixignore`示例：
```text
# 缓存目录
.cache/
tmp/

# 构建输出
dist/
build/

# 日志
*.log
```

## 默认忽略模式

当`ignore.useDefaultPatterns`为true时，Repomix自动忽略以下常见模式：
```text
node_modules/**
.git/**
coverage/**
dist/**
```

完整列表请参见[defaultIgnore.ts](https://github.com/yamadashy/repomix/blob/main/src/config/defaultIgnore.ts)

## 高级功能

### 代码压缩

代码压缩功能（通过`output.compress: true`启用）使用[Tree-sitter](https://github.com/tree-sitter/tree-sitter)智能提取基本代码结构，同时移除实现细节。这有助于在保持重要的结构信息的同时减少令牌数量。

主要优点：
- 显著减少令牌数量
- 保留类和函数签名
- 保持导入和导出
- 保留类型定义和接口
- 移除函数体和实现细节

更多详细信息和示例，请参阅[代码压缩指南](code-compress)。

### Git集成

`output.git`配置提供强大的Git感知功能：

- `sortByChanges`：当设置为true时，文件按Git更改次数（修改该文件的提交数）排序。更改次数较多的文件出现在输出的底部。这有助于优先处理更活跃开发的文件。默认值：`true`
- `sortByChangesMaxCommits`：计算文件更改次数时要分析的最大提交数。默认值：`100`
- `includeDiffs`：当设置为true时，在输出中包含Git差异（同时分别包含工作树和暂存区的更改）。这允许读者查看存储库中的待处理更改。默认值：`false`

配置示例：
```json
{
  "output": {
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": true
    }
  }
}
```

### 安全检查

当`security.enableSecurityCheck`启用时，Repomix使用[Secretlint](https://github.com/secretlint/secretlint)在将代码库包含在输出中之前检测敏感信息。这有助于防止意外暴露：

- API密钥
- 访问令牌
- 私钥
- 密码
- 其他敏感凭据

### 注释移除

当`output.removeComments`设置为`true`时，将从支持的文件类型中移除注释，以减少输出大小并专注于核心代码内容。这在以下情况特别有用：

- 处理大量文档化的代码
- 尝试减少令牌数量
- 专注于代码结构和逻辑

有关支持的语言和详细示例，请参阅[注释移除指南](comment-removal)。
</file>

<file path="website/client/src/zh-cn/guide/custom-instructions.md">
# 自定义指令

Repomix 允许你提供自定义指令，这些指令将被包含在输出文件中。这对于为处理代码库的 AI 系统提供上下文或特定指导非常有用。

## 使用方法

要包含自定义指令，请在仓库根目录创建一个 markdown 文件（例如 `repomix-instruction.md`）。然后，在 `repomix.config.json` 中指定该文件的路径：

```json
{
  "output": {
    "instructionFilePath": "repomix-instruction.md"
  }
}
```

该文件的内容将在输出中的"Instruction"部分中显示。

## 示例

```markdown
# 仓库指令

这个仓库包含了 Repomix 工具的源代码。在分析代码时请遵循以下指导原则：

1. 重点关注 `src/core` 目录中的核心功能
2. 特别注意 `src/core/security` 中的安全检查
3. 忽略 `tests` 目录中的文件

## 代码规范
- 遵循 TypeScript 最佳实践
- 确保所有公共 API 都有适当的文档
- 使用依赖注入模式以便于测试

## 安全考虑
- 确保所有用户输入都经过适当验证
- 避免在日志中记录敏感信息
- 使用安全的依赖版本
```

这将在输出中生成以下部分：

```xml
<instruction>
# 仓库指令

这个仓库包含了 Repomix 工具的源代码。在分析代码时请遵循以下指导原则：

1. 重点关注 `src/core` 目录中的核心功能
2. 特别注意 `src/core/security` 中的安全检查
3. 忽略 `tests` 目录中的文件

## 代码规范
- 遵循 TypeScript 最佳实践
- 确保所有公共 API 都有适当的文档
- 使用依赖注入模式以便于测试

## 安全考虑
- 确保所有用户输入都经过适当验证
- 避免在日志中记录敏感信息
- 使用安全的依赖版本
</instruction>
```

## 最佳实践

1. **保持简洁明确**：指令应该简短但详细
2. **提供具体示例**：在适当的情况下添加代码示例
3. **设置优先级**：将最重要的指令放在前面
4. **包含上下文**：提供项目背景和重要考虑因素
5. **结构化内容**：使用标题和列表使指令易于阅读

## 注意事项

- 避免在指令中包含敏感信息
- 定期更新指令以反映项目的变化
- 确保指令与项目的其他文档保持一致
- 使用清晰的层次结构组织内容
</file>

<file path="website/client/src/zh-cn/guide/github-actions.md">
# 在 GitHub Actions 中使用 Repomix

通过将 Repomix 集成到 GitHub Actions 工作流中，可以自动打包代码库以供 AI 分析。这对于持续集成（CI）、代码审查或为 LLM 工具做准备非常有用。

## 基本用法

在工作流 YAML 文件中添加以下步骤以打包您的仓库：

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.xml
```

## 使用不同的输出格式

可以使用 `style` 参数指定不同的输出格式（默认为 `xml`）：

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.md
    style: markdown
```

## 多目录与压缩选项

可以指定多个目录、包含/排除模式，并启用智能压缩：

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src tests
    include: "**/*.ts,**/*.md"
    ignore: "**/*.test.ts"
    output: repomix-output.txt
    compress: true
```

## 上传输出文件为 Artifact

将生成的文件作为 artifact 上传，以便后续步骤或下载：

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src
    output: repomix-output.xml
    compress: true

- name: Upload Repomix output
  uses: actions/upload-artifact@v4
  with:
    name: repomix-output
    path: repomix-output.xml
```

## Action 输入参数

| 名称                | 说明                                   | 默认值           |
|---------------------|----------------------------------------|------------------|
| `directories`       | 要打包的目录（空格分隔）               | `.`              |
| `include`           | 包含的 glob 模式（逗号分隔）           | `""`           |
| `ignore`            | 排除的 glob 模式（逗号分隔）           | `""`           |
| `output`            | 输出文件路径                            | `repomix-output.xml`    |
| `style`             | 输出样式（xml、markdown、plain）        | `xml`            |
| `compress`          | 启用智能压缩                            | `true`           |
| `additional-args`   | 传递给 repomix CLI 的额外参数           | `""`           |
| `repomix-version`   | 要安装的 npm 包版本                     | `latest`         |

## Action 输出

| 名称           | 说明                   |
|----------------|------------------------|
| `output_file`  | 生成的输出文件路径      |

## 完整工作流示例

以下是使用 Repomix 的 GitHub Actions 工作流完整示例：

```yaml
name: Pack repository with Repomix

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  pack-repo:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Pack repository with Repomix
        uses: yamadashy/repomix/.github/actions/repomix@main
        with:
          output: repomix-output.xml

      - name: Upload Repomix output
        uses: actions/upload-artifact@v4
        with:
          name: repomix-output.xml
          path: repomix-output.xml
          retention-days: 30
```

查看[完整工作流示例](https://github.com/yamadashy/repomix/blob/main/.github/workflows/pack-repository.yml)。
</file>

<file path="website/client/src/zh-cn/guide/index.md">
# Repomix 入门指南

<script setup>
import HomeBadges from '../../../components/HomeBadges.vue'
import YouTubeVideo from '../../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../../utils/videos'
</script>

Repomix 是一个将代码库打包成单个 AI 友好文件的工具。它专为帮助你将代码提供给大型语言模型（如 ChatGPT、DeepSeek、Perplexity、Gemini、Gemma、Llama、Grok 等）而设计。

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

<HomeBadges />

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## 快速开始

在你的项目目录中运行以下命令：

```bash
npx repomix
```

就这么简单！你会在当前目录中找到一个 `repomix-output.xml` 文件，其中包含了以 AI 友好格式整理的整个代码库。

然后，你可以将此文件发送给 AI 助手，并附上类似这样的提示：

```
这个文件包含了仓库中所有文件的合并内容。
我想重构代码，请先帮我审查一下。
```

AI 将分析你的整个代码库并提供全面的见解：

![Repomix 使用示例1](/images/docs/repomix-file-usage-1.png)

在讨论具体修改时，AI 可以帮助生成代码。通过像 Claude 的 Artifacts 这样的功能，你甚至可以一次性接收多个相互依赖的文件：

![Repomix 使用示例2](/images/docs/repomix-file-usage-2.png)

祝你编码愉快！🚀

## 核心功能

- **AI 优化**：以 AI 易于理解的格式整理代码库
- **令牌计数**：为 LLM 上下文限制提供令牌使用统计
- **Git 感知**：自动识别并遵循 `.gitignore` 和 `.git/info/exclude` 文件
- **注重安全**：使用 Secretlint 进行敏感信息检测
- **多种输出格式**：可选纯文本、XML 或 Markdown 格式

## 下一步

- [安装指南](installation.md)：了解安装 Repomix 的不同方式
- [使用指南](usage.md)：学习基本和高级功能
- [配置](configuration.md)：根据需求自定义 Repomix
- [安全功能](security.md)：了解安全检查详情

## 社区

加入我们的 [Discord 社区](https://discord.gg/wNYzTwZFku)：
- 获取 Repomix 使用帮助
- 分享你的使用经验
- 提出新功能建议
- 与其他用户交流

## 支持

发现问题或需要帮助？
- [在 GitHub 上提交问题](https://github.com/yamadashy/repomix/issues)
- 加入 Discord 服务器
- 查看[文档](https://repomix.com)
</file>

<file path="website/client/src/zh-cn/guide/installation.md">
# 安装

## 使用 npx（无需安装）

```bash
npx repomix
```

## 全局安装

### npm 安装
```bash
npm install -g repomix
```

### Yarn 安装
```bash
yarn global add repomix
```

### Bun 安装
```bash
bun add -g repomix
```

### Homebrew 安装（macOS/Linux）
```bash
brew install repomix
```

## Docker 安装

使用 Docker 是最便捷的方式之一，可以避免环境配置问题。以下是具体步骤：

```bash
# 处理当前目录
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix

# 处理指定目录
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory

# 处理远程仓库
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote yamadashy/repomix
```

## VSCode 扩展

通过社区维护的 [Repomix Runner](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner) 扩展，您可以直接在 VSCode 中运行 Repomix。

功能：
- 只需点击几下即可打包任何文件夹
- 可选择文件或内容模式进行复制
- 自动清理输出文件
- 支持 repomix.config.json

从 [VSCode 应用商店](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner)安装。

## 浏览器扩展

直接从任何 GitHub 仓库访问 Repomix！我们的 Chrome 扩展在 GitHub 仓库页面添加了便捷的"Repomix"按钮。

![Repomix Browser Extension](/images/docs/browser-extension.png)

### 安装
- Chrome 扩展: [Repomix - Chrome Web Store](https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa)
- Firefox 插件: [Repomix - Firefox Add-ons](https://addons.mozilla.org/firefox/addon/repomix/)

### 功能
- 一键从 GitHub 仓库访问 Repomix
- 更多精彩功能即将推出！

## 系统要求

- Node.js: ≥ 18.0.0
- Git: 处理远程仓库时需要

## 验证安装

安装完成后，可以通过以下命令验证 Repomix 是否正常工作：

```bash
repomix --version
repomix --help
```
</file>

<file path="website/client/src/zh-cn/guide/mcp-server.md">
# MCP服务器

Repomix 支持 [Model Context Protocol (MCP)](https://modelcontextprotocol.io)，允许 AI 助手直接与您的代码库交互。当作为 MCP 服务器运行时，Repomix 提供了工具，使 AI 助手能够在无需手动准备文件的情况下打包本地或远程仓库进行分析。

> [!NOTE]  
> 这是一个实验性功能，我们将根据用户反馈和实际使用情况积极改进

## 将 Repomix 作为 MCP 服务器运行

要将 Repomix 作为 MCP 服务器运行，请使用 `--mcp` 标志：

```bash
repomix --mcp
```

这会以 MCP 服务器模式启动 Repomix，使其可供支持 Model Context Protocol 的 AI 助手使用。

## 配置 MCP 服务器

要将 Repomix 作为 MCP 服务器与 Claude 等 AI 助手一起使用，您需要配置 MCP 设置：

### 对于 VS Code

您可以使用以下方法之一在 VS Code 中安装 Repomix MCP 服务器：

1. **使用安装徽章：**

  [![Install in VS Code](https://img.shields.io/badge/VS_Code-VS_Code?style=flat-square&label=Install%20Server&color=0098FF)](vscode:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)<br>
  [![Install in VS Code Insiders](https://img.shields.io/badge/VS_Code_Insiders-VS_Code_Insiders?style=flat-square&label=Install%20Server&color=24bfa5)](vscode-insiders:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)

2. **使用命令行：**

  ```bash
  code --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

  对于 VS Code Insiders：
  ```bash
  code-insiders --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

### 对于 Cline（VS Code 扩展）

编辑 `cline_mcp_settings.json` 文件：

```json
{
  "mcpServers": {
    "repomix": {
      "command": "npx",
      "args": [
        "-y",
        "repomix",
        "--mcp"
      ]
    }
  }
}
```

### 对于 Cursor

在 Cursor 中，从 `Cursor Settings` > `MCP` > `+ Add new global MCP server` 添加一个新的 MCP 服务器，配置与 Cline 类似。

### 对于 Claude Desktop

使用与 Cline 类似的配置编辑 `claude_desktop_config.json` 文件。

### 对于 Claude Code

要在 [Claude Code](https://docs.anthropic.com/en/docs/claude-code/overview) 中配置 Repomix 作为 MCP 服务器，请使用以下命令：

```bash
claude mcp add repomix -- npx -y repomix --mcp
```

### 使用 Docker 代替 npx

您可以使用 Docker 代替 npx 来运行 Repomix 作为 MCP 服务器：

```json
{
  "mcpServers": {
    "repomix-docker": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "ghcr.io/yamadashy/repomix",
        "--mcp"
      ]
    }
  }
}
```

## 可用的 MCP 工具

当作为 MCP 服务器运行时，Repomix 提供以下工具：

### pack_codebase

此工具将本地代码目录打包成一个用于 AI 分析的 XML 文件。它分析代码库结构，提取相关代码内容，并生成包含指标、文件树和格式化代码内容的综合报告。

**参数：**
- `directory`：（必需）要打包的目录的绝对路径
- `compress`：（可选，默认值：false）启用 Tree-sitter 压缩以提取基本代码签名和结构，同时删除实现细节。在保持语义含义的同时减少约 70% 的令牌使用量。由于 grep_repomix_output 允许增量内容检索，通常不需要。仅在您特别需要大型仓库的整个代码库内容时使用。
- `includePatterns`：（可选）使用 fast-glob 模式指定要包含的文件。多个模式可以用逗号分隔（例如，"**/*.{js,ts}", "src/**,docs/**"）。只有匹配的文件会被处理。
- `ignorePatterns`：（可选）使用 fast-glob 模式指定要排除的其他文件。多个模式可以用逗号分隔（例如，"test/**,*.spec.js", "node_modules/**,dist/**"）。这些模式补充 .gitignore 和内置排除。
- `topFilesLength`：（可选，默认值：10）在代码库分析的指标摘要中显示的最大文件数（按大小排序）。

**示例：**
```json
{
  "directory": "/path/to/your/project",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### pack_remote_repository

此工具获取、克隆并将 GitHub 仓库打包成一个用于 AI 分析的 XML 文件。它自动克隆远程仓库，分析其结构，并生成综合报告。

**参数：**
- `remote`：（必需）GitHub 仓库 URL 或用户/仓库格式（例如，"yamadashy/repomix", "https://github.com/user/repo", 或 "https://github.com/user/repo/tree/branch"）
- `compress`：（可选，默认值：false）启用 Tree-sitter 压缩以提取基本代码签名和结构，同时删除实现细节。在保持语义含义的同时减少约 70% 的令牌使用量。由于 grep_repomix_output 允许增量内容检索，通常不需要。仅在您特别需要大型仓库的整个代码库内容时使用。
- `includePatterns`：（可选）使用 fast-glob 模式指定要包含的文件。多个模式可以用逗号分隔（例如，"**/*.{js,ts}", "src/**,docs/**"）。只有匹配的文件会被处理。
- `ignorePatterns`：（可选）使用 fast-glob 模式指定要排除的其他文件。多个模式可以用逗号分隔（例如，"test/**,*.spec.js", "node_modules/**,dist/**"）。这些模式补充 .gitignore 和内置排除。
- `topFilesLength`：（可选，默认值：10）在代码库分析的指标摘要中显示的最大文件数（按大小排序）。

**示例：**
```json
{
  "remote": "yamadashy/repomix",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### read_repomix_output

此工具读取 Repomix 生成的输出文件的内容。支持对大文件进行行范围指定的部分读取。此工具专为直接文件系统访问受限的环境而设计。

**参数：**
- `outputId`：（必需）要读取的 Repomix 输出文件的 ID
- `startLine`：（可选）起始行号（从 1 开始，包含）。如果未指定，则从开头读取。
- `endLine`：（可选）结束行号（从 1 开始，包含）。如果未指定，则读取到末尾。

**功能：**
- 专为基于 Web 的环境或沙箱应用程序设计
- 使用其 ID 检索先前生成的输出内容
- 无需文件系统访问权限即可安全访问打包的代码库
- 支持大文件的部分读取

**示例：**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "startLine": 100,
  "endLine": 200
}
```

### grep_repomix_output

此工具使用 JavaScript RegExp 语法的类似 grep 的功能在 Repomix 输出文件中搜索模式。返回匹配行及其周围的可选上下文行。

**参数：**
- `outputId`：（必需）要搜索的 Repomix 输出文件的 ID
- `pattern`：（必需）搜索模式（JavaScript RegExp 正则表达式语法）
- `contextLines`：（可选，默认值：0）在每个匹配项前后显示的上下文行数。如果指定了 beforeLines/afterLines，则被覆盖。
- `beforeLines`：（可选）在每个匹配项前显示的上下文行数（类似 grep -B）。优先于 contextLines。
- `afterLines`：（可选）在每个匹配项后显示的上下文行数（类似 grep -A）。优先于 contextLines。
- `ignoreCase`：（可选，默认值：false）执行不区分大小写的匹配

**功能：**
- 使用 JavaScript RegExp 语法进行强大的模式匹配
- 支持上下文行以更好地理解匹配
- 允许单独控制前/后上下文行
- 区分大小写和不区分大小写的搜索选项

**示例：**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "pattern": "function\\s+\\w+\\(",
  "contextLines": 3,
  "ignoreCase": false
}
```

### file_system_read_file 和 file_system_read_directory

Repomix 的 MCP 服务器提供了两个文件系统工具，允许 AI 助手安全地与本地文件系统交互：

1. `file_system_read_file`
  - 使用绝对路径从本地文件系统读取文件内容
  - 包含内置安全验证以检测和防止访问包含敏感信息的文件
  - 使用 [Secretlint](https://github.com/secretlint/secretlint) 实现安全验证
  - 防止访问包含敏感信息的文件（API 密钥、密码、机密）
  - 验证绝对路径以防止目录遍历攻击
  - 对无效路径和安全问题返回清晰的错误消息

2. `file_system_read_directory`
  - 使用绝对路径列出目录的内容
  - 返回显示文件和子目录的格式化列表，带有清晰的指示符
  - 使用清晰的指示符（`[FILE]` 或 `[DIR]`）显示文件和目录
  - 提供安全的目录遍历和适当的错误处理
  - 验证路径并确保使用绝对路径
  - 对探索项目结构和理解代码库组织很有用

这两个工具都包含了强大的安全措施：
- 绝对路径验证以防止目录遍历攻击
- 权限检查以确保适当的访问权限
- 与 Secretlint 集成以检测敏感信息
- 清晰的错误消息以便于调试和安全意识

**示例：**
```typescript
// 读取文件
const fileContent = await tools.file_system_read_file({
  path: '/absolute/path/to/file.txt'
});

// 列出目录内容
const dirContent = await tools.file_system_read_directory({
  path: '/absolute/path/to/directory'
});
```

这些工具在 AI 助手需要执行以下操作时特别有用：
- 分析代码库中的特定文件
- 导航目录结构
- 验证文件存在性和可访问性
- 确保安全的文件系统操作

## 将 Repomix 作为 MCP 服务器使用的好处

将 Repomix 作为 MCP 服务器使用提供了几个优势：

1. **直接集成**：AI 助手可以直接分析您的代码库，无需手动文件准备。
2. **高效工作流**：通过消除手动生成和上传文件的需求，简化了代码分析过程。
3. **一致输出**：确保 AI 助手以一致、优化的格式接收代码库。
4. **高级功能**：利用 Repomix 的所有功能，如代码压缩、令牌计数和安全检查。

配置完成后，您的 AI 助手可以直接使用 Repomix 的功能来分析代码库，使代码分析工作流更加高效。
</file>

<file path="website/client/src/zh-cn/guide/output.md">
# 输出格式

Repomix 支持三种输出格式：
- XML（默认）
- Markdown
- 纯文本

## XML 格式

```bash
repomix --style xml
```

XML 格式针对 AI 处理进行了优化：

```xml
本文件是整个代码库的合并表示形式...

<file_summary>
（元数据和 AI 指令）
</file_summary>

<directory_structure>
src/
  index.ts
  utils/
    helper.ts
</directory_structure>

<files>
<file path="src/index.ts">
// 文件内容
</file>
</files>
```

::: tip 为什么选择 XML？
XML 标签有助于像 Claude 这样的 AI 模型更准确地解析内容。[Claude 官方文档](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags)推荐使用 XML 标签来构建结构化提示。
:::

## Markdown 格式

```bash
repomix --style markdown
```

Markdown 提供了易读的格式：

```markdown
本文件是整个代码库的合并表示形式...

# 文件概要
（元数据和 AI 指令）

# 目录结构
```
src/
index.ts
utils/
helper.ts
```

# 文件

## File: src/index.ts
```typescript
// 文件内容
```
```

## 在 AI 模型中的使用

每种格式都能在 AI 模型中正常工作，但需要考虑以下几点：
- 对 Claude 使用 XML（解析最准确）
- 对一般可读性使用 Markdown
- 对简单性和通用兼容性使用纯文本

## 自定义设置

在 `repomix.config.json` 中设置默认格式：
```json
{
  "output": {
    "style": "xml",
    "filePath": "output.xml"
  }
}
```

## 纯文本格式

```bash
repomix --style plain
```

输出结构：
```text
本文件是整个代码库的合并表示形式...

================
文件概要
================
（元数据和 AI 指令）

================
目录结构
================
src/
  index.ts
  utils/
    helper.ts

================
文件
================

================
File: src/index.ts
================
// 文件内容
```
</file>

<file path="website/client/src/zh-cn/guide/prompt-examples.md">
# 提示示例

## 代码评审

### 架构评审
```
分析此代码库的架构：
1. 评估整体结构和模式
2. 识别潜在的架构问题
3. 提出改进可扩展性的建议
4. 标注遵循最佳实践的部分

重点关注可维护性和模块化。
```

### 安全性评审
```
对此代码库进行安全性评审：
1. 识别潜在的安全漏洞
2. 检查常见的安全反模式
3. 评审错误处理和输入验证
4. 评估依赖项的安全性

请提供具体示例和修复步骤。
```

### 性能评审
```
从性能角度评审代码库：
1. 识别性能瓶颈
2. 检查资源使用情况
3. 评审算法效率
4. 评估缓存策略

包含具体的优化建议。
```

## 文档生成

### API 文档
```
生成全面的 API 文档：
1. 列出并描述所有公共端点
2. 记录请求/响应格式
3. 包含使用示例
4. 说明限制和约束
```

### 开发者指南
```
创建包含以下内容的开发者指南：
1. 环境搭建说明
2. 项目结构概览
3. 开发工作流程
4. 测试方法
5. 常见问题排查步骤
```

### 架构文档
```
记录系统架构：
1. 高层概述
2. 组件交互
3. 数据流程图
4. 设计决策及理由
5. 系统限制和约束
```

## 分析与改进

### 依赖项分析
```
分析项目依赖：
1. 识别过时的包
2. 检查安全漏洞
3. 建议替代包
4. 评审依赖使用模式

包含具体的升级建议。
```

### 测试覆盖率
```
评审测试覆盖率：
1. 识别未测试的组件
2. 建议额外的测试用例
3. 评审测试质量
4. 推荐测试策略
```

### 代码质量
```
评估代码质量并提出改进建议：
1. 评审命名规范
2. 检查代码组织
3. 评估错误处理
4. 评审注释实践

提供具体的良好和问题模式示例。
```

## 获得更好结果的技巧

1. **明确具体**：包含清晰的目标和评估标准
2. **设置上下文**：说明你的角色和所需的专业水平
3. **请求格式**：定义期望的响应结构
4. **设置优先级**：指出哪些方面最重要

## 模型特定说明

### Claude
- 使用 XML 输出格式
- 将重要指令放在最后
- 指定响应结构

### ChatGPT
- 使用 Markdown 格式
- 将大型代码库分成小节
- 包含系统角色提示

### Gemini
- 适用于所有格式
- 每次请求专注于特定领域
- 使用逐步分析
</file>

<file path="website/client/src/zh-cn/guide/remote-repository-processing.md">
# 远程仓库处理

## 基本用法

处理公共仓库：
```bash
# 使用完整 URL
repomix --remote https://github.com/user/repo

# 使用 GitHub 简写
repomix --remote user/repo
```

## 分支和提交选择

```bash
# 指定分支
repomix --remote user/repo --remote-branch main

# 指定标签
repomix --remote user/repo --remote-branch v1.0.0

# 指定提交哈希
repomix --remote user/repo --remote-branch 935b695
```

## 系统要求

- 必须安装 Git
- 需要网络连接
- 需要仓库的读取权限

## 输出控制

```bash
# 自定义输出位置
repomix --remote user/repo -o custom-output.xml

# 使用 XML 格式
repomix --remote user/repo --style xml

# 移除注释
repomix --remote user/repo --remove-comments
```

## Docker 使用方法

```bash
# 在当前目录处理并输出
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo

# 输出到指定目录
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo
```

## 常见问题

### 访问问题
- 确保仓库是公开的
- 检查 Git 是否已安装
- 验证网络连接

### 大型仓库处理
- 使用 `--include` 选择特定路径
- 启用 `--remove-comments`
- 分开处理不同分支
</file>

<file path="website/client/src/zh-cn/guide/security.md">
# 安全性

## 安全检查功能

Repomix 使用 [Secretlint](https://github.com/secretlint/secretlint) 检测文件中的敏感信息：
- API 密钥
- 访问令牌
- 认证凭证
- 私钥
- 环境变量

## 配置

安全检查默认启用。

通过命令行禁用：
```bash
repomix --no-security-check
```

或在 `repomix.config.json` 中配置：
```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

## 安全措施

1. **二进制文件排除**：输出中不包含二进制文件
2. **Git 感知**：遵循 `.gitignore` 模式
3. **自动检测**：扫描常见安全问题：
    - AWS 凭证
    - 数据库连接字符串
    - 认证令牌
    - 私钥

## 安全检查发现问题时

输出示例：
```bash
🔍 Security Check:
──────────────────
2 suspicious file(s) detected and excluded:
1. config/credentials.json
  - Found AWS access key
2. .env.local
  - Found database password
```

## 最佳实践

1. 分享前务必检查输出内容
2. 使用 `.repomixignore` 排除敏感路径
3. 保持安全检查功能启用
4. 从仓库中移除敏感文件

## 报告安全问题

如果发现安全漏洞，请：
1. 不要创建公开的 Issue
2. 发送邮件至：koukun0120@gmail.com
3. 或使用 [GitHub 安全公告](https://github.com/yamadashy/repomix/security/advisories/new)
</file>

<file path="website/client/src/zh-cn/guide/usage.md">
# 基本用法

## 快速开始

打包整个仓库：
```bash
repomix
```

## 常见使用场景

### 打包指定目录
```bash
repomix path/to/directory
```

### 包含特定文件
使用 [glob 模式](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)：
```bash
repomix --include "src/**/*.ts,**/*.md"
```

### 排除文件
```bash
repomix --ignore "**/*.log,tmp/"
```

### 处理远程仓库
```bash
# 使用 GitHub URL
repomix --remote https://github.com/user/repo

# 使用简写形式
repomix --remote user/repo

# 指定分支/标签/提交
repomix --remote user/repo --remote-branch main
repomix --remote user/repo --remote-branch 935b695
```

### 文件列表输入（stdin）

通过 stdin 传递文件路径以获得终极灵活性：

```bash
# 使用 find 命令
find src -name "*.ts" -type f | repomix --stdin

# 使用 git 获取跟踪的文件
git ls-files "*.ts" | repomix --stdin

# 使用 ls 和 glob 模式
ls src/**/*.ts | repomix --stdin

# 从包含文件路径的文件中读取
cat file-list.txt | repomix --stdin

# 使用 echo 直接输入
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```

`--stdin` 选项允许您向 Repomix 传递文件路径列表，在选择要打包的文件时提供终极灵活性。

> [!NOTE]
> 使用 `--stdin` 时，文件路径可以是相对路径或绝对路径，Repomix 会自动处理路径解析和去重。

## 输出格式

### XML（默认）
```bash
repomix --style xml
```

### Markdown
```bash
repomix --style markdown
```

### 纯文本
```bash
repomix --style plain
```

## 其他选项

### 移除注释
```bash
repomix --remove-comments
```

### 显示行号
```bash
repomix --output-show-line-numbers
```

### 复制到剪贴板
```bash
repomix --copy
```

### 禁用安全检查
```bash
repomix --no-security-check
```

## 配置

初始化配置文件：
```bash
repomix --init
```

更多详细配置选项请参阅[配置指南](/zh-cn/guide/configuration)。
</file>

<file path="website/client/src/zh-cn/index.md">
---
layout: home
title: Repomix
titleTemplate: 将代码库打包成AI友好的格式
aside: false
editLink: false

features:
  - icon: 🤖
    title: AI 优化
    details: 以 AI 易于理解和处理的方式格式化代码库。

  - icon: ⚙️
    title: Git 感知
    details: 自动识别并尊重您的 .gitignore 文件。

  - icon: 🛡️
    title: 注重安全
    details: 集成 Secretlint 进行强大的安全检查，检测并防止敏感信息的泄露。

  - icon: 📊
    title: 令牌计数
    details: 提供每个文件和整个代码库的令牌计数，便于控制 LLM 上下文限制。

---

<script setup>
import YouTubeVideo from '../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../utils/videos'
</script>

<div class="cli-section">

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## 🏆 开源奖项提名

我们深感荣幸！Repomix 已被提名为 [JSNation Open Source Awards 2025](https://osawards.com/javascript/) 的 **Powered by AI** 类别奖项。

这一切都离不开所有使用和支持 Repomix 的用户。谢谢大家！

如果 Repomix 帮助您分析或打包代码库用于 AI 工具，我们将非常感谢您在 **Powered by AI** 类别中为我们投票。

## 什么是 Repomix？

Repomix 是一个强大的工具，可以将您的整个代码库打包到一个 AI 友好的文件中。无论您是在进行代码审查、重构，还是需要 AI 协助您的项目，Repomix 都可以轻松地与 AI 工具共享您的整个代码库上下文。

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

## 快速开始

使用 Repomix 生成打包文件（`repomix-output.xml`）后，您可以将其发送给 AI 助手（如 ChatGPT、Claude），并附上这样的提示：

```
此文件包含了仓库中所有文件的合并内容。
我想重构代码，请先帮我审查一下。
```

AI 将分析您的整个代码库并提供全面的见解：

![Repomix 使用示例1](/images/docs/repomix-file-usage-1.png)

在讨论具体修改时，AI 可以帮助生成代码。通过像 Claude 的 Artifacts 这样的功能，您甚至可以一次性接收多个相互依赖的文件：

![Repomix 使用示例2](/images/docs/repomix-file-usage-2.png)

祝您编码愉快！🚀



## 使用 CLI 工具 {#using-the-cli-tool}

Repomix 可以作为命令行工具使用，提供强大的功能和自定义选项。

**CLI 工具可以访问私有仓库**，因为它使用您本地安装的 Git。

### 快速上手

您可以在项目目录中无需安装即可立即尝试 Repomix：

```bash
npx repomix
```

或者全局安装以便重复使用：

```bash
# 使用 npm 安装
npm install -g repomix

# 或使用 yarn 安装
yarn global add repomix

# 或使用 bun 安装
bun add -g repomix

# 或使用 Homebrew 安装（macOS/Linux）
brew install repomix

# 然后在任意项目目录中运行
repomix
```

就是这么简单！Repomix 将在您的当前目录中生成一个 `repomix-output.xml` 文件，其中包含了以 AI 友好格式整理的整个代码库。



### 基本用法

打包整个代码库：

```bash
repomix
```

打包特定目录：

```bash
repomix path/to/directory
```

使用 [glob 模式](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)打包特定文件：

```bash
repomix --include "src/**/*.ts,**/*.md"
```

排除特定文件：

```bash
repomix --ignore "**/*.log,tmp/"
```

处理远程仓库：
```bash
# 使用简写格式
npx repomix --remote yamadashy/repomix

# 使用完整 URL（支持分支和特定路径）
npx repomix --remote https://github.com/yamadashy/repomix
npx repomix --remote https://github.com/yamadashy/repomix/tree/main

# 使用提交 URL
npx repomix --remote https://github.com/yamadashy/repomix/commit/836abcd7335137228ad77feb28655d85712680f1
```

初始化配置文件（`repomix.config.json`）：

```bash
repomix --init
```

生成打包文件后，您可以将其用于 Claude、ChatGPT、Gemini 等生成式 AI 工具。

#### Docker 使用方法

您也可以使用 Docker 运行 Repomix 🐳  
如果您想在隔离环境中运行 Repomix 或更偏好使用容器，这是一个很好的选择。

基本用法（当前目录）：

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

打包特定目录：
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

处理远程仓库并输出到 `output` 目录：

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### 输出格式

选择您偏好的输出格式：

```bash
# XML 格式（默认）
repomix --style xml

# Markdown 格式
repomix --style markdown

# 纯文本格式
repomix --style plain
```

### 自定义设置

创建 `repomix.config.json` 进行持久化设置：

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

## 高级用户指南

Repomix 为高级用例提供强大的功能。以下是高级用户的一些重要指南：

- **[MCP 服务器](./guide/mcp-server)** - AI 助手的 Model Context Protocol 集成
- **[GitHub Actions](./guide/github-actions)** - 在 CI/CD 工作流中自动化代码库打包
- **[代码压缩](./guide/code-compress)** - 基于 Tree-sitter 的智能压缩（约 70% 令牌减少）
- **[作为库使用](./guide/development/using-repomix-as-a-library)** - 将 Repomix 集成到您的 Node.js 应用程序中
- **[自定义指令](./guide/custom-instructions)** - 为输出添加自定义提示和指令
- **[安全功能](./guide/security)** - 内置 Secretlint 集成和安全检查
- **[最佳实践](./guide/tips/best-practices)** - 使用经过验证的策略优化您的 AI 工作流

### 更多示例
::: tip 需要更多帮助？ 💡
查看我们的[使用指南](./guide/)获取详细说明，或访问[GitHub 仓库](https://github.com/yamadashy/repomix)获取更多示例和源代码。
:::

</div>
</file>

<file path="website/client/src/zh-tw/guide/development/index.md">
# 參與 Repomix 開發

感謝您對 **Repomix** 的興趣！🚀 我們非常歡迎您的幫助，讓它變得更好。本指南將幫助您開始為專案做貢獻。

## 如何貢獻

- **為儲存庫加星**: 通過[為儲存庫加星](https://github.com/yamadashy/repomix)來表示您的支持！
- **建立問題**: 發現了bug？有新功能的想法？通過[建立問題](https://github.com/yamadashy/repomix/issues)讓我們知道。
- **提交拉取請求**: 找到了可以修復或改進的地方？提交PR吧！
- **傳播訊息**: 在社交媒體、部落格或技術社群中分享您使用Repomix的經驗。
- **使用Repomix**: 最有價值的反饋來自實際使用，請隨時將Repomix整合到您自己的專案中！
- **贊助**: 通過[成為贊助者](https://github.com/sponsors/yamadashy)來支持Repomix的開發。

## 快速開始

```bash
git clone https://github.com/yamadashy/repomix.git
cd repomix
npm install
```

## 開發命令

```bash
# 運行 CLI
npm run repomix

# 運行測試
npm run test
npm run test-coverage

# 程式碼檢查
npm run lint
```

## 程式碼風格

- 使用 [Biome](https://biomejs.dev/) 進行程式碼檢查和格式化
- 使用依賴注入以提高可測試性
- 保持文件不超過 250 行
- 為新功能添加測試用例

## Pull Request 提交指南

1. 運行所有測試
2. 通過程式碼檢查
3. 更新文檔
4. 遵循現有程式碼風格

## 開發環境設置

### 前提條件

- Node.js ≥ 18.0.0
- Git
- npm
- Docker（可選，用於運行網站或容器化開發）

### 本地開發

要為Repomix設置本地開發環境：

```bash
# 克隆儲存庫
git clone https://github.com/yamadashy/repomix.git
cd repomix

# 安裝依賴
npm install

# 運行CLI
npm run repomix
```

### Docker開發

您也可以使用Docker運行Repomix：

```bash
# 構建鏡像
docker build -t repomix .

# 運行容器
docker run -v ./:/app -it --rm repomix
```

### 項目結構

項目組織為以下目錄：

```
src/
├── cli/          # CLI實現
├── config/       # 配置處理
├── core/         # 核心功能
│   ├── file/     # 文件處理
│   ├── metrics/  # 指標計算
│   ├── output/   # 輸出生成
│   ├── security/ # 安全檢查
├── mcp/          # MCP服務器集成
└── shared/       # 共享工具
tests/            # 反映src/結構的測試
website/          # 文檔網站
├── client/       # 前端（VitePress）
└── server/       # 後端API
```

## 網站開發

Repomix網站使用[VitePress](https://vitepress.dev/)構建。要在本地運行網站：

```bash
# 先決條件：系統上必須安裝Docker

# 啟動網站開發服務器
npm run website

# 在http://localhost:5173/訪問網站
```

更新文檔時，您只需先更新英文版本。維護者將處理其他語言的翻譯。

## 發布流程

對於維護者和有興趣的貢獻者的發布流程：

1. 更新版本
```bash
npm version patch  # 或minor/major
```

2. 運行測試和構建
```bash
npm run test-coverage
npm run build
```

3. 發布
```bash
npm publish
```

新版本由維護者管理。如果您認為需要發布，請打開一個Issue進行討論。

## 需要幫助？

- [提交 Issue](https://github.com/yamadashy/repomix/issues)
- [加入 Discord](https://discord.gg/wNYzTwZFku)
</file>

<file path="website/client/src/zh-tw/guide/development/using-repomix-as-a-library.md">
# 作為庫使用 Repomix

除了作為 CLI 工具使用 Repomix 外，您還可以將其功能直接集成到 Node.js 應用程序中。

## 安裝

在您的項目中安裝 Repomix 作為依賴項：

```bash
npm install repomix
```

## 基本用法

使用 Repomix 最簡單的方法是通過 `runCli` 函數，它提供與命令行界面相同的功能：

```javascript
import { runCli, type CliOptions } from 'repomix';

// 使用自定義選項處理當前目錄
async function packProject() {
  const options = {
    output: 'output.xml',
    style: 'xml',
    compress: true,
    quiet: true
  } as CliOptions;
  
  const result = await runCli(['.'], process.cwd(), options);
  return result.packResult;
}
```

`result.packResult` 包含有關處理文件的信息，包括：
- `totalFiles`：處理的文件數量
- `totalCharacters`：總字符數
- `totalTokens`：總令牌數（對 LLM 上下文限制有用）
- `fileCharCounts`：每個文件的字符數
- `fileTokenCounts`：每個文件的令牌數

## 處理遠端倉庫

您可以克隆並處理遠端倉庫：

```javascript
import { runCli, type CliOptions } from 'repomix';

// 克隆並處理 GitHub 倉庫
async function processRemoteRepo(repoUrl) {
  const options = {
    remote: repoUrl,
    output: 'output.xml',
    compress: true
  } as CliOptions;
  
  return await runCli(['.'], process.cwd(), options);
}
```

## 使用核心組件

要獲得更多控制，您可以直接使用 Repomix 的低級 API：

```javascript
import { searchFiles, collectFiles, processFiles, TokenCounter } from 'repomix';

async function analyzeFiles(directory) {
  // 查找並收集文件
  const { filePaths } = await searchFiles(directory, { /* 配置 */ });
  const rawFiles = await collectFiles(filePaths, directory);
  const processedFiles = await processFiles(rawFiles, { /* 配置 */ });
  
  // 計算令牌
  const tokenCounter = new TokenCounter('o200k_base');
  
  // 返回分析結果
  return processedFiles.map(file => ({
    path: file.path,
    tokens: tokenCounter.countTokens(file.content)
  }));
}
```

## 實際示例

Repomix 網站（[repomix.com](https://repomix.com)）使用 Repomix 作為庫來處理遠端倉庫。您可以在 [website/server/src/remoteRepo.ts](https://github.com/yamadashy/repomix/blob/main/website/server/src/remoteRepo.ts) 中查看實現。
</file>

<file path="website/client/src/zh-tw/guide/tips/best-practices.md">
# AI 輔助開發最佳實踐：從實踐經驗談起

雖然我還沒有完成一個大型的 AI 輔助開發項目，但我想分享一下到目前為止從與 AI 合作開發中學到的經驗。

## 基本開發方法

在與 AI 合作時，試圖一次性實現所有功能可能會導致意外問題和項目停滯。因此，從核心功能開始，一步一步穩紮穩打地構建每個功能是更有效的方法。

### 現有程式碼的重要性

這種方法之所以有效，是因為通過核心功能的實現，你可以將你理想中的設計和編碼風格具體化為實際程式碼。向 AI 傳達項目願景的最有效方式就是通過反映你的標準和偏好的程式碼本身。

從核心功能開始，確保每個功能在進入下一個功能之前都能正常工作，這樣整個項目就能保持一致性，使 AI 更容易生成更合適的程式碼。

## 模組化方法

將程式碼分解成更小的模組至關重要。根據經驗，將文件限制在 250 行左右的程式碼使得向 AI 提供清晰的指示更容易，並使試錯過程更有效。雖然令牌計數會是更準確的指標，但對人類開發者來說，行數更容易判斷，所以我們使用行數作為參考。

這不僅僅是關於前端、後端和數據庫等大單元的分離，而是關於更精細層面的功能劃分。例如，在一個功能內部，也要將驗證、錯誤處理等具體功能分離成獨立模組。

當然，大單元的分離也很重要，逐步實施模組化方法不僅讓指令更清晰，也讓 AI 能生成更合適的程式碼。這種方法不僅對 AI，對人類開發者來說也是有效的。

## 通過測試確保質量

我認為測試在 AI 輔助開發中尤為重要。測試不僅作為質量保證手段，還作為清晰展示程式碼意圖的文檔。當要求 AI 實現新功能時，現有的測試程式碼有效地充當了規範文檔。

測試也是驗證 AI 生成程式碼正確性的絕佳工具。例如，當讓 AI 為某個模組實現新功能時，預先編寫測試用例可以客觀評估生成的程式碼是否符合預期。這與測試驅動開發（TDD）的理念高度契合，在與 AI 協作時特別有效。

## 規劃與實現的平衡

在實現大規模功能之前，建議先與 AI 討論計劃。整理需求並考慮架構可以使後續實現更順暢。先整理需求，然後在新的對話中進行實現是個好方法。

此外，AI 的輸出必須經過人工審查，並在必要時進行調整。雖然 AI 輸出的質量通常處於中等水準，但與從頭開始編寫程式碼相比，仍然可以提高開發速度。

## 結語

通過實踐這些方法，你可以充分發揮 AI 的優勢，同時構建一個連貫的、高質量的程式碼庫。即使項目規模增長，每個部分都能保持清晰定義和易於管理的狀態。
</file>

<file path="website/client/src/zh-tw/guide/code-compress.md">
# 程式碼壓縮
程式碼壓縮是一個強大的功能，它能夠在移除實現細節的同時智能提取關鍵程式碼結構。在需要減少令牌數量的同時保持程式碼庫的重要結構信息時，這個功能特別有用。

> [!NOTE]
> 這是一個實驗性功能，我們將根據用戶反饋和實際使用情況積極改進。

## 基本用法

使用 `--compress` 標誌啟用程式碼壓縮：

```bash
repomix --compress
```

也可以在遠端倉庫中使用：

```bash
repomix --remote user/repo --compress
```

## 工作原理

壓縮算法使用 Tree-sitter 解析處理程式碼，提取並保留基本結構元素，同時移除實現細節。

壓縮會保留：
- 函數和方法簽名
- 介面和類型定義
- 類結構和屬性
- 重要的結構元素

同時會移除：
- 函數和方法實現
- 迴圈和條件邏輯細節
- 內部變量聲明
- 具體實現程式碼

### 示例

原始 TypeScript 程式碼：

```typescript
import { ShoppingItem } from './shopping-item';

/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
  let total = 0;
  for (const item of items) {
    total += item.price * item.quantity;
  }
  return total;
}

// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

壓縮後：

```typescript
import { ShoppingItem } from './shopping-item';
⋮----
/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
⋮----
// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

## 配置

你可以在配置文件中啟用壓縮：

```json
{
  "output": {
    "compress": true
  }
}
```

## 使用場景

程式碼壓縮在以下情況特別有用：
- 分析程式碼結構和架構
- 減少用於 LLM 處理的令牌數量
</file>

<file path="website/client/src/zh-tw/guide/command-line-options.md">
# 命令行選項

## 基本選項
- `-v, --version`: 顯示版本

## 輸出選項
- `-o, --output <file>`: 輸出文件名（預設：`repomix-output.txt`）
- `--stdout`: 輸出到標準輸出而不是寫入文件（不能與`--output`選項一起使用）
- `--style <type>`: 輸出樣式（`plain`、`xml`、`markdown`）（預設：`xml`）
- `--parsable-style`: 啟用基於所選樣式模式的可解析輸出（預設：`false`）
- `--compress`: 執行智慧程式碼提取，專注於函數和類的簽名，同時刪除實現細節。有關詳細資訊和示例，請參閱[程式碼壓縮指南](code-compress)。
- `--output-show-line-numbers`: 添加行號（預設：`false`）
- `--copy`: 複製到剪貼簿（預設：`false`）
- `--no-file-summary`: 禁用文件摘要（預設：`true`）
- `--no-directory-structure`: 禁用目錄結構（預設：`true`）
- `--no-files`: 禁用文件內容輸出（僅元數據模式）（預設：`true`）
- `--remove-comments`: 移除註釋（預設：`false`）
- `--remove-empty-lines`: 移除空行（預設：`false`）
- `--header-text <text>`: 文件頭部包含的自定義文本
- `--instruction-file-path <path>`: 包含詳細自定義指令的文件路徑
- `--include-empty-directories`: 在輸出中包含空目錄（預設：`false`）
- `--include-diffs`: 在輸出中包含 git 差異（包括工作樹和已暫存的變更，它們將分開顯示）（預設：`false`）
- `--no-git-sort-by-changes`: 禁用按 git 變更計數排序文件（預設：`true`）

## 過濾選項
- `--include <patterns>`: 包含模式（逗號分隔）
- `-i, --ignore <patterns>`: 忽略模式（逗號分隔）
- `--stdin`: 從 stdin 讀取文件路徑而不是自動發現文件
- `--no-gitignore`: 禁用 .gitignore 文件
- `--no-default-patterns`: 禁用預設模式

## 遠端倉庫選項
- `--remote <url>`: 處理遠端倉庫
- `--remote-branch <n>`: 指定遠端分支名稱、標籤或提交哈希（預設為倉庫的預設分支）

## 配置選項
- `-c, --config <path>`: 自定義配置文件路徑
- `--init`: 創建配置文件
- `--global`: 使用全局配置

## 安全選項
- `--no-security-check`: 禁用安全檢查（預設：`true`）

## 令牌計數選項
- `--token-count-encoding <encoding>`: 指定令牌計數編碼（如 `o200k_base`、`cl100k_base`）（預設：`o200k_base`）

## 其他選項
- `--top-files-len <number>`: 顯示的頂部文件數量（預設：`5`）
- `--verbose`: 啟用詳細日誌
- `--quiet`: 禁止所有標準輸出

## 示例

```bash
# 基本用法
repomix

# 自定義輸出
repomix -o output.xml --style xml

# 輸出到標準輸出
repomix --stdout > custom-output.txt

# 將輸出發送到標準輸出，然後通過管道傳遞到另一個命令（例如：simonw/llm）
repomix --stdout | llm "請解釋這段程式碼的功能"

# 使用壓縮的自定義輸出
repomix --compress

# 處理特定文件
repomix --include "src/**/*.ts" --ignore "**/*.test.ts"

# 帶分支的遠端倉庫
repomix --remote https://github.com/user/repo/tree/main

# 帶提交的遠端倉庫
repomix --remote https://github.com/user/repo/commit/836abcd7335137228ad77feb28655d85712680f1

# 使用簡寫的遠端倉庫
repomix --remote user/repo

# 使用 stdin 的文件列表
find src -name "*.ts" -type f | repomix --stdin
git ls-files "*.js" | repomix --stdin
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```
</file>

<file path="website/client/src/zh-tw/guide/comment-removal.md">
# 註釋移除

Repomix 可以在生成輸出文件時自動移除程式碼中的註釋。這有助於減少干擾，讓程式碼更加簡潔。

## 使用方法

要啟用註釋移除，在 `repomix.config.json` 中將 `removeComments` 選項設置為 `true`：

```json
{
  "output": {
    "removeComments": true
  }
}
```

## 支援的語言

Repomix 支援移除多種程式設計語言的註釋，包括：

- JavaScript/TypeScript (`//`, `/* */`)
- Python (`#`, `"""`, `'''`)
- Java (`//`, `/* */`)
- C/C++ (`//`, `/* */`)
- HTML (`<!-- -->`)
- CSS (`/* */`)
- 以及更多語言...

## 示例

以下是 JavaScript 程式碼示例：

```javascript
// 這是單行註釋
function test() {
  /* 這是
     多行註釋 */
  return true;
}
```

啟用註釋移除後，輸出將變為：

```javascript
function test() {
  return true;
}
```

## 注意事項

- 註釋移除在其他處理步驟（如行號添加）之前執行
- 某些註釋，例如 JSDoc 註釋，可能會根據語言和上下文保留
- 如果你需要保留某些重要註釋，請考慮使用其他方式記錄這些信息，例如使用自定義指令

## 建議用法

1. **選擇性使用**：
  - 對於需要向 AI 展示實現細節的程式碼，保留註釋
  - 對於主要關注程式碼結構的分析，移除註釋

2. **配合其他功能**：
  - 與 `--remove-empty-lines` 選項組合使用，獲得更簡潔的輸出
  - 使用自定義指令提供額外的上下文信息

3. **效能考慮**：
  - 移除註釋可以減少輸出文件大小
  - 對於大型程式碼庫特別有用
</file>

<file path="website/client/src/zh-tw/guide/configuration.md">
# 設定

Repomix可以透過設定檔（`repomix.config.json`）或命令列選項進行設定。設定檔允許您自訂程式碼庫的處理和輸出方式。

## 快速開始

在專案目錄中建立設定檔：
```bash
repomix --init
```

這將建立一個帶有預設設定的`repomix.config.json`檔案。您還可以建立一個全域設定檔，在找不到本地設定時將使用它作為後備：

```bash
repomix --init --global
```

## 設定選項

| 選項                             | 說明                                                                                                                         | 預設值                 |
|----------------------------------|------------------------------------------------------------------------------------------------------------------------------|------------------------|
| `input.maxFileSize`              | 要處理的最大檔案大小（位元組）。超過此大小的檔案將被跳過。用於排除大型二進位檔案或資料檔案                                | `50000000`            |
| `output.filePath`                | 輸出檔案名。支援XML、Markdown和純文字格式                                                                                   | `"repomix-output.xml"` |
| `output.style`                   | 輸出樣式（`xml`、`markdown`、`plain`）。每種格式對不同的AI工具都有其優勢                                                   | `"xml"`                |
| `output.parsableStyle`           | 是否根據所選樣式模式轉義輸出。可以提供更好的解析，但可能會增加令牌數量                                                    | `false`                |
| `output.compress`                | 是否使用Tree-sitter執行智慧程式碼提取，在保持結構的同時減少令牌數量                                                       | `false`                |
| `output.headerText`              | 要包含在檔案頭部的自訂文字。對於為AI工具提供上下文或指令很有用                                                            | `null`                 |
| `output.instructionFilePath`     | 包含用於AI處理的詳細自訂指令的檔案路徑                                                                                     | `null`                 |
| `output.fileSummary`             | 是否在輸出開頭包含顯示檔案計數、大小和其他指標的摘要部分                                                                   | `true`                 |
| `output.directoryStructure`      | 是否在輸出中包含目錄結構。幫助AI理解專案組織                                                                               | `true`                 |
| `output.files`                   | 是否在輸出中包含檔案內容。設定為false時只包含結構和元資料                                                                  | `true`                 |
| `output.removeComments`          | 是否從支援的檔案類型中刪除註解。可以減少雜訊和令牌數量                                                                    | `false`                |
| `output.removeEmptyLines`        | 是否從輸出中刪除空行以減少令牌數量                                                                                         | `false`                |
| `output.showLineNumbers`         | 是否為每行添加行號。有助於引用程式碼的特定部分                                                                             | `false`                |
| `output.copyToClipboard`         | 是否除了儲存檔案外還將輸出複製到系統剪貼簿                                                                                 | `false`                |
| `output.topFilesLength`          | 在摘要中顯示的頂部檔案數量。如果設定為0，則不顯示摘要                                                                      | `5`                    |
| `output.includeEmptyDirectories` | 是否在儲存庫結構中包含空目錄                                                                                               | `false`                |
| `output.git.sortByChanges`       | 是否按Git更改次數對檔案進行排序。更改較多的檔案顯示在底部                                                                 | `true`                 |
| `output.git.sortByChangesMaxCommits` | 分析Git更改時要分析的最大提交數。限制歷史深度以提高效能                                                               | `100`                  |
| `output.git.includeDiffs`        | 是否在輸出中包含Git差異。分別顯示工作樹和暫存區的更改                                                                     | `false`                |
| `include`                        | 要包含的檔案模式（使用[glob模式](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)）                 | `[]`                   |
| `ignore.useGitignore`            | 是否使用專案的`.gitignore`檔案中的模式                                                                                     | `true`                 |
| `ignore.useDefaultPatterns`      | 是否使用預設忽略模式（node_modules、.git等）                                                                              | `true`                 |
| `ignore.customPatterns`          | 額外的忽略模式（使用[glob模式](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)）                   | `[]`                   |
| `security.enableSecurityCheck`   | 是否使用Secretlint執行安全檢查以檢測敏感資訊                                                                              | `true`                 |
| `tokenCount.encoding`            | OpenAI的[tiktoken](https://github.com/openai/tiktoken)分詞器使用的令牌計數編碼。GPT-4o使用`o200k_base`，GPT-4/3.5使用`cl100k_base`。詳見[tiktoken model.py](https://github.com/openai/tiktoken/blob/main/tiktoken/model.py#L24) | `"o200k_base"`         |

設定檔支援[JSON5](https://json5.org/)語法，允許：
- 註解（單行和多行）
- 物件和陣列中的尾隨逗號
- 無引號屬性名
- 更靈活的字串語法

## 模式验证

您可以透過添加`$schema`屬性為設定檔啟用模式验证：

```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "output": {
    "filePath": "repomix-output.md",
    "style": "markdown"
  }
}
```

這在支援JSON結構描述的編輯器中提供自動完成和驗證功能。

## 設定檔範例

以下是完整設定檔（`repomix.config.json`）的範例：

```json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 50000000
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "compress": false,
    "headerText": "打包檔案的自訂頭部資訊",
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "includeEmptyDirectories": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false
    }
  },
  "include": ["**/*"],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    // 模式也可以在 .repomixignore 中指定
    "customPatterns": [
      "additional-folder",
      "**/*.log"
    ],
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
```

## 設定檔位置

Repomix按以下順序尋找設定檔：
1. 當前目錄中的本地設定檔（`repomix.config.json`）
2. 全域設定檔：
   - Windows：`%LOCALAPPDATA%\Repomix\repomix.config.json`
   - macOS/Linux：`~/.config/repomix/repomix.config.json`

命令列選項優先於設定檔設定。

## 忽略模式

Repomix提供多種方式來指定要忽略的檔案。模式按以下優先順序處理：

1. CLI選項（`--ignore`）
2. 專案目錄中的`.repomixignore`檔案
3. `.gitignore`和`.git/info/exclude`（如果`ignore.useGitignore`為true）
4. 預設模式（如果`ignore.useDefaultPatterns`為true）

`.repomixignore`範例：
```text
# 快取目錄
.cache/
tmp/

# 建置輸出
dist/
build/

# 日誌
*.log
```

## 預設忽略模式

當`ignore.useDefaultPatterns`為true時，Repomix自動忽略以下常見模式：
```text
node_modules/**
.git/**
coverage/**
dist/**
```

完整列表請參見[defaultIgnore.ts](https://github.com/yamadashy/repomix/blob/main/src/config/defaultIgnore.ts)

## 進階功能

### 程式碼壓縮

程式碼壓縮功能（透過`output.compress: true`啟用）使用[Tree-sitter](https://github.com/tree-sitter/tree-sitter)智慧提取基本程式碼結構，同時移除實作細節。這有助於在保持重要的結構資訊的同時減少令牌數量。

主要優點：
- 顯著減少令牌數量
- 保留類別和函式簽名
- 保持匯入和匯出
- 保留型別定義和介面
- 移除函式本體和實作細節

更多詳細資訊和範例，請參閱[程式碼壓縮指南](code-compress)。

### Git整合

`output.git`設定提供強大的Git感知功能：

- `sortByChanges`：當設定為true時，檔案按Git更改次數（修改該檔案的提交數）排序。更改次數較多的檔案出現在輸出的底部。這有助於優先處理更活躍開發的檔案。預設值：`true`
- `sortByChangesMaxCommits`：計算檔案更改次數時要分析的最大提交數。預設值：`100`
- `includeDiffs`：當設定為true時，在輸出中包含Git差異（同時分別包含工作樹和暫存區的更改）。這允許讀者查看儲存庫中的待處理更改。預設值：`false`

設定範例：
```json
{
  "output": {
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": true
    }
  }
}
```

### 安全檢查

當`security.enableSecurityCheck`啟用時，Repomix使用[Secretlint](https://github.com/secretlint/secretlint)在將程式碼庫包含在輸出中之前檢測敏感資訊。這有助於防止意外暴露：

- API金鑰
- 存取令牌
- 私密金鑰
- 密碼
- 其他敏感憑證

### 註解移除

當`output.removeComments`設定為`true`時，將從支援的檔案類型中移除註解，以減少輸出大小並專注於核心程式碼內容。這在以下情況特別有用：

- 處理大量文件化的程式碼
- 嘗試減少令牌數量
- 專注於程式碼結構和邏輯

有關支援的語言和詳細範例，請參閱[註解移除指南](comment-removal)。
</file>

<file path="website/client/src/zh-tw/guide/custom-instructions.md">
# 自定義指令

Repomix 允許你提供自定義指令，這些指令將被包含在輸出文件中。這對於為處理程式碼庫的 AI 系統提供上下文或特定指導非常有用。

## 使用方法

要包含自定義指令，請在倉庫根目錄創建一個 markdown 文件（例如 `repomix-instruction.md`）。然後，在 `repomix.config.json` 中指定該文件的路徑：

```json
{
  "output": {
    "instructionFilePath": "repomix-instruction.md"
  }
}
```

該文件的內容將在輸出中的「Instruction」部分中顯示。

## 示例

```markdown
# 倉庫指令

這個倉庫包含了 Repomix 工具的原始碼。在分析程式碼時請遵循以下指導原則：

1. 重點關注 `src/core` 目錄中的核心功能
2. 特別注意 `src/core/security` 中的安全檢查
3. 忽略 `tests` 目錄中的文件

## 程式碼規範
- 遵循 TypeScript 最佳實踐
- 確保所有公共 API 都有適當的文檔
- 使用依賴注入模式以便於測試

## 安全考慮
- 確保所有用戶輸入都經過適當驗證
- 避免在日誌中記錄敏感信息
- 使用安全的依賴版本
```

這將在輸出中生成以下部分：

```xml
<instruction>
# 倉庫指令

這個倉庫包含了 Repomix 工具的原始碼。在分析程式碼時請遵循以下指導原則：

1. 重點關注 `src/core` 目錄中的核心功能
2. 特別注意 `src/core/security` 中的安全檢查
3. 忽略 `tests` 目錄中的文件

## 程式碼規範
- 遵循 TypeScript 最佳實踐
- 確保所有公共 API 都有適當的文檔
- 使用依賴注入模式以便於測試

## 安全考慮
- 確保所有用戶輸入都經過適當驗證
- 避免在日誌中記錄敏感信息
- 使用安全的依賴版本
</instruction>
```

## 最佳實踐

1. **保持簡潔明確**：指令應該簡短但詳細
2. **提供具體示例**：在適當的情況下添加程式碼示例
3. **設置優先順序**：將最重要的指令放在前面
4. **包含上下文**：提供專案背景和重要考慮因素
5. **結構化內容**：使用標題和列表使指令易於閱讀

## 注意事項

- 避免在指令中包含敏感信息
- 定期更新指令以反映專案的變化
- 確保指令與專案的其他文檔保持一致
- 使用清晰的層次結構組織內容
</file>

<file path="website/client/src/zh-tw/guide/github-actions.md">
# 在 GitHub Actions 中使用 Repomix

通過將 Repomix 集成到 GitHub Actions 工作流中，可以自動打包程式碼庫以供 AI 分析。這對於持續集成（CI）、程式碼審查或為 LLM 工具做準備非常有用。

## 基本用法

在工作流 YAML 文件中添加以下步驟以打包您的倉庫：

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.xml
```

## 使用不同的輸出格式

可以使用 `style` 參數指定不同的輸出格式（默認為 `xml`）：

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.md
    style: markdown
```

## 多目錄與壓縮選項

可以指定多個目錄、包含/排除模式，並啟用智能壓縮：

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src tests
    include: "**/*.ts,**/*.md"
    ignore: "**/*.test.ts"
    output: repomix-output.txt
    compress: true
```

## 上傳輸出文件為 Artifact

將生成的文件作為 artifact 上傳，以便後續步驟或下載：

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src
    output: repomix-output.xml
    compress: true

- name: Upload Repomix output
  uses: actions/upload-artifact@v4
  with:
    name: repomix-output
    path: repomix-output.xml
```

## Action 輸入參數

| 名稱                | 說明                                   | 預設值           |
|---------------------|----------------------------------------|------------------|
| `directories`       | 要打包的目錄（空格分隔）               | `.`              |
| `include`           | 包含的 glob 模式（逗號分隔）           | `""`           |
| `ignore`            | 排除的 glob 模式（逗號分隔）           | `""`           |
| `output`            | 輸出文件路徑                            | `repomix-output.xml`    |
| `style`             | 輸出樣式（xml、markdown、plain）        | `xml`            |
| `compress`          | 啟用智能壓縮                            | `true`           |
| `additional-args`   | 傳遞給 repomix CLI 的額外參數           | `""`           |
| `repomix-version`   | 要安裝的 npm 包版本                     | `latest`         |

## Action 輸出

| 名稱           | 說明                   |
|----------------|------------------------|
| `output_file`  | 生成的輸出文件路徑      |

## 完整工作流示例

以下是使用 Repomix 的 GitHub Actions 工作流完整示例：

```yaml
name: Pack repository with Repomix

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  pack-repo:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Pack repository with Repomix
        uses: yamadashy/repomix/.github/actions/repomix@main
        with:
          output: repomix-output.xml

      - name: Upload Repomix output
        uses: actions/upload-artifact@v4
        with:
          name: repomix-output.xml
          path: repomix-output.xml
          retention-days: 30
```

查看[完整工作流示例](https://github.com/yamadashy/repomix/blob/main/.github/workflows/pack-repository.yml)。
</file>

<file path="website/client/src/zh-tw/guide/index.md">
# Repomix 入門指南

<script setup>
import HomeBadges from '../../../components/HomeBadges.vue'
import YouTubeVideo from '../../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../../utils/videos'
</script>

Repomix 是一個將程式碼庫打包成單個 AI 友好文件的工具。它專為幫助你將程式碼提供給大型語言模型（如 ChatGPT、DeepSeek、Perplexity、Gemini、Gemma、Llama、Grok 等）而設計。

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

<HomeBadges />

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## 快速開始

在你的專案目錄中執行以下命令：

```bash
npx repomix
```

就這麼簡單！你會在當前目錄中找到一個 `repomix-output.xml` 文件，其中包含了以 AI 友好格式整理的整個程式碼庫。

然後，你可以將此文件傳送給 AI 助手，並附上類似這樣的提示：

```
這個文件包含了倉庫中所有文件的合併內容。
我想重構程式碼，請先幫我審查一下。
```

AI 將分析你的整個程式碼庫並提供全面的見解：

![Repomix 使用示例1](/images/docs/repomix-file-usage-1.png)

在討論具體修改時，AI 可以幫助生成程式碼。透過像 Claude 的 Artifacts 這樣的功能，你甚至可以一次性接收多個相互依賴的文件：

![Repomix 使用示例2](/images/docs/repomix-file-usage-2.png)

祝你編碼愉快！🚀

## 核心功能

- **AI 優化**：以 AI 易於理解的格式整理程式碼庫
- **令牌計數**：為 LLM 上下文限制提供令牌使用統計
- **Git 感知**：自動識別並遵循 `.gitignore` 和 `.git/info/exclude` 文件
- **注重安全**：使用 Secretlint 進行敏感資訊偵測
- **多種輸出格式**：可選純文字、XML 或 Markdown 格式

## 下一步

- [安裝指南](installation.md)：了解安裝 Repomix 的不同方式
- [使用指南](usage.md)：學習基本和進階功能
- [配置](configuration.md)：根據需求自定義 Repomix
- [安全功能](security.md)：了解安全檢查詳情

## 社區

加入我們的 [Discord 社區](https://discord.gg/wNYzTwZFku)：
- 獲取 Repomix 使用幫助
- 分享你的使用經驗
- 提出新功能建議
- 與其他用戶交流

## 支援

發現問題或需要幫助？
- [在 GitHub 上提交問題](https://github.com/yamadashy/repomix/issues)
- 加入 Discord 伺服器
- 查看[文檔](https://repomix.com)
</file>

<file path="website/client/src/zh-tw/guide/installation.md">
# 安裝

## 使用 npx（無需安裝）

```bash
npx repomix
```

## 全局安裝

### npm 安裝
```bash
npm install -g repomix
```

### Yarn 安裝
```bash
yarn global add repomix
```

### Bun 安裝
```bash
bun add -g repomix
```

### Homebrew 安裝（macOS/Linux）
```bash
brew install repomix
```

## Docker 安裝

使用 Docker 是最便捷的方式之一，可以避免環境配置問題。以下是具體步驟：

```bash
# 處理當前目錄
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix

# 處理指定目錄
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory

# 處理遠端倉庫
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote yamadashy/repomix
```

## VSCode 擴展

通過社區維護的 [Repomix Runner](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner) 擴展，您可以直接在 VSCode 中執行 Repomix。

功能：
- 只需點擊幾下即可打包任何資料夾
- 可選擇文件或內容模式進行複製
- 自動清理輸出文件
- 支援 repomix.config.json

從 [VSCode 應用商店](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner)安裝。

## 瀏覽器擴充功能

直接從任何 GitHub 倉庫存取 Repomix！我們的 Chrome 擴充功能在 GitHub 倉庫頁面新增了便捷的「Repomix」按鈕。

![Repomix Browser Extension](/images/docs/browser-extension.png)

### 安裝
- Chrome 擴充功能: [Repomix - Chrome Web Store](https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa)
- Firefox 附加元件: [Repomix - Firefox Add-ons](https://addons.mozilla.org/firefox/addon/repomix/)

### 功能
- 一鍵從 GitHub 倉庫存取 Repomix
- 更多精彩功能即將推出！

## 系統要求

- Node.js: ≥ 18.0.0
- Git: 處理遠端倉庫時需要

## 驗證安裝

安裝完成後，可以通過以下命令驗證 Repomix 是否正常工作：

```bash
repomix --version
repomix --help
```
</file>

<file path="website/client/src/zh-tw/guide/mcp-server.md">
# MCP伺服器

Repomix 支援 [Model Context Protocol (MCP)](https://modelcontextprotocol.io)，允許 AI 助手直接與您的程式碼庫交互。當作為 MCP 伺服器運行時，Repomix 提供了工具，使 AI 助手能夠在無需手動準備文件的情況下打包本地或遠端倉庫進行分析。

> [!NOTE]  
> 這是一個實驗性功能，我們將根據用戶反饋和實際使用情況積極改進

## 將 Repomix 作為 MCP 伺服器運行

要將 Repomix 作為 MCP 伺服器運行，請使用 `--mcp` 標誌：

```bash
repomix --mcp
```

這會以 MCP 伺服器模式啟動 Repomix，使其可供支援 Model Context Protocol 的 AI 助手使用。

## 配置 MCP 伺服器

要將 Repomix 作為 MCP 伺服器與 Claude 等 AI 助手一起使用，您需要配置 MCP 設置：

### 對於 VS Code

您可以使用以下方法之一在 VS Code 中安裝 Repomix MCP 伺服器：

1. **使用安裝徽章：**

  [![Install in VS Code](https://img.shields.io/badge/VS_Code-VS_Code?style=flat-square&label=Install%20Server&color=0098FF)](vscode:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)<br>
  [![Install in VS Code Insiders](https://img.shields.io/badge/VS_Code_Insiders-VS_Code_Insiders?style=flat-square&label=Install%20Server&color=24bfa5)](vscode-insiders:mcp/install?%7B%22name%22%3A%22repomix%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)

2. **使用命令行：**

  ```bash
  code --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

  對於 VS Code Insiders：
  ```bash
  code-insiders --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

### 對於 Cline（VS Code 擴展）

編輯 `cline_mcp_settings.json` 文件：

```json
{
  "mcpServers": {
    "repomix": {
      "command": "npx",
      "args": [
        "-y",
        "repomix",
        "--mcp"
      ]
    }
  }
}
```

### 對於 Cursor

在 Cursor 中，從 `Cursor Settings` > `MCP` > `+ Add new global MCP server` 添加一個新的 MCP 伺服器，配置與 Cline 類似。

### 對於 Claude Desktop

使用與 Cline 類似的配置編輯 `claude_desktop_config.json` 文件。

### 對於 Claude Code

要在 [Claude Code](https://docs.anthropic.com/en/docs/claude-code/overview) 中配置 Repomix 作為 MCP 伺服器，請使用以下命令：

```bash
claude mcp add repomix -- npx -y repomix --mcp
```

### 使用 Docker 代替 npx

您可以使用 Docker 代替 npx 來運行 Repomix 作為 MCP 伺服器：

```json
{
  "mcpServers": {
    "repomix-docker": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "ghcr.io/yamadashy/repomix",
        "--mcp"
      ]
    }
  }
}
```

## 可用的 MCP 工具

當作為 MCP 伺服器運行時，Repomix 提供以下工具：

### pack_codebase

此工具將本地程式碼目錄打包成一個用於 AI 分析的 XML 文件。它分析程式碼庫結構，提取相關程式碼內容，並生成包含指標、文件樹和格式化程式碼內容的綜合報告。

**參數：**
- `directory`：（必需）要打包的目錄的絕對路徑
- `compress`：（可選，預設值：false）啟用 Tree-sitter 壓縮以提取基本程式碼簽名和結構，同時刪除實現細節。在保持語義含義的同時減少約 70% 的令牌使用量。由於 grep_repomix_output 允許增量內容檢索，通常不需要。僅在您特別需要大型倉庫的整個程式碼庫內容時使用。
- `includePatterns`：（可選）使用 fast-glob 模式指定要包含的文件。多個模式可以用逗號分隔（例如，"**/*.{js,ts}", "src/**,docs/**"）。只有匹配的文件會被處理。
- `ignorePatterns`：（可選）使用 fast-glob 模式指定要排除的其他文件。多個模式可以用逗號分隔（例如，"test/**,*.spec.js", "node_modules/**,dist/**"）。這些模式補充 .gitignore 和內建排除。
- `topFilesLength`：（可選，預設值：10）在程式碼庫分析的指標摘要中顯示的最大文件數（按大小排序）。

**示例：**
```json
{
  "directory": "/path/to/your/project",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### pack_remote_repository

此工具獲取、克隆並將 GitHub 倉庫打包成一個用於 AI 分析的 XML 文件。它自動克隆遠端倉庫，分析其結構，並生成綜合報告。

**參數：**
- `remote`：（必需）GitHub 倉庫 URL 或用戶/倉庫格式（例如，"yamadashy/repomix", "https://github.com/user/repo", 或 "https://github.com/user/repo/tree/branch"）
- `compress`：（可選，預設值：false）啟用 Tree-sitter 壓縮以提取基本程式碼簽名和結構，同時刪除實現細節。在保持語義含義的同時減少約 70% 的令牌使用量。由於 grep_repomix_output 允許增量內容檢索，通常不需要。僅在您特別需要大型倉庫的整個程式碼庫內容時使用。
- `includePatterns`：（可選）使用 fast-glob 模式指定要包含的文件。多個模式可以用逗號分隔（例如，"**/*.{js,ts}", "src/**,docs/**"）。只有匹配的文件會被處理。
- `ignorePatterns`：（可選）使用 fast-glob 模式指定要排除的其他文件。多個模式可以用逗號分隔（例如，"test/**,*.spec.js", "node_modules/**,dist/**"）。這些模式補充 .gitignore 和內建排除。
- `topFilesLength`：（可選，預設值：10）在程式碼庫分析的指標摘要中顯示的最大文件數（按大小排序）。

**示例：**
```json
{
  "remote": "yamadashy/repomix",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### read_repomix_output

此工具讀取 Repomix 生成的輸出文件的內容。支援對大文件進行行範圍指定的部分讀取。此工具專為直接文件系統存取受限的環境而設計。

**參數：**
- `outputId`：（必需）要讀取的 Repomix 輸出文件的 ID
- `startLine`：（可選）起始行號（從 1 開始，包含）。如果未指定，則從開頭讀取。
- `endLine`：（可選）結束行號（從 1 開始，包含）。如果未指定，則讀取到末尾。

**功能：**
- 專為基於 Web 的環境或沙箱應用程式設計
- 使用其 ID 檢索先前生成的輸出內容
- 無需文件系統存取權限即可安全存取打包的程式碼庫
- 支援大文件的部分讀取

**示例：**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "startLine": 100,
  "endLine": 200
}
```

### grep_repomix_output

此工具使用 JavaScript RegExp 語法的類似 grep 的功能在 Repomix 輸出文件中搜尋模式。返回匹配行及其周圍的可選上下文行。

**參數：**
- `outputId`：（必需）要搜尋的 Repomix 輸出文件的 ID
- `pattern`：（必需）搜尋模式（JavaScript RegExp 正規表達式語法）
- `contextLines`：（可選，預設值：0）在每個匹配項前後顯示的上下文行數。如果指定了 beforeLines/afterLines，則被覆蓋。
- `beforeLines`：（可選）在每個匹配項前顯示的上下文行數（類似 grep -B）。優先於 contextLines。
- `afterLines`：（可選）在每個匹配項後顯示的上下文行數（類似 grep -A）。優先於 contextLines。
- `ignoreCase`：（可選，預設值：false）執行不區分大小寫的匹配

**功能：**
- 使用 JavaScript RegExp 語法進行強大的模式匹配
- 支援上下文行以更好地理解匹配
- 允許單獨控制前/後上下文行
- 區分大小寫和不區分大小寫的搜尋選項

**示例：**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "pattern": "function\\s+\\w+\\(",
  "contextLines": 3,
  "ignoreCase": false
}
```

### file_system_read_file 和 file_system_read_directory

Repomix 的 MCP 伺服器提供了兩個文件系統工具，允許 AI 助手安全地與本地文件系統交互：

1. `file_system_read_file`
  - 使用絕對路徑從本地文件系統讀取文件內容
  - 包含內建安全驗證以檢測和防止存取包含敏感資訊的文件
  - 使用 [Secretlint](https://github.com/secretlint/secretlint) 實現安全驗證
  - 防止存取包含敏感資訊的文件（API 金鑰、密碼、機密）
  - 驗證絕對路徑以防止目錄遍歷攻擊
  - 對無效路徑和安全問題返回清晰的錯誤訊息

2. `file_system_read_directory`
  - 使用絕對路徑列出目錄的內容
  - 返回顯示文件和子目錄的格式化列表，帶有清晰的指示符
  - 使用清晰的指示符（`[FILE]` 或 `[DIR]`）顯示文件和目錄
  - 提供安全的目錄遍歷和適當的錯誤處理
  - 驗證路徑並確保使用絕對路徑
  - 對探索專案結構和理解程式碼庫組織很有用

這兩個工具都包含了強大的安全措施：
- 絕對路徑驗證以防止目錄遍歷攻擊
- 權限檢查以確保適當的存取權限
- 與 Secretlint 整合以檢測敏感資訊
- 清晰的錯誤訊息以便於除錯和安全意識

**示例：**
```typescript
// 讀取文件
const fileContent = await tools.file_system_read_file({
  path: '/absolute/path/to/file.txt'
});

// 列出目錄內容
const dirContent = await tools.file_system_read_directory({
  path: '/absolute/path/to/directory'
});
```

這些工具在 AI 助手需要執行以下操作時特別有用：
- 分析程式碼庫中的特定文件
- 導航目錄結構
- 驗證文件存在性和可存取性
- 確保安全的文件系統操作

## 將 Repomix 作為 MCP 伺服器使用的好處

將 Repomix 作為 MCP 伺服器使用提供了幾個優勢：

1. **直接整合**：AI 助手可以直接分析您的程式碼庫，無需手動文件準備。
2. **高效工作流程**：通過消除手動生成和上傳文件的需求，簡化了程式碼分析過程。
3. **一致輸出**：確保 AI 助手以一致、最佳化的格式接收程式碼庫。
4. **進階功能**：利用 Repomix 的所有功能，如程式碼壓縮、令牌計數和安全檢查。

配置完成後，您的 AI 助手可以直接使用 Repomix 的功能來分析程式碼庫，使程式碼分析工作流程更加高效。
</file>

<file path="website/client/src/zh-tw/guide/output.md">
# 輸出格式

Repomix 支援三種輸出格式：
- XML（預設）
- Markdown
- 純文字

## XML 格式

```bash
repomix --style xml
```

XML 格式針對 AI 處理進行了優化：

```xml
本文件是整個程式碼庫的合併表示形式...

<file_summary>
（元數據和 AI 指令）
</file_summary>

<directory_structure>
src/
  index.ts
  utils/
    helper.ts
</directory_structure>

<files>
<file path="src/index.ts">
// 文件內容
</file>
</files>
```

::: tip 為什麼選擇 XML？
XML 標籤有助於像 Claude 這樣的 AI 模型更準確地解析內容。[Claude 官方文檔](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags)推薦使用 XML 標籤來構建結構化提示。
:::

## Markdown 格式

```bash
repomix --style markdown
```

Markdown 提供了易讀的格式：

```markdown
本文件是整個程式碼庫的合併表示形式...

# 文件概要
（元數據和 AI 指令）

# 目錄結構
```
src/
index.ts
utils/
helper.ts
```

# 文件

## File: src/index.ts
```typescript
// 文件內容
```
```

## 在 AI 模型中的使用

每種格式都能在 AI 模型中正常工作，但需要考慮以下幾點：
- 對 Claude 使用 XML（解析最準確）
- 對一般可讀性使用 Markdown
- 對簡單性和通用兼容性使用純文字

## 自定義設置

在 `repomix.config.json` 中設置預設格式：
```json
{
  "output": {
    "style": "xml",
    "filePath": "output.xml"
  }
}
```

## 純文字格式

```bash
repomix --style plain
```

輸出結構：
```text
本文件是整個程式碼庫的合併表示形式...

================
文件概要
```
</file>

<file path="website/client/src/zh-tw/guide/prompt-examples.md">
# 提示範例

## 程式碼審查

### 架構審查
```
分析此程式碼庫的架構：
1. 評估整體結構和模式
2. 識別潛在的架構問題
3. 提出改進可擴展性的建議
4. 標註遵循最佳實踐的部分

重點關注可維護性和模組化。
```

### 安全性審查
```
對此程式碼庫進行安全性審查：
1. 識別潛在的安全漏洞
2. 檢查常見的安全反模式
3. 審查錯誤處理和輸入驗證
4. 評估依賴項的安全性

請提供具體示例和修復步驟。
```

### 效能審查
```
從效能角度審查程式碼庫：
1. 識別效能瓶頸
2. 檢查資源使用情況
3. 審查算法效率
4. 評估快取策略

包含具體的優化建議。
```

## 文檔生成

### API 文檔
```
生成全面的 API 文檔：
1. 列出並描述所有公共端點
2. 記錄請求/響應格式
3. 包含使用示例
4. 說明限制和約束
```

### 開發者指南
```
創建包含以下內容的開發者指南：
1. 環境搭建說明
2. 專案結構概覽
3. 開發工作流程
4. 測試方法
5. 常見問題排查步驟
```

### 架構文檔
```
記錄系統架構：
1. 高層概述
2. 組件交互
3. 資料流程圖
4. 設計決策及理由
5. 系統限制和約束
```

## 分析與改進

### 依賴項分析
```
分析專案依賴：
1. 識別過時的包
2. 檢查安全漏洞
3. 建議替代包
4. 審查依賴使用模式

包含具體的升級建議。
```

### 測試覆蓋率
```
審查測試覆蓋率：
1. 識別未測試的組件
2. 建議額外的測試用例
3. 審查測試質量
4. 推薦測試策略
```

### 程式碼質量
```
評估程式碼質量並提出改進建議：
1. 審查命名規範
2. 檢查程式碼組織
3. 評估錯誤處理
4. 審查註釋實踐

提供具體的良好和問題模式示例。
```
</file>

<file path="website/client/src/zh-tw/guide/remote-repository-processing.md">
# 遠端倉庫處理

## 基本用法

處理公共倉庫：
```bash
# 使用完整 URL
repomix --remote https://github.com/user/repo

# 使用 GitHub 簡寫
repomix --remote user/repo
```

## 分支和提交選擇

```bash
# 指定分支
repomix --remote user/repo --remote-branch main

# 指定標籤
repomix --remote user/repo --remote-branch v1.0.0

# 指定提交哈希
repomix --remote user/repo --remote-branch 935b695
```

## 系統要求

- 必須安裝 Git
- 需要網絡連接
- 需要倉庫的讀取權限

## 輸出控制

```bash
# 自定義輸出位置
repomix --remote user/repo -o custom-output.xml

# 使用 XML 格式
repomix --remote user/repo --style xml

# 移除註釋
repomix --remote user/repo --remove-comments
```

## Docker 使用方法

```bash
# 在當前目錄處理並輸出
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo

# 輸出到指定目錄
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix \
  --remote user/repo
```

## 常見問題

### 訪問問題
- 確保倉庫是公開的
- 檢查 Git 是否已安裝
- 驗證網絡連接

### 大型倉庫處理
- 使用 `--include` 選擇特定路徑
- 啟用 `--remove-comments`
- 分開處理不同分支
</file>

<file path="website/client/src/zh-tw/guide/security.md">
# 安全性

## 安全檢查功能

Repomix 使用 [Secretlint](https://github.com/secretlint/secretlint) 檢測文件中的敏感信息：
- API 密鑰
- 訪問令牌
- 認證憑證
- 私鑰
- 環境變量

## 配置

安全檢查預設啟用。

通過命令行禁用：
```bash
repomix --no-security-check
```

或在 `repomix.config.json` 中配置：
```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

## 安全措施

1. **二進制文件排除**：輸出中不包含二進制文件
2. **Git 感知**：遵循 `.gitignore` 模式
3. **自動檢測**：掃描常見安全問題：
    - AWS 憑證
    - 數據庫連接字符串
    - 認證令牌
    - 私鑰

## 安全檢查發現問題時

輸出示例：
```bash
🔍 Security Check:
──────────────────
2 suspicious file(s) detected and excluded:
1. config/credentials.json
  - Found AWS access key
2. .env.local
  - Found database password
```

## 最佳實踐

1. 分享前務必檢查輸出內容
2. 使用 `.repomixignore` 排除敏感路徑
3. 保持安全檢查功能啟用
4. 從倉庫中移除敏感文件

## 報告安全問題

如果發現安全漏洞，請：
1. 不要創建公開的 Issue
2. 發送郵件至：koukun0120@gmail.com
3. 或使用 [GitHub 安全公告](https://github.com/yamadashy/repomix/security/advisories/new)
</file>

<file path="website/client/src/zh-tw/guide/usage.md">
# 基本用法

## 快速開始

打包整個倉庫：
```bash
repomix
```

## 常見使用場景

### 打包指定目錄
```bash
repomix path/to/directory
```

### 包含特定文件
使用 [glob 模式](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)：
```bash
repomix --include "src/**/*.ts,**/*.md"
```

### 排除文件
```bash
repomix --ignore "**/*.log,tmp/"
```

### 處理遠端倉庫
```bash
# 使用 GitHub URL
repomix --remote https://github.com/user/repo

# 使用簡寫形式
repomix --remote user/repo

# 指定分支/標籤/提交
repomix --remote user/repo --remote-branch main
repomix --remote user/repo --remote-branch 935b695
```

### 文件列表輸入（stdin）

通過 stdin 傳遞文件路徑以獲得終極靈活性：

```bash
# 使用 find 命令
find src -name "*.ts" -type f | repomix --stdin

# 使用 git 獲取追蹤的文件
git ls-files "*.ts" | repomix --stdin

# 使用 ls 和 glob 模式
ls src/**/*.ts | repomix --stdin

# 從包含文件路徑的文件中讀取
cat file-list.txt | repomix --stdin

# 使用 echo 直接輸入
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```

`--stdin` 選項允許您向 Repomix 傳遞文件路徑列表，在選擇要打包的文件時提供終極靈活性。

> [!NOTE]
> 使用 `--stdin` 時，文件路徑可以是相對路徑或絕對路徑，Repomix 會自動處理路徑解析和去重。

## 輸出格式

### XML（預設）
```bash
repomix --style xml
```

### Markdown
```bash
repomix --style markdown
```

### 純文字
```bash
repomix --style plain
```

## 其他選項

### 移除註釋
```bash
repomix --remove-comments
```

### 顯示行號
```bash
repomix --output-show-line-numbers
```

### 複製到剪貼簿
```bash
repomix --copy
```

### 禁用安全檢查
```bash
repomix --no-security-check
```

## 配置

初始化配置文件：
```bash
repomix --init
```

更多詳細配置選項請參閱[配置指南](/zh-tw/guide/configuration)。
</file>

<file path="website/client/src/zh-tw/index.md">
---
layout: home
title: Repomix
titleTemplate: 將程式碼庫打包成AI友好的格式
aside: false
editLink: false

features:
  - icon: 🤖
    title: AI 優化
    details: 以 AI 易於理解和處理的方式格式化程式碼庫。

  - icon: ⚙️
    title: Git 感知
    details: 自動識別並尊重您的 .gitignore 文件。

  - icon: 🛡️
    title: 注重安全
    details: 集成 Secretlint 進行強大的安全檢查，檢測並防止敏感信息的洩露。

  - icon: 📊
    title: 令牌計數
    details: 提供每個文件和整個程式碼庫的令牌計數，便於控制 LLM 上下文限制。

---

<script setup>
import YouTubeVideo from '../../components/YouTubeVideo.vue'
import { VIDEO_IDS } from '../../utils/videos'
</script>

<div class="cli-section">

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## 🏆 開源獎項提名

我們深感榮幸！Repomix 已被提名為 [JSNation Open Source Awards 2025](https://osawards.com/javascript/) 的 **Powered by AI** 類別獎項。

這一切都離不開所有使用和支持 Repomix 的用戶。謝謝大家！

如果 Repomix 幫助您分析或打包程式碼庫用於 AI 工具，我們將非常感謝您在 **Powered by AI** 類別中為我們投票。

## 什麼是 Repomix？

Repomix 是一個強大的工具，可以將您的整個程式碼庫打包到一個 AI 友好的檔案中。無論您是在進行程式碼審查、重構，還是需要 AI 協助您的專案，Repomix 都可以輕鬆地與 AI 工具共享您的整個儲存庫上下文。

<YouTubeVideo :videoId="VIDEO_IDS.REPOMIX_DEMO" />

## 快速開始

使用 Repomix 生成打包文件（`repomix-output.xml`）後，您可以將其發送給 AI 助手（如 ChatGPT、Claude），並附上這樣的提示：

```
此文件包含了倉庫中所有文件的合併內容。
我想重構程式碼，請先幫我審查一下。
```

AI 將分析您的整個程式碼庫並提供全面的見解：

![Repomix 使用示例1](/images/docs/repomix-file-usage-1.png)

在討論具體修改時，AI 可以幫助生成程式碼。通過像 Claude 的 Artifacts 這樣的功能，您甚至可以一次性接收多個相互依賴的文件：

![Repomix 使用示例2](/images/docs/repomix-file-usage-2.png)

祝您編碼愉快！🚀



## 使用 CLI 工具 {#using-the-cli-tool}

Repomix 可以作為命令行工具使用，提供強大的功能和自定義選項。

**CLI 工具可以訪問私有倉庫**，因為它使用您本地安裝的 Git。

### 快速上手

您可以在專案目錄中無需安裝即可立即嘗試 Repomix：

```bash
npx repomix
```

或者全局安裝以便重複使用：

```bash
# 使用 npm 安裝
npm install -g repomix

# 或使用 yarn 安裝
yarn global add repomix

# 或使用 bun 安裝
bun add -g repomix

# 或使用 Homebrew 安裝（macOS/Linux）
brew install repomix

# 然後在任意專案目錄中運行
repomix
```

就是這麼簡單！Repomix 將在您的當前目錄中生成一個 `repomix-output.xml` 文件，其中包含了以 AI 友好格式整理的整個程式碼庫。



### 基本用法

打包整個程式碼庫：

```bash
repomix
```

打包特定目錄：

```bash
repomix path/to/directory
```

使用 [glob 模式](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)打包特定文件：

```bash
repomix --include "src/**/*.ts,**/*.md"
```

排除特定文件：

```bash
repomix --ignore "**/*.log,tmp/"
```

處理遠端倉庫：
```bash
# 使用簡寫格式
npx repomix --remote yamadashy/repomix

# 使用完整 URL（支援分支和特定路徑）
npx repomix --remote https://github.com/yamadashy/repomix
npx repomix --remote https://github.com/yamadashy/repomix/tree/main

# 使用提交 URL
npx repomix --remote https://github.com/yamadashy/repomix/commit/836abcd7335137228ad77feb28655d85712680f1
```

初始化配置文件（`repomix.config.json`）：

```bash
repomix --init
```

生成打包文件後，您可以將其用於 Claude、ChatGPT、Gemini 等生成式 AI 工具。

#### Docker 使用方法

您也可以使用 Docker 運行 Repomix 🐳  
如果您想在隔離環境中運行 Repomix 或更偏好使用容器，這是一個很好的選擇。

基本用法（當前目錄）：

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

打包特定目錄：
```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

處理遠端倉庫並輸出到 `output` 目錄：

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### 輸出格式

選擇您偏好的輸出格式：

```bash
# XML 格式（預設）
repomix --style xml

# Markdown 格式
repomix --style markdown

# 純文字格式
repomix --style plain
```

### 自定義設置

創建 `repomix.config.json` 進行持久化設置：

```json
{
  "output": {
    "style": "markdown",
    "filePath": "custom-output.md",
    "removeComments": true,
    "showLineNumbers": true,
    "topFilesLength": 10
  },
  "ignore": {
    "customPatterns": ["*.test.ts", "docs/**"]
  }
}
```

## 進階使用者指南

Repomix 為進階使用案例提供強大的功能。以下是進階使用者的一些重要指南：

- **[MCP 伺服器](./guide/mcp-server)** - AI 助理的 Model Context Protocol 整合
- **[GitHub Actions](./guide/github-actions)** - 在 CI/CD 工作流程中自動化程式碼庫封裝
- **[程式碼壓縮](./guide/code-compress)** - 基於 Tree-sitter 的智慧壓縮（約 70% 令牌減少）
- **[作為函式庫使用](./guide/development/using-repomix-as-a-library)** - 將 Repomix 整合到您的 Node.js 應用程式中
- **[自訂指令](./guide/custom-instructions)** - 為輸出新增自訂提示和指令
- **[安全功能](./guide/security)** - 內建 Secretlint 整合和安全檢查
- **[最佳實務](./guide/tips/best-practices)** - 使用經過驗證的策略最佳化您的 AI 工作流程

### 更多示例
::: tip 需要更多幫助？ 💡
查看我們的[使用指南](./guide/)獲取詳細說明，或訪問[GitHub 倉庫](https://github.com/yamadashy/repomix)獲取更多示例和原始碼。
:::

</div>
</file>

<file path="website/client/utils/videos.ts">
import { VIDEO_IDS } from '../constants/videos';

// For use in markdown files via script setup
export { VIDEO_IDS };

// Helper function for easier access
export const getVideoId = (key: keyof typeof VIDEO_IDS): string => {
  return VIDEO_IDS[key];
};
</file>

<file path="website/client/.gitignore">
.vitepress/cache
.vitepress/dist
node_modules
stats.html
</file>

<file path="website/client/.tool-versions">
nodejs 22.16.0
</file>

<file path="website/client/Dockerfile">
# ==============================================================================
# Base stage
# ==============================================================================
FROM node:24-alpine AS base

# Install Git (required for VitePress)
RUN apk add --no-cache git

WORKDIR /app

# ==============================================================================
# Dependencies installation stage
# ==============================================================================
FROM base AS deps

# Copy package.json and package-lock.json
COPY package*.json ./

# Install all dependencies (with npm cache optimization)
RUN npm ci && npm cache clean --force

# ==============================================================================
# Development stage
# ==============================================================================
FROM deps AS development

# Copy source code
COPY . .

EXPOSE 5173

CMD ["npm", "run", "docs:dev"]
</file>

<file path="website/client/package.json">
{
  "name": "repomix-website-client",
  "private": true,
  "type": "module",
  "scripts": {
    "docs:dev": "vitepress dev",
    "docs:build": "vitepress build",
    "docs:preview": "vitepress preview",
    "lint": "npm run lint-tsc",
    "lint-tsc": "tsc --noEmit"
  },
  "dependencies": {
    "fflate": "^0.8.2",
    "lucide-vue-next": "^0.474.0",
    "vue3-ace-editor": "^2.2.4"
  },
  "devDependencies": {
    "@types/gtag.js": "^0.0.20",
    "rollup-plugin-visualizer": "^6.0.1",
    "vite-plugin-pwa": "^1.0.0",
    "vitepress": "^1.6.3"
  }
}
</file>

<file path="website/client/tsconfig.json">
{
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "jsx": "preserve",
    "sourceMap": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "lib": ["ESNext", "DOM"],
    "skipLibCheck": true,
    "noEmit": true,
    "baseUrl": ".",
    "types": ["vite/client", "vitepress/client"]
  },
  "include": [".vitepress/**/*.ts", ".vitepress/**/*.d.ts", ".vitepress/**/*.tsx", ".vitepress/**/*.vue"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="website/client/tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": [".vitepress/config.ts", ".vitepress/config/**/*", ".vitepress/theme/**/*"]
}
</file>

<file path="website/server/src/schemas/request.ts">
import { isValidRemoteValue } from 'repomix';
import { z } from 'zod';

// Regular expression to validate ignore patterns
// Allowed characters: alphanumeric, *, ?, /, -, _, ., !, (, ), space, comma
const ignorePatternRegex = /^[a-zA-Z0-9*?\/\-_.,!()\s]*$/;

export const packOptionsSchema = z
  .object({
    removeComments: z.boolean().optional(),
    removeEmptyLines: z.boolean().optional(),
    showLineNumbers: z.boolean().optional(),
    fileSummary: z.boolean().optional(),
    directoryStructure: z.boolean().optional(),
    includePatterns: z
      .string()
      .max(1000, 'Include patterns too long')
      .optional()
      .transform((val) => val?.trim()),
    ignorePatterns: z
      .string()
      .regex(ignorePatternRegex, 'Invalid characters in ignore patterns')
      .max(1000, 'Ignore patterns too long')
      .optional()
      .transform((val) => val?.trim()),
    outputParsable: z.boolean().optional(),
    compress: z.boolean().optional(),
  })
  .strict();

const isValidZipFile = (file: File) => {
  return file.type === 'application/zip' || file.name.endsWith('.zip');
};

const fileSchema = z
  .custom<File>()
  .refine((file) => file instanceof File, {
    message: 'Invalid file format',
  })
  .refine((file) => isValidZipFile(file), {
    message: 'Only ZIP files are allowed',
  })
  .refine((file) => file.size <= 10 * 1024 * 1024, {
    // 10MB limit
    message: 'File size must be less than 10MB',
  });

export const packRequestSchema = z
  .object({
    url: z
      .string()
      .min(1, 'Repository URL is required')
      .max(200, 'Repository URL is too long')
      .transform((val) => val.trim())
      .refine((val) => isValidRemoteValue(val), { message: 'Invalid repository URL' })
      .optional(),
    file: fileSchema.optional(),
    format: z.enum(['xml', 'markdown', 'plain']),
    options: packOptionsSchema,
  })
  .strict()
  .refine((data) => data.url || data.file, {
    message: 'Either URL or file must be provided',
  })
  .refine((data) => !(data.url && data.file), {
    message: 'Cannot provide both URL and file',
  });

export type PackRequest = z.infer<typeof packRequestSchema>;
</file>

<file path="website/server/src/utils/cache.ts">
import { promisify } from 'node:util';
import * as zlib from 'node:zlib';
import type { PackOptions } from '../types.js';

const inflateAsync = promisify(zlib.inflate);
const deflateAsync = promisify(zlib.deflate);

interface CacheEntry {
  value: Uint8Array; // Compressed data
  timestamp: number;
}

export class RequestCache<T> {
  private cache: Map<string, CacheEntry> = new Map();
  private readonly ttl: number;

  constructor(ttlInSeconds = 60) {
    this.ttl = ttlInSeconds * 1000;

    // Set up periodic cache cleanup
    setInterval(() => this.cleanup(), ttlInSeconds * 1000);
  }

  async get(key: string): Promise<T | undefined> {
    const entry = this.cache.get(key);
    if (!entry) {
      return undefined;
    }

    const now = Date.now();
    if (now - entry.timestamp > this.ttl) {
      this.cache.delete(key);
      return undefined;
    }

    try {
      // Decompress and return the data
      const decompressedData = await inflateAsync(entry.value);
      return JSON.parse(decompressedData.toString('utf8'));
    } catch (error) {
      console.error('Error decompressing cache entry:', error);
      this.cache.delete(key);
      return undefined;
    }
  }

  async set(key: string, value: T): Promise<void> {
    try {
      // Convert data to JSON string and compress
      const jsonString = JSON.stringify(value);
      const compressedData = await deflateAsync(Buffer.from(jsonString, 'utf8'));

      this.cache.set(key, {
        value: compressedData,
        timestamp: Date.now(),
      });
    } catch (error) {
      console.error('Error compressing cache entry:', error);
    }
  }

  // Remove expired entries from cache
  cleanup(): void {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > this.ttl) {
        this.cache.delete(key);
      }
    }
  }
}

// Cache key generation utility
export function generateCacheKey(
  identifier: string,
  format: string,
  options: PackOptions,
  type: 'url' | 'file',
): string {
  return JSON.stringify({
    identifier,
    format,
    options,
    type,
  });
}
</file>

<file path="website/server/src/utils/errorHandler.ts">
import type { ContentfulStatusCode } from 'hono/utils/http-status';

export class AppError extends Error {
  constructor(
    message: string,
    public readonly statusCode: ContentfulStatusCode = 500,
  ) {
    super(message);
    this.name = 'AppError';
  }
}

export function handlePackError(error: unknown): AppError {
  if (error instanceof AppError) {
    return error;
  }

  if (error instanceof Error) {
    const errorMessage = error.message || '';

    if (errorMessage.includes('Repository not found')) {
      return new AppError('Repository not found', 404);
    }

    if (errorMessage.includes('Failed to clone repository')) {
      return new AppError('Failed to clone repository', 422);
    }

    if (errorMessage.includes('circular') || errorMessage.includes('Converting circular structure to JSON')) {
      return new AppError(
        'Failed to process repository: circular dependency detected in the repository structure',
        422,
      );
    }

    return new AppError(process.env.NODE_ENV === 'production' ? 'An unexpected error occurred' : error.message);
  }

  return new AppError('An unexpected error occurred');
}

export function safeJSONStringify(obj: unknown): string {
  const cache = new Set();
  return JSON.stringify(obj, (key, value) => {
    if (typeof value === 'object' && value !== null) {
      if (cache.has(value)) {
        return '[Circular Reference]';
      }
      cache.add(value);
    }
    return value;
  });
}
</file>

<file path="website/server/src/utils/fileUtils.ts">
import fs from 'node:fs/promises';
import os from 'node:os';
import path from 'node:path';
import { unzip } from 'fflate';
import { FILE_SIZE_LIMITS, formatFileSize } from '../constants.js';
import { AppError } from './errorHandler.js';

// Enhanced ZIP extraction limits (aligned with processZipFile.ts)
const ZIP_SECURITY_LIMITS = {
  MAX_FILES: 10000, // Maximum number of files in the archive
  MAX_UNCOMPRESSED_SIZE: 100_000_000, // Maximum total uncompressed size (100MB)
  MAX_COMPRESSION_RATIO: 100, // Maximum compression ratio to prevent ZIP bombs
  MAX_PATH_LENGTH: 200, // Maximum file path length
  MAX_NESTING_LEVEL: 50, // Maximum directory nesting level
};

export async function extractZip(file: File, destPath: string): Promise<void> {
  try {
    // Validate file size before processing
    if (file.size > FILE_SIZE_LIMITS.MAX_ZIP_SIZE) {
      throw new AppError(`File size exceeds maximum limit of ${formatFileSize(FILE_SIZE_LIMITS.MAX_ZIP_SIZE)}`);
    }

    const arrayBuffer = await file.arrayBuffer();
    const buffer = new Uint8Array(arrayBuffer);

    // Unzip using fflate with promise wrapper
    const files = await new Promise<Record<string, Uint8Array>>((resolve, reject) => {
      unzip(buffer, (err, data) => {
        if (err) reject(err);
        else resolve(data);
      });
    });

    const filePaths = Object.keys(files);

    // 1. Check number of files
    if (filePaths.length > ZIP_SECURITY_LIMITS.MAX_FILES) {
      throw new AppError(
        `ZIP contains too many files (${filePaths.length}). Maximum allowed: ${ZIP_SECURITY_LIMITS.MAX_FILES}`,
      );
    }

    // 2. Calculate total uncompressed size
    const totalUncompressedSize = Object.values(files).reduce((sum, data) => sum + data.length, 0);
    if (totalUncompressedSize > ZIP_SECURITY_LIMITS.MAX_UNCOMPRESSED_SIZE) {
      throw new AppError(
        `Uncompressed size (${(totalUncompressedSize / 1_000_000).toFixed(2)}MB) exceeds maximum limit of ${
          ZIP_SECURITY_LIMITS.MAX_UNCOMPRESSED_SIZE / 1_000_000
        }MB`,
      );
    }

    // 3. Check compression ratio (ZIP bomb detection)
    if (file.size > 0) {
      const compressionRatio = totalUncompressedSize / file.size;
      if (compressionRatio > ZIP_SECURITY_LIMITS.MAX_COMPRESSION_RATIO) {
        throw new AppError(
          `Suspicious compression ratio (${compressionRatio.toFixed(2)}:1). Maximum allowed: ${ZIP_SECURITY_LIMITS.MAX_COMPRESSION_RATIO}:1`,
        );
      }
    }

    // 4. Validate all entries for path traversal, file extensions, and nesting level
    const processedPaths = new Set<string>();

    for (const entryPath of filePaths) {
      // Skip directories (fflate doesn't include directory entries, only files)
      if (entryPath.endsWith('/')) continue;

      // 4.1 Check for unsafe paths (directory traversal prevention)
      const fullPath = path.resolve(destPath, entryPath);
      const relativePath = path.relative(destPath, fullPath);
      if (relativePath.startsWith('..') || path.isAbsolute(relativePath)) {
        throw new AppError(`Security violation: Potential directory traversal attack detected in path: ${entryPath}`);
      }

      // 4.2 Check path length
      if (entryPath.length > ZIP_SECURITY_LIMITS.MAX_PATH_LENGTH) {
        throw new AppError(
          `File path exceeds maximum length: ${entryPath.length} > ${ZIP_SECURITY_LIMITS.MAX_PATH_LENGTH}`,
        );
      }

      // 4.3 Check nesting level
      const nestingLevel = entryPath.split('/').length - 1;
      if (nestingLevel > ZIP_SECURITY_LIMITS.MAX_NESTING_LEVEL) {
        throw new AppError(
          `Directory nesting level exceeds maximum: ${nestingLevel} > ${ZIP_SECURITY_LIMITS.MAX_NESTING_LEVEL}`,
        );
      }

      // 4.4 Check for duplicate paths (could indicate ZipSlip vulnerability attempts)
      const normalizedPath = path.normalize(fullPath);
      if (processedPaths.has(normalizedPath)) {
        throw new AppError(`Duplicate file path detected: ${entryPath}. This could indicate a malicious archive.`);
      }
      processedPaths.add(normalizedPath);
    }

    await fs.mkdir(destPath, { recursive: true });

    // Extract files using fflate with parallel writes
    const writePromises = Object.entries(files)
      .filter(([filePath]) => !filePath.endsWith('/')) // Skip directories
      .map(async ([filePath, data]) => {
        const fullPath = path.join(destPath, filePath);
        const dirPath = path.dirname(fullPath);

        // Create directory if it doesn't exist
        await fs.mkdir(dirPath, { recursive: true });

        // Write the file
        await fs.writeFile(fullPath, data);
      });

    await Promise.all(writePromises);
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    throw new AppError(`Failed to extract ZIP file: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export const createTempDirectory = async (): Promise<string> => {
  try {
    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'repomix-'));
    return tempDir;
  } catch (error) {
    throw new AppError(`Failed to create temporary directory: ${(error as Error).message}`);
  }
};

export const cleanupTempDirectory = async (directory: string): Promise<void> => {
  try {
    if (!directory.includes('repomix-')) {
      throw new AppError('Invalid temporary directory path');
    }
    await fs.rm(directory, { recursive: true, force: true });
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    console.error(`Failed to cleanup temporary directory: ${directory}`, error);
  }
};

export const copyOutputToCurrentDirectory = async (
  sourceDir: string,
  targetDir: string,
  outputFileName: string,
): Promise<void> => {
  // Sanitize file paths
  const sanitizedFileName = path.basename(outputFileName);
  const sourcePath = path.join(sourceDir, sanitizedFileName);
  const targetPath = path.join(targetDir, sanitizedFileName);

  try {
    // Verify source exists
    await fs.access(sourcePath);

    // Ensure target directory exists
    await fs.mkdir(targetDir, { recursive: true });

    await fs.copyFile(sourcePath, targetPath);
  } catch (error) {
    throw new AppError(
      `Failed to copy output file: ${(error as Error).message}. Source: ${sourcePath}, Target: ${targetPath}`,
    );
  }
};
</file>

<file path="website/server/src/utils/logger.ts">
import { LoggingWinston } from '@google-cloud/logging-winston';
import type { Context, Next } from 'hono';
import winston from 'winston';
import { getClientIP } from './network.js';
import { calculateLatency, formatLatencyForDisplay } from './time.js';

// Augment Hono's context type
declare module 'hono' {
  interface ContextVariableMap {
    requestId: string;
  }
}

// Configure transports based on environment
function createLogger() {
  const transports: winston.transport[] = [
    new winston.transports.Console({
      format: winston.format.combine(winston.format.timestamp(), winston.format.json()),
    }),
  ];

  // Add Cloud Logging transport only in production
  if (process.env.NODE_ENV === 'production') {
    const loggingWinston = new LoggingWinston();
    transports.push(loggingWinston);
  }

  return winston.createLogger({
    level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
    transports,
  });
}

// Create the logger instance
const logger = createLogger();

// Generate unique request identifier
function generateRequestId(): string {
  return `req-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

// Error response interface with request tracking
interface ErrorResponse {
  error: string;
  requestId: string;
  timestamp: string;
}

// Generate standardized error response
export function createErrorResponse(message: string, requestId: string): ErrorResponse {
  return {
    error: message,
    requestId,
    timestamp: new Date().toISOString(),
  };
}

// Main logging middleware for Hono
export function cloudLogger() {
  return async function loggerMiddleware(c: Context, next: Next) {
    const requestId = generateRequestId();
    const startTime = Date.now();

    // Add request ID to context for tracking
    c.set('requestId', requestId);

    // Collect basic request information
    const method = c.req.method;
    const url = new URL(c.req.url);
    const userAgent = c.req.header('user-agent');
    const referer = c.req.header('referer');
    const remoteIp = getClientIP(c);

    // Log request start
    logger.info({
      message: `${method} ${url.pathname} started`,
      requestId,
      httpRequest: {
        requestMethod: method,
        requestUrl: url.toString(),
        userAgent,
        referer,
        remoteIp,
      },
    });

    try {
      // Process the request
      await next();

      // Collect response information
      const status = c.res.status;
      const latency = calculateLatency(startTime);
      const contentLength = Number.parseInt(c.res.headers.get('content-length') || '0', 10);

      // Log successful response
      logger.info({
        message: `${method} ${url.pathname} completed in ${formatLatencyForDisplay(startTime)}`,
        requestId,
        httpRequest: {
          requestMethod: method,
          requestUrl: url.toString(),
          status,
          latency, // Now uses the correct format { seconds: number, nanos: number }
          responseSize: contentLength,
          userAgent,
          referer,
          remoteIp,
        },
      });
    } catch (error) {
      // Log error information
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      logger.error({
        message: `${method} ${url.pathname} failed: ${errorMessage} (${formatLatencyForDisplay(startTime)})`,
        requestId,
        error: {
          message: errorMessage,
          stack: error instanceof Error ? error.stack : undefined,
        },
        httpRequest: {
          requestMethod: method,
          requestUrl: url.toString(),
          status: 500,
          latency: calculateLatency(startTime), // Now uses the correct format
          userAgent,
          referer,
          remoteIp,
        },
      });
      throw error;
    }
  };
}

// Utility logging functions
export function logDebug(message: string, context?: Record<string, unknown>): void {
  logger.debug({
    message,
    ...context,
  });
}

export function logInfo(message: string, context?: Record<string, unknown>): void {
  logger.info({
    message,
    ...context,
  });
}

export function logWarning(message: string, context?: Record<string, unknown>): void {
  logger.warn({
    message,
    ...context,
  });
}

export function logError(message: string, error?: Error, context?: Record<string, unknown>): void {
  logger.error({
    message,
    error: error
      ? {
          message: error.message,
          stack: error.stack,
        }
      : undefined,
    ...context,
  });
}
</file>

<file path="website/server/src/utils/network.ts">
import type { Context } from 'hono';

/**
 * Get client IP address
 * Handles various headers in Cloud Run environment
 */
export function getClientIP(c: Context): string {
  return (
    c.req.header('x-forwarded-for')?.split(',')[0] ||
    c.req.header('x-real-ip') ||
    c.req.header('cf-connecting-ip') ||
    '0.0.0.0'
  );
}
</file>

<file path="website/server/src/utils/processConcurrency.ts">
import os from 'node:os';

export const getProcessConcurrency = () => {
  const cpuCount = typeof os.availableParallelism === 'function' ? os.availableParallelism() : os.cpus().length;

  // Use all available CPUs except one
  return Math.max(1, cpuCount - 1);
};
</file>

<file path="website/server/src/utils/rateLimit.ts">
interface RateLimitEntry {
  count: number;
  resetTime: number;
}

export class RateLimiter {
  private limits: Map<string, RateLimitEntry> = new Map();
  private readonly windowMs: number;
  private readonly maxRequests: number;

  constructor(windowMs = 60000, maxRequests = 10) {
    this.windowMs = windowMs;
    this.maxRequests = maxRequests;
  }

  isAllowed(identifier: string): boolean {
    const now = Date.now();
    const entry = this.limits.get(identifier);

    if (!entry || now > entry.resetTime) {
      this.limits.set(identifier, {
        count: 1,
        resetTime: now + this.windowMs,
      });
      return true;
    }

    if (entry.count >= this.maxRequests) {
      return false;
    }

    entry.count += 1;
    return true;
  }

  getRemainingTime(identifier: string): number {
    const entry = this.limits.get(identifier);
    if (!entry) return 0;
    return Math.max(0, entry.resetTime - Date.now());
  }
}
</file>

<file path="website/server/src/utils/sharedInstance.ts">
import type { PackResult } from '../types.js';
import { RequestCache } from './cache.js';
import { RateLimiter } from './rateLimit.js';

// Create shared instances
export const cache = new RequestCache<PackResult>(180); // 3 minutes cache
export const rateLimiter = new RateLimiter(60_000, 3); // 3 requests per minute
</file>

<file path="website/server/src/utils/time.ts">
/**
 * Convert milliseconds to a Duration string that Cloud Logging expects
 * Format: "1.500s" -> { seconds: 1, nanos: 500000000 }
 */
export function formatDuration(durationMs: number): {
  seconds: number;
  nanos: number;
} {
  const seconds = Math.floor(durationMs / 1000);
  const nanos = (durationMs % 1000) * 1_000_000; // Convert remaining ms to nanoseconds
  return { seconds, nanos };
}

/**
 * Calculate latency between start time and now
 */
export function calculateLatency(startTime: number): {
  seconds: number;
  nanos: number;
} {
  const latencyMs = Date.now() - startTime;
  return formatDuration(latencyMs);
}

/**
 * Format latency for display purposes (not for Cloud Logging)
 */
export function formatLatencyForDisplay(startTime: number): string {
  const latencyMs = Date.now() - startTime;
  return `${(latencyMs / 1000).toFixed(3)}s`;
}
</file>

<file path="website/server/src/utils/validation.ts">
import { z } from 'zod';
import { AppError } from './errorHandler.js';

export function validateRequest<T>(schema: z.ZodSchema<T>, data: unknown): T {
  try {
    return schema.parse(data);
  } catch (error) {
    if (error instanceof z.ZodError) {
      const messages = error.errors.map((err) => `${err.path.join('.')}: ${err.message}`).join(', ');
      throw new AppError(`Invalid request: ${messages}`, 400);
    }
    throw error;
  }
}

export function sanitizePattern(patterns: string | undefined): string {
  if (!patterns) return '';

  return (
    patterns
      .split(',')
      .map((p) => p.trim())
      .filter(Boolean)
      // Additional security checks
      .filter((p) => {
        // Prevent absolute paths
        if (p.startsWith('/')) return false;
        // Prevent directory traversal
        if (p.includes('../') || p.includes('..\\')) return false;
        // Prevent environment variable expansion
        if (p.includes('$')) return false;
        // Prevent command execution
        if (p.includes('`') || p.includes('$(')) return false;
        return true;
      })
      .join(',')
  );
}
</file>

<file path="website/server/src/constants.ts">
export const FILE_SIZE_LIMITS = {
  MAX_REQUEST_SIZE: 10 * 1024 * 1024, // 10MB
  MAX_ZIP_SIZE: 10 * 1024 * 1024, // 10MB
  MAX_UNCOMPRESSED_SIZE: 50 * 1024 * 1024, // 50MB
  MAX_FILES: 1000, // Maximum number of files in zip
} as const;

// Helper function to format size for error messages
export const formatFileSize = (bytes: number): string => {
  return `${bytes / 1024 / 1024}MB`;
};
</file>

<file path="website/server/src/index.ts">
import { serve } from '@hono/node-server';
import { Hono } from 'hono';
import { bodyLimit } from 'hono/body-limit';
import { compress } from 'hono/compress';
import { cors } from 'hono/cors';
import { timeout } from 'hono/timeout';
import { FILE_SIZE_LIMITS } from './constants.js';
import { processZipFile } from './processZipFile.js';
import { processRemoteRepo } from './remoteRepo.js';
import type { PackResult } from './types.js';
import { handlePackError } from './utils/errorHandler.js';
import { cloudLogger, createErrorResponse, logError, logInfo } from './utils/logger.js';
import { getProcessConcurrency } from './utils/processConcurrency.js';
import { calculateLatency, formatLatencyForDisplay } from './utils/time.js';

// Log server metrics on startup
logInfo('Server starting', {
  metrics: {
    processConcurrency: getProcessConcurrency(),
  },
});

const app = new Hono();

// Setup custom logger
app.use('*', cloudLogger());

// Configure CORS
app.use(
  '/*',
  cors({
    origin: (origin) => {
      const allowedOrigins = ['http://localhost:5173', 'https://repomix.com', 'https://api.repomix.com'];

      if (!origin || allowedOrigins.includes(origin)) {
        return origin;
      }

      if (origin.endsWith('.repomix.pages.dev')) {
        return origin;
      }

      return null;
    },
    allowMethods: ['GET', 'POST', 'OPTIONS'],
    allowHeaders: ['Content-Type'],
    maxAge: 86400,
    credentials: true,
  }),
);

// Enable compression
app.use(compress());

// Set timeout for API routes
app.use('/api', timeout(30000));

// Health check endpoint
app.get('/health', (c) => c.text('OK'));

// Main packing endpoint
app.post(
  '/api/pack',
  bodyLimit({
    maxSize: FILE_SIZE_LIMITS.MAX_REQUEST_SIZE,
    onError: (c) => {
      const requestId = c.get('requestId');
      const response = createErrorResponse('File size too large', requestId);
      return c.json(response, 413);
    },
  }),
  async (c) => {
    try {
      const formData = await c.req.formData();
      const requestId = c.get('requestId');

      // Get form data
      const format = formData.get('format') as 'xml' | 'markdown' | 'plain';
      const options = JSON.parse(formData.get('options') as string);
      const file = formData.get('file') as File | null;
      const url = formData.get('url') as string | null;

      // Validate input
      if (!file && !url) {
        return c.json(createErrorResponse('Either repository URL or file is required', requestId), 400);
      }

      if (!['xml', 'markdown', 'plain'].includes(format)) {
        return c.json(createErrorResponse('Invalid format specified', requestId), 400);
      }

      // Get client IP
      const clientIp =
        c.req.header('x-forwarded-for')?.split(',')[0] ||
        c.req.header('x-real-ip') ||
        c.req.header('cf-connecting-ip') ||
        '0.0.0.0';

      const startTime = Date.now();

      // Process file or repository
      let result: PackResult;
      if (file) {
        result = await processZipFile(file, format, options, clientIp);
      } else {
        if (!url) {
          return c.json(createErrorResponse('Repository URL is required', requestId), 400);
        }
        result = await processRemoteRepo(url, format, options, clientIp);
      }

      // Log operation result
      logInfo('Pack operation completed', {
        requestId,
        format,
        repository: result.metadata.repository,
        duration: formatLatencyForDisplay(startTime),
        inputType: file ? 'file' : url ? 'url' : 'unknown',
        metrics: {
          totalFiles: result.metadata.summary?.totalFiles,
          totalCharacters: result.metadata.summary?.totalCharacters,
          totalTokens: result.metadata.summary?.totalTokens,
        },
      });

      return c.json(result);
    } catch (error) {
      // Handle errors
      logError('Pack operation failed', error instanceof Error ? error : new Error('Unknown error'), {
        requestId: c.get('requestId'),
      });

      const appError = handlePackError(error);
      return c.json(createErrorResponse(appError.message, c.get('requestId')), appError.statusCode);
    }
  },
);

// Start server
const port = process.env.PORT ? Number.parseInt(process.env.PORT, 10) : 3000;
logInfo(`Server starting on port ${port}`);

serve({
  fetch: app.fetch,
  port,
});

// Export app for testing
export default app;
</file>

<file path="website/server/src/processZipFile.ts">
import { randomUUID } from 'node:crypto';
import fs from 'node:fs/promises';
import path from 'node:path';
import { unzip } from 'fflate';
import { type CliOptions, runDefaultAction, setLogLevel } from 'repomix';
import { packRequestSchema } from './schemas/request.js';
import type { PackOptions, PackResult } from './types.js';
import { generateCacheKey } from './utils/cache.js';
import { AppError } from './utils/errorHandler.js';
import { cleanupTempDirectory, copyOutputToCurrentDirectory, createTempDirectory } from './utils/fileUtils.js';
import { cache, rateLimiter } from './utils/sharedInstance.js';
import { sanitizePattern, validateRequest } from './utils/validation.js';

// Enhanced ZIP extraction limits
const ZIP_SECURITY_LIMITS = {
  MAX_FILES: 10000, // Maximum number of files in the archive
  MAX_UNCOMPRESSED_SIZE: 100_000_000, // Maximum total uncompressed size (100MB)
  MAX_COMPRESSION_RATIO: 100, // Maximum compression ratio to prevent ZIP bombs
  MAX_PATH_LENGTH: 200, // Maximum file path length
  MAX_NESTING_LEVEL: 50, // Maximum directory nesting level
};

/**
 * Process an uploaded ZIP file
 */
export async function processZipFile(
  file: File,
  format: string,
  options: PackOptions,
  clientIp: string,
): Promise<PackResult> {
  // Validate the request (excluding URL validation)
  const validatedData = validateRequest(packRequestSchema, {
    file,
    format,
    options,
  });

  // Rate limit check
  if (!rateLimiter.isAllowed(clientIp)) {
    const remainingTime = Math.ceil(rateLimiter.getRemainingTime(clientIp) / 1000);
    throw new AppError(`Rate limit exceeded. Please try again in ${remainingTime} seconds.`, 429);
  }

  if (!file) {
    throw new AppError('File is required for file processing', 400);
  }

  const cacheKey = generateCacheKey(
    `${file.name}-${file.size}-${file.lastModified}`,
    validatedData.format,
    validatedData.options,
    'file',
  );

  // Check if the result is already cached
  const cachedResult = await cache.get(cacheKey);
  if (cachedResult) {
    return cachedResult;
  }

  // Sanitize patterns
  const sanitizedIncludePatterns = sanitizePattern(validatedData.options.includePatterns);
  const sanitizedIgnorePatterns = sanitizePattern(validatedData.options.ignorePatterns);

  const outputFilePath = `repomix-output-${randomUUID()}.txt`;

  // Create CLI options
  const cliOptions = {
    output: outputFilePath,
    style: validatedData.format,
    parsableStyle: validatedData.options.outputParsable,
    removeComments: validatedData.options.removeComments,
    removeEmptyLines: validatedData.options.removeEmptyLines,
    outputShowLineNumbers: validatedData.options.showLineNumbers,
    fileSummary: validatedData.options.fileSummary,
    directoryStructure: validatedData.options.directoryStructure,
    compress: validatedData.options.compress,
    securityCheck: false,
    topFilesLen: 10,
    include: sanitizedIncludePatterns,
    ignore: sanitizedIgnorePatterns,
    quiet: true, // Enable quiet mode to suppress output
  } as CliOptions;

  setLogLevel(-1);

  const tempDirPath = await createTempDirectory();

  try {
    // Extract the ZIP file to the temporary directory with enhanced security checks
    await extractZipWithSecurity(file, tempDirPath);

    // Execute default action on the extracted directory
    const result = await runDefaultAction([tempDirPath], tempDirPath, cliOptions);
    await copyOutputToCurrentDirectory(tempDirPath, process.cwd(), result.config.output.filePath);
    const { packResult } = result;

    // Read the generated file
    const content = await fs.readFile(outputFilePath, 'utf-8');

    // Create pack result
    const packResultData: PackResult = {
      content,
      format,
      metadata: {
        repository: file.name,
        timestamp: new Date().toISOString(),
        summary: {
          totalFiles: packResult.totalFiles,
          totalCharacters: packResult.totalCharacters,
          totalTokens: packResult.totalTokens,
        },
        topFiles: Object.entries(packResult.fileCharCounts)
          .map(([path, charCount]) => ({
            path,
            charCount,
            tokenCount: packResult.fileTokenCounts[path] || 0,
          }))
          .sort((a, b) => b.charCount - a.charCount)
          .slice(0, cliOptions.topFilesLen),
      },
    };

    // Save the result to cache
    await cache.set(cacheKey, packResultData);

    return packResultData;
  } catch (error) {
    console.error('Error processing uploaded file:', error);
    if (error instanceof AppError) {
      throw error;
    }
    throw new AppError(`File processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`, 500);
  } finally {
    cleanupTempDirectory(tempDirPath);
    // Clean up the output file
    try {
      await fs.unlink(outputFilePath);
    } catch (err) {
      // Ignore file deletion errors
      console.warn('Failed to cleanup output file:', err);
    }
  }
}

/**
 * Enhanced ZIP extraction with security checks using fflate
 */
async function extractZipWithSecurity(file: File, destPath: string): Promise<void> {
  try {
    const arrayBuffer = await file.arrayBuffer();
    const buffer = new Uint8Array(arrayBuffer);

    // Unzip using fflate with promise wrapper
    const files = await new Promise<Record<string, Uint8Array>>((resolve, reject) => {
      unzip(buffer, (err, data) => {
        if (err) reject(err);
        else resolve(data);
      });
    });

    const filePaths = Object.keys(files);

    // 1. Check number of files
    if (filePaths.length > ZIP_SECURITY_LIMITS.MAX_FILES) {
      throw new AppError(
        `ZIP contains too many files (${filePaths.length}). Maximum allowed: ${ZIP_SECURITY_LIMITS.MAX_FILES}`,
        413,
      );
    }

    // 2. Calculate total uncompressed size
    const totalUncompressedSize = Object.values(files).reduce((sum, data) => sum + data.length, 0);

    if (totalUncompressedSize > ZIP_SECURITY_LIMITS.MAX_UNCOMPRESSED_SIZE) {
      throw new AppError(
        `Uncompressed size (${(totalUncompressedSize / 1_000_000).toFixed(2)}MB) exceeds maximum limit of ${
          ZIP_SECURITY_LIMITS.MAX_UNCOMPRESSED_SIZE / 1_000_000
        }MB`,
        413,
      );
    }

    // 3. Check compression ratio (ZIP bomb detection)
    if (file.size > 0) {
      const compressionRatio = totalUncompressedSize / file.size;
      if (compressionRatio > ZIP_SECURITY_LIMITS.MAX_COMPRESSION_RATIO) {
        throw new AppError(
          `Suspicious compression ratio (${compressionRatio.toFixed(2)}:1). Maximum allowed: ${ZIP_SECURITY_LIMITS.MAX_COMPRESSION_RATIO}:1`,
          400,
        );
      }
    }

    // 4. Validate all entries for path traversal, file extensions, and nesting level
    const processedPaths = new Set<string>();

    for (const entryPath of filePaths) {
      // Skip directories (fflate doesn't include directory entries, only files)
      if (entryPath.endsWith('/')) continue;

      // 4.1 Check for unsafe paths (directory traversal prevention)
      const normalizedPath = path.normalize(path.join(destPath, entryPath));
      if (!normalizedPath.startsWith(destPath)) {
        throw new AppError(
          `Security violation: Potential directory traversal attack detected in path: ${entryPath}`,
          400,
        );
      }

      // 4.2 Check path length
      if (entryPath.length > ZIP_SECURITY_LIMITS.MAX_PATH_LENGTH) {
        throw new AppError(
          `File path exceeds maximum length: ${entryPath.length} > ${ZIP_SECURITY_LIMITS.MAX_PATH_LENGTH}`,
          400,
        );
      }

      // 4.3 Check nesting level
      const nestingLevel = entryPath.split('/').length - 1;
      if (nestingLevel > ZIP_SECURITY_LIMITS.MAX_NESTING_LEVEL) {
        throw new AppError(
          `Directory nesting level exceeds maximum: ${nestingLevel} > ${ZIP_SECURITY_LIMITS.MAX_NESTING_LEVEL}`,
          400,
        );
      }

      // 4.4 Check for duplicate paths (could indicate ZipSlip vulnerability attempts)
      if (processedPaths.has(normalizedPath)) {
        throw new AppError(`Duplicate file path detected: ${entryPath}. This could indicate a malicious archive.`, 400);
      }
      processedPaths.add(normalizedPath);
    }

    // If all checks pass, extract the files
    await fs.mkdir(destPath, { recursive: true });

    for (const [filePath, data] of Object.entries(files)) {
      if (filePath.endsWith('/')) continue; // Skip directories

      const fullPath = path.join(destPath, filePath);
      const dirPath = path.dirname(fullPath);

      // Create directory if it doesn't exist
      await fs.mkdir(dirPath, { recursive: true });

      // Write the file
      await fs.writeFile(fullPath, data);
    }
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    throw new AppError(`Failed to extract ZIP file: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}
</file>

<file path="website/server/src/remoteRepo.ts">
import { randomUUID } from 'node:crypto';
import fs from 'node:fs/promises';
import { type CliOptions, runCli } from 'repomix';
import { packRequestSchema } from './schemas/request.js';
import type { PackOptions, PackResult } from './types.js';
import { generateCacheKey } from './utils/cache.js';
import { AppError } from './utils/errorHandler.js';
import { cache, rateLimiter } from './utils/sharedInstance.js';
import { sanitizePattern, validateRequest } from './utils/validation.js';

export async function processRemoteRepo(
  repoUrl: string,
  format: string,
  options: PackOptions,
  clientIp: string,
): Promise<PackResult> {
  // Validate the request
  const validatedData = validateRequest(packRequestSchema, {
    url: repoUrl,
    format,
    options,
  });

  // Rate limit check
  if (!rateLimiter.isAllowed(clientIp)) {
    const remainingTime = Math.ceil(rateLimiter.getRemainingTime(clientIp) / 1000);
    throw new AppError(`Rate limit exceeded. Please try again in ${remainingTime} seconds.`, 429);
  }

  if (!validatedData.url) {
    throw new AppError('Repository URL is required for remote processing', 400);
  }

  // Generate cache key
  const cacheKey = generateCacheKey(validatedData.url, validatedData.format, validatedData.options, 'url');

  // Check if the result is already cached
  const cachedResult = await cache.get(cacheKey);
  if (cachedResult) {
    return cachedResult;
  }

  // Sanitize ignore patterns
  const sanitizedIncludePatterns = sanitizePattern(validatedData.options.includePatterns);
  const sanitizedIgnorePatterns = sanitizePattern(validatedData.options.ignorePatterns);

  const outputFilePath = `repomix-output-${randomUUID()}.txt`;

  // Create CLI options with correct mapping
  const cliOptions = {
    remote: repoUrl,
    output: outputFilePath,
    style: validatedData.format,
    parsableStyle: validatedData.options.outputParsable,
    removeComments: validatedData.options.removeComments,
    removeEmptyLines: validatedData.options.removeEmptyLines,
    outputShowLineNumbers: validatedData.options.showLineNumbers,
    fileSummary: validatedData.options.fileSummary,
    directoryStructure: validatedData.options.directoryStructure,
    compress: validatedData.options.compress,
    securityCheck: false,
    topFilesLen: 10,
    include: sanitizedIncludePatterns,
    ignore: sanitizedIgnorePatterns,
    quiet: true, // Enable quiet mode to suppress output
  } as CliOptions;

  try {
    // Execute remote action
    const result = await runCli(['.'], process.cwd(), cliOptions);
    if (!result) {
      throw new AppError('Remote action failed to return a result', 500);
    }
    const { packResult } = result;

    // Read the generated file
    const content = await fs.readFile(outputFilePath, 'utf-8');

    // Create pack result
    const packResultData: PackResult = {
      content,
      format,
      metadata: {
        repository: repoUrl,
        timestamp: new Date().toISOString(),
        summary: {
          totalFiles: packResult.totalFiles,
          totalCharacters: packResult.totalCharacters,
          totalTokens: packResult.totalTokens,
        },
        topFiles: Object.entries(packResult.fileCharCounts)
          .map(([path, charCount]) => ({
            path,
            charCount,
            tokenCount: packResult.fileTokenCounts[path] || 0,
          }))
          .sort((a, b) => b.charCount - a.charCount)
          .slice(0, cliOptions.topFilesLen),
      },
    };

    // Save the result to cache
    await cache.set(cacheKey, packResultData);

    return packResultData;
  } catch (error) {
    console.error('Error in remote action:', error);
    if (error instanceof Error) {
      throw new AppError(`Remote action failed: ${error.message}`, 500);
    }
    throw new AppError('Remote action failed with unknown error', 500);
  } finally {
    // Clean up the output file
    try {
      await fs.unlink(outputFilePath);
    } catch (err) {
      // Ignore file deletion errors
      console.warn('Failed to cleanup output file:', err);
    }
  }
}
</file>

<file path="website/server/src/types.ts">
export interface PackOptions {
  removeComments?: boolean;
  removeEmptyLines?: boolean;
  showLineNumbers?: boolean;
  fileSummary?: boolean;
  directoryStructure?: boolean;
  includePatterns?: string;
  ignorePatterns?: string;
  outputParsable?: boolean;
  compress?: boolean;
}

interface TopFile {
  path: string;
  charCount: number;
  tokenCount: number;
}

interface PackSummary {
  totalFiles: number;
  totalCharacters: number;
  totalTokens: number;
}

export interface PackResult {
  content: string;
  format: string;
  metadata: {
    repository: string;
    timestamp: string;
    summary?: PackSummary;
    topFiles?: TopFile[];
  };
}

export interface ErrorResponse {
  error: string;
}
</file>

<file path="website/server/.dockerignore">
# Dependencies
node_modules
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Build outputs
dist
build
*.tsbuildinfo

# Development files
.git
.gitignore
.env
.env.*
.npmrc
.yarnrc
.editorconfig
README.md
CHANGELOG.md
LICENSE
*.md

# IDE files
.vscode
.idea
*.swp
*.swo
.DS_Store
Thumbs.db

# Test files
__tests__
test
tests
coverage
.nyc_output

# Docker files
Dockerfile
.dockerignore

# Temporary files
tmp
temp
*.tmp
*.temp

# Log files
logs
*.log

# Cache directories
.npm
.eslintcache

# Cloud platform specific
.gcloudignore
cloudbuild.yaml
cloudbuild.yml

# TypeScript source maps
*.map

# Misc
.git
.github
.circleci
.husky
</file>

<file path="website/server/.gitignore">
dist
node_modules
</file>

<file path="website/server/cloudbuild.yaml">
steps:
  # Build the container image
  - name: 'gcr.io/cloud-builders/docker'
    id: 'build'
    args:
      - 'build'
      - '-t'
      - '$_REGION-docker.pkg.dev/$PROJECT_ID/repomix/server:$BUILD_ID'
      - '--cache-from'
      - '$_REGION-docker.pkg.dev/$PROJECT_ID/repomix/server:latest'
      - '--build-arg'
      - 'NODE_ENV=production'
      - '.'

  # Push the container image
  - name: 'gcr.io/cloud-builders/docker'
    id: 'push'
    args:
      - 'push'
      - '$_REGION-docker.pkg.dev/$PROJECT_ID/repomix/server:$BUILD_ID'

  # Deploy to Cloud Run
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'deploy'
    entrypoint: 'gcloud'
    args:
      - 'run'
      - 'deploy'
      - '$_SERVICE_NAME'
      - '--image'
      - '$_REGION-docker.pkg.dev/$PROJECT_ID/repomix/server:$BUILD_ID'
      - '--region'
      - '$_REGION'
      - '--platform'
      - 'managed'
      - '--port'
      - '8080'
      - '--memory'
      - '2048Mi'
      - '--cpu'
      - '2'
      - '--min-instances'
      - '0'
      - '--max-instances'
      - '10'
      - '--timeout'
      - '31s'
      - '--ingress'
      - 'all'
      - '--allow-unauthenticated'
      - '--set-env-vars'
      - 'NODE_ENV=production'

  # Tag the image as latest
  - name: 'gcr.io/cloud-builders/docker'
    id: 'tag-latest'
    args:
      - 'tag'
      - '$_REGION-docker.pkg.dev/$PROJECT_ID/repomix/server:$BUILD_ID'
      - '$_REGION-docker.pkg.dev/$PROJECT_ID/repomix/server:latest'

  # Push the latest tag
  - name: 'gcr.io/cloud-builders/docker'
    id: 'push-latest'
    args:
      - 'push'
      - '$_REGION-docker.pkg.dev/$PROJECT_ID/repomix/server:latest'

substitutions:
  _REGION: asia-northeast1
  _SERVICE_NAME: repomix-server

options:
  logging: CLOUD_LOGGING_ONLY
  dynamic_substitutions: true

images:
  - '$_REGION-docker.pkg.dev/$PROJECT_ID/repomix/server:$BUILD_ID'
  - '$_REGION-docker.pkg.dev/$PROJECT_ID/repomix/server:latest'
</file>

<file path="website/server/Dockerfile">
# ==============================================================================
# Base image
# ==============================================================================
FROM node:24-alpine AS builder

WORKDIR /app
COPY package*.json ./

# Install all dependencies (including dev dependencies for build)
RUN npm ci

# Copy source code
COPY . .

# Build TypeScript
RUN npm run build

# ==============================================================================
# Production dependencies
# ==============================================================================
FROM node:24-alpine AS deps

WORKDIR /app
COPY package*.json ./

# Install only production dependencies
RUN npm ci --only=production --ignore-scripts && \
    npm cache clean --force

# ==============================================================================
# Runtime image
# ==============================================================================
FROM node:24-alpine

# Install git and ca-certificates (required by repomix for remote repository processing)
RUN apk add --no-cache git ca-certificates

WORKDIR /app

# Copy built application
COPY --from=builder /app/dist ./dist

# Copy production dependencies
COPY --from=deps /app/node_modules ./node_modules

# Set environment variables
ENV NODE_ENV=production \
    PORT=8080

# Expose port
EXPOSE 8080

# Start the server directly
CMD ["node", "dist/index.js"]
</file>

<file path="website/server/package.json">
{
  "name": "repomix-website-server",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "PORT=8080 tsx watch src/index.ts",
    "build": "tsc",
    "lint": "npm run lint-tsc",
    "lint-tsc": "tsc --noEmit",
    "start": "node dist/index.js",
    "clean": "rimraf dist",
    "cloud-deploy": "gcloud builds submit --config=cloudbuild.yaml ."
  },
  "dependencies": {
    "@google-cloud/logging-winston": "^6.0.0",
    "@hono/node-server": "^1.13.8",
    "fflate": "^0.8.2",
    "hono": "^4.6.20",
    "repomix": "^0.3.7",
    "winston": "^3.17.0",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@types/node": "^22.13.0",
    "rimraf": "^6.0.1",
    "tsx": "^4.19.2",
    "typescript": "^5.7.3"
  }
}
</file>

<file path="website/server/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"]
}
</file>

<file path="website/CLAUDE.md">
# Website Documentation

## Project Overview

Full-stack web application consisting of VitePress documentation site (client) and Hono API server for online repository processing, with 12-language support.

## Supported Languages (12 total)
English (en), Japanese (ja), Chinese Simplified (zh-cn), Chinese Traditional (zh-tw), Korean (ko), German (de), French (fr), Spanish (es), Portuguese Brazilian (pt-br), Indonesian (id), Vietnamese (vi), Hindi (hi).

All translations should be accurate and maintain consistent terminology across languages. When adding new features or documentation, please ensure that the English version is updated first, followed by translations in other languages.

## Navigation Configuration
When modifying website navigation or adding new pages:
1. Update the configuration files in `website/client/.vitepress/config/`
2. Each language has its own config file (e.g., `configEnUs.ts`, `configJa.ts`)
3. Shared configurations are in `configShard.ts`

Ensure all language configurations are synchronized to maintain consistency across the documentation.

## Adding New Languages
When adding support for a new language, follow these steps:

1. Create a configuration file (e.g., `configXx.ts`) in `website/client/.vitepress/config/` based on existing language configurations
2. Include proper sidebar navigation, labels, and search translations
3. Update the imports and locale entries in the main VitePress configuration (`config.ts`)
4. Add search configurations to `configShard.ts`
5. Update the supported languages list in this file
6. Create directory structure for content (e.g., `website/client/src/xx/`)
7. Create content files starting with main index page and guide index
8. Progressively translate remaining documentation pages
9. Test navigation and search functionality in the new language

When working on multiple languages simultaneously, approach one language at a time completely before moving to the next language to maintain quality and consistency.
</file>

<file path="website/compose.yml">
# Run website in development mode
# $ docker compose -f website/compose.yml up --build

services:
  client:
    build:
      context: ./client
      dockerfile: Dockerfile
    ports:
      - "5173:5173"
    volumes:
      - ./client:/app
    environment:
      - NODE_ENV=development
    # override default command
    command: sh -c "npm i && npm run docs:dev -- --port 5173 --host"

  server:
    build:
      context: ./server
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    volumes:
      - ./server:/app
    environment:
      - NODE_ENV=development
      - PORT=8080
    # override default command
    command: sh -c "npm i && npm run dev"
    develop:
      watch:
        - action: sync+restart
          path: ./server
          target: /app
</file>

<file path="website/README.md">
# Repomix Website

This directory contains the source code for the Repomix website, built with [VitePress](https://vitepress.dev/) and [Vue.js](https://vuejs.org/)

## Prerequisites

- Docker must be installed on your system

## Development

To start the development server:

```bash
# Start the website development server
npm run website

# Access the website at http://localhost:5173/
```

## Documentation

When updating documentation, you only need to update the English version (`client/src/en/`).
The maintainers will handle translations to other languages.

## Building for Production

To build the website for production:

```bash
npm run website:build
```

The built files will be available in the `client/dist` directory.
</file>

<file path=".clinerules">
# Important
- Follow all AI instructions in the `.github/instructions/` directory
- The base instructions are located in `.github/instructions/base.instructions.md`
</file>

<file path=".codecov.yml">
coverage:
  status:
    patch:
      default:
        target: 80%
        informational: true
    project:
      default:
        target: 75%
        threshold: 1%
</file>

<file path=".coderabbit.yaml">
# CodeRabbit configuration file for Repomix project
# See: https://docs.coderabbit.ai/getting-started/configure-coderabbit/

# Language configuration
language: en-US

# Review configuration
reviews:
  # Review levels for different types of changes
  profile: chill # Options: chill, assertive

  # Auto review only on PR creation, not on subsequent changes
  auto_review:
    enabled: true
    drafts: false

    # Disable incremental reviews after PR creation
    auto_incremental_review: false

  # Request changes for critical issues
  request_changes_workflow: true

  # High-level summary for complex PRs
  high_level_summary: false

  # Poem style for fun summary (optional)
  poem: false

# Chat configuration
chat:
  auto_reply: false

# Knowledge base configuration
knowledge_base:
  # Opt out of sensitive file content analysis
  opt_out: false

# Early access features
early_access: true
</file>

<file path=".cursorrules">
# Important
- Follow all AI instructions in the `.github/instructions/` directory
- The base instructions are located in `.github/instructions/base.instructions.md`
</file>

<file path=".dockerignore">
node_modules
npm-debug.log
.git
.gitignore
.env
.env.*
*.md
.vscode
coverage
.nyc_output
dist
build
</file>

<file path=".editorconfig">
root = true

[*]
indent_style = space
indent_size = 2
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true
end_of_line = lf
max_line_length = unset

[*.md]
trim_trailing_whitespace = false
</file>

<file path=".gitignore">
# Dependency directories
node_modules/

# Build output
lib/
website/client/.vitepress/dist/

# Logs
*.log

# OS generated files
.DS_Store

# Editor directories and files
.vscode/
.idea/

# Test coverage
coverage/

# Temporary files
*.tmp
*.temp

# Repomix output
repomix-output.txt
repomix-output.xml
repomix-output.md

# ESLint cache
.eslintcache

# yarn
.yarn/

# biome
.biome/

# aider
.aider*

# private files
.cursor/rules/
.github/todo.md
.mcp.json
</file>

<file path=".node-version">
23.6.0
</file>

<file path=".repomixignore">
node_modules
.yarn
.eslinttcache
tests/integration-tests/fixtures
</file>

<file path=".secretlintrc.json">
{
  "rules": [
    {
      "id": "@secretlint/secretlint-rule-preset-recommend"
    }
  ]
}
</file>

<file path=".tool-versions">
nodejs 24.0.1
</file>

<file path="biome.json">
{
  "$schema": "https://biomejs.dev/schemas/1.8.3/schema.json",
  "files": {
    "include": [
      "./bin/**",
      "./src/**",
      "./tests/**",
      "./website/**",
      "./browser/**",
      "./.devcontainer/**",
      "./.github/**",
      "package.json",
      "biome.json",
      ".secretlintrc.json",
      "tsconfig.json",
      "tsconfig.build.json",
      "vite.config.ts",
      "repomix.config.json"
    ],
    "ignore": [
      "website/client/.vitepress/.temp",
      "website/client/.vitepress/dist",
      "website/client/.vitepress/cache",
      "website/server/dist",
      "browser/dist",
      "browser/packages"
    ]
  },
  "organizeImports": {
    "enabled": true
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true
    }
  },
  "formatter": {
    "enabled": true,
    "formatWithErrors": false,
    "indentStyle": "space",
    "indentWidth": 2,
    "lineWidth": 120
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "single",
      "trailingCommas": "all",
      "semicolons": "always"
    }
  },
  "json": {
    "parser": {
      "allowComments": true,
      "allowTrailingCommas": true
    },
    "formatter": {
      "enabled": false
    }
  }
}
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

# Repomix Project Structure and Overview

This document provides a structural overview of the Repomix project, designed to aid AI code assistants (like Copilot) in understanding the codebase.

Please refer to `README.md` for a complete and up-to-date project overview, and `CONTRIBUTING.md` for implementation guidelines and contribution procedures.

## Project Overview

Repomix is a tool that packs the contents of a software repository into a single file, making it easier for AI systems to analyze and process the codebase. It supports various output formats (XML, Markdown, or plain text), ignores files based on configurable patterns, and performs security checks to exclude potentially sensitive information.

## Directory Structure

The project is organized into the following directories:

```
repomix/
├── browser/ # Browser extension source code
├── src/ # Main source code
│   ├── cli/ # Command-line interface logic (argument parsing, command handling, output)
│   ├── config/ # Configuration loading, schema, and defaults
│   ├── core/ # Core logic of Repomix
│   │   ├── file/ # File handling (reading, processing, searching, tree structure generation, git commands)
│   │   ├── metrics/ # Calculating code metrics (character count, token count)
│   │   ├── output/ # Output generation (different styles, headers, etc.)
│   │   ├── packager/ # Orchestrates file collection, processing, output, and clipboard operations.
│   │   ├── security/ # Security checks to exclude sensitive files
│   │   ├── mcp/ # MCP server integration (packaging codebases for AI analysis)
│   │   ├── tokenCount/ # Token counting using Tiktoken
│   │   └── treeSitter/ # Code parsing using Tree-sitter and language-specific queries
│   └── shared/ # Shared utilities and types (error handling, logging, helper functions)
├── tests/ # Unit and integration tests (organized mirroring src/)
│   ├── cli/
│   ├── config/
│   ├── core/
│   ├── integration-tests/
│   ├── shared/
│   └── testing/
└── website/ # Documentation website (VitePress)
```



# Coding Guidelines
- Follow the Airbnb JavaScript Style Guide.
- Split files into smaller, focused units when appropriate:
  - Aim to keep code files under 250 lines. If a file exceeds 250 lines, split it into multiple files based on functionality.
- Add comments to clarify non-obvious logic. **Ensure all comments are written in English.**
- Provide corresponding unit tests for all new features.
- After implementation, verify changes by running:
  ```bash
  npm run lint  # Ensure code style compliance
  npm run test  # Verify all tests pass
  ```

## Commit Messages
- Follow the [Conventional Commits](https://www.conventionalcommits.org/) specification for all commit messages
- Always include a scope in your commit messages
- Format: `type(scope): Description`
  ```
  # Examples:
  feat(cli): Add new --no-progress flag
  fix(security): Handle special characters in file paths
  docs(website): Update installation guide
  style(website): Update GitHub sponsor button color
  refactor(core): Split packager into smaller modules
  test(cli): Add tests for new CLI options
  ```
- Types: feat, fix, docs, style, refactor, test, chore, etc.
- Scope should indicate the affected part of the codebase (cli, core, website, security, etc.)
- Description should be clear and concise in present tense
- Description must start with a capital letter

## Pull Request Guidelines
- All pull requests must follow the template:
  ```md
  <!-- Please include a summary of the changes -->

  ## Checklist

  - [ ] Run `npm run test`
  - [ ] Run `npm run lint`
  ```
- Include a clear summary of the changes at the top of the pull request description
- Reference any related issues using the format `#issue-number` 


## Dependencies and Testing
- Inject dependencies through a deps object parameter for testability
- Example:
  ```typescript
  export const functionName = async (
    param1: Type1,
    param2: Type2,
    deps = {
      defaultFunction1,
      defaultFunction2,
    }
  ) => {
    // Use deps.defaultFunction1() instead of direct call
  };
  ```
- Mock dependencies by passing test doubles through deps object
- Use vi.mock() only when dependency injection is not feasible

## Generate Comprehensive Output
- Include all content without abbreviation, unless specified otherwise
- Optimize for handling large codebases while maintaining output quality
</file>

<file path="CODE_OF_CONDUCT.md">
# Repomix Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we, as contributors and maintainers, pledge to make participation in our project and community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contribute to creating a positive environment include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or advances
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as physical or electronic addresses, without explicit permission
* Other conduct that could reasonably be considered inappropriate in a professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that do not align with this Code of Conduct or to ban temporarily or permanently any contributor for behaviors that they deem inappropriate, threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project email address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [koukun0120@gmail.com](mailto:koukun0120@gmail.com). All complaints will be reviewed and investigated, resulting in a response deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality concerning the reporter of an incident. Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [https://www.contributor-covenant.org/version/1/4/code-of-conduct.html](https://www.contributor-covenant.org/version/1/4/code-of-conduct.html).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this Code of Conduct, see [https://www.contributor-covenant.org/faq](https://www.contributor-covenant.org/faq).
</file>

<file path="CONTRIBUTING.md">
# Contribution Guide

Thanks for your interest in **Repomix**! 🚀 We'd love your help to make it even better. Here's how you can get involved:


- **Create an Issue**: Spot a bug? Have an idea for a new feature? Let us know by creating an issue.
- **Submit a Pull Request**: Found something to fix or improve? Jump in and submit a PR!
- **Spread the Word**: Share your experience with Repomix on social media, blogs, or with your tech community.
- **Use Repomix**: The best feedback comes from real-world usage, so feel free to integrate Repomix into your own projects!

## Maintainers

Repomix is maintained by Yamadashy ([@yamadashy](https://github.com/yamadashy)). While all contributions are welcome, please understand that not every suggestion may be accepted if they don't align with the project's goals or coding standards.

---

## Pull Requests

Before submitting a Pull Request, please ensure:

1. Your code passes all tests: Run `npm run test`
2. Your code adheres to our linting standards: Run `npm run lint`
3. You have updated relevant documentation (especially README.md) if you've added or changed functionality.

## Local Development

To set up Repomix for local development:

```bash
git clone https://github.com/yamadashy/repomix.git
cd repomix
npm install
```

To run Repomix locally:

```bash
npm run repomix
```

### Docker Usage
You can also run Repomix using Docker. Here's how:

First, build the Docker image:
```bash
docker build -t repomix .
```

Then, run the Docker container:
```bash
docker run -v ./:/app -it --rm repomix
```

### Coding Style

We use [Biome](https://biomejs.dev/) for linting and formatting. Please make sure your code follows the style guide by running:

```bash
npm run lint
```

### Testing

We use [Vitest](https://vitest.dev/) for testing. To run the tests:

```bash
npm run test
```

For test coverage:

```bash
npm run test-coverage
```

### Documentation

When adding new features or making changes, please update the relevant documentation in the README.md file.

### Website Development

The Repomix website is built with [VitePress](https://vitepress.dev/). To run the website locally:

```bash
# Prerequisites: Docker must be installed on your system

# Start the website development server
npm run website

# Access the website at http://localhost:5173/
```

The website source code is located in the `website` directory. The main components are:

- `website/client`: Frontend code (Vue.js components, styles, etc.)
- `website/server`: Backend API server

When updating documentation, you only need to update the English version (`website/client/src/en/`).
The maintainers will handle translations to other languages.

## Releasing

New versions are managed by the maintainer. If you think a release is needed, open an issue to discuss it

Thank you for contributing to Repomix!
</file>

<file path="Dockerfile">
FROM node:22-slim

RUN apt-get update && apt-get install -y --no-install-recommends \
    git \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

RUN mkdir /repomix
WORKDIR /repomix

# Install dependencies and build repomix, then link the package to the global scope
# To reduce the size of the layer, npm ci and npm link are executed in the same RUN command
COPY . .
RUN npm ci \
    && npm run build \
    && npm link \
    && npm ci --omit=dev \
    && npm cache clean --force

WORKDIR /app

# Check the operation of repomix
RUN repomix --version
RUN repomix --help

ENTRYPOINT ["repomix"]
</file>

<file path="LICENSE">
Copyright 2024 Kazuki Yamada

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</file>

<file path="llms-install.md">
# Repomix MCP Server Installation Guide

This guide is specifically designed for AI agents like Cline to install and configure the Repomix MCP server for use with LLM applications like Claude Desktop, Cursor, Roo Code, and Cline.

## Overview

Repomix MCP server is a powerful tool that packages local or remote codebases into AI-friendly formats. It allows AI assistants to analyze code efficiently without manual file preparation, optimizing token usage and providing consistent output.

## Prerequisites

Before installation, you need:

1. Node.js 18.0.0 or higher
2. npm (Node Package Manager)

## Installation and Configuration

### Configure MCP Settings

Add the Repomix MCP server configuration to your MCP settings file based on your LLM client:

#### Configuration File Locations

- Cline (VS Code Extension): `~/Library/Application Support/Code/User/globalStorage/saoudrizwan.claude-dev/settings/cline_mcp_settings.json`
- Roo Code (VS Code Extension): `~/Library/Application Support/Code/User/globalStorage/rooveterinaryinc.roo-cline/settings/cline_mcp_settings.json`
- Claude Desktop: `~/Library/Application Support/Claude/claude_desktop_config.json`
- Cursor: `[project root]/.cursor/mcp.json`

Add this configuration to your chosen client's settings file:

```json
{
  "mcpServers": {
    "repomix": {
      "command": "npx",
      "args": [
        "-y",
        "repomix",
        "--mcp"
      ],
      "disabled": false,
      "autoApprove": []
    }
  }
}
```

This configuration uses `npx` to run Repomix directly without requiring a global installation.

## Available MCP Tools

Once configured, you'll have access to these Repomix tools:

### 1. pack_codebase

This tool packages a local code directory into a consolidated XML file for AI analysis. It analyzes the codebase structure, extracts relevant code content, and generates a comprehensive report including metrics, file tree, and formatted code content.

**Parameters:**
- `directory`: (Required) Absolute path to the directory to pack
- `compress`: (Optional, default: false) Enable Tree-sitter compression to extract essential code signatures and structure while removing implementation details. Reduces token usage by ~70% while preserving semantic meaning. Generally not needed since grep_repomix_output allows incremental content retrieval. Use only when you specifically need the entire codebase content for large repositories.
- `includePatterns`: (Optional) Specify files to include using fast-glob patterns. Multiple patterns can be comma-separated (e.g., "**/*.{js,ts}", "src/**,docs/**"). Only matching files will be processed.
- `ignorePatterns`: (Optional) Specify additional files to exclude using fast-glob patterns. Multiple patterns can be comma-separated (e.g., "test/**,*.spec.js", "node_modules/**,dist/**"). These patterns supplement .gitignore and built-in exclusions.
- `topFilesLength`: (Optional, default: 10) Number of largest files by size to display in the metrics summary for codebase analysis.

**Example:**
```json
{
  "directory": "/path/to/your/project",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### 2. pack_remote_repository

This tool fetches, clones, and packages a GitHub repository into a consolidated XML file for AI analysis. It automatically clones the remote repository, analyzes its structure, and generates a comprehensive report.

**Parameters:**
- `remote`: (Required) GitHub repository URL or user/repo format (e.g., "yamadashy/repomix", "https://github.com/user/repo", or "https://github.com/user/repo/tree/branch")
- `compress`: (Optional, default: false) Enable Tree-sitter compression to extract essential code signatures and structure while removing implementation details. Reduces token usage by ~70% while preserving semantic meaning. Generally not needed since grep_repomix_output allows incremental content retrieval. Use only when you specifically need the entire codebase content for large repositories.
- `includePatterns`: (Optional) Specify files to include using fast-glob patterns. Multiple patterns can be comma-separated (e.g., "**/*.{js,ts}", "src/**,docs/**"). Only matching files will be processed.
- `ignorePatterns`: (Optional) Specify additional files to exclude using fast-glob patterns. Multiple patterns can be comma-separated (e.g., "test/**,*.spec.js", "node_modules/**,dist/**"). These patterns supplement .gitignore and built-in exclusions.
- `topFilesLength`: (Optional, default: 10) Number of largest files by size to display in the metrics summary for codebase analysis.

**Example:**
```json
{
  "remote": "yamadashy/repomix",
  "compress": false,
  "includePatterns": "src/**/*.ts,**/*.md",
  "ignorePatterns": "**/*.log,tmp/",
  "topFilesLength": 10
}
```

### 3. read_repomix_output

This tool reads the contents of a Repomix-generated output file. Supports partial reading with line range specification for large files. This tool is designed for environments where direct file system access is limited.

**Parameters:**
- `outputId`: (Required) ID of the Repomix output file to read
- `startLine`: (Optional) Starting line number (1-based, inclusive). If not specified, reads from beginning.
- `endLine`: (Optional) Ending line number (1-based, inclusive). If not specified, reads to end.

**Features:**
- Specifically designed for web-based environments or sandboxed applications
- Retrieves the content of previously generated outputs using their ID
- Provides secure access to packed codebase without requiring file system access
- Supports partial reading for large files

**Example:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "startLine": 100,
  "endLine": 200
}
```

### 4. grep_repomix_output

This tool searches for patterns in a Repomix output file using grep-like functionality with JavaScript RegExp syntax. Returns matching lines with optional context lines around matches.

**Parameters:**
- `outputId`: (Required) ID of the Repomix output file to search
- `pattern`: (Required) Search pattern (JavaScript RegExp regular expression syntax)
- `contextLines`: (Optional, default: 0) Number of context lines to show before and after each match. Overridden by beforeLines/afterLines if specified.
- `beforeLines`: (Optional) Number of context lines to show before each match (like grep -B). Takes precedence over contextLines.
- `afterLines`: (Optional) Number of context lines to show after each match (like grep -A). Takes precedence over contextLines.
- `ignoreCase`: (Optional, default: false) Perform case-insensitive matching

**Features:**
- Uses JavaScript RegExp syntax for powerful pattern matching
- Supports context lines for better understanding of matches
- Allows separate control of before/after context lines
- Case-sensitive and case-insensitive search options

**Example:**
```json
{
  "outputId": "8f7d3b1e2a9c6054",
  "pattern": "function\\s+\\w+\\(",
  "contextLines": 3,
  "ignoreCase": false
}
```

### 5. file_system_read_file

This tool reads a file from the local file system using an absolute path. Includes built-in security validation to detect and prevent access to files containing sensitive information.

**Parameters:**
- `path`: (Required) Absolute path to the file to read

**Security features:**
- Implements security validation using [Secretlint](https://github.com/secretlint/secretlint)
- Prevents access to files containing sensitive information (API keys, passwords, secrets)
- Validates absolute paths to prevent directory traversal attacks

**Example:**
```json
{
  "path": "/absolute/path/to/file.txt"
}
```

### 6. file_system_read_directory

This tool lists the contents of a directory using an absolute path. Returns a formatted list showing files and subdirectories with clear indicators.

**Parameters:**
- `path`: (Required) Absolute path to the directory to list

**Features:**
- Shows files and directories with clear indicators (`[FILE]` or `[DIR]`)
- Provides safe directory traversal with proper error handling
- Validates paths and ensures they are absolute
- Useful for exploring project structure and understanding codebase organization

**Example:**
```json
{
  "path": "/absolute/path/to/directory"
}
```

## Verify Installation

To verify the installation is working:

1. Restart your LLM application (Cline, Claude Desktop, etc.)
2. Test the connection by running a simple command like:
  ```
  Please package the local directory /path/to/project for AI analysis using Repomix.
  ```
  or
  ```
  Please fetch and package the GitHub repository yamadashy/repomix for AI analysis.
  ```

## Usage Examples

Here are some examples of how to use Repomix MCP server with AI assistants:

### Local Codebase Analysis

```
Can you analyze the code in my project at /path/to/project? Please use Repomix to package it first.
```

### Remote Repository Analysis

```
I'd like you to review the code in the GitHub repository username/repo. Please use Repomix to package it first.
```

### Specific File Types Analysis

```
Please package my project at /path/to/project, but only include TypeScript files and markdown documentation.
```

## Troubleshooting

### Common Issues and Solutions

1. **MCP server connection issues**
  - Verify the syntax in your MCP settings file is correct
  - Ensure you have an active internet connection (needed for npx to fetch the package)
  - Check if any other MCP servers are causing conflicts

2. **Packaging failures**
  - Verify the specified directory or repository exists
  - Check if you have sufficient disk space
  - For remote repositories, ensure you have internet connectivity
  - Try with simpler parameters first, then add complexity

3. **JSON parsing errors in configuration**
  - Make sure your MCP settings file is properly formatted
  - Verify all paths use forward slashes, even on Windows
  - Check for any missing commas or brackets in the configuration

## Additional Information

For more detailed information, visit the [Repomix official documentation](https://repomix.com). You can also join the [Discord community](https://discord.gg/wNYzTwZFku) for support and questions.
</file>

<file path="package.json">
{
  "name": "repomix",
  "version": "0.3.9",
  "description": "A tool to pack repository contents to single file for AI consumption",
  "main": "./lib/index.js",
  "types": "./lib/index.d.ts",
  "exports": {
    ".": {
      "import": {
        "types": "./lib/index.d.ts",
        "default": "./lib/index.js"
      },
      "require": {
        "types": "./lib/index.d.ts",
        "default": "./lib/index.js"
      },
      "default": "./lib/index.js"
    }
  },
  "bin": "./bin/repomix.cjs",
  "scripts": {
    "clean": "rimraf lib",
    "build": "npm run clean && tsc -p tsconfig.build.json --sourceMap --declaration",
    "lint": "npm run lint-biome && npm run lint-ts && npm run lint-secretlint",
    "lint-biome": "biome check --write",
    "lint-ts": "tsc --noEmit",
    "lint-secretlint": "secretlint \"**/*\" --secretlintignore .gitignore",
    "test": "vitest",
    "test-coverage": "vitest run --coverage",
    "repomix": "npm run build && node --trace-warnings bin/repomix.cjs",
    "repomix-src": "npm run repomix -- --include 'src,tests'",
    "repomix-website": "npm run repomix -- --include 'website'",
    "website": "docker compose -f website/compose.yml up --build",
    "website-generate-schema": "tsx website/client/scripts/generateSchema.ts",
    "npm-publish": "npm run npm-publish-check-branch && npm run lint && npm run test-coverage && npm run build && npm publish",
    "npm-publish-check-branch": "git branch --show-current | grep -q '^main$' || (echo 'Release is only allowed from the main branch' && exit 1)",
    "npm-release-patch": "npm version patch && npm run npm-publish",
    "npm-release-minor": "npm version minor && npm run npm-publish",
    "npm-release-prerelease": "npm version prerelease && npm run npm-publish"
  },
  "keywords": [
    "repository",
    "generative-ai",
    "ai",
    "llm",
    "source-code",
    "code-analysis",
    "codebase-packer",
    "development-tool",
    "ai-assistant",
    "code-review"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/yamadashy/repomix.git"
  },
  "bugs": {
    "url": "https://github.com/yamadashy/repomix/issues"
  },
  "author": "Kazuki Yamada <koukun0120@gmail.com>",
  "homepage": "https://github.com/yamadashy/repomix",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "files": [
    "lib/",
    "bin/",
    "README.md",
    "LICENSE"
  ],
  "type": "module",
  "dependencies": {
    "@clack/prompts": "^0.10.1",
    "@modelcontextprotocol/sdk": "^1.11.0",
    "@secretlint/core": "^9.3.1",
    "@secretlint/secretlint-rule-preset-recommend": "^9.3.1",
    "cli-spinners": "^2.9.2",
    "clipboardy": "^4.0.0",
    "commander": "^14.0.0",
    "fast-xml-parser": "^5.2.0",
    "fflate": "^0.8.2",
    "git-url-parse": "^16.1.0",
    "globby": "^14.1.0",
    "handlebars": "^4.7.8",
    "iconv-lite": "^0.6.3",
    "istextorbinary": "^9.5.0",
    "jschardet": "^3.1.4",
    "json5": "^2.2.3",
    "log-update": "^6.1.0",
    "minimatch": "^10.0.1",
    "picocolors": "^1.1.1",
    "piscina": "^4.9.2",
    "strip-comments": "^2.0.1",
    "strip-json-comments": "^5.0.1",
    "tiktoken": "^1.0.20",
    "tree-sitter-wasms": "^0.1.12",
    "web-tree-sitter": "^0.24.7",
    "zod": "^3.24.3"
  },
  "devDependencies": {
    "@biomejs/biome": "^1.9.4",
    "@secretlint/types": "^9.3.4",
    "@types/node": "^22.14.1",
    "@types/strip-comments": "^2.0.4",
    "@vitest/coverage-v8": "^3.1.1",
    "git-up": "^8.1.1",
    "rimraf": "^6.0.1",
    "secretlint": "^9.3.1",
    "tsx": "^4.19.4",
    "typescript": "^5.8.3",
    "vite": "^5.4.18",
    "vitest": "^3.1.1"
  },
  "engines": {
    "node": ">=18.0.0",
    "yarn": ">=1.22.22"
  }
}
</file>

<file path="README.md">
<div align="center" markdown="1">
   <sup>Special thanks to:</sup>
   <br>
   <br>
   <a href="https://www.warp.dev/repomix">
      <img alt="Warp sponsorship" width="400" src="website/client/src/public/images/sponsors/warp/Terminal-Image.png">
   </a>

### [Warp, the agent terminal for developers](https://www.warp.dev/repomix)
[Available for MacOS, Linux, & Windows](https://www.warp.dev/repomix)<br>

</div>

<hr />

<div align="center">
  <a href="https://repomix.com">
    <img src="website/client/src/public/images/repomix-title.png" alt="Repomix" width="500" height="auto" />
  </a>
  <p align="center">
    <b>Pack your codebase into AI-friendly formats</b>
  </p>
</div>

<p align="center">
  <a href="https://repomix.com"><b>Use Repomix online! 👉 repomix.com</b></a><br>
</p>

<p align="center">
  Need discussion? Join us on <a href="https://discord.gg/wNYzTwZFku">Discord</a>!<br>
  <i>Share your experience and tips</i><br>
  <i>Stay updated on new features</i><br>
  <i>Get help with configuration and usage</i><br>
</p>

<hr />

[![npm](https://img.shields.io/npm/v/repomix.svg?maxAge=1000)](https://www.npmjs.com/package/repomix)
[![npm](https://img.shields.io/npm/d18m/repomix)](https://www.npmjs.com/package/repomix)
[![Actions Status](https://github.com/yamadashy/repomix/actions/workflows/ci.yml/badge.svg)](https://github.com/yamadashy/repomix/actions?query=workflow%3A"ci")
[![codecov](https://codecov.io/github/yamadashy/repomix/graph/badge.svg)](https://codecov.io/github/yamadashy/repomix)
[![Sponsors](https://img.shields.io/github/sponsors/yamadashy?logo=github)](https://github.com/sponsors/yamadashy)
[![Discord](https://badgen.net/discord/online-members/wNYzTwZFku?icon=discord&label=discord)](https://discord.gg/wNYzTwZFku)

[![DeepWiki](https://img.shields.io/badge/DeepWiki-yamadashy%2Frepomix-blue.svg?logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAyCAYAAAAnWDnqAAAAAXNSR0IArs4c6QAAA05JREFUaEPtmUtyEzEQhtWTQyQLHNak2AB7ZnyXZMEjXMGeK/AIi+QuHrMnbChYY7MIh8g01fJoopFb0uhhEqqcbWTp06/uv1saEDv4O3n3dV60RfP947Mm9/SQc0ICFQgzfc4CYZoTPAswgSJCCUJUnAAoRHOAUOcATwbmVLWdGoH//PB8mnKqScAhsD0kYP3j/Yt5LPQe2KvcXmGvRHcDnpxfL2zOYJ1mFwrryWTz0advv1Ut4CJgf5uhDuDj5eUcAUoahrdY/56ebRWeraTjMt/00Sh3UDtjgHtQNHwcRGOC98BJEAEymycmYcWwOprTgcB6VZ5JK5TAJ+fXGLBm3FDAmn6oPPjR4rKCAoJCal2eAiQp2x0vxTPB3ALO2CRkwmDy5WohzBDwSEFKRwPbknEggCPB/imwrycgxX2NzoMCHhPkDwqYMr9tRcP5qNrMZHkVnOjRMWwLCcr8ohBVb1OMjxLwGCvjTikrsBOiA6fNyCrm8V1rP93iVPpwaE+gO0SsWmPiXB+jikdf6SizrT5qKasx5j8ABbHpFTx+vFXp9EnYQmLx02h1QTTrl6eDqxLnGjporxl3NL3agEvXdT0WmEost648sQOYAeJS9Q7bfUVoMGnjo4AZdUMQku50McDcMWcBPvr0SzbTAFDfvJqwLzgxwATnCgnp4wDl6Aa+Ax283gghmj+vj7feE2KBBRMW3FzOpLOADl0Isb5587h/U4gGvkt5v60Z1VLG8BhYjbzRwyQZemwAd6cCR5/XFWLYZRIMpX39AR0tjaGGiGzLVyhse5C9RKC6ai42ppWPKiBagOvaYk8lO7DajerabOZP46Lby5wKjw1HCRx7p9sVMOWGzb/vA1hwiWc6jm3MvQDTogQkiqIhJV0nBQBTU+3okKCFDy9WwferkHjtxib7t3xIUQtHxnIwtx4mpg26/HfwVNVDb4oI9RHmx5WGelRVlrtiw43zboCLaxv46AZeB3IlTkwouebTr1y2NjSpHz68WNFjHvupy3q8TFn3Hos2IAk4Ju5dCo8B3wP7VPr/FGaKiG+T+v+TQqIrOqMTL1VdWV1DdmcbO8KXBz6esmYWYKPwDL5b5FA1a0hwapHiom0r/cKaoqr+27/XcrS5UwSMbQAAAABJRU5ErkJggg==)](https://deepwiki.com/yamadashy/repomix)
<!-- DeepWiki badge generated by https://deepwiki.ryoppippi.com/ -->

📦 Repomix is a powerful tool that packs your entire repository into a single, AI-friendly file.  
It is perfect for when you need to feed your codebase to Large Language Models (LLMs) or other AI tools like Claude,
ChatGPT, DeepSeek, Perplexity, Gemini, Gemma, Llama, Grok, and more.

[![Sponsors](https://cdn.jsdelivr.net/gh/yamadashy/sponsor-list/sponsors/sponsors.png)](https://github.com/sponsors/yamadashy)

## 🏆 Open Source Awards Nomination

We're honored! Repomix has been nominated for the **Powered by AI** category at the [JSNation Open Source Awards 2025](https://osawards.com/javascript/).

This wouldn't have been possible without all of you using and supporting Repomix. Thank you!

If Repomix has helped you analyze or pack codebases for AI tools, we'd be grateful for your vote in the **Powered by AI** category.

## 🎉 New: Repomix Website & Discord Community!

- Try Repomix in your browser at [repomix.com](https://repomix.com/)
- Join our [Discord Server](https://discord.gg/wNYzTwZFku) for support and discussion

**We look forward to seeing you there!**

## 🌟 Features

- **AI-Optimized**: Formats your codebase in a way that's easy for AI to understand and process.
- **Token Counting**: Provides token counts for each file and the entire repository, useful for LLM context limits.
- **Simple to Use**: You need just one command to pack your entire repository.
- **Customizable**: Easily configure what to include or exclude.
- **Git-Aware**: Automatically respects your `.gitignore` files and `.git/info/exclude`.
- **Security-Focused**: Incorporates [Secretlint](https://github.com/secretlint/secretlint) for robust security checks to detect and prevent inclusion of sensitive information.
- **Code Compression**: The `--compress` option uses [Tree-sitter](https://github.com/tree-sitter/tree-sitter) to extract key code elements, reducing token count while preserving structure.

## 🚀 Quick Start

### Using the CLI Tool `>_`

You can try Repomix instantly in your project directory without installation:

```bash
npx repomix
```

Or install globally for repeated use:

```bash
# Install using npm
npm install -g repomix

# Alternatively using yarn
yarn global add repomix

# Alternatively using bun
bun add -g repomix

# Alternatively using Homebrew (macOS/Linux)
brew install repomix

# Then run in any project directory
repomix
```

That's it! Repomix will generate a `repomix-output.xml` file in your current directory, containing your entire
repository in an AI-friendly format.

You can then send this file to an AI assistant with a prompt like:

```
This file contains all the files in the repository combined into one.
I want to refactor the code, so please review it first.
```

![Repomix File Usage 1](website/client/src/public/images/docs/repomix-file-usage-1.png)

When you propose specific changes, the AI might be able to generate code accordingly. With features like Claude's
Artifacts, you could potentially output multiple files, allowing for the generation of multiple interdependent pieces of
code.

![Repomix File Usage 2](website/client/src/public/images/docs/repomix-file-usage-2.png)

Happy coding! 🚀

### Using The Website 🌐

Want to try it quickly? Visit the official website at [repomix.com](https://repomix.com). Simply enter your repository
name, fill in any optional details, and click the **Pack** button to see your generated output.

#### Available Options

The website offers several convenient features:

- Customizable output format (XML, Markdown, or Plain Text)
- Instant token count estimation
- Much more!

### Using The Browser Extension 🧩

Get instant access to Repomix directly from any GitHub repository! Our Chrome extension adds a convenient "Repomix" button to GitHub repository pages.

![Repomix Browser Extension](website/client/src/public/images/docs/browser-extension.png)

#### Install
- Chrome Extension: [Repomix - Chrome Web Store](https://chromewebstore.google.com/detail/repomix/fimfamikepjgchehkohedilpdigcpkoa)
- Firefox Add-on: [Repomix - Firefox Add-ons](https://addons.mozilla.org/firefox/addon/repomix/)

#### Features
- One-click access to Repomix for any GitHub repository
- More exciting features coming soon!

### Using The VSCode Extension ⚡️

A community-maintained VSCode extension called [Repomix Runner](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner) (created by [massdo](https://github.com/massdo)) lets you run Repomix right inside your editor with just a few clicks. Run it on any folder, manage outputs seamlessly, and control everything through VSCode's intuitive interface. 

Want your output as a file or just the content? Need automatic cleanup? This extension has you covered. Plus, it works smoothly with your existing repomix.config.json.

Try it now on the [VSCode Marketplace](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner)!
Source code is available on [GitHub](https://github.com/massdo/repomix-runner).

### Alternative Tools 🛠️

If you're using Python, you might want to check out `Gitingest`, which is better suited for Python ecosystem and data
science workflows:
https://github.com/cyclotruc/gitingest

## 📊 Usage

To pack your entire repository:

```bash
repomix
```

To pack a specific directory:

```bash
repomix path/to/directory
```

To pack specific files or directories
using [glob patterns](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax):

```bash
repomix --include "src/**/*.ts,**/*.md"
```

To exclude specific files or directories:

```bash
repomix --ignore "**/*.log,tmp/"
```

To pack a remote repository:

```bash
repomix --remote https://github.com/yamadashy/repomix

# You can also use GitHub shorthand:
repomix --remote yamadashy/repomix

# You can specify the branch name, tag, or commit hash:
repomix --remote https://github.com/yamadashy/repomix --remote-branch main

# Or use a specific commit hash:
repomix --remote https://github.com/yamadashy/repomix --remote-branch 935b695

# Another convenient way is specifying the branch's URL
repomix --remote https://github.com/yamadashy/repomix/tree/main

# Commit's URL is also supported
repomix --remote https://github.com/yamadashy/repomix/commit/836abcd7335137228ad77feb28655d85712680f1

```

To pack files from a file list (via stdin):

```bash
# Using find command
find src -name "*.ts" -type f | repomix --stdin

# Using git to get tracked files
git ls-files "*.ts" | repomix --stdin

# Using ls with glob patterns
ls src/**/*.ts | repomix --stdin

# From a file containing file paths
cat file-list.txt | repomix --stdin

# Direct input with echo
echo -e "src/index.ts\nsrc/utils.ts" | repomix --stdin
```

The `--stdin` option allows you to pipe a list of file paths to Repomix, giving you ultimate flexibility in selecting which files to pack.

> [!NOTE]
> When using `--stdin`, file paths can be relative or absolute, and Repomix will automatically handle path resolution and deduplication.

To compress the output:

```bash
repomix --compress

# You can also use it with remote repositories:
repomix --remote yamadashy/repomix --compress
```

To initialize a new configuration file (`repomix.config.json`):

```bash
repomix --init
```

Once you have generated the packed file, you can use it with Generative AI tools like ChatGPT, DeepSeek, Perplexity, Gemini, Gemma, Llama, Grok, and more.

### Docker Usage 🐳

You can also run Repomix using Docker.  
This is useful if you want to run Repomix in an isolated environment or prefer using containers.

Basic usage (current directory):

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix
```

To pack a specific directory:

```bash
docker run -v .:/app -it --rm ghcr.io/yamadashy/repomix path/to/directory
```

Process a remote repository and output to a `output` directory:

```bash
docker run -v ./output:/app -it --rm ghcr.io/yamadashy/repomix --remote https://github.com/yamadashy/repomix
```

### Prompt Examples

Once you have generated the packed file with Repomix, you can use it with AI tools like ChatGPT, DeepSeek, Perplexity, Gemini, Gemma, Llama, Grok, and more.
Here are some example prompts to get you started:

#### Code Review and Refactoring

For a comprehensive code review and refactoring suggestions:

```
This file contains my entire codebase. Please review the overall structure and suggest any improvements or refactoring opportunities, focusing on maintainability and scalability.
```

#### Documentation Generation

To generate project documentation:

```
Based on the codebase in this file, please generate a detailed README.md that includes an overview of the project, its main features, setup instructions, and usage examples.
```

#### Test Case Generation

For generating test cases:

```
Analyze the code in this file and suggest a comprehensive set of unit tests for the main functions and classes. Include edge cases and potential error scenarios.
```

#### Code Quality Assessment

Evaluate code quality and adherence to best practices:

```
Review the codebase for adherence to coding best practices and industry standards. Identify areas where the code could be improved in terms of readability, maintainability, and efficiency. Suggest specific changes to align the code with best practices.
```

#### Library Overview

Get a high-level understanding of the library

```
This file contains the entire codebase of library. Please provide a comprehensive overview of the library, including its main purpose, key features, and overall architecture.
```

Feel free to modify these prompts based on your specific needs and the capabilities of the AI tool you're using.

### Community Discussion

Check out our [community discussion](https://github.com/yamadashy/repomix/discussions/154) where users share:

- Which AI tools they're using with Repomix
- Effective prompts they've discovered
- How Repomix has helped them
- Tips and tricks for getting the most out of AI code analysis

Feel free to join the discussion and share your own experiences! Your insights could help others make better use of
Repomix.

### Output File Format

Repomix generates a single file with clear separators between different parts of your codebase.  
To enhance AI comprehension, the output file begins with an AI-oriented explanation, making it easier for AI models to
understand the context and structure of the packed repository.

#### XML Format (default)

The XML format structures the content in a hierarchical manner:

```xml
This file is a merged representation of the entire codebase, combining all repository files into a single document.

<file_summary>
  (Metadata and usage AI instructions)
</file_summary>

<directory_structure>
src/
cli/
cliOutput.ts
index.ts

(...remaining directories)
</directory_structure>

<files>
<file path="src/index.js">
  // File contents here
</file>

(...remaining files)
</files>

<instruction>
(Custom instructions from `output.instructionFilePath`)
</instruction>
```

For those interested in the potential of XML tags in AI contexts:  
https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags

> When your prompts involve multiple components like context, instructions, and examples, XML tags can be a
> game-changer. They help Claude parse your prompts more accurately, leading to higher-quality outputs.

This means that the XML output from Repomix is not just a different format, but potentially a more effective way to feed
your codebase into AI systems for analysis, code review, or other tasks.

#### Markdown Format

To generate output in Markdown format, use the `--style markdown` option:

```bash
repomix --style markdown
```

The Markdown format structures the content in a hierarchical manner:

````markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.

# File Summary

(Metadata and usage AI instructions)

# Repository Structure

```
src/
  cli/
    cliOutput.ts
    index.ts
```

(...remaining directories)

# Repository Files

## File: src/index.js

```
// File contents here
```

(...remaining files)

# Instruction

(Custom instructions from `output.instructionFilePath`)
````

This format provides a clean, readable structure that is both human-friendly and easily parseable by AI systems.

#### Plain Text Format

To generate output in plain text format, use the `--style plain` option:

```bash
repomix --style plain
```

```text
This file is a merged representation of the entire codebase, combining all repository files into a single document.

================================================================
File Summary
================================================================
(Metadata and usage AI instructions)

================================================================
Directory Structure
================================================================
src/
  cli/
    cliOutput.ts
    index.ts
  config/
    configLoader.ts

(...remaining directories)

================================================================
Files
================================================================

================
File: src/index.js
================
// File contents here

================
File: src/utils.js
================
// File contents here

(...remaining files)

================================================================
Instruction
================================================================
(Custom instructions from `output.instructionFilePath`)
```

### Command Line Options

#### Basic Options
- `-v, --version`: Show tool version

#### Output Options
- `-o, --output <file>`: Specify the output file name
- `--stdout`: Output to stdout instead of writing to a file (cannot be used with `--output` option)
- `--style <style>`: Specify the output style (`xml`, `markdown`, `plain`)
- `--parsable-style`: Enable parsable output based on the chosen style schema. Note that this can increase token count.
- `--compress`: Perform intelligent code extraction, focusing on essential function and class signatures to reduce token count
- `--output-show-line-numbers`: Show line numbers in the output
- `--copy`: Additionally copy generated output to system clipboard
- `--no-file-summary`: Disable file summary section output
- `--no-directory-structure`: Disable directory structure section output
- `--remove-comments`: Remove comments from supported file types
- `--remove-empty-lines`: Remove empty lines from the output
- `--header-text <text>`: Custom text to include in the file header
- `--instruction-file-path <path>`: Path to a file containing detailed custom instructions
- `--include-empty-directories`: Include empty directories in the output
- `--include-diffs`: Include git diffs in the output (includes both work tree and staged changes separately)
- `--no-git-sort-by-changes`: Disable sorting files by git change count (enabled by default)

#### Filter Options
- `--include <patterns>`: List of include patterns (comma-separated)
- `-i, --ignore <patterns>`: Additional ignore patterns (comma-separated)
- `--stdin`: Read file paths from stdin instead of discovering files automatically
- `--no-gitignore`: Disable .gitignore file usage
- `--no-default-patterns`: Disable default patterns

#### Remote Repository Options
- `--remote <url>`: Process a remote Git repository
- `--remote-branch <name>`: Specify the remote branch name, tag, or commit hash (defaults to repository default branch)

#### Configuration Options
- `-c, --config <path>`: Path to a custom config file
- `--init`: Create config file
- `--global`: Use global config

#### Security Options
- `--no-security-check`: Disable security check

#### Token Count Options
- `--token-count-encoding <encoding>`: Specify token count encoding used by OpenAI's [tiktoken](https://github.com/openai/tiktoken) tokenizer (e.g., `o200k_base` for GPT-4o, `cl100k_base` for GPT-4/3.5). See [tiktoken model.py](https://github.com/openai/tiktoken/blob/main/tiktoken/model.py#L24) for encoding details.

#### MCP
- `--mcp`: Run as a [MCP (Model Context Protocol)](https://modelcontextprotocol.io) server

#### Other Options
- `--top-files-len <number>`: Number of top files to display in the summary
- `--verbose`: Enable verbose logging
- `--quiet`: Disable all output to stdout

Examples:

```bash
# Basic usage
repomix

# Custom output
repomix -o output.xml --style xml

# Output to stdout
repomix --stdout > custom-output.txt

# Send output to stdout, then pipe into another command (for example, simonw/llm)
repomix --stdout | llm "Please explain what this code does."

# Custom output with compression
repomix --compress

# Process specific files
repomix --include "src/**/*.ts" --ignore "**/*.test.ts"

# Remote repository with branch
repomix --remote https://github.com/user/repo/tree/main

# Remote repository with commit
repomix --remote https://github.com/user/repo/commit/836abcd7335137228ad77feb28655d85712680f1

# Remote repository with shorthand
repomix --remote user/repo
```

### Updating Repomix

To update a globally installed Repomix:

```bash
# Using npm
npm update -g repomix

# Using yarn
yarn global upgrade repomix

# Using bun
bun update -g repomix
```

Using `npx repomix` is generally more convenient as it always uses the latest version.

### Remote Repository Processing

Repomix supports processing remote Git repositories without the need for manual cloning. This feature allows you to
quickly analyze any public Git repository with a single command.

To process a remote repository, use the `--remote` option followed by the repository URL:

```bash
repomix --remote https://github.com/yamadashy/repomix
```

You can also use GitHub's shorthand format:

```bash
repomix --remote yamadashy/repomix
```

You can specify the branch name, tag, or commit hash:

```bash
# Using --remote-branch option
repomix --remote https://github.com/yamadashy/repomix --remote-branch main

# Using branch's URL
repomix --remote https://github.com/yamadashy/repomix/tree/main
```

Or use a specific commit hash:

```bash
# Using --remote-branch option
repomix --remote https://github.com/yamadashy/repomix --remote-branch 935b695

# Using commit's URL
repomix --remote https://github.com/yamadashy/repomix/commit/836abcd7335137228ad77feb28655d85712680f1
```

### Code Compression

The `--compress` option utilizes [Tree-sitter](https://github.com/tree-sitter/tree-sitter) to perform intelligent code extraction, focusing on essential function and class signatures while removing implementation details. This can help reduce token count while retaining important structural information.

```bash
repomix --compress
```

For example, this code:

```typescript
import { ShoppingItem } from './shopping-item';

/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
  let total = 0;
  for (const item of items) {
    total += item.price * item.quantity;
  }
  return total;
}

// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

Will be compressed to:

```typescript
import { ShoppingItem } from './shopping-item';
⋮----
/**
 * Calculate the total price of shopping items
 */
const calculateTotal = (
  items: ShoppingItem[]
) => {
⋮----
// Shopping item interface
interface Item {
  name: string;
  price: number;
  quantity: number;
}
```

> [!NOTE]
> This is an experimental feature that we'll be actively improving based on user feedback and real-world usage

### MCP Server Integration

Repomix supports the [Model Context Protocol (MCP)](https://modelcontextprotocol.io), allowing AI assistants to directly interact with your codebase. When run as an MCP server, Repomix provides tools that enable AI assistants to package local or remote repositories for analysis without requiring manual file preparation.

```bash
repomix --mcp
```

#### Configuring MCP Servers

To use Repomix as an MCP server with AI assistants like Claude, you need to configure the MCP settings:

**For VS Code:**

You can install the Repomix MCP server in VS Code using one of these methods:

1. **Using the Install Badge:**

  [![Install in VS Code](https://img.shields.io/badge/VS_Code-Install_Server-0098FF?style=flat-square&logo=visualstudiocode&logoColor=white)](https://insiders.vscode.dev/redirect/mcp/install?name=repomix&config=%7B%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D)
  [![Install in VS Code Insiders](https://img.shields.io/badge/VS_Code_Insiders-Install_Server-24bfa5?style=flat-square&logo=visualstudiocode&logoColor=white)](https://insiders.vscode.dev/redirect/mcp/install?name=repomix&config=%7B%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22repomix%22%2C%22--mcp%22%5D%7D&quality=insiders)

2. **Using the Command Line:**

  ```bash
  code --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

  For VS Code Insiders:
  ```bash
  code-insiders --add-mcp '{"name":"repomix","command":"npx","args":["-y","repomix","--mcp"]}'
  ```

**For Cline (VS Code extension):**

Edit the `cline_mcp_settings.json` file:
```json
{
  "mcpServers": {
    "repomix": {
      "command": "npx",
      "args": [
        "-y",
        "repomix",
        "--mcp"
      ]
    }
  }
}
```

**For Cursor:**

In Cursor, add a new MCP server from `Cursor Settings` > `MCP` > `+ Add new global MCP server` with a configuration similar to Cline.

**For Claude Desktop:**

Edit the `claude_desktop_config.json` file with similar configuration to Cline's config.

**For Claude Code:**

To configure Repomix as an MCP server in [Claude Code](https://docs.anthropic.com/en/docs/claude-code/overview), use the following command:

```bash
claude mcp add repomix -- npx -y repomix --mcp
```

**Using Docker instead of npx:**

You can use Docker as an alternative to npx for running Repomix as an MCP server:

```json
{
  "mcpServers": {
    "repomix-docker": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "ghcr.io/yamadashy/repomix",
        "--mcp"
      ]
    }
  }
}
```

Once configured, your AI assistant can directly use Repomix's capabilities to analyze codebases without manual file preparation, making code analysis workflows more efficient.

#### Available MCP Tools

When running as an MCP server, Repomix provides the following tools:

1. **pack_codebase**: Package a local code directory into a consolidated XML file for AI analysis
  - Parameters:
    - `directory`: Absolute path to the directory to pack
    - `compress`: (Optional, default: false) Enable Tree-sitter compression to extract essential code signatures and structure while removing implementation details. Reduces token usage by ~70% while preserving semantic meaning. Generally not needed since grep_repomix_output allows incremental content retrieval. Use only when you specifically need the entire codebase content for large repositories.
    - `includePatterns`: (Optional) Specify files to include using fast-glob patterns. Multiple patterns can be comma-separated (e.g., "**/*.{js,ts}", "src/**,docs/**"). Only matching files will be processed.
    - `ignorePatterns`: (Optional) Specify additional files to exclude using fast-glob patterns. Multiple patterns can be comma-separated (e.g., "test/**,*.spec.js", "node_modules/**,dist/**"). These patterns supplement .gitignore and built-in exclusions.
    - `topFilesLength`: (Optional, default: 10) Number of largest files by size to display in the metrics summary for codebase analysis.

2. **pack_remote_repository**: Fetch, clone, and package a GitHub repository into a consolidated XML file for AI analysis
  - Parameters:
    - `remote`: GitHub repository URL or user/repo format (e.g., "yamadashy/repomix", "https://github.com/user/repo", or "https://github.com/user/repo/tree/branch")
    - `compress`: (Optional, default: false) Enable Tree-sitter compression to extract essential code signatures and structure while removing implementation details. Reduces token usage by ~70% while preserving semantic meaning. Generally not needed since grep_repomix_output allows incremental content retrieval. Use only when you specifically need the entire codebase content for large repositories.
    - `includePatterns`: (Optional) Specify files to include using fast-glob patterns. Multiple patterns can be comma-separated (e.g., "**/*.{js,ts}", "src/**,docs/**"). Only matching files will be processed.
    - `ignorePatterns`: (Optional) Specify additional files to exclude using fast-glob patterns. Multiple patterns can be comma-separated (e.g., "test/**,*.spec.js", "node_modules/**,dist/**"). These patterns supplement .gitignore and built-in exclusions.
    - `topFilesLength`: (Optional, default: 10) Number of largest files by size to display in the metrics summary for codebase analysis.

3. **read_repomix_output**: Read the contents of a Repomix-generated output file. Supports partial reading with line range specification for large files.
  - Parameters:
    - `outputId`: ID of the Repomix output file to read
    - `startLine`: (Optional) Starting line number (1-based, inclusive). If not specified, reads from beginning.
    - `endLine`: (Optional) Ending line number (1-based, inclusive). If not specified, reads to end.
  - Features:
    - Specifically designed for web-based environments or sandboxed applications
    - Retrieves the content of previously generated outputs using their ID
    - Provides secure access to packed codebase without requiring file system access
    - Supports partial reading for large files

4. **grep_repomix_output**: Search for patterns in a Repomix output file using grep-like functionality with JavaScript RegExp syntax
  - Parameters:
    - `outputId`: ID of the Repomix output file to search
    - `pattern`: Search pattern (JavaScript RegExp regular expression syntax)
    - `contextLines`: (Optional, default: 0) Number of context lines to show before and after each match. Overridden by beforeLines/afterLines if specified.
    - `beforeLines`: (Optional) Number of context lines to show before each match (like grep -B). Takes precedence over contextLines.
    - `afterLines`: (Optional) Number of context lines to show after each match (like grep -A). Takes precedence over contextLines.
    - `ignoreCase`: (Optional, default: false) Perform case-insensitive matching
  - Features:
    - Uses JavaScript RegExp syntax for powerful pattern matching
    - Supports context lines for better understanding of matches
    - Allows separate control of before/after context lines
    - Case-sensitive and case-insensitive search options

5. **file_system_read_file**: Read a file from the local file system using an absolute path. Includes built-in security validation to detect and prevent access to files containing sensitive information.
  - Parameters:
    - `path`: Absolute path to the file to read
  - Security features:
    - Implements security validation using [Secretlint](https://github.com/secretlint/secretlint)
    - Prevents access to files containing sensitive information (API keys, passwords, secrets)
    - Validates absolute paths to prevent directory traversal attacks

6. **file_system_read_directory**: List the contents of a directory using an absolute path. Returns a formatted list showing files and subdirectories with clear indicators.
  - Parameters:
    - `path`: Absolute path to the directory to list
  - Features:
    - Shows files and directories with clear indicators (`[FILE]` or `[DIR]`)
    - Provides safe directory traversal with proper error handling
    - Validates paths and ensures they are absolute
    - Useful for exploring project structure and understanding codebase organization

## ⚙️ Configuration

Create a `repomix.config.json` file in your project root for custom configurations.

```bash
repomix --init
```

Here's an explanation of the configuration options:

| Option                           | Description                                                                                                                  | Default                |
|----------------------------------|------------------------------------------------------------------------------------------------------------------------------|------------------------|
| `input.maxFileSize`              | Maximum file size in bytes to process. Files larger than this will be skipped                                                | `50000000`            |
| `output.filePath`                | The name of the output file                                                                                                  | `"repomix-output.xml"` |
| `output.style`                   | The style of the output (`xml`, `markdown`, `plain`)                                                                         | `"xml"`                |
| `output.parsableStyle`           | Whether to escape the output based on the chosen style schema. Note that this can increase token count.                      | `false`                |
| `output.compress`                | Whether to perform intelligent code extraction to reduce token count                                                         | `false`                |
| `output.headerText`              | Custom text to include in the file header                                                                                    | `null`                 |
| `output.instructionFilePath`     | Path to a file containing detailed custom instructions                                                                       | `null`                 |
| `output.fileSummary`             | Whether to include a summary section at the beginning of the output                                                          | `true`                 |
| `output.directoryStructure`      | Whether to include the directory structure in the output                                                                     | `true`                 |
| `output.files`                   | Whether to include file contents in the output                                                                               | `true`                 |
| `output.removeComments`          | Whether to remove comments from supported file types                                                                         | `false`                |
| `output.removeEmptyLines`        | Whether to remove empty lines from the output                                                                                | `false`                |
| `output.showLineNumbers`         | Whether to add line numbers to each line in the output                                                                       | `false`                |
| `output.copyToClipboard`         | Whether to copy the output to system clipboard in addition to saving the file                                                | `false`                |
| `output.topFilesLength`          | Number of top files to display in the summary. If set to 0, no summary will be displayed                                     | `5`                    |
| `output.includeEmptyDirectories` | Whether to include empty directories in the repository structure                                                             | `false`                |
| `output.git.sortByChanges`       | Whether to sort files by git change count (files with more changes appear at the bottom)                                     | `true`                 |
| `output.git.sortByChangesMaxCommits` | Maximum number of commits to analyze for git changes                                                                     | `100`                  |
| `output.git.includeDiffs`       | Whether to include git diffs in the output (includes both work tree and staged changes separately)                          | `false`                |
| `include`                        | Patterns of files to include (using [glob patterns](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax))  | `[]`                   |
| `ignore.useGitignore`            | Whether to use patterns from the project's `.gitignore` file                                                                 | `true`                 |
| `ignore.useDefaultPatterns`      | Whether to use default ignore patterns                                                                                       | `true`                 |
| `ignore.customPatterns`          | Additional patterns to ignore (using [glob patterns](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax)) | `[]`                   |
| `security.enableSecurityCheck`   | Whether to perform security checks on files                                                                                  | `true`                 |
| `tokenCount.encoding`            | Token count encoding used by OpenAI's [tiktoken](https://github.com/openai/tiktoken) tokenizer (e.g., `o200k_base` for GPT-4o, `cl100k_base` for GPT-4/3.5). See [tiktoken model.py](https://github.com/openai/tiktoken/blob/main/tiktoken/model.py#L24) for encoding details. | `"o200k_base"`         |

The configuration file supports [JSON5](https://json5.org/) syntax, which allows:
- Comments (both single-line and multi-line)
- Trailing commas in objects and arrays
- Unquoted property names
- More relaxed string syntax

Example configuration:

```json5
{
  "input": {
    "maxFileSize": 50000000
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "compress": false,
    "headerText": "Custom header information for the packed file.",
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "includeEmptyDirectories": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false
    }
  },
  "include": ["**/*"],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    // Patterns can also be specified in .repomixignore
    "customPatterns": [
      "additional-folder",
      "**/*.log"
    ],
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
```

### Global Configuration

To create a global configuration file:

```bash
repomix --init --global
```

The global configuration file will be created in:

- Windows: `%LOCALAPPDATA%\Repomix\repomix.config.json`
- macOS/Linux: `$XDG_CONFIG_HOME/repomix/repomix.config.json` or `~/.config/repomix/repomix.config.json`

Note: Local configuration (if present) takes precedence over global configuration.

### Include and Ignore

#### Include Patterns

Repomix now supports specifying files to include
using [glob patterns](https://github.com/mrmlnc/fast-glob?tab=readme-ov-file#pattern-syntax). This allows for more
flexible and powerful file selection:

- Use `**/*.js` to include all JavaScript files in any directory
- Use `src/**/*` to include all files within the `src` directory and its subdirectories
- Combine multiple patterns like `["src/**/*.js", "**/*.md"]` to include JavaScript files in `src` and all Markdown
  files

#### Ignore Patterns

Repomix offers multiple methods to set ignore patterns for excluding specific files or directories during the packing
process:

- **.gitignore**: By default, patterns listed in your project's `.gitignore` files and `.git/info/exclude` are used. This behavior can be controlled with the `ignore.useGitignore` setting or the `--no-gitignore` cli option.
- **Default patterns**: Repomix includes a default list of commonly excluded files and directories (e.g., node_modules,
  .git, binary files). This feature can be controlled with the `ignore.useDefaultPatterns` setting or the `--no-default-patterns` cli option. Please
  see [defaultIgnore.ts](src/config/defaultIgnore.ts) for more details.
- **.repomixignore**: You can create a `.repomixignore` file in your project root to define Repomix-specific ignore
  patterns. This file follows the same format as `.gitignore`.
- **Custom patterns**: Additional ignore patterns can be specified using the `ignore.customPatterns` option in the
  configuration file. You can overwrite this setting with the `-i, --ignore` command line option.

Priority Order (from highest to lowest):

1. Custom patterns `ignore.customPatterns`
2. `.repomixignore`
3. `.gitignore` and `.git/info/exclude` (if `ignore.useGitignore` is true and `--no-gitignore` is not used)
4. Default patterns (if `ignore.useDefaultPatterns` is true and `--no-default-patterns` is not used)

This approach allows for flexible file exclusion configuration based on your project's needs. It helps optimize the size
of the generated pack file by ensuring the exclusion of security-sensitive files and large binary files, while
preventing the leakage of confidential information.

Note: Binary files are not included in the packed output by default, but their paths are listed in the "Repository
Structure" section of the output file. This provides a complete overview of the repository structure while keeping the
packed file efficient and text-based.

### Custom Instruction

The `output.instructionFilePath` option allows you to specify a separate file containing detailed instructions or
context about your project. This allows AI systems to understand the specific context and requirements of your project,
potentially leading to more relevant and tailored analysis or suggestions.

Here's an example of how you might use this feature:

1. Create a file named `repomix-instruction.md` in your project root:

```markdown
# Coding Guidelines

- Follow the Airbnb JavaScript Style Guide
- Suggest splitting files into smaller, focused units when appropriate
- Add comments for non-obvious logic. Keep all text in English
- All new features should have corresponding unit tests

# Generate Comprehensive Output

- Include all content without abbreviation, unless specified otherwise
- Optimize for handling large codebases while maintaining output quality
```

2. In your `repomix.config.json`, add the `instructionFilePath` option:

```json5
{
  "output": {
    "instructionFilePath": "repomix-instruction.md",
    // other options...
  }
}
```

When Repomix generates the output, it will include the contents of `repomix-instruction.md` in a dedicated section.

Note: The instruction content is appended at the end of the output file. This placement can be particularly effective
for AI systems. For those interested in understanding why this might be beneficial, Anthropic provides some insights in
their documentation:  
https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/long-context-tips

> Put long-form data at the top: Place your long documents and inputs (~20K+ tokens) near the top of your prompt, above
> your query, instructions, and examples. This can significantly improve Claude's performance across all models.
> Queries at the end can improve response quality by up to 30% in tests, especially with complex, multi-document inputs.

### Comment Removal

When `output.removeComments` is set to `true`, Repomix will attempt to remove comments from supported file types. This
feature can help reduce the size of the output file and focus on the essential code content.

Supported languages include:  
HTML, CSS, JavaScript, TypeScript, Vue, Svelte, Python, PHP, Ruby, C, C#, Java, Go, Rust, Swift, Kotlin, Dart, Shell,
and YAML.

Note: The comment removal process is conservative to avoid accidentally removing code. In complex cases, some comments
might be retained.

## 🔍 Security Check

Repomix includes a security check feature that uses [Secretlint](https://github.com/secretlint/secretlint) to detect
potentially sensitive information in your files. This feature helps you identify possible security risks before sharing
your packed repository.

The security check results will be displayed in the CLI output after the packing process is complete. If any suspicious
files are detected, you'll see a list of these files along with a warning message.

Example output:

```
🔍 Security Check:
──────────────────
2 suspicious file(s) detected:
1. src/utils/test.txt
2. tests/utils/secretLintUtils.test.ts

Please review these files for potentially sensitive information.
```

By default, Repomix's security check feature is enabled. You can disable it by setting `security.enableSecurityCheck` to
`false` in your configuration file:

```json
{
  "security": {
    "enableSecurityCheck": false
  }
}
```

Or using the `--no-security-check` command line option:

```bash
repomix --no-security-check
```

> [!NOTE]
> Disabling security checks may expose sensitive information. Use this option with caution and only when necessary, such
> as when working with test files or documentation that contains example credentials.

## 🤖 Using Repomix with GitHub Actions

You can also use Repomix in your GitHub Actions workflows. This is useful for automating the process of packing your codebase for AI analysis.

Basic usage:

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.xml
    style: xml
```

Use `--style` to generate output in different formats:

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    output: repomix-output.md
    style: markdown
```

Pack specific directories with compression:

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src tests
    include: "**/*.ts,**/*.md"
    ignore: "**/*.test.ts"
    output: repomix-output.txt
    compress: true
```

Upload the output file as an artifact:

```yaml
- name: Pack repository with Repomix
  uses: yamadashy/repomix/.github/actions/repomix@main
  with:
    directories: src
    output: repomix-output.txt
    compress: true

- name: Upload Repomix output
  uses: actions/upload-artifact@v4
  with:
    name: repomix-output
    path: repomix-output.txt
```

Complete workflow example:

```yaml
name: Pack repository with Repomix

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  pack-repo:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Pack repository with Repomix
        uses: yamadashy/repomix/.github/actions/repomix@main
        with:
          output: repomix-output.xml

      - name: Upload Repomix output
        uses: actions/upload-artifact@v4
        with:
          name: repomix-output.xml
          path: repomix-output.xml
          retention-days: 30
```

See the complete workflow example [here](https://github.com/yamadashy/repomix/blob/main/.github/workflows/pack-repository.yml).

### Action Inputs

| Name | Description | Default |
|------|-------------|---------|
| `directories` | Space-separated list of directories to process (e.g., `src tests docs`) | `.` |
| `include` | Comma-separated glob patterns to include files (e.g., `**/*.ts,**/*.md`) | `""` |
| `ignore` | Comma-separated glob patterns to ignore files (e.g., `**/*.test.ts,**/node_modules/**`) | `""` |
| `output` | Relative path for the packed file (extension determines format: `.txt`, `.md`, `.xml`) | `repomix-output.xml` |
| `compress` | Enable smart compression to reduce output size by pruning implementation details | `true` |
| `style` | Output style (`xml`, `markdown`, `plain`) | `xml` |
| `additional-args` | Extra raw arguments for the repomix CLI (e.g., `--no-file-summary --no-security-check`) | `""` |
| `repomix-version` | Version of the npm package to install (supports semver ranges, tags, or specific versions like `0.2.25`) | `latest` |

### Action Outputs

| Name | Description |
|------|-------------|
| `output_file` | Path to the generated output file. Can be used in subsequent steps for artifact upload, LLM processing, or other operations. The file contains a formatted representation of your codebase based on the specified options. |

## 📚 Using Repomix as a Library

In addition to using Repomix as a CLI tool, you can also use it as a library in your Node.js applications.

### Installation

```bash
npm install repomix
```

### Basic Usage

```javascript
import { runCli, type CliOptions } from 'repomix';

// Process current directory with custom options
async function packProject() {
  const options = {
    output: 'output.xml',
    style: 'xml',
    compress: true,
    quiet: true
  } as CliOptions;
  
  const result = await runCli(['.'], process.cwd(), options);
  return result.packResult;
}
```

### Process Remote Repository

```javascript
import { runCli, type CliOptions } from 'repomix';

// Clone and process a GitHub repo
async function processRemoteRepo(repoUrl) {
  const options = {
    remote: repoUrl,
    output: 'output.xml',
    compress: true
  } as CliOptions;
  
  return await runCli(['.'], process.cwd(), options);
}
```

### Using Core Components

If you need more control, you can use the low-level APIs:

```javascript
import { searchFiles, collectFiles, processFiles, TokenCounter } from 'repomix';

async function analyzeFiles(directory) {
  // Find and collect files
  const { filePaths } = await searchFiles(directory, { /* config */ });
  const rawFiles = await collectFiles(filePaths, directory);
  const processedFiles = await processFiles(rawFiles, { /* config */ });
  
  // Count tokens
  const tokenCounter = new TokenCounter('o200k_base');
  
  // Return analysis results
  return processedFiles.map(file => ({
    path: file.path,
    tokens: tokenCounter.countTokens(file.content)
  }));
}
```

For more examples, check the source code at [website/server/src/remoteRepo.ts](https://github.com/yamadashy/repomix/blob/main/website/server/src/remoteRepo.ts) which demonstrates how repomix.com uses the library.

## 🤝 Contribution

We welcome contributions from the community! To get started, please refer to our [Contributing Guide](CONTRIBUTING.md).

### Contributors

<a href="https://github.com/yamadashy/repomix/graphs/contributors">
  <img alt="contributors" src="https://contrib.rocks/image?repo=yamadashy/repomix"/>
</a>

## 🔒 Privacy Policy

### Repomix CLI Tool

- **Data Collection**: The Repomix CLI tool does **not** collect, transmit, or store any user data, telemetry, or repository information.
- **Network Usage**: Repomix CLI operates fully offline after installation. The only cases where an internet connection is needed are:
  - Installation via npm/yarn.
  - Using the `--remote` flag to process remote repositories.
  - Checking for updates (manually triggered).
- **Security Considerations**: Since all processing is local, Repomix CLI is safe to use with private and internal repositories.

### Repomix Website ([repomix.com](https://repomix.com/))

- **Data Collection**: The Repomix website uses **Google Analytics** to collect usage data, such as page views and user interactions. This helps us understand how the website is used and improve the user experience.
- **File Processing**: When uploading ZIP files or folders, your files are temporarily stored on our servers for processing. All uploaded files and processed data are automatically deleted immediately after processing is complete.

### Repomix Browser Extension

- **Data Collection**: The Repomix browser extension does **not** collect, transmit, or store any user data, telemetry, or repository information.
- **Permissions**: The extension only requires minimal permissions necessary to add the Repomix button to GitHub repository pages. It does not access or modify repository data.

### Liability Disclaimer

Repomix (the CLI tool, website, and browser extension) is provided "as is" without any warranties or guarantees.  
We do not take responsibility for how the generated output is used, including but not limited to its accuracy, legality, or any potential consequences arising from its use.

## 📜 License

This project is licensed under the [MIT License](LICENSE).

<p align="center">
  &nbsp;&nbsp;&nbsp;
  <a href="#repo-content-pjax-container" target="_blank">
    Back To Top
  </a>
</p>
</file>

<file path="repomix-instruction.md">
# Repomix Project Structure and Overview

This document provides a structural overview of the Repomix project, designed to aid AI code assistants (like Copilot) in understanding the codebase.

Please refer to `README.md` for a complete and up-to-date project overview, and `CONTRIBUTING.md` for implementation guidelines and contribution procedures.

## Project Overview

Repomix is a tool that packs the contents of a software repository into a single file, making it easier for AI systems to analyze and process the codebase. It supports various output formats (plain text, XML, Markdown), ignores files based on configurable patterns, and performs security checks to exclude potentially sensitive information.

## Directory Structure

The project is organized into the following directories:

```
repomix/
├── src/ # Main source code
│   ├── cli/ # Command-line interface logic (argument parsing, command handling, output)
│   ├── config/ # Configuration loading, schema, and defaults
│   ├── core/ # Core logic of Repomix
│   │   ├── file/ # File handling (reading, processing, searching, tree structure generation, git commands)
│   │   ├── metrics/ # Calculating code metrics (character count, token count)
│   │   ├── output/ # Output generation (different styles, headers, etc.)
│   │   ├── packager/ # Orchestrates file collection, processing, output, and clipboard operations.
│   │   ├── security/ # Security checks to exclude sensitive files
│   │   ├── tokenCount/ # Token counting using Tiktoken
│   │   └── tree-sitter/ # Code parsing using Tree-sitter and language-specific queries
│   └── shared/ # Shared utilities and types (error handling, logging, helper functions)
├── tests/ # Unit and integration tests (organized mirroring src/)
│   ├── cli/
│   ├── config/
│   ├── core/
│   ├── integration-tests/
│   ├── shared/
│   └── testing/
└── website/ # Documentation website (VitePress)
    ├── client/      # Client-side code (Vue.js components, styles, configuration)
    │   ├── .vitepress/  # VitePress configuration and theme
    │   │   ├── config/  # Site configuration files (navigation, sidebar, etc.)
    │   │   └── theme/   # Custom theme and styles
    │   ├── components/ # Vue.js components for the website
    │   └── src/        # Markdown files for the documentation in various languages (en, ja, etc.)
    └── server/      # Server-side API (for remote repository processing)
        └── src/       # Server source code (API endpoints, request handling)
```

----------------------------------------------------------------

# Coding Guidelines
- Follow the Airbnb JavaScript Style Guide.
- Split files into smaller, focused units when appropriate:
  - Aim to keep code files under 250 lines. If a file exceeds 250 lines, split it into multiple files based on functionality.
- Add comments to clarify non-obvious logic. **Ensure all comments are written in English.**
- Provide corresponding unit tests for all new features.
- After implementation, verify changes by running:
  ```bash
  npm run lint  # Ensure code style compliance
  npm run test  # Verify all tests pass
  ```

## Dependencies and Testing
- Inject dependencies through a deps object parameter for testability
- Example:
  ```typescript
  export const functionName = async (
    param1: Type1,
    param2: Type2,
    deps = {
      defaultFunction1,
      defaultFunction2,
    }
  ) => {
    // Use deps.defaultFunction1() instead of direct call
  };
  ```
- Mock dependencies by passing test doubles through deps object
- Use vi.mock() only when dependency injection is not feasible

## Generate Comprehensive Output
- Include all content without abbreviation, unless specified otherwise
- Optimize for handling large codebases while maintaining output quality

----------------------------------------------------------------

# GitHub Release Note Guidelines
When writing release notes, please follow these guidelines:

- When referencing issues or PRs, use the gh command to verify the content:
  ```bash
  gh issue view <issue-number>  # For checking issue content
  gh pr view <pr-number>        # For checking PR content
  ```
  This helps ensure accuracy in release note descriptions.

Here are some examples of release notes that follow the guidelines:

v0.2.25
````md
This release brings significant improvements to output formatting and introduces flexible remote repository handling capabilities along with enhanced logging features.

# Improvements ⚡

## Remote Repository Enhancement (#335)
- Added branch/tag parsing directly from repository URLs:
```bash
repomix --remote https://github.com/yamadashy/repomix/tree/0.1.x
```
Functions identically to:
```bash
repomix --remote https://github.com/yamadashy/repomix --remote-branch 0.1.x
```

Special thanks to @huy-trn for implementing this user-friendly feature!

## Enhanced Output Formatting (#328, #329, #330)
- Added "End of Codebase" marker for better clarity in output
- Improved output header accuracy:
  - Better representation of codebase scope
  - Clear indication when using `--include` or `--ignore` options

Special thanks to @gitkenan for adding the "End of Codebase" marker and reporting the header issue!

## Path Pattern Support (#337)
- Added support for special characters in paths:
  - Handles parentheses in include patterns (e.g., `src/(categories)/**/*`)
  - Improved escaping for `[]` and `{}`
  - Essential for Next.js route groups and similar frameworks

Thank you @matheuscoelhomalta for improving path pattern support!

# How to Update

```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
````

v0.2.24
````md
This release significantly enhances configuration flexibility with comprehensive CLI flag support and expands default ignore patterns for better project scaffolding. 

# What's New 🚀

## CLI Flags Revolution (#324)
- New command-line configuration now available.

```
- `--no-gitignore`: Disable .gitignore file usage
- `--no-default-patterns`: Disable default patterns
- `--header-text <text>`: Custom text to include in the file header
- `--instruction-file-path <path>`: Path to a file containing detailed custom instructions
- `--include-empty-directories`: Include empty directories in the output
```

Special recognition to @massdo for driving ecosystem growth.

# Improvements ⚡

## Enhanced Ignore Patterns (#318, #322)
- Expanded default ignores for Rust projects:
  - `target/`, `Cargo.lock`, build artifacts
  - PHP, Ruby, Go, Elixir, Haskell: package manager lock files

To @boralg for helping curate Rust-specific patterns!

# How to Update
```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
````

v0.2.23
````md
This release adds significant performance improvements for large repositories, making Repomix faster and more efficient when needed.

# Improvements ⚡

## Parallel Processing Enhancement (#309)
- Implemented worker threads using [Piscina](https://github.com/piscinajs/piscina) for parallel processing

### Benchmark Results
- `yamadashy.repomix`: No significant change
  - Before: 868.73 millis
  - After: 671.26 millis
- `facebook/react`: 29x faster
  - Before: 123.31 secs
  - After: 4.19 secs
- `vercel/next.js`: 58x faster
  - Before: 17.85 mins
  - After: 17.27 secs

Note: While Repomix is not primarily designed for processing large repositories, and speed is not a primary goal, faster processing can provide a better user experience when working with larger codebases.

# How to Update

```bash
npm update -g repomix
```


---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
````

v0.2.22
````md
This release introduces significant improvements to large file handling and expands the Repomix ecosystem with new tools and community channels.

# Improvements ⚡ 

## Improved Large File Handling (#302)

- Added a file size limit check (50MB) to prevent memory issues
- Graceful error handling for large files with clear user guidance:

Special thanks to @slavashvets for their continued contributions!

# Ecosystem Growth 🤝 

## New VS Code Extension (#300)
A community-created VS Code extension "Repomix Runner" is now available:
- Run Repomix directly from VS Code
- Extension by @massdo: [View on VS Code Marketplace](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner)

Thank you @massdo for bringing Repomix to VS Code and expanding our tooling ecosystem!

## Official Social Media
- Launched official Repomix X (Twitter) account: [@repomix_ai](https://x.com/repomix_ai)
  - Follow for updates, tips, and community highlights

# How to Update

```bash
npm update -g repomix
```

---

Join our growing community on [Discord](https://discord.gg/BF8GxZHE2C) and follow us on [X](https://x.com/repomix_ai) for updates!
````

v0.2.21
````md
This release introduces significant improvements to output formatting and documentation, featuring a new parsable style option for enhanced XML handling.

# What's New 🚀 

## Enhanced Output Style Control (#287)
- Added new `parsableStyle` option for better output handling:
  - Ensures output strictly follows the specification of the chosen format
  - Provides properly escaped XML output with fast-xml-parser
  - Dynamically adjusts markdown code block delimiters to avoid content conflicts
- Available via CLI flag `--parsable-style` or in configuration file

Special thanks to @atollk for their first contribution!

# Documentation 📚

## README Enhancements (#296)
- Updated Homebrew installation documentation to include Linux support

Special thanks to @chenrui333 for their continued contributions!

## Website Multi-Language Support (#293)
- Enhanced multi-language support in [repomix.com](https://repomix.com)

# How to Update

To update to the latest version, run:
```bash
npm update -g repomix
```


---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
</file>

<file path="repomix.config.json">
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 50000000
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "compress": false,
    "headerText": "This repository contains the source code for the Repomix tool.\nRepomix is designed to pack repository contents into a single file,\nmaking it easier for AI systems to analyze and process the codebase.\n\nKey Features:\n- Configurable ignore patterns\n- Custom header text support\n- Efficient file processing and packing\n\nPlease refer to the README.md file for more detailed information on usage and configuration.\n",
    "instructionFilePath": "repomix-instruction.md",
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "includeEmptyDirectories": true,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    // ignore is specified in .repomixignore
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
</file>

<file path="SECURITY.md">
# Security Policy

## Reporting a Vulnerability

To securely report a vulnerability, please [open an advisory on GitHub](https://github.com/yamadashy/repomix/security/advisories/new) or report it by sending an email to `koukun0120@gmail.com`.
</file>

<file path="tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "rootDir": "./src"
  },
  "include": ["./src/**/*"]
}
</file>

<file path="tsconfig.json">
{
  "compileOnSave": false,
  "compilerOptions": {
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "target": "es2016",
    "outDir": "./lib",
    "rootDir": ".",
    "strict": true,
    "esModuleInterop": true,
    "noImplicitAny": true,
    "skipLibCheck": true,
    "lib": ["es2022"],
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "types": ["node", "picocolors"]
  },
  "include": ["src/**/*", "tests/**/*"],
  "exclude": ["tests/integration-tests/fixtures"]
}
</file>

<file path="typos.toml">
[files]
extend-exclude = [
    "website/client/.vitepress/config/*.ts",
    "website/client/src/**/*.md",
    ".git",
    "browser/**/*.txt",
]
ignore-hidden = false

[default.extend-words]
# Vietnamese language words that might be flagged as typos
Nam = "Nam"  # Part of "Việt Nam" (Vietnam in Vietnamese)
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    include: ['tests/**/*.test.ts'],
    coverage: {
      include: ['src/**/*'],
      exclude: ['src/index.ts'],
      reporter: ['text', 'json', 'html'],
    },
    watch: false,
    testTimeout: 15000,
  },
});
</file>

</files>


<instruction>
# Repomix Project Structure and Overview

This document provides a structural overview of the Repomix project, designed to aid AI code assistants (like Copilot) in understanding the codebase.

Please refer to `README.md` for a complete and up-to-date project overview, and `CONTRIBUTING.md` for implementation guidelines and contribution procedures.

## Project Overview

Repomix is a tool that packs the contents of a software repository into a single file, making it easier for AI systems to analyze and process the codebase. It supports various output formats (plain text, XML, Markdown), ignores files based on configurable patterns, and performs security checks to exclude potentially sensitive information.

## Directory Structure

The project is organized into the following directories:

```
repomix/
├── src/ # Main source code
│   ├── cli/ # Command-line interface logic (argument parsing, command handling, output)
│   ├── config/ # Configuration loading, schema, and defaults
│   ├── core/ # Core logic of Repomix
│   │   ├── file/ # File handling (reading, processing, searching, tree structure generation, git commands)
│   │   ├── metrics/ # Calculating code metrics (character count, token count)
│   │   ├── output/ # Output generation (different styles, headers, etc.)
│   │   ├── packager/ # Orchestrates file collection, processing, output, and clipboard operations.
│   │   ├── security/ # Security checks to exclude sensitive files
│   │   ├── tokenCount/ # Token counting using Tiktoken
│   │   └── tree-sitter/ # Code parsing using Tree-sitter and language-specific queries
│   └── shared/ # Shared utilities and types (error handling, logging, helper functions)
├── tests/ # Unit and integration tests (organized mirroring src/)
│   ├── cli/
│   ├── config/
│   ├── core/
│   ├── integration-tests/
│   ├── shared/
│   └── testing/
└── website/ # Documentation website (VitePress)
    ├── client/      # Client-side code (Vue.js components, styles, configuration)
    │   ├── .vitepress/  # VitePress configuration and theme
    │   │   ├── config/  # Site configuration files (navigation, sidebar, etc.)
    │   │   └── theme/   # Custom theme and styles
    │   ├── components/ # Vue.js components for the website
    │   └── src/        # Markdown files for the documentation in various languages (en, ja, etc.)
    └── server/      # Server-side API (for remote repository processing)
        └── src/       # Server source code (API endpoints, request handling)
```

----------------------------------------------------------------

# Coding Guidelines
- Follow the Airbnb JavaScript Style Guide.
- Split files into smaller, focused units when appropriate:
  - Aim to keep code files under 250 lines. If a file exceeds 250 lines, split it into multiple files based on functionality.
- Add comments to clarify non-obvious logic. **Ensure all comments are written in English.**
- Provide corresponding unit tests for all new features.
- After implementation, verify changes by running:
  ```bash
  npm run lint  # Ensure code style compliance
  npm run test  # Verify all tests pass
  ```

## Dependencies and Testing
- Inject dependencies through a deps object parameter for testability
- Example:
  ```typescript
  export const functionName = async (
    param1: Type1,
    param2: Type2,
    deps = {
      defaultFunction1,
      defaultFunction2,
    }
  ) => {
    // Use deps.defaultFunction1() instead of direct call
  };
  ```
- Mock dependencies by passing test doubles through deps object
- Use vi.mock() only when dependency injection is not feasible

## Generate Comprehensive Output
- Include all content without abbreviation, unless specified otherwise
- Optimize for handling large codebases while maintaining output quality

----------------------------------------------------------------

# GitHub Release Note Guidelines
When writing release notes, please follow these guidelines:

- When referencing issues or PRs, use the gh command to verify the content:
  ```bash
  gh issue view <issue-number>  # For checking issue content
  gh pr view <pr-number>        # For checking PR content
  ```
  This helps ensure accuracy in release note descriptions.

Here are some examples of release notes that follow the guidelines:

v0.2.25
````md
This release brings significant improvements to output formatting and introduces flexible remote repository handling capabilities along with enhanced logging features.

# Improvements ⚡

## Remote Repository Enhancement (#335)
- Added branch/tag parsing directly from repository URLs:
```bash
repomix --remote https://github.com/yamadashy/repomix/tree/0.1.x
```
Functions identically to:
```bash
repomix --remote https://github.com/yamadashy/repomix --remote-branch 0.1.x
```

Special thanks to @huy-trn for implementing this user-friendly feature!

## Enhanced Output Formatting (#328, #329, #330)
- Added "End of Codebase" marker for better clarity in output
- Improved output header accuracy:
  - Better representation of codebase scope
  - Clear indication when using `--include` or `--ignore` options

Special thanks to @gitkenan for adding the "End of Codebase" marker and reporting the header issue!

## Path Pattern Support (#337)
- Added support for special characters in paths:
  - Handles parentheses in include patterns (e.g., `src/(categories)/**/*`)
  - Improved escaping for `[]` and `{}`
  - Essential for Next.js route groups and similar frameworks

Thank you @matheuscoelhomalta for improving path pattern support!

# How to Update

```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
````

v0.2.24
````md
This release significantly enhances configuration flexibility with comprehensive CLI flag support and expands default ignore patterns for better project scaffolding. 

# What's New 🚀

## CLI Flags Revolution (#324)
- New command-line configuration now available.

```
- `--no-gitignore`: Disable .gitignore file usage
- `--no-default-patterns`: Disable default patterns
- `--header-text <text>`: Custom text to include in the file header
- `--instruction-file-path <path>`: Path to a file containing detailed custom instructions
- `--include-empty-directories`: Include empty directories in the output
```

Special recognition to @massdo for driving ecosystem growth.

# Improvements ⚡

## Enhanced Ignore Patterns (#318, #322)
- Expanded default ignores for Rust projects:
  - `target/`, `Cargo.lock`, build artifacts
  - PHP, Ruby, Go, Elixir, Haskell: package manager lock files

To @boralg for helping curate Rust-specific patterns!

# How to Update
```bash
npm update -g repomix
```

---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
````

v0.2.23
````md
This release adds significant performance improvements for large repositories, making Repomix faster and more efficient when needed.

# Improvements ⚡

## Parallel Processing Enhancement (#309)
- Implemented worker threads using [Piscina](https://github.com/piscinajs/piscina) for parallel processing

### Benchmark Results
- `yamadashy.repomix`: No significant change
  - Before: 868.73 millis
  - After: 671.26 millis
- `facebook/react`: 29x faster
  - Before: 123.31 secs
  - After: 4.19 secs
- `vercel/next.js`: 58x faster
  - Before: 17.85 mins
  - After: 17.27 secs

Note: While Repomix is not primarily designed for processing large repositories, and speed is not a primary goal, faster processing can provide a better user experience when working with larger codebases.

# How to Update

```bash
npm update -g repomix
```


---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.
````

v0.2.22
````md
This release introduces significant improvements to large file handling and expands the Repomix ecosystem with new tools and community channels.

# Improvements ⚡ 

## Improved Large File Handling (#302)

- Added a file size limit check (50MB) to prevent memory issues
- Graceful error handling for large files with clear user guidance:

Special thanks to @slavashvets for their continued contributions!

# Ecosystem Growth 🤝 

## New VS Code Extension (#300)
A community-created VS Code extension "Repomix Runner" is now available:
- Run Repomix directly from VS Code
- Extension by @massdo: [View on VS Code Marketplace](https://marketplace.visualstudio.com/items?itemName=DorianMassoulier.repomix-runner)

Thank you @massdo for bringing Repomix to VS Code and expanding our tooling ecosystem!

## Official Social Media
- Launched official Repomix X (Twitter) account: [@repomix_ai](https://x.com/repomix_ai)
  - Follow for updates, tips, and community highlights

# How to Update

```bash
npm update -g repomix
```

---

Join our growing community on [Discord](https://discord.gg/BF8GxZHE2C) and follow us on [X](https://x.com/repomix_ai) for updates!
````

v0.2.21
````md
This release introduces significant improvements to output formatting and documentation, featuring a new parsable style option for enhanced XML handling.

# What's New 🚀 

## Enhanced Output Style Control (#287)
- Added new `parsableStyle` option for better output handling:
  - Ensures output strictly follows the specification of the chosen format
  - Provides properly escaped XML output with fast-xml-parser
  - Dynamically adjusts markdown code block delimiters to avoid content conflicts
- Available via CLI flag `--parsable-style` or in configuration file

Special thanks to @atollk for their first contribution!

# Documentation 📚

## README Enhancements (#296)
- Updated Homebrew installation documentation to include Linux support

Special thanks to @chenrui333 for their continued contributions!

## Website Multi-Language Support (#293)
- Enhanced multi-language support in [repomix.com](https://repomix.com)

# How to Update

To update to the latest version, run:
```bash
npm update -g repomix
```


---

As always, if you encounter any issues or have suggestions, please let us know through our GitHub issues or join our [Discord community](https://discord.gg/wNYzTwZFku) for support.

</instruction>
